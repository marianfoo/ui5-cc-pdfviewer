/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

        (c) Copyright 2009-2015 SAP SE. All rights reserved
    
 */
sap.ui.define(["../thirdparty/three"],function(e){"use strict";var t={lineColor:{value:new THREE.Color(1,1,1)},linewidth:{value:1},resolution:{value:new THREE.Vector2(1,1)},dashScale:{value:1},dashPeriod:{value:new THREE.Vector3(1,1,1)},dashAtlas:{value:null},lineLength:{value:1e5}};var i=THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,t]);var n=["#include <common>","#include <color_pars_vertex>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","","uniform float linewidth;","uniform vec2 resolution;","","attribute vec3 instanceStart;","attribute vec3 instanceEnd;","","varying vec2 vTC;","","#if defined(USE_DASH) || TRIM_STYLE","attribute vec2 instanceDistance;","varying float vLineDistance;","#endif","","void trimSegment(const in vec4 start, inout vec4 end) {","\t// trim end segment so it terminates between the camera plane and the near plane","","\t// conservative estimate of the near plane","\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column","\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column","\tfloat nearEstimate = -0.5 * b / a;","","\tfloat t = (nearEstimate - start.z) / (end.z - start.z);","","\tend.xyz = mix(start.xyz, end.xyz, t);","}","","void main() {","\tvTC = uv * linewidth;","","\t// camera space","\tvec4 start = modelViewMatrix * vec4(instanceStart, 1.0);","\tvec4 end = modelViewMatrix * vec4(instanceEnd, 1.0);","","\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane","\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space","\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly","\t// perhaps there is a more elegant solution -- WestLangley","","\tbool perspective = (projectionMatrix[ 2 ][ 3 ] == -1.0); // 4th entry in the 3rd column","\tif (perspective) {","\t\tif (start.z < 0.0 && end.z >= 0.0) {","\t\t\ttrimSegment(start, end);","\t\t} else if (end.z < 0.0 && start.z >= 0.0) {","\t\t\ttrimSegment(end, start);","\t\t}","\t}","","\t// clip space","\tvec4 clipStart = projectionMatrix * start;","\tvec4 clipEnd = projectionMatrix * end;","","\t// ndc space","\tvec2 ndcStart = clipStart.xy / clipStart.w;","\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;","","\t// direction","\tvec2 dir = (ndcEnd - ndcStart) * resolution;","\tfloat l = length(dir);","\tdir = normalize(dir);","","\t// perpendicular to dir","\tvec2 offset = vec2(dir.y, -dir.x) * position.x;","","#if defined(USE_DASH) || TRIM_STYLE","\tvLineDistance = mix(instanceDistance.x, instanceDistance.y, position.y);","#endif","","\t// endcaps","\tif ( position.y < 0.0 ) {","\t\toffset -= dir;","#if defined(USE_DASH)","\t\tvLineDistance = mix(instanceDistance.x, instanceDistance.y, position.y * linewidth / l);","#endif","\t} else if ( position.y > 1.0 ) {","\t\toffset += dir;","#if defined(USE_DASH)","\t\tvLineDistance = mix(instanceDistance.x, instanceDistance.y, 1.0 + (position.y - 1.0) * linewidth / l);","#endif","\t}","","\t// select end","\tvec4 clip = (position.y < 0.5) ? clipStart : clipEnd;","\tclip /= clip.w; // remove perspective correction","","\tclip.xy += offset * (linewidth / resolution);","","\tgl_Position = clip;","","\tvec4 mvPosition = (position.y < 0.5) ? start : end; // this is an approximation","","#include <logdepthbuf_vertex>","#include <clipping_planes_vertex>","#include <fog_vertex>","}"].join("\n");var a=["uniform vec3 diffuse;","uniform vec3 lineColor;","uniform float opacity;","uniform float linewidth;","","#ifdef USE_DASH","uniform float dashScale;","uniform vec3 dashPeriod;","uniform sampler2D dashAtlas;","#endif","","#if (TRIM_STYLE & 2)","uniform float lineLength;","#endif","","varying float vLineDistance;","","#include <common>","#include <color_pars_fragment>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","","varying vec2 vTC;","","void main() {","","#include <clipping_planes_fragment>","","\tvec4 diffuseColor = vec4(diffuse * lineColor, opacity);","","\tvec2 uv = abs(vTC);","\tdiffuseColor.a *= clamp(linewidth + 0.5 - uv.y, 0.0, 1.0); // line antialiasing","","#if (TRIM_STYLE & 1)","\tif (vLineDistance < 0.0)","\t\tdiscard;","#endif","","#if (TRIM_STYLE & 2)","\tif (vLineDistance > lineLength)","\t\tdiscard;","#endif","","\tif (uv.x > linewidth) { // apply segment cap","#if (SEGMENT_CAP_STYLE == 1) // round cap","\t\tvec2 delta = vec2(uv.y, uv.x - linewidth);","\t\tdiffuseColor.a *= clamp(linewidth - length(delta), 0.0, 1.0);","#else","\t\tdiffuseColor.a *= clamp(linewidth + 1.0 - uv.x, 0.0, 1.0);","#endif","\t}","","#include <logdepthbuf_fragment>","#include <color_fragment>","","#ifdef USE_DASH","\tfloat x = fract(vLineDistance * dashPeriod.y / dashScale);","\tvec4 dash = texture2D(dashAtlas, vec2(x * dashPeriod.z, 0.5));","\tdash.zw *= 255.0;","\tx *= dashPeriod.x;","\tdash.zw = vec2(dash.z - x, x - dash.w);","\tx = min(dash.z, dash.w) * dashScale;","#if (DASH_CAP_STYLE == 1) // round cap","\tvec2 delta = vec2(x * 2.0, uv.y);","\tdiffuseColor.a *= max(step(x / linewidth, 0.0), clamp(linewidth + 0.5 - length(delta), 0.0, 1.0));","#else // no cap","\tdiffuseColor.a *= clamp(0.5 - x, 0.0, 1.0);","#endif","#endif","","\tgl_FragColor = diffuseColor;","","#include <premultiplied_alpha_fragment>","#include <tonemapping_fragment>","#include <encodings_fragment>","#include <fog_fragment>","}"].join("\n");function r(e){THREE.ShaderMaterial.call(this,{type:"PolylineMaterial",uniforms:THREE.UniformsUtils.clone(i),vertexShader:n,fragmentShader:a});this.defines.DASH_CAP_STYLE=0;this.defines.SEGMENT_CAP_STYLE=0;this.defines.TRIM_STYLE=0;this._dashPattern=[];Object.defineProperties(this,{color:{enumerable:true,get:function(){return this.uniforms.diffuse.value},set:function(e){this.uniforms.diffuse.value=e}},lineColor:{enumerable:true,get:function(){return this.uniforms.lineColor.value},set:function(e){this.uniforms.lineColor.value=e}},linewidth:{enumerable:true,get:function(){return this.uniforms.linewidth.value},set:function(e){this.uniforms.linewidth.value=e}},dashCapStyle:{enumerable:true,get:function(){return this.defines.DASH_CAP_STYLE},set:function(e){this.defines.DASH_CAP_STYLE=e}},segmentCapStyle:{enumerable:true,get:function(){return this.defines.SEGMENT_CAP_STYLE},set:function(e){this.defines.SEGMENT_CAP_STYLE=e}},trimStyle:{enumerable:true,get:function(){return this.defines.TRIM_STYLE},set:function(e){this.defines.TRIM_STYLE=e}},dashScale:{enumerable:true,get:function(){return this.uniforms.dashScale.value},set:function(e){this.uniforms.dashScale.value=e}},dashPattern:{enumerable:true,get:function(){return this._dashPattern},set:function(e){this._dashPattern=e;this._updateDashAtlas()}},resolution:{enumerable:true,get:function(){return this.uniforms.resolution.value},set:function(e){this.uniforms.resolution.value.copy(e)}},lineLength:{enumerable:true,get:function(){return this.uniforms.lineLength.value},set:function(e){this.uniforms.lineLength.value=e}}});this.setValues(e)}r.prototype=Object.create(THREE.ShaderMaterial.prototype);r.prototype.constructor=r;r.prototype.isLineMaterial=true;r.prototype._updateDashAtlas=function(){if(!this._dashPattern.length){delete this.defines.USE_DASH;this.uniforms.dashAtlas.value=null;this.needsUpdate=true;return}var e=Array.from(this._dashPattern);if(e.length&1){e=e.concat(e)}var t=e.reduce(function(e,t){return e+Math.ceil(t)});var i=THREE.Math.ceilPowerOfTwo(t);this.uniforms.dashPeriod.value.set(t,1/t,t/i);var n=new Uint8Array(i*4);for(var a=0,r=0,s=0;a<e.length;a++){var o=e[a];var l=a&1?r+o:r;var d=a&1?r:r+o;var c=a&1?0:255;while(o-- >0){n[s++]=c;n[s++]=0;n[s++]=l;n[s++]=d;r++}}var u=new THREE.DataTexture(n,i,1,THREE.RGBAFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter);u.needsUpdate=true;this.defines.USE_DASH="";this.uniforms.dashAtlas.value=u;this.needsUpdate=true};r.prototype.copy=function(e){THREE.ShaderMaterial.prototype.copy.call(this,e);this.color.copy(e.color);this.lineColor.copy(e.lineColor);this.linewidth=e.linewidth;this.dashCapStyle=e.dashCapStyle;this.segmentCapStyle=e.segmentCapStyle;this.trimStyle=e.trimStyle;this.dashPattern=e.dashPattern;this.resolution=e.resolution;this.lineLength=e.lineLength;return this};return r});
//# sourceMappingURL=PolylineMaterial.js.map