/* SAP CVOM 4.0 Â© <2012-2014> SAP SE. All rights reserved. Build Version 7.34.1-SNAPSHOT, Build Context N/A */
sap.viz.extapi.env.Language.register({id:'language',value: {IDS_MULTIDUALLINECHART:"Multiple Line Chart with 2 Y-Axes",IDS_BASESINGLECHART:"Base Single Chart",IDS_TRELLISCOMBINATIONEXCHART:"Trellis Combination Chart",IDS_HORIZONTALAREACHART:"Horizontal Area Chart",IDS_BULLETFORECASTVALUES:"Forecast Values",IDS_TRELLISPERCENTAGEHORIZONTALAREACHART:"Trellis 100% Horizontal Area Chart",IDS_ANIMATION:"animation",IDS_COLORING_TYPE_POSITIVE:"Good",IDS_INVALID_DATE:"Invalid date",IDS_ITEM_SELECTED:"item selected",IDS_GRIDVISIBLE:"gridVisible",IDS_MULTIHORIZONTALAREACHART:"Multiple Horizontal Area Chart",IDS_ENABLEROUNDCORNER:"enableRoundCorner",IDS_TREECHART:"Tree",IDS_TRELLISHORIZONTALLINECHART:"Trellis Horizontal Line Chart",IDS_MULTISTACKEDBARCHART:"Multiple Stacked Bar Chart",IDS_RADARAXESVALUE:"Radar Axes Values",IDS_MULTIPIEWITHDEPTHCHART:"Multiple Pie with Depth Chart",IDS_PIESECTORCOLORNAME:"Sector Color",IDS_TRELLISBARCHART:"Trellis Bar Chart",IDS_TRELLISDUALPERCENTAGESTACKEDBARCHART:"Trellis 100% Stacked Bar Chart with 2 X-Axes",IDS_TIMEVALUEBUBBLECHART:"Time Bubble Chart",IDS_FORMAT:"Format",IDS_SECONDARYAXISLABELNAME:"Secondary Category Axis",IDS_LABEL:"Label",IDS_TRELLISPERCENTAGESTACKEDBARCHART:"Trellis 100% Stacked Bar Chart",IDS_DATA_FRAME:"Data Frame",IDS_SECONDARYVALUES:"Secondary Values",IDS_SEMANTIC_DEFAULT_TITLE:"Semantic Rules",IDS_TIMEBUBBLECHART:"Time Bubble Chart",IDS_COLORING_TYPE_NEUTRAL:"Neutral",IDS_MULTIPIECHART:"Multiple Pie Chart",IDS_NETLINK:"Network Link",IDS_VARIANTBARCHART:"Variant Bar Chart (POC)",IDS_MULTISTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart",IDS_TRELLISAREACHART:"Trellis Area Chart",IDS_MULTIVERTICALBARCHART:"Multiple Column Chart",IDS_INCREASING:"Increasing",IDS_MULTIPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart",IDS_STACKEDVERTICALBARCHART:"Stacked Column Chart",IDS_VALUE_AXIS:"Value Axis",IDS_ABOVE_IS_GOOD:"Above is Good",IDS_TIMESERIESCOLUMNCHART:"Column Chart for Date/Time Series",IDS_MULTIDUALSTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart with 2 Y-Axes",IDS_TRELLISHORIZONTALCOMBINATIONCHART:"Trellis Combined Bar Line Chart",IDS_SCATTERMATRIXCHART:"Scatter Matrix Chart",IDS_ENDCOLUMN:"endColumn",IDS_DUALSTACKEDVERTICALBARCHART:"Stacked Column Chart with 2 Y-Axes",IDS_DEFAULTMND:"All Measures",IDS_VALUE_SELECTED:"value selected",IDS_MARKERS:"Markers",IDS_TAGFAMILY:"Tags Family",IDS_POSITIVE_INFINITY:"+Infinity",IDS_PRIMARYVALUES:"Primary Values",IDS_DONUTWITHDEPTHCHART:"Doughnut with Depth Chart",IDS_LEGEND_TITLE:"Title of Legend",IDS_TREENODE:"Tree Node",IDS_VERTICALBULLETCHART:"Vertical Bullet Chart",IDS_FISCALPERIOD:"Fiscal Period",IDS_CATEGORY_AXIS2:"Category Axis 2",IDS_MULTIDUALHORIZONTALLINECHART:"Multiple Horizontal Line Chart with 2 X-Axes",IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart with 2 Y-Axes",IDS_TRELLISBULLETCHART:"Trellis Bullet Chart",IDS_MULTIDONUTWITHDEPTHCHART:"Multiple Doughnut with Depth Chart",IDS_AUTOBINNINGOTHERS:"Others",IDS_PIESECTORSIZE:"Sector Size",IDS_COMBINATIONCHART:"Combined Column Line Chart",IDS_COLORING_TYPE_OTHER:"Other",IDS_COLUMNCONFIG:"columnConfig",IDS_MULTIDUALBARCHART:"Multiple Bar Chart with 2 X-Axes",IDS_TAGNAME:"Tags Name",IDS_TYPE:"Type",IDS_STARTCOLOR:"startcolor",IDS_PERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart",IDS_STARTCOLUMN:"startColumn",IDS_DUALHORIZONTALLINECHART:"Horizontal Line Chart with 2 X-Axes",IDS_NUMBERCHART_VALUE:"Value",IDS_SHAPE:"Shape",IDS_TRELLISSTACKEDCOLUMNCHART:"Trellis Stacked Column Chart",IDS_VERTICALBOXPLOTCHART:"Box Plot",IDS_BASEHORIZONTALCHART:"Base horizontal XY Chart",IDS_SCATTERCHART:"Scatter Plot",IDS_TOOLTIPVISIBLE:"tooltipVisible",IDS_PERCENTAGEAREACHART:"100% Area Chart",IDS_WATERFALLTYPE:"Waterfall Type",IDS_SEMANTICCOLOROTHERS:"Others",IDS_HORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart",IDS_REGIONCOLOR:"Region Color",IDS_BORDER:"Border",IDS_ITEMS_SELECTED:"items selected",IDS_TRENDLINE_LINEAR:"Linear Regression",IDS_MULTIPERCENTAGEAREACHART:"Multiple 100% Area Chart",IDS_REFERENCEVALUES:"Reference Values",IDS_WATERFALLCHART:"Waterfall Chart",IDS_TRELLISHORIZONTALAREACHART:"Trellis Horizontal Area Chart",IDS_HORIZONTALSTACKEDWATERFALL:"Horizontal Stacked Waterfall Chart",IDS_STACKEDWATERFALLCHART:"Stacked Waterfall Chart",IDS_DUALTIMESERIESCOMBINATIONCHART:"Combined Column Line Chart for Date/Time Series with 2 Y-Axes",IDS_VISIBLE:"visible",IDS_GRIDLINE:"Gridline",IDS_BULLETADDITIONALVALUES:"Additional Values",IDS_SECONDARYVALUESCOLORPALETTE:"secondaryValuesColorPalette",IDS_SIZE:"size",IDS_MULTIBARCHART:"Multiple Bar Chart",IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart with 2 Y-Axes",IDS_TRELLISSCATTERCHART:"Trellis Scatter Chart",IDS_TARGET:"Target",ID_FORECAST_VALUES:"Forecast Values",IDS_TAGCLOUDCHART:"Tag Cloud",IDS_TIMESERIESBUBBLECHART:"Bubble Chart for Date/Time Series",IDS_LOWCOLUMN:"lowColumn",IDS_TARGETVALUES:"Target Values",IDS_MULTIBUBBLECHART:"Multiple Bubble Chart",IDS_FILLVISIBLE:"fillVisible",IDS_TRELLISDUALPERCENTAGESTACKEDCOLUMNCHART:"Trellis 100% Stacked Column Chart with 2 Y-Axes",IDS_END_OF_PERIOD:"End of Period",IDS_STACKEDBARCHART:"Stacked Bar Chart",IDS_PIECHART:"Pie Chart",IDS_VERTICALBARCHART:"Column Chart",IDS_TIME_FROM:"From",IDS_SPARKLINECHART:"Spark Line Chart (POC)",IDS_TRELLISPERCENTAGESTACKEDCOLUMNCHART:"Trellis 100% Stacked Column Chart",IDS_ISNOVALUE:"No value",IDS_BUBBLEWIDTH:"Bubble Width",IDS_BUBBLESIZE:"Bubble Size",IDS_TIMESERIESSCATTERCHART:"Scatter Plot for Date/Time Series",IDS_HORIZONTALWATERFALLCHART:"Horizontal Waterfall Chart",IDS_TIMESERIESSTACKEDCOMBINATIONCHART:"Combined Stacked Line Chart for Date/Time Series",IDS_VALUEFORMAT:"valueFormat",IDS_PIEWITHDEPTHCHART:"Pie with Depth Chart",IDS_BASEBUBBLECHART:"Base Scatter Chart",IDS_REFINEVISIBLE:"reflineVisible",IDS_TRELLISSTACKEDBARCHART:"Trellis Stacked Bar Chart",IDS_DUALLINECHART:"Line Chart with 2 Y-Axes",IDS_BULLETACTUALVALUES:"Actual Values",IDS_HEATMAPCHART:"Heat Map",IDS_BELOW_IS_BAD:"Below is Bad",IDS_WIDTH:"Width",IDS_MEKKOCHART:"Marimekko chart",IDS_HOVERLINEVISIBLE:"hoverlineVisible",IDS_COMBINATIONEXCHART:"Combination Chart",IDS_HORIZONTALMEKKOCHART:"Horizontal Marimekko Chart",IDS_BUBBLECHART:"Bubble Chart",IDS_BASEMULTIPLEXYCHART:"Base Multiple XY Chart",IDS_TRELLISRADARCHART:"Trellis Radar Chart",IDS_TRELLISVERTICALBULLETCHART:"Trellis Vertical Bullet Chart",IDS_HEADERVISIBLE:"headerVisible",IDS_FISCALYEAR:"Fiscal Year",IDS_LINECHART:"Line Chart",IDS_BUBBLEHEIGHT:"Bubble Height",IDS_NUMBERCHART:"Numeric Point",IDS_PERCENTAGEHORIZONTALMEKKOCHART:"100% Horizontal Marimekko Chart",IDS_PERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart",IDS_MARKER:"Marker",IDS_BASEVERTICALCHART:"Base Vertical XY Chart",IDS_SEMANTICTOTAL:"Total",IDS_DIUALLINECHART:"Line Chart with 2 Y-Axes",IDS_TRELLIS_COLUMN:"Trellis Column",IDS_BASEMULTIPLECHART:"Base Multiple Chart",IDS_PERCENTAGEMEKKOCHART:"100% Marimekko Chart",IDS_MULTIDUALVERTICALBARCHART:"Multiple Column Chart with 2 Y-Axes",IDS_DUALCOMBINATIONCHART:"Combined Column Line Chart with 2 Y-Axes",IDS_RADARCHART:"Radar Chart",IDS_TRELLISCOMBINATIONCHART:"Trellis Combined Column Line Chart",IDS_DUALSTACKEDBARCHART:"Stacked Bar Chart with 2 X-Axes",IDS_TRELLISPERCENTAGEAREACHART:"Trellis 100% Area Chart",IDS_SELECTABILITY:"Selectability",IDS_AXISVISIBLE:"axisVisible",IDS_TRELLISDUALSTACKEDCOLUMNCHART:"Trellis Stacked Column Chart with 2 Y-Axes",IDS_DEFAULTCHARTTITLE:"Title of Chart",IDS_ERROR_INVALIDE_DATA_MULTIPLEUNITS:"Some measures have different units.",IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart",IDS_AXISLABELS:"Axis Labels",IDS_MULTIDUALSTACKEDBARCHART:"Multiple Stacked Bar Chart with 2 X-Axes",IDS_MULTIRADARCHART:"Multiple Radar Chart",IDS_COLORING_TYPE_CRITICAL:"Warning",IDS_TRELLIS_ROW:"Trellis Row",IDS_TIMESERIESBULLETCHART:"Bullet Chart for Date/Time Series",IDS_MULTILINECHART:"Multiple Line Chart",IDS_BARCHART:"Bar Chart",IDS_3D_BAR:"3D Bar Chart",IDS_TRELLISCOLUMNCHART:"Trellis Column Chart",IDS_DATAUPDATING:"dataUpdating",IDS_3D_COLUMN:"3D Column Chart",IDS_TRELLISPIECHART:"Trellis Pie Chart",IDS_NETWORKCHART:"Network Chart",IDS_HORIZONTALLINECHART:"Horizontal Line Chart",IDS_DUALVERTICALBARCHART:"Column Chart with 2 Y-Axes",IDS_DECREASING:"Decreasing",IDS_RECTANGLEWEIGHT:"Rectangle Weight",IDS_PIEDEPTHSIZE:"Depth Size",IDS_MULTIHORIZONTALLINECHART:"Multiple Horizontal Line Chart",IDS_DUALHORIZONTALSTACKEDCOMBINATIONCHART:"Horizontal Combined Stacked Line Chart with 2 X-Axes",IDS_COLOR:"color",IDS_TEXT:"Text",IDS_DUALBARCHART:"Bar Chart with 2 X-Axes",IDS_DATALOADING:"dataLoading",IDS_TRELLISLINECHART:"Trellis Line Chart",IDS_LINECONFIG:"lineConfig",IDS_BASECHART:"Base Chart",IDS_TRELLISDUALCOLUMNCHART:"Trellis Column Chart with 2 Y-Axes",IDS_HORIZONTALBOXPLOTCHART:"Horizontal Box Plot",IDS_VALUES_SELECTED:"values selected",IDS_PRIMARYVALUECOLORPALETTE:"primaryValuesColorPalette",IDS_DUALHORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart with 2 X-Axes",IDS_TRELLISDONUTCHART:"Trellis Doughnut Chart",IDS_HIGHCOLUMN:"highColumn",IDS_PERCENTAGEHORIZONTALAREACHART:"100% Horizontal Area Chart",IDS_TREEMAPCHART:"Tree Map",IDS_TIMESERIESPERCENTSTACKEDCOLUMNCHART:"100% Stacked Column Chart for Date/Time Series",IDS_MULTISCATTERCHART:"Multiple Scatter Plot",IDS_TIMELINECHART:"Line Chart for Date/Time Series",IDS_SEMANTICCOLORRANGE:"Semantic Range",IDS_MODE:"Mode",IDS_TIME_TO:"To",IDS_TRELLISDUALLINECHART:"Trellis Line Chart with 2 Y-Axes",IDS_COLORING_TYPE_NEGATIVE:"Bad",IDS_BULLETCHART:"Bullet Chart",IDS_AREACHART:"Area Chart",IDS_TIMESERIESCOMBINATIONCHART:"Combined Column Line Chart for Date/Time Series",IDS_FORECAST_VALUES:"Forecast Values",IDS_LINE:"Line",IDS_CATEGORY_AXIS:"Category Axis",IDS_ENDCOLOR:"endcolor",IDS_TIMESERIESSTACKEDCOLUMNCHART:"Stacked Column Chart for Date/Time Series",IDS_DUALPERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart with 2 X-Axes",IDS_VALUE_AXIS2:"Value Axis 2",IDS_WEIGHT:"weight",IDS_REGIONSHAPE:"Region Shape",IDS_DONUTCHART:"Donut Chart",IDS_TITLE:"Title",IDS_CURRENT_SELECTION:"Current Selection",IDS_TIMESERIESWATERFALLCHART:"Waterfall Chart for Date/Time Series",IDS_MULTIPERCENTAGEHORIZONTALAREACHART:"Multiple 100% Horizontal Area Chart",IDS_RECTANGLECOLOR:"Rectangle Color",IDS_CATEGORYAXIS:"Axis Labels Category",IDS_COLUMNSEQUENCE:"columnSequence",IDS_MAINLABELAXISNAME:"Main Category Axis",IDS_RADARAXES:"Radar Axes",IDS_DAY:"Day",IDS_HORIZONTALSTACKEDCOMBINATIONCHART:"Horizontal Combined Stacked Line Chart",IDS_PERCENTAGEDONUTCHART:"100% Donut Chart",IDS_SHOWFIRSTLINE:"showFirstLine",IDS_DRAWINGEFFECT:"drawingEffect",IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart with 2 X-Axes",IDS_TRELLISBUBBLECHART:"Trellis Bubble Chart",IDS_TRELLISDUALBARCHART:"Trellis Bar Chart with 2 X-Axes",IDS_TRELLISDUALHORIZONTALLINECHART:"Trellis Horizontal Line Chart with 2 X-Axes",IDS_BAR:"Bar",IDS_TAGWEIGHT:"Tags Weight",IDS_POSITION:"Position",IDS_STACKEDCOMBINATIONCHART:"Combined Stacked Line Chart",IDS_TRELLISDUALSTACKEDBARCHART:"Trellis Stacked Bar Chart with 2 X-Axes",IDS_NEGATIVE_INFINITY:"-Infinity",IDS_MULTIAREACHART:"Multiple Area Chart",IDS_DUALSTACKEDCOMBINATIONCHART:"Combined Stacked Line Chart with 2 Y-Axes",IDS_MULTIDONUTCHART:"Multiple Doughnut Chart",IDS_RECTANGLETITLE:"Rectangle Title",}});
(function (global) {
    // cache global require & define
    sap.viz.moduleloader.originalDefine = global.define;
    sap.viz.moduleloader.originalRequire = global.require;
    sap.viz.moduleloader.originalRequirejs = global.requirejs;

    // replace with sap.viz.moduleloader.require/define
    global.define = sap.viz.moduleloader.define;
    global.require = sap.viz.moduleloader.require.config({
        context: 'info'
    });
    global.requirejs = require;
})(this);

define('sap/viz/chart/layout/BaseLayout',[
    'sap/viz/framework/property/PropertyManager'
], function(PropertyManager){

    /**
     * The base class for all layout algorithms.
     * @constructor
     * @abstract
     * @param {sap.viz.chart.components.container.UIContainer} [container]
     */
    function BaseLayout(container){
        this.config = new PropertyManager();
        this.config.add({
            container: container,
            totalWidth: 0,
            totalHeight: 0
        });
    }

    var prot = BaseLayout.prototype;

    /**
     * Calculate layout position and size for every component
     * @param {Association Array} components
     * @return: {Association Array} - an association array of layout result for every item
     * Each layout result is: 
     * {
     *    width: ...
     *    height: ...
     *    x: ...
     *    y: ...
     * }
     */
    prot.layout = function(components){
    };

    prot._dictToArray = function(dict){
        var arr = [];
        for(var key in dict){
            if(dict.hasOwnProperty(key)){
                arr.push(dict[key]);
            }
        }
        return arr;
    };

    prot.destroy = function() {
        this.config.destroy();
        this.config = null;
    };
    
    return BaseLayout;
});

define('sap/viz/chart/layout/DockLayout',[
    "sap/viz/framework/common/util/oo",
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/PositionUtil',
    "sap/viz/chart/layout/BaseLayout"
], function(oo, Constants, TypeUtils, NumberUtils, PositionUtils, BaseLayout) {

    var DockLayout = function() {
        DockLayout.superclass.constructor.apply(this, arguments);
        this.config.add({
            padding: null,
            paddingLeft: null,
            paddingRight: null,
            paddingTop: null,
            paddingBottom: null,
            isTrellis : false
        });
    };

    oo.extend(DockLayout, BaseLayout);

    DockLayout.Position = {
        top: "top",
        bottom: "bottom",
        left: "left",
        right: "right"
    };

    var MIN_WIDTH_HEIGHT_LIMITATION_FOR_PADDING = 108;
    var MIN_PADDING_WHEN_LIMITATION = 5;
    var MIN_WIDTH_HEIGHT_FOR_LAYOUT = 0;
    var FIX_AXIS_SPACING_MAX_IN_PX = Constants.AXIS.FIX_SPACING_MAX_IN_PX;
    var FIX_SPACING_MAX_IN_PX = Constants.TITLE.FIX_SPACING_MAX_IN_PX;

    function hasEnoughSpace(bound, preferredSize, maxSize, isHorizontal) {

        var minWidth = preferredSize.minWidth || 0;
        var minHeight = preferredSize.minHeight || 0;

        if (bound.width < minWidth || bound.height < minHeight) {
            return false;
        }

        if (preferredSize.width && preferredSize.height) {
            if (preferredSize.width < preferredSize.minWidth ||
                preferredSize.height < preferredSize.minHeight) {
                return false;
            }
        }

        if (isHorizontal === false && maxSize.maxWidth && maxSize.maxWidth < preferredSize.minWidth) {
            return false;
        }

        if (isHorizontal === true && maxSize.maxHeight && maxSize.maxHeight < preferredSize.minHeight) {
            return false;
        }

        return true;
    }

    function getMaxSizeValue(width, height, layoutInfo) {

        var result = {};

        if (layoutInfo == null) {
            return result;
        }

        [{d: 'width', md: 'maxWidth', pd: width},
         {d: 'height', md: 'maxHeight', pd: height}]
        .forEach(function(dim){
            var actualSize, actualMaxSize;

            actualSize = parseFloat(layoutInfo[dim.d])>=0 && NumberUtils.getSizeValue(layoutInfo[dim.d], dim.pd);
            actualMaxSize = NumberUtils.getSizeValue(layoutInfo[dim.md], dim.pd);
            if (actualSize > actualMaxSize) {
                result[dim.md] = actualSize;
            }else if (layoutInfo[dim.md]) {
                result[dim.md] = actualMaxSize;
            }
        });
         
        return result;
    }

    function calculatePadding(config, width, height) {

        var getPositiveInt = NumberUtils.getPositiveInt;
        var constantPaddingInPX = Constants.PADDING.DEFAULT;
        if(constantPaddingInPX < 1 && constantPaddingInPX > 0){
            constantPaddingInPX = constantPaddingInPX * Math.min(width, height);
        }

        // if padding is not set, default value is 24
        var padding = getPositiveInt(config.get("padding"), constantPaddingInPX);
        var paddingTop = getPositiveInt(config.get("paddingTop"), padding);
        var paddingRight = getPositiveInt(config.get("paddingRight"), padding);
        var paddingBottom = getPositiveInt(config.get("paddingBottom"), padding);
        var paddingLeft = getPositiveInt(config.get("paddingLeft"), padding);

        var isFixedPadding = config.get('isFixedPadding');

        if (!isFixedPadding && (width <= MIN_WIDTH_HEIGHT_LIMITATION_FOR_PADDING ||
            height <= MIN_WIDTH_HEIGHT_LIMITATION_FOR_PADDING)) {
            paddingTop = Math.min(MIN_PADDING_WHEN_LIMITATION, paddingTop);
            paddingRight = Math.min(MIN_PADDING_WHEN_LIMITATION, paddingRight);
            paddingBottom = Math.min(MIN_PADDING_WHEN_LIMITATION, paddingBottom);
            paddingLeft = Math.min(MIN_PADDING_WHEN_LIMITATION, paddingLeft);

            config.set('paddingTop', paddingTop);
            config.set('paddingRight', paddingRight);
            config.set('paddingBottom', paddingBottom);
            config.set('paddingLeft', paddingLeft);
        }

        return {
            paddingTop: paddingTop,
            paddingRight: paddingRight,
            paddingBottom: paddingBottom,
            paddingLeft: paddingLeft
        };
    }

    function stackSpacingDefault(x) {
        return x.option.spacing;
    }

    /*
     * modules:
     * [{
     *      module: null,
     *      priority: 1,
     *      maxHeight: 1,
     *      maxWidth: 1,
     *      position: 1
     * }]
     */
    DockLayout.prototype.layout = function(components, options){
        var config = this.config;
        var width = config.get('totalWidth');
        var height = config.get('totalHeight');
        var isFixedPadding = config.get('isFixedPadding');

        var spacingFn = stackSpacingDefault;

        var paddingInfo = calculatePadding(config, width, height);

        var bounds = {
            x: paddingInfo.paddingLeft,
            y: paddingInfo.paddingTop,
            //width should be not negative
            width: (width - (paddingInfo.paddingLeft + paddingInfo.paddingRight)) > 0 ?
                (width - (paddingInfo.paddingLeft + paddingInfo.paddingRight)) : MIN_WIDTH_HEIGHT_FOR_LAYOUT,
            height: (height - (paddingInfo.paddingTop + paddingInfo.paddingBottom)) > 0 ?
                (height - (paddingInfo.paddingTop + paddingInfo.paddingBottom)) : MIN_WIDTH_HEIGHT_FOR_LAYOUT
        };

        var maxBoundWidth = bounds.width;
        var maxBoundHeight = bounds.height;

        var componentsArray = this._dictToArray(components);

        componentsArray.sort(function(a, b) {
            return a.option.priority - b.option.priority;
        });

        var results = {};
        
        var isTrellis = config.get('isTrellis');

        var fixLayoutFloat = function(bounds){ 
                if (bounds.width < 1) {
                    bounds.width = 0;
                }
                if (bounds.height < 1) {
                    bounds.height = 0;
                }
            };

        for (var i = 0; i < componentsArray.length; i++) {
            var component = componentsArray[i];
            var layoutInfo = component.option;
            var module = component.module;
            var maxSize = getMaxSizeValue(maxBoundWidth, maxBoundHeight, layoutInfo);
            var isHorizontal = PositionUtils.isHorizontal(layoutInfo.position);
            var isFixSize = (isHorizontal ? parseFloat(layoutInfo.height) >=0 : parseFloat(layoutInfo.width) >= 0) && 
                        component.module.properties().visible === true;

            if (layoutInfo && layoutInfo.position) {
                var spacingWithMainToRough, spacingMaxInPX;
                var spacing = spacingFn(component);
                if(spacing){
                    spacingWithMainToRough = spacing.spacingWithMainToRough || 0;
                    spacingMaxInPX = spacing.spacingMaxInPX || 0;
                }else{
                    spacingWithMainToRough = 0;
                    spacingMaxInPX = 0;
                }
                if (isFixSize) {
                    //legend group must know the real size that DockLayout can give to calculate the wrap info
                    bounds.maxWidth = NumberUtils.getSizeValue(layoutInfo.width, bounds.width - 
                        Math.min(spacingWithMainToRough * bounds.width, spacingMaxInPX));
                    bounds.maxHeight = NumberUtils.getSizeValue(layoutInfo.height, bounds.height -
                        (module.alias === 'title' ? 0 :
                        Math.min(spacingWithMainToRough * bounds.height, spacingMaxInPX)));
                }
                var componentSize = module.getPreferredSize(bounds, isTrellis, isFixSize, options);
                // if space is not enough, the module is not participated in layout phase.
                if (!isFixSize && !hasEnoughSpace(bounds, componentSize, maxSize, isHorizontal)) {
                    results[module.alias] = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                    continue;
                }

                var result = {
                    width: isFixSize ? 
                        NumberUtils.getSizeValue(layoutInfo.width, bounds.width - 
                            Math.min(spacingWithMainToRough * bounds.width, spacingMaxInPX)) : componentSize.width,
                    height: isFixSize ? 
                        NumberUtils.getSizeValue(layoutInfo.height, bounds.height - (module.alias === 'title' ? 0 :
                            Math.min(spacingWithMainToRough * bounds.height, spacingMaxInPX))) : componentSize.height
                };

                // set size
                if (isHorizontal) {
                    if(componentSize.maxSize && componentSize.maxSize.width < bounds.width) {
                        result.actualWidth = componentSize.maxSize.width;
                    }                
                    result.width = bounds.width;
                    if (maxSize.maxHeight && maxSize.maxHeight < result.height) {
                        result.height = maxSize.maxHeight;
                    }

                } else {
                    if(componentSize.maxSize && componentSize.maxSize.height < bounds.height) {
                        result.actualHeight = componentSize.maxSize.height;
                    }
                    result.height = bounds.height;
                    if (maxSize.maxWidth && maxSize.maxWidth < result.width) {
                        result.width = maxSize.maxWidth;
                    }
                }

                if(!isFixSize && (result.width === 0 || result.height === 0)){
                    spacingWithMainToRough = 0;
                    spacingMaxInPX = 0;
                }
                var position = layoutInfo.position;
                if(DockLayout.Position[position] === undefined){
                    if(layoutInfo.defaultPosition){
                        position = layoutInfo.defaultPosition;
                    }
                }
                var spacingInPX = 0;
                var isFixedPaddingSpace = isFixedPadding && result.width !== 0 && result.height !== 0;
                if (position === DockLayout.Position.top) {
                    spacingInPX = isFixedPaddingSpace ? FIX_SPACING_MAX_IN_PX : 
                        (isFixSize && module.alias === 'title' ? 0 : 
                        Math.min(spacingWithMainToRough * bounds.height, spacingMaxInPX));
                    result.x = bounds.x;
                    result.y = bounds.y;
                    bounds.y += (result.height + spacingInPX);
                    bounds.height -= (result.height + spacingInPX);

                } else if (position === DockLayout.Position.bottom) {
                    spacingInPX = isFixedPaddingSpace ? FIX_SPACING_MAX_IN_PX : 
                        (isFixSize && module.alias === 'title' ? 0 : 
                        Math.min(spacingWithMainToRough * bounds.height, spacingMaxInPX));
                    bounds.height -= result.height;
                    result.x = bounds.x;
                    result.y = bounds.y + bounds.height;
                    if (isFixedPadding && module.alias === 'legendGroup') {
                        spacingInPX = FIX_AXIS_SPACING_MAX_IN_PX;
                    }
                    bounds.height -= spacingInPX;
                    if(bounds.height < 0) {
                        bounds.height = 0;
                    }
                } else if (position === DockLayout.Position.left) {
                    spacingInPX = isFixedPaddingSpace ? FIX_SPACING_MAX_IN_PX : 
                        Math.min(spacingWithMainToRough * bounds.width, spacingMaxInPX);
                    result.x = bounds.x;
                    result.y = bounds.y;
                    bounds.x += result.width + spacingInPX;
                    bounds.width -= (result.width + spacingInPX);

                } else if (position === DockLayout.Position.right) {
                    spacingInPX = isFixedPaddingSpace ? FIX_SPACING_MAX_IN_PX : 
                        Math.min(spacingWithMainToRough * bounds.width, spacingMaxInPX);
                    bounds.width -= result.width;
                    result.x = bounds.x + bounds.width;
                    result.y = bounds.y;
                    bounds.width -= spacingInPX;
                    if(bounds.width < 0) {
                        bounds.width = 0;
                    }
                }
                results[module.alias] = result;
                if(isFixSize) {
                    fixLayoutFloat(bounds);        
                    if (!hasEnoughSpace(result, componentSize, maxSize, isHorizontal)) {
                        results[module.alias] = {
                            x: results[module.alias].x ? results[module.alias].x : 0,
                            y: results[module.alias].y ? results[module.alias].y : 0,
                            width: 0,
                            height: 0
                        };
                    }            
                }
            } else {
                results[module.alias] = {
                    x: bounds.x,
                    y: bounds.y,
                    width: bounds.width,
                    height: bounds.height
                };
            }
        }
        return results;
    };

    return DockLayout;
});

define('sap/viz/chart/layout/GridLayout',[
    "sap/viz/framework/common/util/oo",
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/PositionUtil',
    "sap/viz/chart/layout/DockLayout"
], function(oo, Constants, TypeUtils, NumberUtils, PositionUtils, DockLayout) {

    var GridLayout = function() {
        GridLayout.superclass.constructor.apply(this, arguments);
        this.config.add({
            legendGroup: { 
                layout: {
                    respectPlotPosition: true,
                    alignment: "topLeft",
                }
            },
            title: { 
                layout: {
                    respectPlotPosition: true
                }
            }
        });
    };

    oo.extend(GridLayout, DockLayout);
    
    
    /*
     * modules:
     * [{
     *      module: null,
     *      priority: 1,
     *      maxHeight: 1,
     *      maxWidth: 1,
     *      position: 1
     * }]
     */
    GridLayout.prototype.layout = function(components, options) {
        
        var positionDef = DockLayout.Position;
        
        var results = GridLayout.superclass.layout.call(this, components, options);
        
        var centerKey = this._getCenterModuleKey(components, positionDef);
        
        if (centerKey == null) {
            
            for (var itemKey in components) {
                if (components.hasOwnProperty(itemKey)) {
                    var current = components[itemKey].module;
                    current.setSize(results[itemKey]);
                    if (current.layout) {
                        current.layout();
                    }
                }
            }
            
            return results;
        }
        
        var centerSize = results[centerKey];
        var centerModule = components[centerKey].module;
        centerModule.setSize(centerSize);
        if (centerModule.layout){
            centerModule.layout(options, centerSize);
        }
        
        var plotX = centerSize.x;
        var plotY = centerSize.y;
        var plotWidth = centerSize.width;
        var plotHeight = centerSize.height;
        
        if (centerModule.getPlotPosition) {
            var plotPosition = centerModule.getPlotPosition();
            plotX += plotPosition.x;
            plotWidth = plotPosition.width;
            plotY += plotPosition.y;
            plotHeight = plotPosition.height;
        }
        
        for (var key in components) {
            if (components.hasOwnProperty(key)) {
                
                if (key === centerKey) {
                    continue;
                }
                
                var option = components[key].option;
                var position = option.position || option.defaultPosition;
                              
                //for legendGroup, if respectPlotPosition is false, it should not change x,y and size.
                if( (key !== Constants.LEGEND_GROUP.KEY || 
                   this.config.get("legendGroup.layout.respectPlotPosition")) &&
                   (key !== Constants.TITLE.KEY || 
                           this.config.get("title.layout.respectPlotPosition"))) {   
                    if (position === "top" || position === "bottom") {
                        results[key].x = plotX;
                        results[key].width = plotWidth;
                    } else if (position === "left" || position === "right") {
                        results[key].y = plotY;
                        results[key].height = plotHeight;
                    }
                }
                
                if(key === Constants.LEGEND_GROUP.KEY &&
                   this.config.get("legendGroup.layout.alignment") === "center"
                   ) {
                    if((position === "left" || position === "right") &&
                        results[key].actualHeight && 
                        results[key].actualHeight < results[key].height) {
                        results[key].y += (results[key].height - results[key].actualHeight)/2;                        
                    } 
                    else if((position === "top" || position === "bottom") &&
                        results[key].actualWidth && 
                        results[key].actualWidth < results[key].width) {
                        results[key].x += (results[key].width - results[key].actualWidth)/2;                        
                    } 
                }
                
                if(key === Constants.LEGEND_GROUP.KEY &&
                    options.isRTL && this.config.get("legendGroup.layout.alignment") === "topLeft" &&
                    (position === "top" || position === "bottom")) {
                    var offset = results[key].width - results[key].actualWidth;
                    if(offset > 0) {
                        results[key].x += offset;
                    }
                }
                
                var currentModule = components[key].module;
                currentModule.setSize(results[key]);
                if (currentModule.layout) {
                    currentModule.layout();
                }
            }
        }
        
        return results;
    };

    GridLayout.prototype._getCenterModuleKey = function(components, positionDef) {
        
        for (var key in components) {
            if (components.hasOwnProperty(key)) {
                
                var option = components[key].option;
                var position = option.position || option.defaultPosition;
                
                if (positionDef[position] == null) {
                    return key;
                }
            }
        }
        return null;
    };
    
    return GridLayout;
});

define('sap/viz/chart/components/UIComponent',[
    "sap/viz/framework/common/util/EventDispatch",
    "sap/viz/framework/core/Runtime",
    "sap/viz/framework/property/PropertyManager"
], function Setup(EventDispatch, Runtime, PropertyManager) {

    /**
     * To initialize UI component object.
     *
     * @name UIComponent
     * @constructor
     * @param {framework/core/Runtime} runtime
     * @param {Object} options
     */
    var UIComponent = function(runtime, options) {

        options = options || {};
        this._options = options;
        this._name = options.name ? options.name : null;

        this._eventDispatch = new EventDispatch();

        this._data = null;
        
        // used in UIContainer
        this.alias = options.alias || null;
        
        this._renderTo = 'SVG';

        this._size = {
            width: 0,
            height: 0
        };

        this._realSize = {
            width: 0,
            height: 0
        };

        this._runtime = runtime ? runtime : Runtime._create(options);

        // Allow the creator to pass its PropertyManager to this module, so that
        // this module can get proxy based on it, instead of the root one.
        // TODO Jove fix the temp propertyMgr reference here
        var propertyManager = options.properties || this._runtime._propertyMgr;

        this._properties = (this._name) ? propertyManager.proxy(this._name) :
            propertyManager;
        
       

        if (runtime == null) {
            this._addDefaultProperties();
        }
    };
    
    UIComponent.prototype._isRTL = function(){
        var isRTL = false;
        var envManager = this._runtime.envManager();
        if (envManager) {
            isRTL = envManager.isRTL();
        }
        return isRTL;
    };

    /**
     * allow the creator to set properties of component individually.
     */
    UIComponent.prototype.properties = function(props) {
        
        if (arguments.length === 0 || typeof props === 'string') {
            return this._properties.get(props);
        }
        
        this._properties.set(props);
    };
    
    /**
     * @return {framework/core/Runtime}
     */
    UIComponent.prototype.runtime = function() {
        return this._runtime;
    };

    /**
     * @return {Boolean}
     */
    UIComponent.prototype.isVisible = function() {
        return true;
    };

    /**
     * @return {String}
     */
    UIComponent.prototype.getName = function() {
        return this._name;
    };

    /**
     * To set data.
     */
    UIComponent.prototype.setData = function(data) {
        this._data = data;
        return this;
    };

    /**
     * To get data.
     */
    UIComponent.prototype.getData = function() {
        return this._data;
    };

    /**
     * To set render container(DIV/SVG).
     */
    UIComponent.prototype.renderTo = function(data) {
        if(arguments.length){
            this._renderTo = data;
            return this;
        }
        return this._renderTo;
    };
    /**
     * To set visual canvas size
     
     * @param size {width: Number, height: Number}
     */
    UIComponent.prototype.setSize = function(sizeInfo) {
        if (sizeInfo.width != null) {
            this._size.width = sizeInfo.width;
            this._realSize.width = sizeInfo.width;
        }
        if (sizeInfo.height != null) {
            this._size.height = sizeInfo.height;
            this._realSize.height = sizeInfo.height;
        }
        return this;
    };

    UIComponent.prototype.getSize = function() {
        return {
            height: this._size.height,
            width: this._size.width
        };
    };
    
    UIComponent.prototype.clearSize = function() {
        this._size.height = 0;
        this._size.width = 0;   
        return this;
    };

    /**
     * To set real size
     *
     * @param size {width: Number, height: Number}
     */
    UIComponent.prototype.setRealSize = function(sizeInfo) {
        if (sizeInfo.width != null) {
            this._realSize.width = sizeInfo.width;
        }
        if (sizeInfo.height != null) {
            this._realSize.height = sizeInfo.height;
        }
        return this;
    };

    /**
     * To obtain container measure size.
     *
     * @param measureInfo {width: Number, height: Number} optional the max width and height allown for this component
     *
     * @return {
     *   maxWidth: ?,
     *   maxHeight: ?,
     *   minWidth: ?,
     *   minHeight: ?,
     *   width: ?,
     *   height: ?
     *  }
     */
    UIComponent.prototype.getPreferredSize = function(measureInfo) {};

    /**
     * To render element.
     *
     * @param rootElement {D3Selection} the parent D3 selection for rendering
     */
    UIComponent.prototype.render = function(rootElement) {};

    /**
     * @return {framework/common/util/EventDispatch}
     */
    UIComponent.prototype.getDispatch = function() {
        return this._eventDispatch;
    };

    UIComponent.prototype.destroy = function() {
        if (this._eventDispatch) {
            this._eventDispatch.destroy();
        }
        
        this._runtime = null;
        this._eventDispatch = null;
        this._data = null;
        
        // only destroy proxy property manager
        // original property manager will be destroyed in ChartApp.
        if (this._properties && this._properties.origin != this._properties) {
            this._properties.destroy();
        }
        this._properties = null;
        this._size = null;
        this._name = null;
        this._options = null;
        this._renderTo = null;
        this._realSize = null;
        this.alias = null;
    };

    UIComponent.prototype._exposeMoreEvents = function() {
        this._eventDispatch.addEventTypes.apply(this._eventDispatch, arguments);
        return this;
    };

    // Prevent from non-definition for standalone mode.
    UIComponent.prototype._addDefaultProperties = function() {};

    UIComponent.prototype.statusChanged = function(status){};
    
    return UIComponent;
});

define('sap/viz/chart/components/util/BoundUtil',[],
    function Setup() {
        var classname = 'v-bound';
        var BoundUtil = {
            drawBound: function(selection, width, height, css, isEventRect) {
                var rect;
                if (width < 0 || height < 0) {
                    return null;
                }
                if (selection.select('.' + classname).node() == null) {
                    rect = selection.insert('rect', ':first-child').attr('class', classname).attr('width', width).attr(
                        'height', height);
                    if (isEventRect) {
                        rect.attr("fill", "transparent");
                    } else {
                        rect.attr('visibility', 'hidden');
                    }
                } else {
                    rect = selection.select('.' + classname).attr('width', width).attr('height', height);
                }

                if (css) {
                    for (var i in css) {
                        if (css.hasOwnProperty(i)) {
                            rect.attr(i, css[i]);
                        }
                    }
                }
                return rect;
            }

        };

        return BoundUtil;
    });
define('sap/viz/chart/components/util/StyleUtils',[], function() {

    var cssPropsMapping = {
        color: "fill",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontWeight: "font-weight",
        letterSpacing: "letter-spacing",
        fontStyle: "font-style"
    };
    
    var styleUtilObj = {};

    styleUtilObj.convertToCss = function(styleObj) {
        var result = [];

        for (var name in cssPropsMapping) {
            if (styleObj[name] != null) {
                result.push(cssPropsMapping[name] + ":" + styleObj[name]);
            }
        }
        return result.join(";");
    };
    
    styleUtilObj.buildParentStyle = function(childStyle, parentStyle) {
        //the requirement is: if parentStyle property is null, it uses child style property.
        var realParentStyle = {};
        var prop;
        for (prop in childStyle) {
            if (childStyle.hasOwnProperty(prop)) {
                realParentStyle[prop] = (parentStyle && parentStyle[prop]) || 
                                        childStyle[prop];
            }
        }
        return realParentStyle;
    };

    return styleUtilObj;
});
define('sap/viz/chart/components/util/TextUtils',['sap/viz/framework/common/util/TypeUtils',
        "sap/viz/framework/common/util/NumberUtils",
        'sap/viz/framework/common/util/UADetector',
        "sap/viz/framework/common/util/GeometryUtils",
        'sap/viz/chart/components/util/StyleUtils'],
    function Setup(TypeUtils, NumberUtils, UADetector, GeometryUtils, StyleUtils) {
        var ns = "http://www.w3.org/2000/svg";
        var node;
        var svgNode;
        var canvasNode;
        var context2D;
        var canvasFont;
        var fasterFun;
        var sensitiveStyle = ["font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style",
            "font-variant", "font-weight", "letter-spacing", "word-spacing", "alignment-baseline", "baseline-shift",
            "dominant-baseline"
        ];
        var textSizeCache = {};
        var textSizeCacheForSuper = [];
        var textHeightCacheForCanvas = {};
        var textSizeCacheForCanvas = {};
        var myTextSizeCache = [];
        var computedTextSizeCache = {};

        function getSvgNode(){
            var svg = document.body.appendChild(document.createElementNS(ns, "svg"));
            svg.style.cssText = "position:absolute;top:-1000px;z-index:-9000;width:1px;height:1px";
            return svg;
        }

        function getNode() {
            if (!node) {
                if(!svgNode){
                    svgNode = getSvgNode();
                }
                node = svgNode.appendChild(document.createElementNS(ns, "text"));
            }
            return node;
        }

        function applyText(text, style) {
            var node = getNode();

            if (!style) {
                node.removeAttribute("style");
            } else {
                if (!TypeUtils.isString(style)) {
                    var computedStyle = UADetector.isIE() ? style.ownerSVGElement.getComputedStyle(style) : window
                        .getComputedStyle(style);

                    var cssText = "";
                    sensitiveStyle.forEach(function(i) {
                        var s = computedStyle.getPropertyValue(i);
                        if (s !== null) {
                            cssText += i + ":" + s + ";";
                        }
                    });
                    style = cssText;
                }
                node.style.cssText = style;
            }
            if (text === undefined || text === null) {
                text = "";
            }

            node.textContent = text;
            return node;
        }

        function getComputedTextLengthWithSpace(node) {
            var text = node.textContent;
            if (text.substr(text.length - 1, 1) === ' ') {
                //consider ending whitespaces beacuse browser will trim whitespace 
                //when calling getComputedTextLength() and getBoundingClientRect()
                var single = 'M';
                node.textContent = single;
                var singleLength = node.getComputedTextLength();
                node.textContent = text + single;
                var appendLength = node.getComputedTextLength();
                var ret = appendLength - singleLength ;
                node.textContent = text;
                return ret;
            } else {
                return node.getComputedTextLength();
            }
        }

        function isGetSubStringLength(node, i) {
            //the function is used to check if getSubStringLength
            //is supported in IE. getSubStringLength will fail in IE11 if the string has both RTL and LTR characters.
            return (UADetector.isIE() && 
                (i <= 0 || (node.getSubStringLength(0, (i - 1)) < node.getSubStringLength(0, i))));
        }

        function ellipsis(text, textNode, expectedLength, cssStyle, textApplied, reverseDots, 
            hasLetterSpacing, postfix) {
            postfix = postfix || "";
            var ellipsisObj = {};
            var ellipsisLength = 0;
            ellipsisObj.realLength = 0;

            var textStr = "";
            var originText;
            if (text) {
                originText = text.toString();
                textStr = originText + postfix;
            }
            
            function cleanUp(){
                if (textNode) {
                    textNode.textContent = "";
                }
                ellipsisObj.text = "";
            }

            //no space at all
            if(expectedLength <= 0){
                cleanUp();
                return ellipsisObj;
            }
            
            var node, initTextLength;
            node = textApplied ? getNode() : applyText(textStr, cssStyle || textNode);
            initTextLength = hasLetterSpacing ? node.getBoundingClientRect().width : 
                getComputedTextLengthWithSpace(node);
            //enough space, no need to truncate
            if (initTextLength <= expectedLength) {
                if (textNode) {
                    textNode.textContent = textStr;
                }

                ellipsisObj.text = textStr;
                ellipsisObj.realLength = initTextLength;
                return ellipsisObj;
            }

            //get "..." size
            var index = "..." + cssStyle;
            if (!myTextSizeCache[index]) {
                node.textContent = "...";
                myTextSizeCache[index] = hasLetterSpacing ? node.getBoundingClientRect().width : 
                    getComputedTextLengthWithSpace(node);
            }else{
                if(textStr.length > 3){
                    //not enough space for "M..."
                    if (expectedLength < myTextSizeCache[index] /3*4) {
                        cleanUp();
                        return ellipsisObj;
                    }
                }else if(expectedLength < myTextSizeCache[index] / 3 * textStr.length){
                    cleanUp();
                    return ellipsisObj;
                }
            }
            ellipsisLength = myTextSizeCache[index];

            //truncate some chars in a while loop
            expectedLength -= ellipsisLength;
            node.textContent = textStr;
            var i;
            var isValid = false;
        
            if (expectedLength > 0) {
                var charNumber = textStr.length;
                var postfixNumber = postfix && postfix.length || 0;
                i = Math.ceil(expectedLength / initTextLength * charNumber) - postfixNumber;

                var textLength;
                if (!isGetSubStringLength(node, i) || postfix) {
                    node.textContent = text.toString().substring(0, i) + postfix;
                    textLength = hasLetterSpacing ? node.getBoundingClientRect().width : 
                        getComputedTextLengthWithSpace(node);
                } else {
                    textLength = node.getSubStringLength(0, i);
                }
                
                var lastTextLength = textLength;
                var increase = textLength <= expectedLength;
                var add = increase? +1: -1;

                //try to keep as many char as possible
                while ( 0 < i && i <= charNumber) {
                    lastTextLength = trySubstr(increase, originText, postfix, i, 
                                               node, textNode, ellipsisObj, cssStyle, 
                                               expectedLength, reverseDots, hasLetterSpacing, ellipsisLength,
                                               lastTextLength);
                    if(lastTextLength === -1){
                        isValid = true;
                        break;
                    }

                    i += add;
                }
            }
            
            if(!isValid){
                cleanUp();
            }
            return ellipsisObj;
        }

        function trimRight(str) {
            if (TypeUtils.isExist(str)) {
                var endWithSpace = str[str.length - 1] === ' ';
                while (endWithSpace) {
                    str = str.substring(0, str.length - 1);
                    endWithSpace = str[str.length - 1] === ' ';
                }
            }
            return str;
        }

        function trySubstr(increase, originText, postfix, i, 
                            node, textNode, ellipsisObj, cssStyle, 
                            expectedLength, reverseDots, hasLetterSpacing, ellipsisLength, 
                            lastTextLength){
            var subStr = originText.substring(0, i) + postfix;
            var textLength, reText;
            if (!isGetSubStringLength(node, i) || postfix) {
                node.textContent = subStr;
                textLength = hasLetterSpacing ? node.getBoundingClientRect().width : 
                    getComputedTextLengthWithSpace(node);
            } else {
                textLength = node.getSubStringLength(0, i);
            }
            if ((increase && textLength > expectedLength) ||  
                (!increase && textLength <= expectedLength)) {
                subStr = increase ? originText.substring(0, i-1) : originText.substring(0, i);
                var isEmpty = false;
                if (hasLetterSpacing) {
                    var trimStr = trimRight(subStr);
                    subStr = trimStr.substring(0, trimStr.length - 1);
                    isEmpty = subStr.length === 0;
                }
                if (reverseDots) {
                    reText =  isEmpty ? "" : postfix + "..." + subStr;
                }
                else {
                    reText = isEmpty ? "" : subStr + "..." + postfix;
                }
                if (textNode) {
                    textNode.textContent = reText;
                    textNode.appendChild(document.createElementNS(textNode.namespaceURI, "title"))
                        .textContent = originText + postfix;
                }
                ellipsisObj.text = reText;
                ellipsisObj.realLength = (increase ? lastTextLength : textLength ) + ellipsisLength;
                return -1;
            }
            return textLength;
        }
 
        function uniqueStringArray(array) {
            var dict = {};
            var unique = [];
            array.forEach(function(e) {
                if (!dict[e]) {
                    dict[e] = true;
                    unique.push(e);
                }
            });
            return unique;
        }
    
        function mapEscapedChars(e){
            if ("[]\\^$.|?*+(){}".split("").indexOf(e) > -1){
                return "\\" + e;
            } else {
                return e;
            }
        }

        function generateRegExp(str, type) {
            if (str == null || str === "") {
                return str;
            }
            var chars = uniqueStringArray(str.split(""));
            var regDes = "[" + chars.map(mapEscapedChars).join("") + "]+";
            var withGlobal = true;
            if (type === "start"){
                regDes = "^" + regDes;
                withGlobal = false;
            } else if (type === "end"){
                regDes = regDes + "$";
                withGlobal = false;
            }
            return withGlobal ? new RegExp(regDes, "g") : new RegExp(regDes);
        }

        function getDelimiterRegExp(delimiters) {
            return generateRegExp(delimiters.join(""));
        }

        return {
            /**
             * Measure the dimension of the text in given style
             *
             * @param {String}
             *          text the text to be measured
             * @param style
             *          the style definition text or a DOM node. If it is a node, its style will be used to measure
             * text.
             * @returns {Object}
             */
            measure: function(text, style) {
                if (text === '') {
                    return {
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0
                    };
                }
                var box = GeometryUtils.getBBox(applyText(text, style));
                return {
                    width: box.width,
                    height: box.height,
                    x: box.x,
                    y: box.y
                };
            },

            /**
             * Measure text in a canvas
             *
             * @param {String}
             *          the text to be measured
             * @param {String}
             *          fontSize
             * @param {String}
             *          fontWeight
             * @param {String}
             *          fontFamily
             * @param {String}
             *          letterSpacing
             * @returns {Object}
             */
            measureInCanvas: function(text, tFontSize, tFontWeight, tFontFamily) {
                if (!tFontFamily || !tFontSize || !tFontWeight) {
                    //the function cannot get right value
                    return;
                }

                var strWidth = 0;
                if (!canvasNode) {
                    canvasNode = document.createElement("canvas");
                    canvasNode.style.cssText =
                    "position:absolute;top:-1000px;z-index:-9000;width:0px;height:0px;visibility:hidden";
                    document.body.appendChild(canvasNode);
                }

                if (canvasNode.getContext) {
                    if(!context2D){
                        context2D = canvasNode.getContext("2d");
                    }
                    var fontString = tFontWeight + " " + tFontSize + " " + tFontFamily;
                    if(canvasFont != fontString){
                        canvasFont = fontString;
                        context2D.font = fontString;
                    }
                    strWidth = context2D.measureText(text).width;
                }

                if(!textHeightCacheForCanvas[tFontSize]){
                    textHeightCacheForCanvas[tFontSize] =  NumberUtils.preciseSimple(parseFloat(tFontSize) * 1.2);
                }
                var fontSizeFloat = textHeightCacheForCanvas[tFontSize];

                return {
                    width: strWidth,
                    height: fontSizeFloat
                };
            },

            /**
             * Fast measure the dimension of the text in given fontSize, fontWeight and fontFamily
             *
             * @param {String}
             *          text the text to be measured
             * @param {String}
             *          fontSize
             * @param {String}
             *          fontWeight
             * @param {String}
             *          fontFamily
             * @param {String}
             *          letterSpacing
             * @returns {Object}
             */
            fastMeasure: function(text, tFontSize, tFontWeight, tFontFamily, tLetterSpacing, tFontStyle) {
                var index = text + tFontSize + tFontWeight + tFontFamily + tLetterSpacing;
                if(tFontStyle){
                    index += tFontStyle;
                }
                var cachedSize = textSizeCache[index];
                if(!cachedSize){
                    var cssStyle = "font-size:" + tFontSize + "; font-weight:" +
                            tFontWeight + "; font-family:" + tFontFamily + "; letter-spacing:" + tLetterSpacing;
                    if(tFontStyle){
                        cssStyle = cssStyle + '; font-style: ' + tFontStyle;
                    }
                    textSizeCache[index] = this.measure(text, cssStyle);
                    cachedSize = textSizeCache[index];
                }
                return {
                    width: cachedSize.width,
                    height: cachedSize.height,
                    x: cachedSize.x,
                    y: cachedSize.y
                };
            },

            //find the fastest measure function for the browser.
            //measureInCanvas may be faster in Chrome, but not in Firefox.
            bestMeasureFun: function(tFontSize, tFontWeight, tFontFamily, tLetterSpacing) {
                if (!fasterFun) {
                    var i;
                    var testTimes = 100;
                    var testText = "Test";
                    //test measureInCanvas
                    var startC = new Date().getTime();
                    for (i = 0; i < testTimes; i++) {
                        this.measureInCanvas(testText, tFontSize, tFontWeight, tFontFamily);
                    }
                    var endC = new Date().getTime();
                    var timeC = endC - startC;

                    //test measure
                    var startM = new Date().getTime();
                    for (i = 0; i < testTimes; i++) {
                        this.measure(testText, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
                            "; font-family:" + tFontFamily + "; letter-spacing:" + tLetterSpacing);
                    }
                    var endM = new Date().getTime();
                    var timeM = endM - startM;

                    if (timeC < timeM) {
                        fasterFun = "C";
                    } else {
                        fasterFun = "M";
                    }
                }

                return fasterFun;
            },
            /**
             * Super fast measure the dimension of the text in given fontSize, fontWeight and fontFamily
             *
             * @param {String}
             *          text the text to be measured
             * @param {String}
             *          fontSize
             * @param {String}
             *          fontWeight
             * @param {String}
             *          fontFamily
             * @returns {Object}
             */
            superFastMeasure: function(text, FontSize, FontWeight, FontFamily) {
                var index, tFontSize, tFontWeight, tFontFamily, tStyle;
                if (arguments.length === 2) {
                    tStyle = this.parseStyle(FontSize);
                    tFontSize = tStyle.FontSize;
                    tFontWeight = tStyle.FontWeight;
                    tFontFamily = tStyle.FontFamily;
                } else if (arguments.length === 4) {
                    tFontSize = FontSize;
                    tFontWeight = FontWeight;
                    tFontFamily = FontFamily;
                }
                index = text + tFontSize + tFontWeight + tFontFamily;
                var cachedSize = textSizeCacheForSuper[index];
                if (!cachedSize) {
                    if (this.bestMeasureFun(tFontSize, tFontWeight, tFontFamily) === "C") {
                        textSizeCacheForSuper[index] = this.measureInCanvas(text, tFontSize, tFontWeight, 
                            tFontFamily);
                    } else {
                        textSizeCacheForSuper[index] = this.measure(text, "font-size:" + tFontSize + "; font-weight:" +
                            tFontWeight + "; font-family:" + tFontFamily);
                    }
                    cachedSize = textSizeCacheForSuper[index];
                }
                return cachedSize;
            },
            canvasMeasure: function(text, FontSize, FontWeight, FontFamily, LetterSpacing) {
                var index, tFontSize, tFontWeight, tFontFamily, tLetterSpacing, tStyle;
                if (arguments.length === 2) {
                    tStyle = this.parseStyle(FontSize);
                    tFontSize = tStyle.FontSize;
                    tFontWeight = tStyle.FontWeight;
                    tFontFamily = tStyle.FontFamily;
                    tLetterSpacing = tStyle.LetterSpacing;
                } else {
                    tFontSize = FontSize;
                    tFontWeight = FontWeight;
                    tFontFamily = FontFamily;
                    if (LetterSpacing !== undefined && LetterSpacing !== null) {
                        tLetterSpacing = LetterSpacing;
                    }
                }

                //check if font size has unit
                tFontSize = tFontSize.toString();
                var lastChat = tFontSize[tFontSize.length-1];
                if(!isNaN(parseFloat(lastChat))) {
                    tFontSize += "px";
                }

                // check if letter spacing has unit
                if (tLetterSpacing !== undefined && tLetterSpacing !== null) {
                    tLetterSpacing = tLetterSpacing.toString();
                    lastChat = tLetterSpacing[tLetterSpacing.length - 1];
                    if (!isNaN(parseFloat(lastChat))) {
                        tLetterSpacing += "px";
                    }
                }
                index = text + tFontSize + tFontWeight + tFontFamily;
                if (tLetterSpacing !== undefined && tLetterSpacing !== null) {
                    index += tLetterSpacing;
                }
                var cachedSize = textSizeCacheForCanvas[index];
                if (!cachedSize) {
                    cachedSize = (textSizeCacheForCanvas[index] = this.measureInCanvas(text, tFontSize, tFontWeight,
                        tFontFamily));
                }
                return cachedSize;
            },

            /**
             * Ellipsis long text.
             *
             * @param {String}
             *          text the text to be processed
             * @param {Node}
             *          textNode the svg:text which will be display text
             * @param {Number}
             *          maxLength the max text length
             */
            ellipsis: function (text, textNode, maxLength, cssStyle, options, postfix) {
                var ellipsisObj = ellipsis(text, textNode, maxLength, cssStyle, false,
                            (options && options.reverseDots), (options && options.hasLetterSpacing), postfix);
                if (options && options.needRealLength) {
                    return ellipsisObj;
                }
                else {
                    return ellipsisObj.text;
                }
            },

            /**
             * Ellipsis long text in a circle area.
             *
             * @param {String}
             *          text the text to be processed
             * @param {Node}
             *          textNode the svg:text which will be display text
             * @param {Number}
             *          r the radius of circle
             * @param {Number}
             *          h the offset from center of circle
             * @param {Object}
             *          cssStyle the style object
             */
            ellipsisInCircle: function(text, textNode, r, h, cssStyle) {
                var node = applyText(text, textNode);

                var maxLength = Math.sqrt(Math.pow(r, 2) - Math.pow(h + GeometryUtils.getBBox(node).height / 2, 2)) * 2;
                ellipsis(text, textNode, maxLength, cssStyle, true);
            },

            verticalCentralOffset: function(text, textNode) {
                var tmpNode = applyText(text, textNode);
                var box = GeometryUtils.getBBox(tmpNode);
                var actualHeight = -box.y;
                var fontSize = parseInt(tmpNode.ownerSVGElement.getComputedStyle(tmpNode)["fontSize"], 0);
                return (actualHeight - (box.height - fontSize)) / 2;
            },

            parseStyle: function(style) {
                var tStyle = {};
                var temp = style.toLowerCase();
                tStyle.FontSize = this.getStyleValue(temp, "font-size");
                tStyle.FontWeight = this.getStyleValue(temp, "font-weight");
                tStyle.FontFamily = this.getStyleValue(temp, "font-family");
                tStyle.LetterSpacing = this.getStyleValue(temp, "letter-spacing");
                return tStyle;
            },

            getStyleValue: function(style, key) {
                var result, index1, index2;
                index1 = style.indexOf(key);
                if (index1 >= 0) {
                    index1 = style.indexOf(":", index1) + 1;
                    index2 = style.indexOf(";", index1);
                    if (index2 < 0) {
                        index2 = style.length;
                    }
                    result = style.substring(index1, index2);
                }
                return result;
            },
            getTextBaselineOffset: function(styles) {
                var measureBox = this.fastMeasure("Tag", styles['fontSize'], styles['fontWeight'],
                    styles['fontFamily'], styles['letterSpacing']);
                return measureBox.height + measureBox.y;
            },
            getAbsoluteTextBaselineOffset: function(styles) {
                var measureBox = this.fastMeasure("Tag", styles['fontSize'], styles['fontWeight'],
                    styles['fontFamily'], styles['letterSpacing']);
                return measureBox.y;
            },
            getTextBBox: function(textNode){
                var bbox;
                if(textNode.parentNode){
                    bbox = GeometryUtils.getBBox(textNode);
                }else{
                    if(!svgNode){
                        svgNode = getSvgNode();
                    }
                    svgNode.appendChild(textNode);
                    bbox = GeometryUtils.getBBox(textNode);
                }
                return bbox;
            },
            //validate fontWeight and fontSize
            validateFontStyle: function(style){
                if(TypeUtils.isNumber(style)){
                    return style + "px";
                }
                return style;
            },
            destroy: function() {
                if (svgNode && svgNode.parentNode) {
                    svgNode.parentNode.removeChild(svgNode);
                }
                svgNode = null;
                node = null;
                textSizeCache = [];
                textSizeCacheForSuper = [];
                textHeightCacheForCanvas = {};
                textSizeCacheForCanvas = {};
                myTextSizeCache = [];
                if (canvasNode) {
                    canvasNode.parentNode.removeChild(canvasNode);
                }
                canvasNode = null;
                context2D = null;
                canvasFont = null;
            },
            wrapText: function(text, delimiters, width, lineNumber, style) {
                var size, beyond = false, maxWidth = 0;
                var cssStyle = TypeUtils.isString(style)? style : StyleUtils.convertToCss(style);
                var lineWidthArray = [];
                var minWidth = this.getTextLength("M...", cssStyle);
                if (lineNumber === 1) {
                    size = this.getTextLength(text, cssStyle);

                    if (width === undefined || width === null) {
                        //support null and undefined for info/geo
                        beyond = true;
                        maxWidth = size;
                    } else {
                        beyond = size > width;
                        maxWidth = Math.min(size, width);
                    }
                    return {
                        "lines": [text],
                        "maxWidth": maxWidth,
                        "beyond": beyond,
                        "lineWidthArray": [maxWidth]
                    };
                }
                var delimiterRegX = getDelimiterRegExp(delimiters);
                var targetText = String(text).trim();
                if (targetText === "") {
                    return {
                        "lines": [text],
                        "maxWidth": maxWidth,
                        "beyond": beyond,
                        "lineWidthArray": [maxWidth]
                    };
                }
                var lines = [];
                var words = targetText.split(delimiterRegX);
                var wLength = words.length;
                if (wLength <= 1) {
                    lines = [text];
                    maxWidth = this.getTextLength(text, cssStyle);
                    if (width === undefined || width === null) {
                        beyond = true;
                    } else {
                        beyond = maxWidth > width;
                        maxWidth = Math.min(maxWidth, width);
                    }
                    lineWidthArray = [maxWidth];
                } else {
                    var dl;
                    if (delimiterRegX === ""){
                        dl = Array.apply(null, new Array(wLength - 1)).map(String.prototype.valueOf, "");
                    } else {
                        dl = targetText.match(delimiterRegX);
                    }
                    var dLength = dl.length;
                    var count = 0;
                    var reserved = "";
                    var lastSize;
                    for (var i = 0; i < wLength; ++i){
                        if (beyond) {
                            reserved = reserved + (i < dLength ? words[i] + dl[i] : words[i]);
                        } else {
                            var candidate = reserved + (i < dLength ? words[i] + dl[i] : words[i]);
                            lastSize = size;
                            size = this.getTextLength(candidate, cssStyle);
                            ++count;
                            if (size > width){
                                if (count === 1 || lines.length === lineNumber - 1){
                                    beyond = true;
                                    //if beyond, width cannot be smaller than minWidth
                                    maxWidth = width > minWidth ? width : minWidth;
                                    reserved = candidate;
                                    continue;
                                } else {
                                    lines.push(reserved);
                                    lineWidthArray.push(lastSize);
                                    --i;
                                    count = 0;
                                    reserved = "";
                                }
                            } else {
                                maxWidth = Math.max(maxWidth, size);
                                reserved = candidate;
                                if (i === wLength - 1) {
                                    lines.push(reserved);
                                    lineWidthArray.push(size);
                                }
                            }
                        }
                    }
                    if (beyond) {
                        lines.push(reserved);
                        lineWidthArray.push(maxWidth);
                    }
                }
                return {"lines": lines, "maxWidth": maxWidth, "beyond": beyond, "lineWidthArray": lineWidthArray};
            },
            drawWrappedText: function (wrapper, wrappedText, delimiters, lineNumber, width,
                lineHeight, style, options) {
                var isRTL;
                var ellipsisOptions;
                var middleText = true;
                //if no options are set, by default we middle text strings
                if(options) {
                    isRTL = options.isRTL;
                    ellipsisOptions = options.ellipsisOptions;
                    middleText = options.middleText;
                }

                if (TypeUtils.isString(wrappedText)) {
                    wrappedText = this.wrapText(wrappedText, delimiters, width, lineNumber, style);
                }
                wrapper.selectAll('tspan').remove();
                wrapper.selectAll('title').remove();
                var lines = wrappedText.lines;
                
                var length = lines.length;
                var y = 0;
                for (var i = 0; i < length; ++i){
                    var tspanNode = wrapper.append("tspan").attr('aria-hidden', true);
                    if (wrappedText.beyond) {
                        this.ellipsis(lines[i], tspanNode.node(), width,
                            StyleUtils.convertToCss(style), ellipsisOptions);
                        tspanNode.selectAll('title').remove();
                    } else {
                        tspanNode.node().textContent = lines[i];
                    }
                    tspanNode.attr("y", y).attr("x", 0)
                        .attr('font-weight', style['fontWeight'])
                        .attr('font-family', style['fontFamily'])
                        .attr('font-size', style['fontSize'])
                        .attr('letter-spacing', style['letterSpacing'])
                        .attr('font-style', style['fontStyle']);
                    y += lineHeight;

                    var textWidth;
                    if(middleText) {
                        textWidth = wrappedText.lineWidthArray[i];
                        tspanNode.attr("x", (width - textWidth) / 2);
                    }
                    else if(isRTL) {
                        textWidth = wrappedText.beyond ? 
                            tspanNode.node().getComputedTextLength() : wrappedText.maxWidth;
                        tspanNode.attr("x", width - textWidth);
                    }
                }
                wrapper.attr("height", lineHeight * length);
                if (wrappedText.beyond) {
                    wrapper.append("title").node().textContent = wrappedText.lines.join("");
                }
                //return the actual with of wrappeed text
                var actualWidth = 0;
                if (wrappedText && wrappedText.maxWidth) {
                    actualWidth = wrappedText.maxWidth;
                }
                return actualWidth;
            },
            getTextLength: function(text, cssStyle) {
                //use the measure function that ellipsis uses to get accurate value
                var index = text + cssStyle;
                var cachedSize = computedTextSizeCache[index];
                if(!cachedSize){
                    var node = applyText(text, cssStyle);
                    computedTextSizeCache[index] = getComputedTextLengthWithSpace(node);
                    cachedSize = computedTextSizeCache[index];
                }
                return cachedSize;
            }
        };
    });

define('sap/viz/chart/components/title/Title',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/UIComponent',
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/chart/components/util/BoundUtil',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/util/StyleUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/PropertyZoneUtil',
    'sap/viz/framework/common/util/TitleUtil'
], function(oo, UIComponent, langManager, BoundUtil, TextUtils, StyleUtils, UADetector, PropertyZoneUtil,TitleUtil) {

    var Title = function(runtime, options) {
        Title.superclass.constructor.apply(this, arguments);
        
        this._wrapper = null;
        this._height = 0;
        this._width = 0;
        this._pfSize = {
                maxWidth: 0,
                maxHeight: 0,
                minWidth: 0,
                minHeight: 0,
                width: 0,
                height: 0
            };
        var that = this;
        runtime.zoneManager().add({
            tempPropertyZone: {
                title: {
                    value: [],
                    readonly: true,
                    serializable: false,
                    get: function() {
                        var result = [],
                            boundRect, bound;
                        if (that.isVisible()) {
                            boundRect = that._wrapper.node().getBoundingClientRect();
                            bound = [
                                []
                            ];
                            bound[0].push([boundRect.left, boundRect.top]);
                            bound[0].push([boundRect.right, boundRect.top]);
                            bound[0].push([boundRect.right, boundRect.bottom]);
                            bound[0].push([boundRect.left, boundRect.bottom]);
                            result.push({
                                "name": 'title',
                                "bound": bound
                            });
                            if (that._wrapper && that._wrapper.node()) {
                                var root = that._wrapper.node().ownerSVGElement;
                                PropertyZoneUtil.calcOffsetFromChart(root, result);
                            }
                        }
                        return result;
                    }
                }
            }
        });
        var properties = this._properties;
        ['height'].forEach(function(e){
            var prop = {
                    set: function(value, obj){
                        if(value === null || parseFloat(value)>=0){
                            return value;
                        }else{
                            return obj.value; /**no change*/
                        }
                    }
                },
            fullPathprop={
                    layout:{}
                };
            fullPathprop.layout[e] = prop;
            properties.add(fullPathprop);
        });
        var graphicModel = this.runtime().graphicModel();
        if (graphicModel) {
            graphicModel.registerExposedModule(options.name);
        }
    };

    oo.extend(Title, UIComponent);

    Title.prototype.setPosition = function (position) {
        this._position = position;
    };

    Title.prototype.setSize = function(value) {
        this._width = value.width;
        this._height = value.height;
    };

    Title.prototype.getSize = function() {
        return {
            width: this._width,
            height: this._height
        };
    };

    Title.prototype.getPosition = function() {
        var propId = "layout.position",
            pos = this._position || this._properties.get(propId);
        if (["top", "bottom"].indexOf(pos) == -1 ){
            pos = this._properties.getDefault(propId);
        } 
        return pos||"top";
    };    
    
    Title.prototype._getPostfix = function(){
        var dynamicScale = this._runtime.statusManager().get("dynamicScale");
        return dynamicScale && dynamicScale.onlyChartTitle && dynamicScale.postfix || "";
    };

    Title.prototype.getPreferredSize = function(bounds, isTrellis, isFixSize, options) {
        this._pfSize = {
            maxWidth: 0,
            maxHeight: 0,
            minWidth: 0,
            minHeight: 0,
            width: 0,
            height: 0
        };
        if (this._properties.get("visible") === true) {
            var fontSize = this._properties.get("style.fontSize");
            var fontWeight = this._properties.get("style.fontWeight");
            var fontFamily = this._properties.get("style.fontFamily");
            var letterSpacing = this._properties.get("style.letterSpacing");
            var titleText = this._properties.get("text");

            if (options && options._semanticDisplayStyleRules && 
                options._semanticDisplayStyleRules.title) {
                // modify title style
                var titleStyle = options._semanticDisplayStyleRules.title;
                if (titleStyle.fontWeight) {
                    fontWeight = titleStyle.fontWeight;
                }
                if (titleStyle.fontFamily) {
                    fontFamily = titleStyle.fontFamily;
                }
            }
            
            var text = TitleUtil.getTextShow(titleText);
            text += this._getPostfix();
            var titleSize = TextUtils.fastMeasure(text, fontSize, fontWeight, fontFamily, letterSpacing);

            this._pfSize.width = this._pfSize.maxWidth = titleSize.width;
            this._pfSize.height = this._pfSize.maxHeight = titleSize.height;

            var minTitleSize = TextUtils.fastMeasure("...", fontSize, fontWeight, fontFamily, letterSpacing);

            this._pfSize.minWidth = minTitleSize.width;
            this._pfSize.minHeight = minTitleSize.height;

            this._pfSize.width = Math.max(this._pfSize.minWidth, this._pfSize.width);
            this._pfSize.height = Math.max(this._pfSize.minHeight, this._pfSize.height);

            this._pfSize.hideOversize = true;
            this._pfSize.maxSizeConstant = 1 / 3;
        }
        return this._pfSize;        
    };

    Title.prototype.isVisible = function() {
        var isVisible = this._properties.get("visible");
        return isVisible === true && this._width > 0 && this._height > 0;
    };

    /**
     * To render element.
     */
    Title.prototype.render = function(rootElement, semanticDisplayStyleRules) {
        
        var titleText = this._properties.get("text");
        var text = TitleUtil.getTextShow(titleText);

        var wrapper = rootElement.selectAll('text.v-title').data([text]);
        this._wrapper = wrapper;
        var titleVisible = this.isVisible();
        if (titleVisible) {
            
            var width = this._width;
            var height = this._height;
            var alignment = this._properties.get("alignment");
            var fontWeight, fontFamily, color, letterSpacing, fontStyle;
            
            if (semanticDisplayStyleRules && semanticDisplayStyleRules.title) {
                var titleStyle = semanticDisplayStyleRules.title;
                if (titleStyle.fontWeight) {
                    fontWeight = titleStyle.fontWeight;
                }
                if (titleStyle.fontFamily) {
                    fontFamily = titleStyle.fontFamily;
                }
                if (titleStyle.color) {
                    color = titleStyle.color;
                }
                if (titleStyle.letterSpacing) {
                    letterSpacing = titleStyle.letterSpacing;
                }
                if (titleStyle.fontStyle) {
                    fontStyle = titleStyle.fontStyle;
                }
            }

            var style = {
                color: color || this._properties.get("style.color"),
                fontFamily: fontFamily || this._properties.get("style.fontFamily"),
                fontSize: this._properties.get("style.fontSize"),
                fontWeight: fontWeight || this._properties.get("style.fontWeight"),
                letterSpacing: letterSpacing || this._properties.get("style.letterSpacing"),
                fontStyle: fontStyle || this._properties.get("style.fontStyle")
            };

            BoundUtil.drawBound(rootElement, width, height, undefined, true);

            var textAlign = alignment || "center";

            var textAnchor = null;
            var envManager = this.runtime().envManager();
            if (envManager) {
                textAnchor = envManager.textAnchor();
            }

            var ellipsisOptions = {};
            ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

            var rightOffset = this._pfSize.width;
            var centerOffset = this._pfSize.width / 2;
            if (this._pfSize.width > width) {
                rightOffset = width;
                centerOffset = width / 2;
            }
            var xPos = {
                right: width - rightOffset,
                center: width / 2 - centerOffset,
                left: 0
            }[textAlign];

            // invalid alignment
            if (xPos == null) {
                xPos = width / 2 - centerOffset;
            }
            var x;
            var y;
            wrapper.exit().remove();
            wrapper.enter().append('text').attr('class', 'v-title viz-title-label');

            var fill = this.runtime().effectManager().register({
                fillColor: style.color
            });
            wrapper.attr('fill', fill).attr('font-family', style.fontFamily).attr('font-size', style.fontSize).attr(
                'font-weight', style.fontWeight).attr('font-style', style.fontStyle)
                .attr('text-anchor', textAnchor).attr('x', xPos)
                .attr('y', 'top' == this.getPosition() ? this._pfSize.height/2 : height - this._pfSize.height/2)
                .attr('dominant-baseline', 'central');

            if (UADetector.isIE()) {
                wrapper.attr('y', 'top' == this.getPosition() ? this._pfSize.height : height)
                .attr('dominant-baseline', 'auto');
            }

            TextUtils.ellipsis(text, wrapper.node(), width, 
                StyleUtils.convertToCss(style), ellipsisOptions, this._getPostfix());
        } else {
            rootElement.selectAll('text.v-title').remove();
        }

    };

    Title.prototype.destroy = function() {
        Title.superclass.destroy.call(this);
        this.clear();
        this._wrapper = null;
        this._height = null;
        this._width = null;
    };
    
    Title.prototype.clear = function() {
        if (this._wrapper) {
            this._wrapper.remove();
        }
    };

    Title.prototype.supportFixedLayout = true;
    
    return Title;
});

define('sap/viz/chart/components/Background',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/UIComponent',
    "sap/viz/framework/common/util/DataGraphics"
], function(oo, UIComponent, DataGraphics) {

    var dispatch = d3.dispatch;

    var CSSCLASS_BORDER = 'v-background-border',
        CSSCLASS_BORDER_2 = 'viz-plot-background-border';
    var CSSCLASS_BODY = 'v-background-body',
        CSSCLASS_BODY_2 = 'viz-plot-background';
    var CSSCLASS_MORPHABLEBACKGROUND = "v-morphable-background";

    /**
     * Background module
     */
    function Background(runtime, options) {
        Background.superclass.constructor.apply(this, arguments);
        this._eDispatch = new dispatch('initialized');
        // Currently not expose background in graphicModel.
        // var graphicModel = this.runtime().graphicModel();
        // if (graphicModel) {
        //     graphicModel.registerExposedModule('background');
        // }
    }

    oo.extend(Background, UIComponent);

    var prot = Background.prototype;

    prot.render = function(selection) {
        var props = this._properties;

        if (props.get('visible') && this._size.width > 0 && this._size.height > 0) {
            var d3rect = selection.select('.' + CSSCLASS_BODY);
            if (d3rect.empty()) {
                d3rect = selection.append('svg:rect')
                    .attr('class', CSSCLASS_BODY + ' ' + CSSCLASS_BODY_2 + ' ' + CSSCLASS_MORPHABLEBACKGROUND);
            }
            var rectFillColor = this._data && this._data.color || props.get('color') || 'transparent';

            DataGraphics.setData(d3rect.node(), {
                color: rectFillColor
            });
            var size = this._size;
            var height = size.height;
            var width = size.width;

            var fillID = this.runtime().effectManager().register({
                graphType: 'background',
                fillColor: rectFillColor,
                drawingEffect: props.get('drawingEffect'),
                direction: props.get('gradientDirection')
            });
            d3rect.attr('x', 0)
                .attr('y', 0)
                .attr('width', width)
                .attr('height', height)
                .style('fill',fillID);

            var needDrawBorder = !(this._data && this._data.hasBorder === false);

            if (needDrawBorder) {
                var borderData = [];
                if (props.get('border.left.visible')) {
                    borderData.push({
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: height
                    });
                }
                if (props.get('border.right.visible')) {
                    borderData.push({
                        x1: width,
                        y1: 0,
                        x2: width,
                        y2: height
                    });
                }
                if (props.get('border.top.visible')) {
                    borderData.push({
                        x1: 0,
                        y1: 0,
                        x2: width,
                        y2: 0
                    });
                }
                if (props.get('border.bottom.visible')) {
                    borderData.push({
                        x1: 0,
                        y1: height,
                        x2: width,
                        y2: height
                    });
                }

                var d3border = selection.selectAll("." + CSSCLASS_BORDER).data(borderData);
                d3border.enter().append('svg:line').attr('class', CSSCLASS_BORDER + ' ' + CSSCLASS_BORDER_2);
                d3border.exit().remove();
                d3border.attr('x1', function(d) {
                    return d.x1;
                }).attr('y1', function(d) {
                    return d.y1;
                }).attr('x2', function(d) {
                    return d.x2;
                }).attr('y2', function(d) {
                    return d.y2;
                });
                d3border.style("stroke", props.get('border.stroke')).
                    style("stroke-width", props.get('border.strokeWidth'));
                // now we use attribute in dom element to let customer css file work.
                /*d3border.each(function(d) {
                    d3.select(this).attr('shape-rendering', 'crispEdges');
                    for (var key in properties.style.border) {
                        if (properties.style.border.hasOwnProperty(key)) {
                            d3.select(this).attr(key, properties.style.border[key]);
                        }
                    }
                });*/
            }
        } else {
            var temp = selection.node();
            while (temp.hasChildNodes()) {
                temp.removeChild(temp.firstChild);
            }
        }

        //currently, we do not have animation. If it has, should fire initialized event after animation complete.
        this._eDispatch.initialized();

        return this;
    };

    prot.adjustPosition = function(selection, size) {
        if (!selection || !size) {
            return;
        }

        var props = this._properties;
        if (props.get('visible') && this._size.width > 0 && this._size.height > 0) {
            var background = selection.select("." + CSSCLASS_BODY);
            background.attr("x", size.x);
            background.attr("y", size.y);
            background.attr("width", size.width);
            background.attr("height", size.height);

            var borders = selection.selectAll("." + CSSCLASS_BORDER)[0];
            var border, x1, y1, x2;
            for (var i = 0; i < borders.length; i++) {
                border = borders[i];
                x1 = Number(border.getAttribute("x1"));
                y1 = Number(border.getAttribute("y1"));
                x2 = Number(border.getAttribute("x2"));

                if (x1 === 0 && y1 === 0 && x2 === 0) {
                    border.setAttribute("x1", size.x);
                    border.setAttribute("y1", size.y);
                    border.setAttribute("x2", size.x);
                    border.setAttribute("y2", size.y + size.height);
                } else if (x1 > 0 && y1 === 0 && x2 > 0) {
                    border.setAttribute("x1", size.x + size.width);
                    border.setAttribute("y1", size.y);
                    border.setAttribute("x2",  size.x + size.width);
                    border.setAttribute("y2", size.y + size.height);
                } else if (x1 === 0 && y1 === 0 && x2 > 0) {
                    border.setAttribute("x1", size.x);
                    border.setAttribute("y1", size.y);
                    border.setAttribute("x2", size.x + size.width);
                    border.setAttribute("y2", size.y);
                } else if (x1 === 0 && y1 > 0 && x2 > 0) {
                    border.setAttribute("x1", size.x);
                    border.setAttribute("y1", size.y + size.height);
                    border.setAttribute("x2", size.x + size.width);
                    border.setAttribute("y2", size.y + size.height);
                }
            }
        }
    };

    prot.destroy = function() {
        Background.superclass.destroy.call(this);
        this._eDispatch.on('initialized', null);
        this._eDispatch = null;
    };

    return Background;
});

define('sap/viz/chart/components/scrollbar/Scrollbar',[
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/UIComponent',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/PositionUtil'
], function Setup(
    Constants,
    oo,
    UIComponent,
    ObjectUtils,
    TypeUtils,
    UADetector,
    PositionUtil
    ) {

    var SCROLLBAR_THUMB_CLASS = "v-m-scrollbarThumb";
    var SCROLLBAR_TRACK_CLASS = "v-m-scrollbarTrack";

    var ScrollBar = function(runtime, options) {
        ScrollBar.superclass.constructor.apply(this, arguments);
        this._exposeMoreEvents("scroll");
        this._thumbSpace = ScrollBar.getThumbSpace(options.location);

        this._thumbSize = 0;
        this._trackSize = 0;
        this._contentSize = 0;
        this._borderWidth = 0;
        this._spacingPadding = 0;
        this._thumbPosition = 0;
        this._minThumbPosition = 0;
        this._maxThumbPosition = 0;

        this._isExist = true;
        this._isVisible = true;
        this._position = "bottom";
        this._selection = null;
        this._wrapper = null;
        this._thumbNode = null;
        this._trackNode = null;
        this._thumbHover = false;
    };

    oo.extend(ScrollBar, UIComponent);

    ScrollBar.getThumbSpace = function(location) {
        if (UADetector.isMobile()){
            return 7;
        }else{
            if(location === "legend"){
                return 8;
            }
            return 12;
        }
    };

    ScrollBar.prototype._notNeedDesktopInteraction = function(){
        return  UADetector.isMobile() ||
                this.runtime().effectManager().ghostEffect();
    };

    ScrollBar.prototype._initSetting = function(){
        var props = this._properties;
        if(!UADetector.isMobile()){
            this._borderWidth = getValue(props, "border.width");
            this._borderWidth = Math.min(this._borderWidth, 4);
            this._borderWidth = Math.max(this._borderWidth, 0);
        }
        this._spacingPadding = getValue(props, "spacing");
        this._spacingPadding = Math.min(this._spacingPadding, 4);
        this._spacingPadding = Math.max(this._spacingPadding, 0);
    };

    function getValue(props, key) {
        var value = parseFloat(props.get(key));
        if (TypeUtils.isNaN(value)) {
            value = parseFloat(props.getDefault(key));
        }
        return value;
    }

    ScrollBar.prototype.render = function(selection) {
        ScrollBar.superclass.render.apply(this, arguments);
        if (selection) {
            this._selection = selection;
            this._wrapper = this._selection.selectAll('g');
            if (this._wrapper.empty()) {
                this._wrapper = this._selection.append('g');
            }
        }
        if(!this._selection){
            return;
        }
        if (this._isExist) {
            var isVertical = this._isVertical();
            var sizeField = isVertical ? "height" : "width";
            var trackSize = this._trackSize || this._size[sizeField];
            trackSize = parseFloat(trackSize);
            this._trackSize = trackSize;
            var contentSize = this._contentSize || this._realSize[sizeField];
            contentSize = parseFloat(contentSize);
            if (contentSize < trackSize) {
                contentSize = trackSize;
            }
            this._contentSize = contentSize;
            //draw track;
            this._thumbSpace = parseFloat(this._thumbSpace);
            var thumbSpace = this._thumbSpace;
            var props = this._properties;

            this.getThumbRatio();

            var borderWidth = parseFloat(this._borderWidth);
            var borderColor = UADetector.isMobile() ? props.getDefault("border.color") : props.get("border.color");
            var spacingPadding = this._spacingPadding;
            var wrapper = this._wrapper;
            var visibility = this._isVisible? "visible":"hidden";
            var trackNode = wrapper.select("rect." + SCROLLBAR_TRACK_CLASS);
            if (trackNode.empty()) {
                trackNode = wrapper.append('rect').attr('class', SCROLLBAR_TRACK_CLASS);
            }
            trackNode.attr("visibility", visibility).attr("fill", props.get("track.fill"));
            trackNode.attr("stroke-width", borderWidth).attr("stroke", borderColor);
            if (isVertical) {
                trackNode.attr('width', thumbSpace).attr('height', trackSize);
            } else {
                trackNode.attr('width', trackSize).attr('height', thumbSpace);
            }
            this._trackNode = trackNode;

            //draw thumb
            var thumbNode = wrapper.select("rect." + SCROLLBAR_THUMB_CLASS);
            if (thumbNode.empty()) {
                thumbNode = wrapper.append('rect').attr('class', SCROLLBAR_THUMB_CLASS);
            }
            var thumbFill = this._thumbHover ? "thumb.hoverFill" : "thumb.fill";
            thumbNode.attr("visibility", visibility).attr("fill", props.get(thumbFill));
            var thumbSize = this._thumbSize;
            var thumbMargin = spacingPadding + borderWidth;

            if (isVertical) {
                thumbNode.attr('width', thumbSpace - thumbMargin * 2)
                .attr('height', thumbSize).attr('transform',
                    'translate(' + thumbMargin + ', ' + (this._thumbPosition + thumbMargin) + ')');
            } else {
                thumbNode.attr('width', thumbSize).attr('height', thumbSpace - thumbMargin * 2)
                .attr('transform',
                    'translate(' + (this._thumbPosition + thumbMargin) + ', ' + thumbMargin + ')');
            }
            this._thumbNode = thumbNode;

            this.show(1600);

            if (this._notNeedDesktopInteraction()) {
                return;
            }

            //The reason why we add event listener here is because we need to support global
            //drag and move but interaction framework is limited inside the chart root node.
            (function handleMouseEvent(thumb, track, scrollBar) {
                function bindScrollBar(fn) {
                    return fn.bind(scrollBar);
                }

                var clickHandler = bindScrollBar(function(event) {
                    this._startPos = undefined;
                    var offset = this._thumbSize;
                    var trackBoudingBox = this._trackNode.node().getBoundingClientRect();
                    if (this._isVertical()) {
                        if (event.clientY < (trackBoudingBox.top + this._thumbPosition)) {
                            offset = -offset;
                        }
                    } else {
                        if (event.clientX < (trackBoudingBox.left + this._thumbPosition)) {
                            offset = -offset;
                        }
                    }
                    this._scroll(offset);
                    var runtimeCtx = this.runtime();
                    if(runtimeCtx) {
                        runtimeCtx.fireInteractionEvent("scrollbarReleased");
                    }
                    return false;
                });

                var downHandler = bindScrollBar(function(event) {
                    if (this._isVertical()) {
                        this._startPos = event.clientY;
                    } else {
                        this._startPos = event.clientX;
                    }
                    this._thumbHover = true;
                    this._thumbNode.attr('fill', this._properties.get(
                        'thumb.hoverFill'));
                    this._isPressed = true;
                    stopPropagation(event);
                });

                var upHandler = bindScrollBar(function(event) {
                    this._startPos = undefined;
                    this._isPressed = false;
                    if (this._thumbNode && event.target !== this._thumbNode.node()) {
                        this._thumbNode.attr('fill', this._properties.get(
                            'thumb.fill'));
                        this._thumbHover = false;
                    }
                    var runtimeCtx = this.runtime();
                    if(runtimeCtx) {
                        runtimeCtx.fireInteractionEvent("scrollbarReleased");
                    }
                });

                var moveHandler = bindScrollBar(function(event) {
                    if (this._startPos !== undefined) {
                        if (this._isVertical()) {
                            this._scroll(event.clientY - this._startPos);
                            this._startPos = event.clientY;
                        } else {
                            this._scroll(event.clientX - this._startPos);
                            this._startPos = event.clientX;
                        }
                        //this._thumbNode.attr('visibility', 'visible');
                    }
                });

                var overHandler = bindScrollBar(function() {
                    this._thumbNode.attr('fill', this._properties.get(
                        'thumb.hoverFill'));
                    this._thumbHover = true;
                });

                var leaveHandler = bindScrollBar(function() {
                    if (!this._isPressed) {
                        if(this._thumbNode) {
                            this._thumbHover = false;
                            this._thumbNode.attr('fill', this._properties.get(
                                'thumb.fill'));
                        }
                    }
                });

                function getGlobalDocument() {
                    var main = window;
                    if (main.addEventListener === undefined) {
                        main = document.body;
                    }
                    return main;
                }

                function glMoveHandler(event) {
                    moveHandler(event);
                    event.preventDefault();
                    stopPropagation(event);
                    return false;
                }

                function glUpHandler(event) {
                    upHandler(event);
                    var main = getGlobalDocument();
                    main.removeEventListener("mousemove", glMoveHandler, true);
                    main.removeEventListener("mouseup", glUpHandler, true);
                    return false;
                }

                thumb.on('mouseover', overHandler)
                    .on('mouseleave', leaveHandler)
                    .on('mousedown', function() {
                        var event = d3.event;
                        downHandler(event);
                        var main = getGlobalDocument();
                        main.addEventListener('mousemove', glMoveHandler, true);
                        main.addEventListener('mouseup', glUpHandler, true);
                        stopPropagation(event);
                        return false;
                    });

                track.on('click', function(){
                    return clickHandler(d3.event);
                });

            })(thumbNode, trackNode, this);
        } else {
            if (this._wrapper) {
                this._wrapper.remove();
                this._wrapper = null;
                this._thumbNode = null;
                this._trackNode = null;
            }
        }
    };

    var stopPropagation = function(event) {
        if (event && event.stopPropagation) {
            event.stopPropagation();
        }
    };

    ScrollBar.prototype._isFull = function() {
        return this._trackSize >= this._contentSize;
    };

    ScrollBar.prototype.destroy = function() {
        this._eventDispatch.on("scroll", null);
        ScrollBar.superclass.destroy.call(this);
        this._thumbSpace = 0;

        this._thumbSize = 0;
        this._trackSize = 0;
        this._contentSize = 0;
        this._borderWidth = 0;
        this._spacingPadding = 0;
        this._thumbPosition = 0;
        this._maxThumbPosition = 0;
        this._minThumbPosition = 0;

        this._isExist = true;
        this._isVisible = true;
        this._position = "bottom";
        this._selection = null;
        this._wrapper = null;
        this._thumbNode = null;
        this._trackNode = null;
    };

    ScrollBar.prototype.getPreferredSize = function() {
        var result = {
            maxWidth: 0,
            maxHeight: 0,
            minWidth: 0,
            minHeight: 0,
            width: 0,
            height: 0,
            spacings: [{
                "interval": 0,
                "type": Constants.SPACING_TYPE.STEP
            }]
        };
        if (this._isExist) {
            var thumbSpace = this._thumbSpace;
            if (this._isVertical()) {
                result.maxWidth = result.width = thumbSpace;
            } else {
                result.maxHeight = result.height = thumbSpace;
            }
            result.spacings[0].interval = thumbSpace;
        }
        return result;
    };

    ScrollBar.prototype.setPosition = function(pos) {
        this._position = pos;
        return this;
    };

    ScrollBar.prototype._isVertical = function() {
        return PositionUtil.isVertical(this._position);
    };

    ScrollBar.prototype._isHorizontal = function() {
        return PositionUtil.isHorizontal(this._position);
    };

    ScrollBar.prototype.isExist = function(_) {
        if (!arguments.length) {
            return this._isExist;
        }
        this._isExist = !!_;
        return this;
    };

    ScrollBar.prototype.isVisible = function(_) {
        if (!arguments.length) {
            return this._isVisible;
        }
        this._isVisible = !!_;
        return this;
    };

    ScrollBar.prototype.setTrackSize = function(_) {
        this._trackSize = +_;
        return this;
    };

    ScrollBar.prototype.getTrackSize = function() {
        return this._trackSize;
    };

    ScrollBar.prototype.getContentSize = function() {
        return this._contentSize;
    };

    ScrollBar.prototype.setContentSize = function(_) {
        this._contentSize = +_;
        return this;
    };

    ScrollBar.prototype.getThumbSize = function(){
        return this._thumbSize;
    };

    ScrollBar.prototype.isThumbOverTrack = function(offset) {
        var isOver = false;
        var thumbPos = this._thumbPosition;
        var minThumbPos = this._minThumbPosition;
        var maxThumbPos = this._maxThumbPosition;
        if (thumbPos === minThumbPos && (thumbPos + offset) < minThumbPos) {
            isOver = true;
        }

        if (Math.floor(thumbPos) === Math.floor(maxThumbPos) &&
            (thumbPos + offset) > maxThumbPos) {
            isOver = true;
        }
        return isOver;
    };

    ScrollBar.prototype.getThumbRatio = function() {
        this._initSetting();
        var trackSize = this._trackSize;
        var contentSize = this._contentSize;
        var borderWidth = this._borderWidth;
        var spacingPadding = this._spacingPadding;
        var thumbSpace = this._thumbSpace;
        var thumbMargin = 2 * (spacingPadding + borderWidth);
        if (trackSize <= 0 || contentSize <= 0){
            return null;
        }
        if (contentSize < trackSize) {
            contentSize = trackSize;
        }
        var thumbSize = 0;
        if(contentSize !== 0) {
            thumbSize = (trackSize - borderWidth) * trackSize / contentSize;
        }
        var minThumbSize = thumbSpace * 2;

        if(minThumbSize > trackSize){
            minThumbSize = trackSize;
        }
        if (thumbSize < minThumbSize) {
            thumbSize = minThumbSize;
        }
        this._thumbSize = thumbSize;
        this._maxThumbPosition = trackSize - thumbSize - thumbMargin;
        this._minThumbPosition = 0;
        this._offsetRatio = (contentSize - trackSize) / (trackSize - thumbMargin - thumbSize);

        return this._offsetRatio;
    };

    ScrollBar.prototype._scroll = function(delta, forceEvent, isWheelEvent) {
        var currentPos = Math.min(this._maxThumbPosition, Math.max(this._minThumbPosition, this._thumbPosition +
            delta));
        if((!isWheelEvent && forceEvent) || this._thumbPosition !== currentPos){
            this.setThumbPosition(currentPos);
            var offset = -Math.ceil(currentPos * this._offsetRatio);
            this._eventDispatch.scroll({
                offset: offset,
                reachMax: currentPos === this._maxThumbPosition
            });
        }
    };

    ScrollBar.prototype.getThumbPosition = function(){
        return this._thumbPosition;
    };

    ScrollBar.prototype.setThumbPosition = function(pos) {
        if (!this._isExist){
            return;
        }
        var position = +pos;
        var thumbSpace = this._thumbSpace;
        var spacingPadding = this._spacingPadding;
        var borderWidth = this._borderWidth;
        var thumbBorderPadding = spacingPadding + borderWidth;
        this._thumbPosition = Math.min(this._maxThumbPosition, position);
        if(this._thumbNode){
            if (this._isVertical()) {
                this._thumbNode.attr('transform', 'translate(' + thumbBorderPadding + ', ' +
                    (this._thumbPosition + thumbBorderPadding) + ')');
            } else {
                this._thumbNode.attr('transform', 'translate(' + (this._thumbPosition + thumbBorderPadding) +
                    ', ' + thumbBorderPadding + ')');
            }
        }
        return this;
    };

    function _show() {
        //this.isVisible(true);
        if (this._thumbNode) {
            this._thumbNode.attr("visibility", "visible");
        }
        if (this._trackNode) {
            this._trackNode.attr("visibility", "visible");
        }
    }

    function _hide() {
        //this.isVisible(false);
        if (this._thumbNode) {
            this._thumbNode.attr("visibility", "hidden");
        }
        if (this._trackNode) {
            this._trackNode.attr("visibility", "hidden");
        }
    }

    ScrollBar.prototype.show = function (time, force){
        var show = _show.bind(this),
            hide = _hide.bind(this);
        if (!force && (this._isFull() || !this.isVisible())){
            hide();
            return;
        }
        show();
        if (UADetector.isMobile()){
            if (!time){
                time = 800;
            }
            if (this._timeoutId){
                window.clearTimeout(this._timeoutId);
            }
            this._timeoutId = window.setTimeout(hide, time);
        }
    };

    return ScrollBar;
});

define('sap/viz/chart/components/scrollbar/PaginationScrollbar',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/scrollbar/Scrollbar'
], function Setup(
    oo,
    Scrollbar
    ) {

    var SCROLL_EVENT_NAME = "scroll";
    var PaginationScrollbar = function(runtime, options) {
        PaginationScrollbar.superclass.constructor.apply(this, arguments);
        
        //property of scrollbar depends on the name. Now we use plotArea.scrollbar.
        var propertyManager = options.properties || this._runtime._propertyMgr;
        this._properties = propertyManager.proxy("plotArea.scrollbar");
        this._thumbRatio = 0;
    };

    oo.extend(PaginationScrollbar, Scrollbar);
    
    PaginationScrollbar.prototype._scroll = function(delta, forceEvent) {
        PaginationScrollbar.superclass._scroll.apply(this, arguments);
        
        var scrollCtx = {};
        this._thumbRatio = this._thumbPosition/this._maxThumbPosition;
        scrollCtx.position = this._thumbRatio;
        if(this.runtime()) {
            this.runtime().eventDispatcher().fire(SCROLL_EVENT_NAME, scrollCtx);
        }
    };

    return PaginationScrollbar;
});

define('sap/viz/chart/components/legend/BaseLegend',['sap/viz/framework/common/util/oo', 'sap/viz/chart/components/UIComponent', 
    'sap/viz/chart/components/util/BoundUtil',
    "sap/viz/framework/common/util/TypeUtils", 'sap/viz/chart/components/util/TextUtils',
    'sap/viz/framework/common/util/PropertyZoneUtil', 'sap/viz/framework/common/util/FeedingZoneUtil',
    'sap/viz/framework/common/lang/LangManager', 
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/StyleUtils',
    "sap/viz/framework/interaction/Constants"
], function(oo, UIComponent, BoundUtil, TypeUtils, TextUtils,
    PropertyZoneUtil, FeedingZoneUtil, langManager, 
    Constants,
    ObjectUtils, 
    StyleUtils,
    InteractionConstants) {

    var MND = "measureNames";
    //the max wrapped text line
    var MAX_LINE_LIMIT = 3;

    var BaseLegend = function(runtime, options) {
  
        BaseLegend.superclass.constructor.apply(this, arguments);

        this._type = "BaseLegend";
        this._title = undefined;
        this._bindingFields = null;
        this._parent = null;
        this._pos = {
            x: 0,
            y: 0
        };
        this._titleMarginBottom = 0.5;
        this._width = 0;
        this._height = 0;
        
        this._position = null;
        
        var that = this;
        var legendPropertyZone = {},
            legendFeedingZone = {};

        legendPropertyZone[this._name] = {
            value: [],
            readonly: true,
            serializable: false,
            get: function() {
                var result = [],
                    zonenamePrefix, boundRect, boundRect1, bound, bound1, temp, root;
                zonenamePrefix = that.getZonePrefix();

                // Get legend title property zone
                if (that.isVisible() && that._properties.get('title.visible') && that._parent) {
                    var titleNode = that._parent.select(".viz-legend-title.v-title").node();
                    boundRect = titleNode ? titleNode.getBoundingClientRect() : null;
                    if (boundRect && boundRect.width > 1.5 && boundRect.height > 1.5) {
                        bound = [
                            []
                        ];
                        bound[0].push([boundRect.left, boundRect.top]);
                        bound[0].push([boundRect.right, boundRect.top]);
                        bound[0].push([boundRect.right, boundRect.bottom]);
                        bound[0].push([boundRect.left, boundRect.bottom]);
                        result.push({
                            "name": zonenamePrefix + ' title',
                            "bound": bound
                        });
                    }
                }
                if (that._parent && that._parent.select(".v-bound").node()) {
                    temp = that._parent.select(".v-bound").node().getBoundingClientRect();
                    if (temp.width > 1.5 && temp.height > 1.5) {
                        boundRect1 = {
                            left: temp.left,
                            right: temp.right,
                            top: temp.top,
                            bottom: temp.bottom
                        };
                        if (result.length > 0) {
                            boundRect1.top = result[0].bound[0][3][1] + 1;
                        }
                        bound1 = [
                            []
                        ];
                        bound1[0].push([boundRect1.left, boundRect1.top]);
                        bound1[0].push([boundRect1.right, boundRect1.top]);
                        bound1[0].push([boundRect1.right, boundRect1.bottom]);
                        bound1[0].push([boundRect1.left, boundRect1.bottom]);

                        result.push({
                            "name": zonenamePrefix,
                            "bound": bound1
                        });
                    }
                    root = that._parent.node().ownerSVGElement;
                }
                PropertyZoneUtil.calcOffsetFromChart(root, result);
                return result;
            }
        };
        var noFeeding = options && options.options && options.options.noFeeding;
        if (!noFeeding){
            legendFeedingZone[this._name] = {
                value: [],
                readonly: true,
                serializable: false,
                get: function() {
                    var result, zonenamePrefix, feeding;
                    if (that._parent && !that._isDedicated) {
                        var root = d3.select(that._parent.node().ownerSVGElement);
                        zonenamePrefix = that.getZonePrefix();
                        result = FeedingZoneUtil.buildRes(zonenamePrefix, feeding, root, true);
                    }
                    return result;
                }
            };
            this.runtime().zoneManager().add({
                tempPropertyZone: legendPropertyZone,
                tempFeedingZone: legendFeedingZone
            });
        } else {
            this.runtime().zoneManager().add({
                tempPropertyZone: legendPropertyZone,
            });
        }

        var props = this._properties;

        this._orientation = null;

        this._titleFont = {
            'fontFamily': props.get('title.style.fontFamily'),
            'fontSize': props.get('title.style.fontSize'),
            'fontWeight': props.get('title.style.fontWeight'),
            'color': props.get('title.style.color'),
            'fontStyle': props.get('title.style.fontStyle')
        };
        var graphicModel = this.runtime().graphicModel();
        if (graphicModel) {
            graphicModel.registerExposedModule(options.name);
        }
    };

    oo.extend(BaseLegend, UIComponent);


    BaseLegend.prototype.getType = function() {
        return this._type;
    };

    /**
     * To fix non property definition for standalone mode.
     */
    BaseLegend.prototype._addDefaultProperties = function() {

        this._properties.add({
            'visible' : true,
            'title' : {
                'visible' : false,
                'text' : null,
                'style' : {
                    'color' : '#000000',
                    'fontFamily' : "'Open Sans', Arial, Helvetica, sans-serif",
                    'fontSize' : '14px',
                    'fontWeight' : 'bold',
                    'fontStyle' : 'normal'
                }
            },
            'label' : {
                'style' : {
                    'color' : '#000000',
                    'fontFamily' : "'Open Sans', Arial, Helvetica, sans-serif",
                    'fontSize' : '12px',
                    'fontWeight' : 'normal',
                    'fontStyle' : 'normal'
                }
            }
        });
    };
    
    BaseLegend.prototype.visible = function() {
        return this._properties.get("visible");
    };
    
    BaseLegend.prototype.setPosition = function(position) {
        this._position = position;
    };   

    BaseLegend.prototype.getPosition = function() {
        return this._position;
    };   

    BaseLegend.prototype.setOrientation = function(orientation) {
        this._orientation = orientation;
    };

    BaseLegend.prototype.setDedicated = function(_isDedicated) {
        this._isDedicated = _isDedicated;
    };

    BaseLegend.prototype.isHorizontal = function() {
        return (this._orientation === 'top') || (this._orientation === 'bottom');
    };

    BaseLegend.prototype.render = function(selection, loadMore) {      
        this._pos = {
            x: 0,
            y: 0
        };

        var bound;
        var titleWrapper = selection.selectAll('text.v-title');
        if (this.isVisible() || this._isDedicated) {
            var props = this._properties;
            bound = BoundUtil.drawBound(selection, this._width, this._height, undefined, true);
            //reset x and y offset in case it is set by last time drawing 
            bound.attr("x", null);
            bound.attr("y", null);
            if (!loadMore){
                bound.attr("stroke", null).attr("stroke-width", null);
            }
            if (this._properties.get("title.visible") === true) {
                if (titleWrapper.empty()) {
                    titleWrapper = selection.append('text').attr('class', 'v-title viz-legend-title');
                } else {
                    titleWrapper.html("");
                }
                
                var textAnchor = null;
                var envManager = this.runtime().envManager();
                if (envManager) {
                    textAnchor = envManager.textAnchor();
                }
                titleWrapper.attr("text-anchor", textAnchor);
                
                var defalutTitleFont;
                defalutTitleFont = {
                    "fill": props.get('title.style.color'),
                    "font-family": props.get('title.style.fontFamily'),
                    "font-size": props.get('title.style.fontSize'),
                    "font-weight": props.get('title.style.fontWeight'),
                    "font-style": props.get('title.style.fontStyle')
                };

                var lineNumber = this._getWrapText();
                lineNumber = (lineNumber && lineNumber > 1) ? lineNumber : 1;
                var lineHeight = parseInt(this._titleFont.fontSize, 10);
                var options = {};
                options.isRTL = this._isRTL();
                options.ellipsisOptions = {};
                options.middleText = false;
                options.ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

                TextUtils.drawWrappedText(titleWrapper, this._titleText, [" "], lineNumber,
                    this._width, lineHeight, this._titleFont, options);
                
                var titleTextHeight = parseInt(titleWrapper.attr("height"));

                this._pos.y = this._pos.y + titleTextHeight;
                titleWrapper.attr('font-weight', defalutTitleFont['font-weight']).attr('fill',
                    defalutTitleFont.fill).attr('font-family', defalutTitleFont['font-family']).attr('font-size',
                    defalutTitleFont['font-size']).attr('font-style', defalutTitleFont['font-style']).attr('x',
                    this._pos.x).attr('y', this._pos.y).attr('visibility', 'inherit');
                
                titleWrapper.selectAll("tspan").attr("dy", "1em");

                this._pos.y = this._pos.y + lineHeight * this._titleMarginBottom;
            } else {
                titleWrapper.remove();
            }
        } else {
            var alignmentSize;
            if (this._properties._props['legendGroup.layout.width'] && 
                this._properties._props['legendGroup.layout.height']) {
                alignmentSize = {
                    width : this._properties._props['legendGroup.layout.width'].value,
                    height : this._properties._props['legendGroup.layout.height'].value
                };
            }
            if (this.visible() && alignmentSize && (alignmentSize.width || alignmentSize.height)) {
                bound = BoundUtil.drawBound(selection, 
                alignmentSize.width || this._originWidth, alignmentSize.height || this._originHeight);
            } else {
                bound = BoundUtil.drawBound(selection, 0, 0); 
            }
            titleWrapper.remove();
        }
        
        if(this._properties.origin.get("legendGroup.layout.alignment") === "center" && 
           (this._properties.origin.get("legendGroup.layout.position") === "top" || 
            this._properties.origin.get("legendGroup.layout.position") === "bottom")) {
            this._renderedWidth = 0;
            var titleNode = titleWrapper.node();
            if(titleNode) {
                this._renderedWidth = titleNode.getBoundingClientRect().width;
            }
        }
        if(bound) {
            this._bound = bound.node();
        }
        return this;
    };

    BaseLegend.prototype.width = function(width) {
        if (!arguments.length) {
            return this._width;
        }
        this._width = width;
        if (width > 0) {
            this._originWidth = width;
        }
        return this;
    };

    BaseLegend.prototype.height = function(height) {
        if (!arguments.length) {
            return this._height;
        }
        this._height = height;
        if (height > 0) {
            this._originHeight = height;
        }
        return this;
    };

    BaseLegend.prototype.setSize = function(size) {
        this._width = size.width;
        this._height = size.height;
        // record the origin size to apply for the feeding zone without enough area.
        if (size.width > 0) {
            this._originWidth = size.width;
        }
        if (size.height > 0) {
            this._originHeight = size.height;    
        }
    };

    BaseLegend.prototype.setBindingFields = function(_) {
        this._bindingFields = _;
        return this;
    };

    BaseLegend.prototype.parent = function(parent) {
        if (!arguments.length) {
            return this._parent;
        }
        this._parent = parent;
        return this;
    };

    BaseLegend.prototype.getParent = function() {
        return this._parent;
    };

    BaseLegend.prototype._getTitleText = function() {
        var text = "";
        var userInputTitle = this._properties.get("title.text");

        if (TypeUtils.isString(userInputTitle)) {
            text = userInputTitle;
        } else if (this._bindingFields && this._bindingFields.length) {
            text = this._constructTitle(this._bindingFields);
        } else {
            text = langManager.get('IDS_LEGEND_TITLE');
        }
        return text;
    };

    BaseLegend.prototype.getLegendTitleText = function() {
        return this._getTitleText();
    };

    BaseLegend.prototype._constructTitle = function(header) {
        var toDraw = header.filter(function(hd) {
            return !hd.hidden;
        }).map(function(o) {

            if (o.id === MND) {
                return o.name || langManager.get("IDS_DEFAULTMND") || o.id;
            }

            return o.name || o.id;
        });

        var toDrawItems = [];

        for (var i = 0; i < toDraw.length; i++) {
            if (header && header.length > 1 && header[i].id === MND && header[i].values.length === 1) {
                // only one measure and one or more dimensions.
                // We ignore the measure name.
                continue;
            }

            toDrawItems.push(toDraw[i]);
        }

        return toDrawItems.join(" / ");
    };

    BaseLegend.prototype._getTitlePreferredSize = function(bounds) {
        this._setupThemeStyleDef();
        var preSize = {
            maxWidth: 0,
            maxHeight: 0,
            minWidth: 0,
            minHeight: 0
        };
        if (this._properties.get("title.visible")) {
            var titleTextHeight = parseInt(this._titleFont.fontSize, 10);

            var fontStyle = StyleUtils.convertToCss(this._titleFont);
            var titleText = this._getTitleText();
            var lineNumber = this._getWrapText();
            titleText = TextUtils.wrapText(titleText, [" "], bounds.maxWidth, lineNumber,
                this._properties.get("title.style"));
            var linesCount = titleText.lines.length;
            preSize = {
                maxHeight: titleTextHeight * (linesCount + this._titleMarginBottom),
                minWidth: TextUtils.getTextLength("M...", fontStyle),
                minHeight: titleTextHeight * (linesCount + this._titleMarginBottom),
                maxWidth: titleText.maxWidth
            };
            this._titleText = titleText;
        }
        return preSize;
    };

    BaseLegend.prototype.getData = function() {
        return this._data;
    };

    BaseLegend.prototype.setData = function(value) {
        this._data = value;
        return this;
    };

    BaseLegend.prototype.data = function(value) {
        if (!arguments.length) {
            return this.getData();
        }
        return this.setData(value);
    };

    BaseLegend.prototype.destroy = function() {
        this._properties = null;
        this._title = null;
        this._parent = null;
        
        this._bindingFields = null;
        this._pos = null;
        this._titleMarginBottom = null;
        this._width = null;
        this._height = null;
        this._titleFont = null;
        this._orientation = null;
        this._isDedicated = null;
        this._wrap = null;
        BaseLegend.superclass.destroy.call(this);
    };
    BaseLegend.prototype.hasData = function(){
        return true;
    };

    BaseLegend.prototype.getPreferredSize = function(bound) {
        var result = {
            width: 0,
            height: 0,
            maxWidth: 0,
            maxHeight: 0,
            minWidth: 0,
            minHeight: 0
        };
        if(!this.hasData()){
            return result;
        }
        this._pos = {
            x : 0,
            y : 0
        };
        var bounds = ObjectUtils.extend(false, bound);
        bounds.maxWidth = bounds.maxWidth || bounds.width;
        bounds.maxHeight = bounds.maxHeight || bounds.height;
       
        if (this.visible() || this._isDedicated) {
            // currently, we always disable title of legend.
            var titleSize = this._getTitlePreferredSize(bounds);
            bounds.height -= titleSize.maxHeight;
            var bodySize = this._getBodyPreferredSize(bounds);

            result = {
                width: (titleSize.maxWidth > bodySize.maxWidth ? titleSize.maxWidth : bodySize.maxWidth),
                height: titleSize.maxHeight + bodySize.maxHeight,
                maxWidth: (titleSize.maxWidth > bodySize.maxWidth ? titleSize.maxWidth : bodySize.maxWidth),
                maxHeight: titleSize.maxHeight + bodySize.maxHeight,
                minWidth: (titleSize.minWidth > bodySize.minWidth ? titleSize.minWidth : bodySize.minWidth),
                minHeight: titleSize.minHeight + bodySize.minHeight
            };

            if (this._isDedicated) {
                this._width = result.maxWidth;
                this._height = result.maxHeight;
            }
        }
        return result;
    };

    BaseLegend.prototype.isVisible = function() {
        return this.visible() && this._width > 0 && this._height > 0;
    };

    BaseLegend.prototype.isSelectable =function(){
        var parentOpt = this._properties.origin,
            selectionMode = (parentOpt.get('interaction.selectability.mode') || "").toUpperCase(),
            currentSelectionBehavior = 
                (parentOpt.get("interaction.selectability.behavior") || "").toUpperCase();
        return !(( selectionMode === InteractionConstants.SELECTION_MODE.NONE) || 
        (parentOpt.get('interaction.selectability.legendSelection') === false) ||
        (selectionMode === InteractionConstants.SELECTION_MODE.SINGLE && currentSelectionBehavior !== 
                InteractionConstants.SELECTION_BEHAVIOR.SERIES));
    };

    BaseLegend.prototype._setupThemeStyleDef = function() {

        var props = this._properties.proxy('title.style');

        var titleStyle;
        titleStyle = {
            "fill": props.get('color'),
            "font-family": props.get('fontFamily'),
            "font-size": props.get('fontSize'),
            "font-weight": props.get('fontWeight'),
            "font-style": props.get('fontStyle')
        };
        if (titleStyle) {
            if (titleStyle.fill) {
                this._titleFont.color = titleStyle.fill;
            }
            if (titleStyle['font-family']) {
                this._titleFont.fontFamily = titleStyle['font-family'];
            }
            if (titleStyle['font-size']) {
                this._titleFont.fontSize = titleStyle['font-size'];
            }
            if (titleStyle['font-weight']) {
                this._titleFont.fontWeight = titleStyle['font-weight'];
            }
            if (titleStyle['font-style']) {
                this._titleFont.fontStyle = titleStyle['font-style'];
            }
        }
    };

    BaseLegend.prototype._adjustRendererOption = function(rendererOption) {
    };

    BaseLegend.prototype._getWrapText = function() {
        var lineNum = 1;
        //we disable word-warp for RTL, because RTL is not for Lumira,
        //but word-warp is for Lumira
       
        if (!this._isRTL()) {
            //only support left and right layout position
            var layoutPosition = this._properties.origin.get('legendGroup.layout.position');
            if (layoutPosition === "left" || layoutPosition === "right") {
                //the line num is between 1 - 4 as PO demand
                lineNum = this._properties.origin.get('legendGroup.linesOfWrap');
                if (isNaN(lineNum) || lineNum < 1) {
                    //return default value if the property is invalid
                    lineNum = 1;
                } else if (lineNum > MAX_LINE_LIMIT) {
                    lineNum = MAX_LINE_LIMIT;
                }
            }
        }
        return lineNum;
    };
    BaseLegend.prototype.getZonePrefix = function(){
        return 'legend';
    };

    var isSizeLegend = function(legendType) {
        var result = false;
        if (legendType === 'SizeLegend') {
            result = true;
        }
        return result;
    };

    return BaseLegend;
});

define('sap/viz/chart/components/util/DrawUtil',['sap/viz/framework/common/util/TypeUtils',
        'sap/viz/framework/common/util/SVG'],

    function Setup(TypeUtils, SVG) {

        var symbolMap = {};
        var projectionCache = {};
        var BAR_MIN_FILL_SIZE = 2;

        function genSymbolKey(props){
            var sep = "_";
            return props.type + sep + props.rx + sep + props.ry;
        }

        /*jshint bitwise:false */
        var DrawUtil = {};

        /**
         *  props = {
         *    type:
         *    rx:
         *    ry:
         *    borderWidth:
         *  }
         *  @return path "d" for D3
         */
        DrawUtil.createMarkerData = function(props) {
            return SVG.generateMarkerPath(props);
        };

        DrawUtil.createElements = function(d3Enter, props) {
            return d3Enter.append("path").attr("class", props.className);
        };

        DrawUtil.createElement = function(d3Parent, props, effectManager) {
            var d3Element = d3Parent.append("path").attr("class", props.className);
            props.node = d3Element;
            DrawUtil.drawGraph(props, effectManager);
            return d3Element;
        };

        /**
         * props = {
         *   node: current d3 svg element,
         *  graphType : marker type
         *  drawingEffect: drawingEffect
         *  direction : direction
         *   rx : size
         *  ry: size
         *  fillColor: color
         *  borderWidth:
         *  borderColor,
         *  visibility: "visible" or "hidden"
         *  animateTime: total time for animation in ms
         *  strokeOpacity: opacity for border line
         *  endFunc: callback function, when animation complete, it will be called
         * }
         *  effectManager: current effectManager
         */
        DrawUtil.drawGraph = function(props, effectManager) {
            return DrawUtil.updateGraph(props, effectManager, DrawUtil.createGraph(props));
        };

        DrawUtil.createGraph = function(props) {
            var para = {
                    type: (typeof props.graphType === 'string') ? props.graphType : props.graphType.type,
                    rx: Math.round(props.rx),
                    ry: Math.round(props.ry),
                    borderWidth: Math.round(props.borderWidth),
                    innerBorder:props.dpPattern === 'noFill'
                };
            var result = DrawUtil.createMarkerData(para);
            if (!result && props.defaultShape) {
                para.type = props.defaultShape;
                result = DrawUtil.createMarkerData(para);
            }
            
            return result;
        };

        DrawUtil.updateGraph = function(props, effectManager, definition) {
            var customStyle = props.graphType.style;
            var opacity = props.opacity;
            if (!opacity){
                opacity = 1;
            }
            var fill = effectManager ? effectManager.register(props) : props.fillColor;
            var borderColor = props.borderColor;
            if(props.dpPattern === 'noFill'){
                borderColor = fill;
                fill = props.bgColor;

            }

            if (effectManager && borderColor){
                borderColor = effectManager.register({
                    fillColor: borderColor
                });
            }
            var node = props.node;
            node.setAttribute("class", props.className);
            node.setAttribute("fill", fill);
            if (fill !== "transparent" || borderColor !== "transparent") {
                node.setAttribute("stroke-width", props.borderWidth);
                node.setAttribute("stroke", borderColor);
                node.setAttribute("opacity", opacity);
                var fillOpacity = props.fillOpacity;
                if (fillOpacity != null) {
                    node.setAttribute("fill-opacity", fillOpacity);
                }
            }
            if(customStyle){
                Object.keys(customStyle).forEach(function(key) {
                    this.setAttribute(key, customStyle[key]);
                }, node);
            }
            node.setAttribute("stroke-opacity", props.strokeOpacity);
            if (definition) {
                node.setAttribute("d", definition);
            }

            return node;
        };

        DrawUtil.rgb2Hex = function(rgb) {
            return "#" + ((1 << 24) + (rgb.r << 16) + (rgb.g << 8) + rgb.b).toString(16).slice(1);
        };

        DrawUtil.colorLinerTransform = function(rgbHelperFun, linerVariable, colorString) {
            var oldRGB = rgbHelperFun.color2rgba(colorString);
            var factor = 1,
                constant = 0;
            factor = linerVariable.factor;
            constant = linerVariable.constant;
            return {
                r: Math.min(255, Math.round(oldRGB.r * factor + constant)),
                g: Math.min(255, Math.round(oldRGB.g * factor + constant)),
                b: Math.min(255, Math.round(oldRGB.b * factor + constant))
            };
        };

        DrawUtil.barUpdate = function(node, config, size) {
            var graphic = config.graphic;
            var width = size.width;
            var height = size.height;
            var minSize = size.minSize;
            var rect = node.querySelector("rect");
            if (rect) {
                rect.setAttribute("width", width);
                rect.setAttribute("height", height);
                if(graphic.stroke) {
                    var strokeWidth = minSize > graphic.strokeWidth + BAR_MIN_FILL_SIZE ?
                            graphic.strokeWidth : minSize - BAR_MIN_FILL_SIZE;
                    if(strokeWidth >= 1){
                        rect.setAttribute('stroke', graphic.stroke);
                        rect.setAttribute('stroke-width', graphic.strokeWidth);
                    }else{
                        rect.removeAttribute('stroke');
                        rect.removeAttribute('stroke-width');
                    }
                }           
            }

            if (graphic.pattern === "noFill" && config.path) {
                var path = node.querySelector("path");
                if (path) {
                    path.setAttribute("d", config.path);
                }
            }
        };

        return DrawUtil;
    });

define('sap/viz/chart/components/util/DataPointUtils',[
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/TypeUtils"
], function(SVG, DOM, Constants, DataGraphics, TypeUtils) {
    var CLASSDATAPOINT = Constants.CSS.CLASS.DATAPOINT,
        TAG_DATAPOINT = "g",
        SELECTOR_DATAPOINT = "." + CLASSDATAPOINT,
        CLASSDATAPOINT_DEFAULT = Constants.CSS.CLASS.DATAPOINTDEFAULT;
    var DATA_ATTR_HIGHLIGHTED = "data-highlighted";
    var DATA_ATTR_DATAID = "data-id";
    var DATA_ATTR_DATAPOINTID = "data-datapoint-id";
    var DATA_ATTR_DATASTACKID = "data-datastack-id";
    var DATA_ATTR_RECAPSTACKID = "data-recap-id";

    var AREA_ATTR_ID = "data-area-id";

    function getNodeDom(dataPoints, service){
        var dataPointNodes = service.getNodes(service.NodeType.DATA_POINT, false);
        var targets = findByDataPointIds(dataPointNodes, dataPoints);
        // Ensure targets is a normal array
        return [].slice.apply(targets);
    }

    function findByDataPointIds(nodes, ids){
        return DataPoints.findIdsWithClassId(nodes, ids, DATA_ATTR_DATAPOINTID);
    }

    var DataPoints = {
        findArea: function(parent, id) {
            return parent.querySelector("[" + AREA_ATTR_ID + "='" + id + "']");
        },
        setAreaId: function(node, dataId) {
            node.setAttribute(AREA_ATTR_ID, dataId);
        },
        findAll: function(parent) {
            return parent.querySelectorAll(SELECTOR_DATAPOINT);
        },
        find: function(parent, id) {
            return parent.querySelector("." + CLASSDATAPOINT + "[" + DATA_ATTR_DATAID + "='" + id + "']");
        },
        findByDataPointId: function(parent, id){
            return parent.querySelector("[" + DATA_ATTR_DATAPOINTID + "='" + id + "']");
        },
        findIdsWithClassId : function(nodes, ids, classId){
            if(!TypeUtils.isArray(ids)){
                ids = [ids];
            }
            var idMap = {};
            var i;
            for(i = ids.length; i--;){
                idMap[ids[i]] = 1;
            }
            
            var dpHash = {};
            
            var targetIds = [];
            for(i = nodes.length; i--;){
                var node = nodes[i];
                var dpId = node.getAttribute(classId);
                if(idMap[dpId]){
                    dpHash[dpId] = node;
                    targetIds.push(dpId);
                }
            }
            
            var results = [];
            for (i = targetIds.length; i--;) {
                results.push(dpHash[targetIds[i]]);
            }
            return results;
        },
        findByDataStackIds : function(nodes, ids){
            return DataPoints.findIdsWithClassId(nodes, ids, DATA_ATTR_DATASTACKID);
        },
        findByDataRecapIds : function(nodes, ids){
            return DataPoints.findIdsWithClassId(nodes, ids, DATA_ATTR_RECAPSTACKID);
        },

        findByDataPointIds : findByDataPointIds,

        isDataPoint: function(node) {
            return DOM.matches(node, SELECTOR_DATAPOINT);
        },
        setDataId: function(node, dataId) {
            node.setAttribute(DATA_ATTR_DATAID, dataId);
        },
        getDataId: function(node) {
            return node.getAttribute(DATA_ATTR_DATAID);
        },
        setDataPointId: function(node, id){
            node.setAttribute(DATA_ATTR_DATAPOINTID, id);
        },
        getDataStackId: function(node, id){
            return node.getAttribute(DATA_ATTR_DATASTACKID);
        },
        getDataRecapId: function(node, id){
            return node.getAttribute(DATA_ATTR_RECAPSTACKID);
        },
        setDataStackId: function(node, id){
            node.setAttribute(DATA_ATTR_DATASTACKID, id);
        },
        setDataRecapId: function(node, id){
            node.setAttribute(DATA_ATTR_RECAPSTACKID, id);
        },
        getDataPointId: function(node){
            return node.getAttribute(DATA_ATTR_DATAPOINTID);
        },
        highlight: function(node) {
            node.setAttribute(DATA_ATTR_HIGHLIGHTED, "true");
        },
        unhighlight: function(node) {
            node.removeAttribute(DATA_ATTR_HIGHLIGHTED);
        },
        isHighlighted: function(node) {
            return node.getAttribute(DATA_ATTR_HIGHLIGHTED) === "true";
        },
        create: function(parent, dataId) {
            var dataPointNode = SVG.create(TAG_DATAPOINT, parent);
            dataPointNode.setAttribute("class", CLASSDATAPOINT + ' ' +
                CLASSDATAPOINT_DEFAULT + ' ' + Constants.CSS.CLASS.MORPHABLEDATAPOINT);
            dataPointNode.setAttribute(DATA_ATTR_DATAID, dataId);
            return dataPointNode;
        },
        setContext: function(node, data) {
            return DataGraphics.setContext(node, data);
        },
        getContext: function(node) {
            return DataGraphics.getContext(node);
        },
        getAdditionCtx: function(node){
            return DataGraphics.getAdditionCtx(node);
        },
        getAdditionCtxByDataModel: function(node, dataModel){
            
            var context = DataGraphics.getAdditionCtx(node);
            
            if (context != null) {
                return context;
            }
            
            var datapointId = this.getDataPointId(node);
            
            var dataPoint = dataModel.getDataPoint(datapointId);
            
            if (dataPoint == null) {
                return null;
            }
            return dataPoint.additionCtx();
        },
        getContextByDataModel: function(node, dataModel) {
            
            var context = DataGraphics.getContext(node);
            
            if (context != null) {
                return context;
            }
            
            var datapointId = this.getDataPointId(node);
            
            var dataPoint = dataModel.getDataPoint(datapointId);
            
            if (dataPoint == null) {
                return null;
            }
            return dataPoint.context();
        },
        getDataPointByDataLabel: function(target, service) {
            var dpId = this.getDataPointId(target);
            var nodes = service.getNodes(service.NodeType.DATA_POINT, false);
            return findByDataPointIds(nodes, dpId)[0];
        },
        
        getNodes : function(dataPoints, service){
            if (service.isBigDataMode()) {
                return dataPoints;
            }
            return getNodeDom(dataPoints, service);
        },

        getNodeDom: getNodeDom
    };

    return DataPoints;
});

define('sap/viz/chart/behavior/config/SelectionUtil',[
    'sap/viz/framework/chartmodel/DataSelector',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/interaction/Constants',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/RuleUtil',
    'sap/viz/framework/common/util/ObjectUtils'
], function(
    DataSelector,
    DataGraphics,
    DataPointUtils,
    Constants,
    SDKConstants,
    TypeUtils,
    DataUtils,
    RuleUtil,
    ObjectUtils
){
    var DATE_TYPE = "date";
    var RANGE_OFFSET = SDKConstants.RANGE_SELECTION.OFFSET;

    function getDataPointNodes(condition, service){
        var dpIds = getDataPointIds(condition, service);
        var dataPointNodes = service.getNodes(service.NodeType.DATA_POINT, false);
        var targets = DataPointUtils.findByDataPointIds(dataPointNodes, dpIds);
        // Ensure targets is a normal array
        return [].slice.apply(targets);
    }

    function getCorrespondingLegendItem(currentDataPointNode, service) {

        var hideSemanticLegend = service.getSemanticManager().isHideSemanticLegend();
        var dpId = DataPointUtils.getDataPointId(currentDataPointNode);
        var dp = service.getDataModel().getDataPoint(dpId);
        if (hideSemanticLegend && dp._isSemantic) {
            return null;
        }

        var legendItemTarget;
        //get all legend items
        var legendItemNotes = service.getNodes(service.NodeType.LEGEND_ITEM, false);
        for (var i = 0; !legendItemTarget && i < legendItemNotes.length; i++) {
            var ctxToHighlight = DataGraphics.getContext(legendItemNotes[i]).ctx;
            var correspondingDataPointNodes = getDataPointNodes(ctxToHighlight, service);
            for (var j = 0; !legendItemTarget && j < correspondingDataPointNodes.length; j++) {
                var correspondingDataPointNodeId = DataPointUtils.getDataPointId(correspondingDataPointNodes[j]);
                if (correspondingDataPointNodeId === dpId) {
                    legendItemTarget = legendItemNotes[i];
                }
            }
        }
        return legendItemTarget;
    }

    function updateCorrespondingSelectedLegendItems(service, isMBC) {
        if (!service.isTrellis() && service.getProperties().get("legend.selectionFeedback")) {
            var selectedDataPoints = service.getStatus("selectedDataPoints") || [];
            //selectedDataPoints is an id array.
            //get all legend items
            var nodeType;
            var nodeClass;
            if (isMBC) {
                nodeType = service.NodeType.MBC_LEGEND_ITEM;
                nodeClass = Constants.CSS.CLASS.MBCLEGENDITEM;
            }
            else {
                nodeType = service.NodeType.LEGEND_ITEM;
                nodeClass = Constants.CSS.CLASS.LEGENDITEM;
            }
            var legendItemNotes = service.getNodes(nodeType, false);

            for (var i = 0; i < legendItemNotes.length; i++) {
                var d3Item = d3.select(legendItemNotes[i]);

                var ctxToSelect = DataGraphics.getContext(legendItemNotes[i]).ctx;
                if (isMBC) {
                    //shallow copy
                    ctxToSelect = ObjectUtils.extend({}, ctxToSelect);
                    delete ctxToSelect.measureName;
                }

                var correspondingDataPointIds = getDataPointIds(ctxToSelect, service);
                var isShouldBeSelected = (correspondingDataPointIds && correspondingDataPointIds.length);
                for (var j = 0; (isShouldBeSelected && j < correspondingDataPointIds.length) ; j++) {
                    isShouldBeSelected = (selectedDataPoints.indexOf(correspondingDataPointIds[j]) >= 0);
                }
                //to change class
                d3Item.classed(nodeClass + Constants.CSS.CLASS.SELECTED, isShouldBeSelected);
            }

            if (isMBC) {
                resetMBCLegendSelectionEffect(service);
            }
            else {
                resetLegendSelectionEffect(service);
            }
        }
    }

    function getParseId(condition, dataModel, dataType) {
        var bindings = dataModel._bindingFeeds, id;
        if (bindings) {
            for (var i = 0; i < bindings.length; i++) {
                if (dataModel["_" + bindings[i]] && dataModel["_" + bindings[i]].metaData) {
                    var metaData = dataModel["_" + bindings[i]].metaData;
                    for (var j = 0; j < metaData.length; j++) {
                        if (metaData[j].dataType && metaData[j].dataType.toLowerCase() === dataType) {
                            id = metaData[j].id;
                        }
                    }
                }
            }
        }
        return id;
    }

    function parseCondition(condition, dataModel, dataType, parserOption) {
        var id = getParseId(condition, dataModel, dataType);
        if (TypeUtils.isExist(id)) {
            parseConditionById(condition, id, dataType, parserOption);
        }
    }

    function parseConditionById(condition, id, dataType, parserOption) {
        if (TypeUtils.isArray(condition) || TypeUtils.isPlainObject(condition)) {
            for (var i in condition) {
                if (condition.hasOwnProperty(i)) {
                    if (i === id) {
                        RuleUtil.parseRules[dataType](condition, i, parserOption);
                        condition[i + DataUtils.DIMENSION_PARSED_VALUE_SUFFIX] = condition[i];
                        delete condition[i];
                    } else {
                        parseConditionById(condition[i], id, dataType, parserOption);
                    }
                }
            }
        }
    }

    function getDataPointsByCondition(condition, service, needParse, parserOption) {
        var dataModel = service.getDataModel();
        if (needParse){
            //parseCondition would change the condition object, so make a clone.
            condition = ObjectUtils.clone(condition, true);
            parseCondition(condition, dataModel, DATE_TYPE, parserOption);
        }
        var selector = new DataSelector(condition, dataModel);
        return selector.getDataPoints();
    }

    function getDataPointIds(condition, service, needParse, parserOption) {
        var dataPoints = getDataPointsByCondition(condition, service, needParse, parserOption);
        return dataPoints.map(function(dp){
            return (dp.id).toString();
        });
    }

    function isLegendTriggerable(service, nodeType) {
        var selectability = service.getProperties().get("interaction.selectability");
        if (!selectability) {
            return false;
        }
        var tempSelectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        var currentSelectionBehavior = tempSelectionBehavior ? tempSelectionBehavior.toUpperCase()
        : tempSelectionBehavior;
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        var legendNode = service.getNodes(nodeType);
        if (!selectability.legendSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE ||
            (selectionMode === SDKConstants.SELECTION_MODE.SINGLE && currentSelectionBehavior !==
                SDKConstants.SELECTION_BEHAVIOR.SERIES) || !legendNode.node()) {
            return false;
        } else {
            return true;
        }
    }

    function processTimeCursor(event, service) {

        var inLasso = service.getStatus("lassoStartPoint");
        var bInRange = service.getStatus("rangeSelection");
        var cursorStyle = service._rootNode.node().style;
        if(!inLasso && bInRange){
            var point = event.data.point;
            var rangeBox = service.getBBox(service.BoxType.RANGE_SELECTION);
            var bbox = service.getBBox(service.BoxType.PLOT_BOUND_NODE);
            if(bbox.x > point.x || bbox.x + bbox.width < point.x ||
                    bbox.y > point.y || bbox.y + bbox.height < point.y){
                cursorStyle.cursor="default";
            }   else if( Math.abs(point.x - rangeBox.x) <= RANGE_OFFSET  ||
                    Math.abs(point.x - rangeBox.x - rangeBox.width) <= RANGE_OFFSET){
                cursorStyle.cursor="col-resize";
            }else if(rangeBox.x < point.x  && rangeBox.x + rangeBox.width > point.x){
                cursorStyle.cursor="move";

            }else {
                cursorStyle.cursor="default";
            }

        }else {
            cursorStyle.cursor="default";
        }
    }

    function getTargets(items, service) {
        var conditions = items.map(function(item) {
            return item.data;
        });
        var statusMgr = service.getStatusManager();
        var renderType = service._getRenderType();
        var parserOption = {
            dataTimeLevel: null,
            showAsUTC: false
        };
        var regPattern = /timeseries.*column|timeseries.*combination|timeseries_bullet|timeseries_waterfall/;
        if (regPattern.test(renderType)){
            parserOption = {
                dataTimeLevel: statusMgr.get("timeLevels")[0],
                showAsUTC: service.getProperties().get("general.showAsUTC")
            };
        }
        parserOption.originProps = service.getProperties();
        return getDataPointIds(conditions, service, true, parserOption);
    }
    function cleanRangeSelection(service) {
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        if(service.getStatus("rangeSelection")){
            service.setStatus("selectedDataPoints", []);
            service.fireEvent("clearPlot").fireEvent("deselectDataPoint", {
                targets : DataPointUtils.getNodes(selectedDataPoints, service),
                isAnyOtherSelected : false
            });
            service.setStatus("rangeSelection", false);
            service.setStatus("rangeDomain", null);

        }
    }

    function getDpInfos(plotModule, elements) {
        var dpInfos = [];
        for (var i = 0, length = elements.length; i < length; i++) {
            var part = plotModule.mappingDataPointInfo(elements[i]);
            if (part) {
                dpInfos.push(part);
            }
        }

        dpInfos = dpInfos.sort(function(one, two) {
            return one.seqId - two.seqId;
        });
        return dpInfos;
    }

    function getSelectedPeriods(service, selectedDataPoints) {
        var selectedPeriods = [];
        var dataModel = service.getDataModel();
        if(dataModel && dataModel._timeAxis) {
            var timeField = dataModel.timeAxis().metaData.map(function(e) {
                return e.id;
            });
            selectedDataPoints.forEach(function(id) {
                var dp = dataModel.getDataPoint(id);
                if (dp && dp._data && selectedPeriods.indexOf(
                    dp._data[timeField + DataUtils.DIMENSION_PARSED_VALUE_SUFFIX]) < 0) {
                    selectedPeriods.push(dp._data[timeField + DataUtils.DIMENSION_PARSED_VALUE_SUFFIX]);
                }
            });
        }
        return selectedPeriods;
    }

    var resetLegendSelectionEffect = function (service) {
        if (!service.isTrellis() && service.getProperties().get("legend.selectionFeedback")) {
            service.getNodes(service.NodeType.LEGEND_ITEM).each(function () {
                var item = d3.select(this);
                if (item.classed(Constants.CSS.CLASS.LEGENDITEM)) {
                    var fillColor = "transparent";
                    var isHover = item.select("rect").classed(Constants.CSS.CLASS.HOVER_SHADOW);
                    if (item.classed(Constants.CSS.CLASS.LEGENDITEM + Constants.CSS.CLASS.SELECTED)) {
                        var colorProp = (isHover ?
                            "legend.hoverSelectedShadow.color" : "legend.mouseDownShadow.color");
                        fillColor = service.getProperties().get(colorProp);
                    }
                    else if (isHover) {
                        fillColor = service.getProperties().get("legend.hoverShadow.color");
                    }

                    item.select("rect").attr("fill", fillColor);
                }
            });
        }
    };

    function getColorProperty(service, propertyName, defaultValue) {
        var prop = service.getProperties().get(propertyName);
        var color;
        if (prop && prop.color) {
            color = prop.color;
        } else {
            color = defaultValue;
        }
        return color;
    }

    var resetMBCLegendSelectionEffect = function (service) {
        if (!service.isTrellis() && service.getProperties().get("legend.selectionFeedback")) {
            service.getNodes(service.NodeType.MBC_LEGEND_ITEM).each(function () {
                var item = d3.select(this);
                if (item.classed(Constants.CSS.CLASS.MBCLEGENDITEM)) {
                    var strokeColor = null;
                    var strokeWidth = null;
                    var isHover = item.classed(Constants.CSS.CLASS.HOVER_SHADOW);
                    if (item.classed(Constants.CSS.CLASS.MBCLEGENDITEM + Constants.CSS.CLASS.SELECTED)) {
                        strokeWidth = Constants.MBCLEGEND.VISIBLE_STROKE_WIDTH;
                        if (isHover) {
                            strokeColor = getColorProperty(service, "legend.hoverSelectedShadow");
                        }
                        else {
                            strokeColor = getColorProperty(service, "legend.mouseDownShadow",
                                Constants.MBCLEGEND.HOVER_SHADOW_MOUSE_DOWN_COLOR);
                        }
                    }
                    else if (isHover) {
                        strokeWidth = Constants.MBCLEGEND.VISIBLE_STROKE_WIDTH;
                        strokeColor = getColorProperty(service, "legend.hoverShadow",
                            Constants.MBCLEGEND.HOVER_SHADOW_COLOR);
                    }
                    item.attr("stroke", strokeColor);
                    item.attr("stroke-width", strokeWidth);
                }
            });
        }
    };

    return {
        getDataPointIds: getDataPointIds,
        getDataPointNodes: getDataPointNodes,
        isLegendTriggerable: isLegendTriggerable,
        getTargets: getTargets,
        getDataPoint : function(node){
            return DataPointUtils.getContext(node);
        },

        getDataPointContext : function(dataPoint){
            return dataPoint;
        },

        hasDataPoint : function(dataPoints, dataPoint) {
            return dataPoints && dataPoints.some(function(dp){
                return +dp === +dataPoint;
            });
        },
        processTimeCursor: processTimeCursor,
        getDpInfos: getDpInfos,
        cleanRangeSelection : cleanRangeSelection,
        getSelectedPeriods: getSelectedPeriods,
        getCorrespondingLegendItem: getCorrespondingLegendItem,
        updateCorrespondingSelectedLegendItems: updateCorrespondingSelectedLegendItems,
        resetLegendSelectionEffect: resetLegendSelectionEffect,
        resetMBCLegendSelectionEffect: resetMBCLegendSelectionEffect,
        getColorProperty: getColorProperty
    };
});

define('sap/viz/chart/components/util/ColorUtil',["sap/viz/framework/common/util/DataGraphics"], function(DataGraphics) {

    //refer to sapjira /secure/attachment/119796/2014-06-18%20Coloring%20of%20Data%20Labels.pdf
    //and http://www.w3.org/TR/AERT#color-contrast
    var DARK_LABEL_COLOR = "#000000";
    var LIGHT_LABEL_COLOR = "#ffffff";
    var DEFAULT_LABEL_COLOR = "#333333";
    var DARK_FLAG = 116;
    var DEFAULT_BACKGROUND_COLOR = "#ffffff";

    var STROKECOLORADJUST_FOR_DARK = 1.2;
    var STROKECOLORADJUST_FOR_LIGHT = 0.7;

    var ColorUtil = {};

    var getColorObj = function(color) {
        //we may need to NamedColorUtils.convertColor(color);
        var reColor = color;
        reColor = reColor.toLowerCase();
        reColor = d3.rgb(reColor);
        return reColor;
    };

    ColorUtil.getMixedColor = function(frontColor, backColor, frontColorOpacity) {
        var mixedColor = frontColor;
        if(frontColorOpacity !== 1)
        {
            if(backColor.toLowerCase() === "transparent") {
                backColor = "#ffffff";
            }
            var rgbFrontColor = getColorObj(frontColor);
            var rgbBackColor = getColorObj(backColor);
            var mixedRGBColor = d3.rgb(rgbFrontColor.r * frontColorOpacity +
                                    rgbBackColor.r * ( 1 - frontColorOpacity),
                                    rgbFrontColor.g * frontColorOpacity + rgbBackColor.g * ( 1 - frontColorOpacity),
                                    rgbFrontColor.b * frontColorOpacity + rgbBackColor.b * ( 1 - frontColorOpacity));

            mixedColor = mixedRGBColor.toString();
        }

        return mixedColor;
    };

    ColorUtil.getReferenceColorValue = function(refColor) {
        refColor = refColor.toLowerCase();
        var reg = /([a-z]+)\((.*)\)/i.exec(refColor);
        var rgb;
        if (reg && reg[1] === "rgba" && reg[2]) {
            // handle rgba input manually
            var rColor = reg[2].split(",");
            var opacity = rColor[3];
            refColor = d3.rgb(rColor[0], rColor[1], rColor[2]);
            rgb = d3.rgb(ColorUtil.getMixedColor(refColor.toString(), DEFAULT_BACKGROUND_COLOR, opacity));
            // return alpha blended color
        } else {
            rgb = getColorObj(refColor);
        }
        var reValue = ((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000;
        return reValue;
    };

    ColorUtil.getDataLabelColor = function(backColor, isUseDefaultColor) {
        var labelColor = DARK_LABEL_COLOR;
        if(isUseDefaultColor) {
            labelColor = DEFAULT_LABEL_COLOR;
        }
        else {
            if(backColor)
            {
                if(backColor.toLowerCase() === "transparent") {
                    backColor = "#ffffff";
                }
                var reValue = ColorUtil.getReferenceColorValue(backColor);

                if(reValue <= DARK_FLAG) {
                    labelColor = LIGHT_LABEL_COLOR;
                }
            }
        }
        return labelColor;
    };

    ColorUtil.getStrokeColorAdjustValue = function(refNode) {
        var backgroundColor = ColorUtil.getBackgroundColor(refNode);
        if(backgroundColor.toLowerCase() === "transparent") {
            backgroundColor = "#ffffff";
        }
        var reValue = ColorUtil.getReferenceColorValue(backgroundColor);

        var adjustValue = STROKECOLORADJUST_FOR_LIGHT;
        if(reValue <= DARK_FLAG) {
            adjustValue = STROKECOLORADJUST_FOR_DARK;
        }

        return adjustValue;
    };

    ColorUtil.getBackgroundColor = function(refNode) {
        var backgroundColor = "transparent";
        var backgroundClassName = "v-background-body";

        //refNode is a DOM element
        var plotNode;
        var tempNode;
        for(tempNode = refNode;tempNode;tempNode = tempNode.parentNode)
        {
            if(!d3.select(tempNode).select("." + backgroundClassName).empty())
            {
                //find plotNode
                plotNode = tempNode;
                break;
            }
        }

        if(plotNode)
        {
            var plotBackgroundNode = d3.select(plotNode).select("." + backgroundClassName).node();

            var backgroundData;
            if(plotBackgroundNode)
            {
                backgroundData = DataGraphics.getData(plotBackgroundNode);
                if (backgroundData) {
                    backgroundColor = backgroundData.color;
                }
            }
            //we ignore opacity here.
            if(!backgroundColor ||
                backgroundColor.toLowerCase() === "transparent") {
                var rootBackgroundNode;
                if (plotNode.parentNode && plotNode.parentNode.parentNode){
                    rootBackgroundNode =
                        d3.select(plotNode.parentNode.parentNode)
                        .select("." + backgroundClassName).node();
                }
                if(rootBackgroundNode) {
                    backgroundData = DataGraphics.getData(rootBackgroundNode);
                    if (backgroundData) {
                        backgroundColor = backgroundData.color;
                    }
                }
            }

            if(!backgroundColor) {
                backgroundColor = "transparent";
            }
        }
        return backgroundColor;
    };
    
    ColorUtil.getBgColor = function(propMgr, props){
        var bgColor = "#ffffff";
        for(var i = 0; i < props.length; ++i){
            var temp = propMgr.get(props[i]);
            if(temp && temp !== "transparent"){
                bgColor = temp;
                break;
            }
        }
        return bgColor;
    };

    return ColorUtil;
});

define('sap/viz/chart/components/plots/PlotHelper',[
    'jquery'

], function($) {
    var plotMapping = {
        'pie': {
            options: {
                isDonut: false
            }
        },
        'donut': {
            options: {
                isDonut: true
            }
        },
        'column': {
            options: {
                isHorizontal: false
            }
        },
        'stacked_column': {
            options: {
                isSupportFlexibleStack: true,
                isHorizontal: false,
            }
        },
        '100_stacked_column': {
            options: {
                isHorizontal: false
            }
        },
        'bar': {
            options: {
                isHorizontal: true
            }
        },
        'bullet' : {
            options : {
                isHorizontal : true
            }
        },
        'vertical_bullet':{
            options : {
                isHorizontal : false
            }
        },
        'stacked_bar' : {
            options : {
                isHorizontal : true
            }
        },
        '100_stacked_bar': {
            options: {
                isHorizontal: true
            }
        },
        'line': {
            options: {
                isHorizontal: false
            }
        },
        'area': {
            options: {
                isHorizontal: false
            }
        },
        'horizontal_area': {
            options: {
                isHorizontal: true
            }
        },
        'horizontal_line': {
            options: {
                isHorizontal: true
            }
        },
        '100_area': {
            options: {
                isHorizontal: false
            }
        },
        '100_horizontal_area': {
            options: {
                isHorizontal: true
            }
        },
        'combination': {
            options: {
                isHorizontal: false
            }
        },
        'horizontal_combination': {
            options: {
                isHorizontal: true
            }
        },
        'bubble': {
            options: {}
        },
        'time_bubble' : {
            options : {}
        },
        'scatter': {
            options: {}
        },
        'timeseries_scatter': {
            options: {}
        },
        'timeseries_bubble': {
            options: {}
        },
        'stacked_combination': {
            options: {
                isHorizontal: false
            }
        },
        'horizontal_stacked_combination': {
            options: {
                isHorizontal: true
            }
        },
        'mekko': {
            options: {
                isHorizontal: false
            }
        },
        '100_mekko': {

        },
        'timeseries_line' : {
            options: {
                isHorizontal: false
            }
        },
        'timeseries_column' : {
            options: {
                isHorizontal: false
            }
        },
        'timeseries_stacked_column' : {
            options: {
                isHorizontal: false
            }
        },
        'timeseries_100_stacked_column' : {
            options: {
                isHorizontal: false
            }
        },
        'timeseries_combination' : {
            options: {
                isHorizontal: false
            }
        },
        'dual_timeseries_combination' : {
            options: {
                isHorizontal: false
            }
        },
        'timeseries_stacked_combination' : {
            options: {
                isHorizontal: false
            }
        },
        'horizontal_mekko': {
            options: {
                isHorizontal: true
            }
        },
        '100_horizontal_mekko': {
            options: {
                isHorizontal: true
            }
        },
        'timeseries_waterfall' : {
            options: {
                isHorizontal: false
            }
        },
        'waterfall': {
            options: {
                isHorizontal: false
            }
        },
        'stacked_waterfall': {
            options: {
                isHorizontal: false
            }
        },
        'horizontal_waterfall': {
            options: {
                isHorizontal: true
            }
        },
        'horizontal_stacked_waterfall': {
            options: {
                isHorizontal: true
            }
        },
        'radar': {
            options: {
                isHorizontal: false
            }
        },
        'heatmap' : {
            options: {}
        },
        'treemap' : {
            options: {}
        },
        'timeseries_bullet': {
            options: {
                isHorizontal: false
            }
        },
        'combinationEx' : {
            options: {}
        }
    };

    return {
        register: function(plotName, config) {
            plotMapping[plotName] = config;
        },
        create: function(renderType, plotClazz, runtime, options) {
            var config = plotMapping[renderType];
            var opts = options ? $.extend(true, {}, config ? config.options : {}, options) : config.options;
            opts.name = "plotArea";
            opts.renderType = renderType;
            return new plotClazz(runtime, opts);
        },
        getOptions: function(renderType) {
            var config = plotMapping[renderType];
            return config && config.options;
        }
    };

});

define('sap/viz/chart/components/util/ChartConstants',[], function Setup() {
    var CONNECTOR = "_";
    var HORIZONTAL = "horizontal";
    var COMBINATION = "combination";
    var STACKED = "stacked";
    var COLUMN = "column";
    var BAR = "bar";
    var BULLET = "bullet";
    var LINE = "line";
    var SCATTER = "scatter";
    var BUBBLE = "bubble";
    var PIE = "pie";
    var TIMESCATTER = 'timeseries_scatter';
    var CATEGORYAXIS_NAVIGATOR = "categoryAxisNavigator";
    var CATEGORYAXIS2_NAVIGATOR = "categoryAxis2Navigator";
    var TIMEAXIS_NAVIGATOR = "timeAxisNavigator";
    var DATAPOINT_NAVIGATOR = "datapointNavigator";
    var LEGEND_NAVIGATOR = "legendNavigator";
    var COLORLEGEND_NAVIGATOR = "colorLegendNavigator";
    var MBCLEGEND_NAVIGATOR = "mbcLegendNavigator";
    var HEATMAP = "heatmap";
    var TREEMAP = "treemap";
    var WATERFALL = "waterfall";
    var TIMEWATERFALL = "timeseries_waterfall";
    var AREA = "area";
    var RADAR = 'radar';
    var PERCENT = "100";
    var chartConstants = {
        "STACKED": STACKED,
        "COMBINATION": COMBINATION,
        "COLUMN": COLUMN,
        "BAR": BAR,
        "BULLET": BULLET,
        "LINE": LINE,
        "SCATTER": SCATTER,
        "BUBBLE": BUBBLE,
        "PIE": PIE,
        "TIMESCATTER": TIMESCATTER,
        "COLUMN_COMBINATION": COLUMN + CONNECTOR + COMBINATION,
        "STACKED_COLUMN": STACKED + CONNECTOR +COLUMN,
        "STACKED_BAR": STACKED + CONNECTOR + BAR,
        "STACKED_COMBINATION": STACKED + CONNECTOR + COMBINATION,
        "HORIZONTAL_COMBINATION": HORIZONTAL + CONNECTOR + COMBINATION,
        "HORIZONTAL_STACKED_COMBINATION": HORIZONTAL + CONNECTOR + STACKED + CONNECTOR + COMBINATION,
        "CATEGORYAXIS_NAVIGATOR": CATEGORYAXIS_NAVIGATOR,
        "CATEGORYAXIS2_NAVIGATOR": CATEGORYAXIS2_NAVIGATOR,
        "TIMEAXIS_NAVIGATOR": TIMEAXIS_NAVIGATOR,
        "DATAPOINT_NAVIGATOR": DATAPOINT_NAVIGATOR,
        "LEGEND_NAVIGATOR": LEGEND_NAVIGATOR,
        "COLORLEGEND_NAVIGATOR": COLORLEGEND_NAVIGATOR,
        "MBCLEGEND_NAVIGATOR": MBCLEGEND_NAVIGATOR,
        "HEATMAP": HEATMAP,
        "TREEMAP": TREEMAP,
        "WATERFALL":WATERFALL,
        "TIMEWATERFALL": TIMEWATERFALL,
        "AREA":AREA,
        "RADAR": RADAR,
        "PERCENT_STACKED_COLUMN": PERCENT + CONNECTOR + STACKED + CONNECTOR + COLUMN,
        "PERCENT_STACKED_BAR": PERCENT + CONNECTOR + STACKED + CONNECTOR + BAR
    };

    return chartConstants;
});

define('sap/viz/chart/components/util/ChartTypeUtils',[
    "sap/viz/chart/components/plots/PlotHelper",
    "sap/viz/chart/components/util/ChartConstants"
], function Setup(PlotHelper, ChartConstants) {
    var chartTypes = {
        addTrellisType: function(chartType) {
            var TrellisType = [];
            for (var i = 0; i < chartType.length; ++i) {
                if (chartType[i].indexOf("info/") >= 0 &&
                    chartType[i].indexOf("info/trellis_") === -1) {
                    var type = chartType[i].replace("info/", "info/trellis_");
                    TrellisType.push(type);
                }
            }
            return [].concat(chartType, TrellisType);
        },

        getChartTypeProperty: function(renderType) {
            var renderProp = {};
            if (renderType.indexOf(ChartConstants.STACKED) > -1) {
                if (renderType.search(/bar|column/) !== -1) {
                    renderProp.type = ChartConstants.STACKED_COLUMN;
                } else if (renderType.indexOf(ChartConstants.STACKED_COMBINATION) > -1) {
                    renderProp.type = ChartConstants.STACKED_COMBINATION;
                }
            } else {
                if (renderType.search(/bar|column/) !== -1) {
                    renderProp.type = ChartConstants.COLUMN;
                } else if (renderType.indexOf(ChartConstants.BULLET) > -1) {
                    renderProp.type = ChartConstants.BULLET;
                } else if (renderType.indexOf(ChartConstants.LINE) > -1) {
                    renderProp.type = ChartConstants.LINE;
                } else if (renderType.indexOf(ChartConstants.COMBINATION) > -1) {
                    renderProp.type = ChartConstants.COLUMN_COMBINATION;
                } else if (renderType.search(/pie|donut/) !== -1) {
                    renderProp.type = ChartConstants.PIE;
                } else if (renderType.search(/^timeseries.*(scatter|bubble)/) !== -1) {
                    renderProp.type = ChartConstants.TIMESCATTER;
                } else if (renderType.search(/(scatter|bubble)/) !== -1) {
                    renderProp.type = ChartConstants.SCATTER;
                } else if (renderType.indexOf(ChartConstants.HEATMAP) > -1) {
                    renderProp.type = ChartConstants.HEATMAP;
                } else if (renderType.indexOf(ChartConstants.TREEMAP) > -1) {
                    renderProp.type = ChartConstants.TREEMAP;
                } else if (renderType.indexOf(ChartConstants.WATERFALL) > -1) {
                    renderProp.type = ChartConstants.WATERFALL;
                } else if (renderType.indexOf(ChartConstants.AREA) > -1) {
                    renderProp.type = ChartConstants.AREA;
                } else if (renderType.indexOf(ChartConstants.RADAR) > -1) {
                    renderProp.type = ChartConstants.RADAR;
                }
            }
            var options = PlotHelper.getOptions(renderType);
            if (!options) {
                return null;
            }
            if (options.isHorizontal !== undefined) {
                renderProp.isVerticalRender = !options.isHorizontal;
            }
            return renderProp;
        }
    };

    return chartTypes;
});

define('sap/viz/chart/components/accessibility/ChartComponentNavigator',[
    "sap/viz/framework/common/util/ObjectUtils"
], function(ObjectUtils) {

    function ChartComponentNavigator(options) {
        this._isVerticalRender = options.isVerticalRender;
        this._renderType = options.renderType;
        this._navigatorType = options.navigatorType;
        this._constants = {
            "UP" : "up",
            "DOWN" : "down",
            "LEFT" : "left",
            "RIGHT" : "right"
        };
        ObjectUtils.extendByRepalceArray(true, this._constants, options.chartConstants);
    }

    var prot = ChartComponentNavigator.prototype;

    prot.init = function() {
    };

    prot.destroy = function() {
        this._renderType = null;
        this._isVerticalRender = null;
        this._constants = null;
        this._navigatorType = null;
    };

    prot.left = function(id) {
        return null;
    };

    prot.right = function(id) {
        return null;
    };

    prot.up = function(id) {
        return null; 
    };

    prot.down = function(id) {
        return null; 
    };

    prot.getFirstStartPoint = function() {
        return null;
    };

    return ChartComponentNavigator;
});

define('sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory',[
    "sap/viz/chart/components/util/ChartTypeUtils",
    "sap/viz/chart/components/util/ChartConstants",
    "sap/viz/chart/components/accessibility/ChartComponentNavigator"
], function(
    ChartTypeUtils,
    ChartConstants,
    ChartComponentNavigator
   
    ) {

    var factory = {};

    factory.createNavigator = function(options, navigatorType) {
        var renderType = options.renderType;
        var renderProp = ChartTypeUtils.getChartTypeProperty(renderType);
        if (!renderProp) {
            return null;
        }
        options.renderType = renderProp.type;
        if (renderProp.isVerticalRender !== undefined) {
            options.isVerticalRender = renderProp.isVerticalRender;
        }
        options.chartConstants = ChartConstants;
        options.isDual = renderType.indexOf("dual") > -1;
        options.isPercentage = renderType.indexOf("100") > -1;
        options.isTimeColumn = /timeseries_column/.test(renderType);
        options.isTimeWaterfall = /timeseries_waterfall/.test(renderType);
        options.isTimeBullet = /timeseries_bullet/.test(renderType);
        options.navigatorType = navigatorType;

        var navigatorClass = this.get(navigatorType, renderProp.type) || ChartComponentNavigator;

        return new navigatorClass(options);
    };
    var mapping = {};
    factory.get = function(navigatorType, renderType){
        if(navigatorType === ChartConstants.DATAPOINT_NAVIGATOR){
            return mapping[renderType];
        }else{
            return mapping[navigatorType];
        }
    };
    factory.register = function(navigatorType, renderType, className){
        if(navigatorType === ChartConstants.DATAPOINT_NAVIGATOR){
            mapping[renderType] = className;
        }else{
            mapping[navigatorType] = className;
        }
    };

    return factory;
});

define('sap/viz/chart/components/accessibility/ColorLegendNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/ChartComponentNavigator"
], function(oo, ChartComponentNavigator) {

    function ColorLegendNavigator(options) {
        ColorLegendNavigator.superclass.constructor.apply(this, arguments);
        this._legendLabels = this.buildLegendLabels(options.cells);
        this._cells = options.cells;
        this._horizontalSingle = this._cells.length == 1? true: false;
    }

    oo.extend(ColorLegendNavigator, ChartComponentNavigator);
    
    var prot = ColorLegendNavigator.prototype;

    prot.buildLegendLabels = function(cells) {
        var legendLabels = [];
        this._verticalSingle = true;
        for (var i = 0; i < cells.length; ++i) {
            if (cells[i].length > 1) {
                this._verticalSingle = false;
            }
            for (var j = 0; j < cells[i].length; ++j) {
                var id = cells[i][j].id;
                var index = {row : i, col : j};
                legendLabels[id] = index;
            }
        }
        return legendLabels;
    };

    prot.destroy = function() {
        ColorLegendNavigator.superclass.destroy.apply(this, arguments);
        this._cells = null;
        this._legendLabels = null;
    };

    prot.up = function(id) {
        if (this._horizontalSingle) {
            return this.getSiblingCell(id, -1);
        } else {
            return this.getNextRowCell(id, -1);
        }
    };

    prot.down = function(id) {
        if (this._horizontalSingle) {
            return this.getSiblingCell(id, 1);
        } else {
            return this.getNextRowCell(id, 1);
        }
    };
    
    prot.left = function(id) {
        if (this._verticalSingle) {
            return this.getNextRowCell(id, -1);
        } else {
            return this.getSiblingCell(id, -1);
        }
    };
    
    prot.right = function(id) {
        if (this._verticalSingle) {
            return this.getNextRowCell(id, 1);
        } else {
            return this.getSiblingCell(id, 1);
        }
    };

    prot.getCell = function(id){
        var index = this._legendLabels[id];
        return this._cells[index.row][index.col] || null;
    };

    prot.getSiblingCell = function(id, direction) {
        var index = this._legendLabels[id];
        var siblingCell = this._cells[index.row][index.col + direction];
        return siblingCell ? siblingCell : null;
    };

    prot.getNextRowCell = function(id, direction) {
        var index = this._legendLabels[id];
        var nextRow = this._cells[index.row + direction];
        if (!nextRow){
            return null;
        }
        return nextRow[index.col] != null ? nextRow[index.col] : nextRow[nextRow.length - 1];
    };

    prot.getFirstStartPoint = function() {
        return this._cells[0][0];
    };

    prot.isLastCellID = function(id) {
        if (this._cells) {
            var len = this._cells.length;
            var lastColLen = this._cells[len -1].length;
            return id === this._cells[len - 1][lastColLen - 1].id;
        } else {
            return false;
        }
    };

    return ColorLegendNavigator;
});

define('sap/viz/chart/scales/BaseScale',[],
    function() {

        var BaseScale = function(domain, range) {
            this.__className = "sap.viz.scale.BaseScale";
            this._scale = undefined;
            this._type = null;
            this._domain = domain;
            this._range = range;
            this._metaData = null;
            this._isReset = false;
            this._option = null;
        };

        BaseScale.prototype.scale = function(value) {

        };

        BaseScale.prototype.getDomain = function() {
            return this._domain;
        };

        BaseScale.prototype.setDomain = function(domain) {
            this._domain = domain;
            this._isReset = true;
            return this;
        };

        BaseScale.prototype.getRange = function() {
            return this._range;
        };

        BaseScale.prototype.setRange = function(range) {
            this._range = range;
            this._isReset = true;
            return this;
        };

        BaseScale.prototype.getOption = function() {
            return this._option;
        };

        BaseScale.prototype.setOption = function(option) {
            this._option = option;
            return this;
        };

        BaseScale.prototype.getMetaData = function() {
            return this._metaData;
        };

        BaseScale.prototype.normalizeValue = function(v) {
            return v;
        };

        BaseScale.prototype.destroy = function() {
            this._domain = null;
            this._range = null;
            var scale = this._scale;
            if (scale) {
                if (scale.domain) {
                    scale.domain([]);
                }
                if (scale.range) {
                    scale.range([]);
                }
            }
            this._scale = null;
            this._type = null;
            this._metaData = null;
            this.__className = null;
        };

        return BaseScale;
    });

define('sap/viz/chart/scales/ValueScale',['sap/viz/framework/common/util/oo',
        'sap/viz/chart/scales/BaseScale',
        "sap/viz/framework/common/util/NumberUtils"],
    function(oo,
    BaseScale,
    NumberUtils) {

        var ValueScale = function(domain, range, domainFixed, options) {
            ValueScale.superclass.constructor.apply(this, arguments);
            this.__className = "sap.viz.scale.ValueScale";
            this._tickHint = undefined;
            this._domainFixed = domainFixed ? domainFixed : [false, false];
            this._type = "linear";
            this._min = "auto";
            this._max = "auto";
            this._dataBound = options && options.dataBound;
            this._autoDomain = [];
            //Variable _domainChanged is true;
            //it means value scale domain is changed, we should use it as input domain.
            this._domainChanged = false;
            //Variable _zeroAdjusted is true;
            //it means we always use 0 as domain[0] value instead of original domain[0].
            this._zeroAdjusted = true;
            this.maximizedDomain = options && options.maximizedDomain;
            this._allowDecimals = options && options.hasOwnProperty("allowDecimals")? 
                                  options.allowDecimals : true;
            this._initScale();
        };

        oo.extend(ValueScale, BaseScale);

        ValueScale.prototype.scale = function(value) {
            this._ensureScaled();
            return this._scale(value);
        };

        ValueScale.prototype.nice = function() {
            this._ensureScaled();
            this._scale = this._scale.nice();
            this._domain = this._scale.domain();
            this._range = this._scale.range();
            return this;
        };

        ValueScale.prototype.ticks = function(number) {
            this._ensureScaled();
            var result = this._scale.ticks(number);
            if(!this.getAllowDecimals()){
                result = result.filter(function(num){return !NumberUtils.isFloat(num);});
            }
            return result;
        };

        ValueScale.prototype.getTickHint = function() {
            return this._tickHint;
        };

        ValueScale.prototype.setTickHint = function(number) {
            this._tickHint = number;
        };

        ValueScale.prototype.isFixed = function() {
            return this._domainFixed && (this._domainFixed[0] || this._domainFixed[1]);
        };
        
        ValueScale.prototype.getDataBound = function() {
            return this._dataBound;
        };
        
        ValueScale.prototype.getDomainFixed = function() {
            return this._domainFixed;
        };

        ValueScale.prototype.setDomainFixed = function(domainFixed) {
            this._domainFixed = domainFixed;
        };

        ValueScale.prototype.getDomainChanged = function() {
            return this._domainChanged;
        };

        ValueScale.prototype.setDomainChanged = function(domainChanged) {
            this._domainChanged = domainChanged;
        };

        ValueScale.prototype.getAllowDecimals = function() {
            return this._allowDecimals;
        };

        ValueScale.prototype.setAllowDecimals = function(allowDecimals) {
            this._allowDecimals = allowDecimals;
        };

        ValueScale.prototype.getZeroAdjusted = function() {
            return this._zeroAdjusted;
        };

        ValueScale.prototype.setZeroAdjusted = function(_zeroAdjusted) {
            this._zeroAdjusted = _zeroAdjusted;
        };

        ValueScale.prototype.total = function(value) {
            if (this._domain) {
                this._scale.domain([0, value]);
            }
        };
        
        ValueScale.prototype._ensureScaled = function() {
            if (this._scale === undefined || this._isReset === true) {
                this._initScale();
            }
        };

        ValueScale.prototype._initScale = function() {
            this._scale = d3.scale.linear();
            if (this._domain) {
                this._scale.domain(this._domain);
            }
            if (this._range) {
                this._scale.range(this._range);
            }
            this._isReset = false;
        };

        ValueScale.prototype.getAutoDomain = function() {
            return this._autoDomain;
        };

        ValueScale.prototype.setAutoDomain = function(domain) {
            this._autoDomain = domain;
            return this;
        };
        
        ValueScale.prototype.destroy = function() {
            // release all properties which hold dom instances
            ValueScale.superclass.destroy.call(this);
            
            this._domainFixed = null;
            this._autoDomain = null;
            
            this._min = null;
            this._max = null;
            this._isReset = null;
            this._tickHint = null;

            this._domainChanged = null;
            this._zeroAdjusted = null;
        }; 
        return ValueScale;
    });
define('sap/viz/chart/scales/ScalesFactory',[], function() {
    var registeredScales = [];
    var ScalesFactory = {};
    /*
     * Register scaleClass for special chart type and scale type. 
     * If you want to register scale for all chart type, please input chartType as null
     */
    ScalesFactory.register = function(chartType, scaleType,  scaleClass){
        registeredScales.push({chartType:chartType, scaleType:scaleType, scaleClass:scaleClass});
    };
    /*
     *  We match both chart type and scale type first.
     *  then match scale type only  
     */
    ScalesFactory.getScale = function(chartType, scaleType){
        var scale = null;
        for(var i = registeredScales.length - 1; i >= 0; --i){
            var item = registeredScales[i];

            if(item.chartType === chartType && item.scaleType === scaleType){
                scale = item.scaleClass;
                break;
            }
            if(!scale && !item.chartType && item.scaleType === scaleType){
                scale = item.scaleClass;
            }
        }
        return scale;
    };
   
    return ScalesFactory;
});
define('sap/viz/chart/scales/ScaleUtil',[
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/chart/scales/ScalesFactory",
    "sap/viz/framework/common/util/DataUtils",
    "sap/viz/framework/scale/ScaleUtil",
], function Setup(NumberUtils, TypeUtils, ObjectUtils, TimeUtil, ScalesFactory, DataUtils, ScaleUtils) {
        var MND_NAME = ["measureNamesDimension", "measureNames"];
        var hasNoNullValue = ScaleUtils.hasNoNullValue;
        function hasValue(dataModel, i){
            var bValue = false;
            if(!/timeseries/.test(dataModel._chartType)){
                var valueAxis = dataModel.valueAxis().values[i];
                var valueAxis2 = dataModel.valueAxis2().values[i];
                bValue = hasNoNullValue(valueAxis, valueAxis2) ;
            }else{
                var color = dataModel.color();
                var series = dataModel.getInitSeries();
                var cLen = color.rowArray.length;
                var sLen = series.length / cLen;

                for(var j = i * sLen; !bValue && j < (i + 1) * sLen; j++){
                    bValue = series[j].some(function(e){
                        return e.valueAxis != null;
                    });
                }
            }
            return bValue;
            
        }
        
        function hasShapeValue(dataModel, i){
            var bValue = false;
            var j;
            if(!/timeseries/.test(dataModel._chartType)){
                var valueAxis = dataModel.valueAxis().values;
                var valueAxis2 = dataModel.valueAxis2().values;
                if(dataModel.color().rowArray){
                    for(j = 0; !bValue && j < valueAxis.length; ++j){
                        bValue = hasNoNullValue(valueAxis[j][i], valueAxis2[j][i]);
                    }
                }else{
                    bValue = hasNoNullValue(valueAxis[i], valueAxis2[i]);
                }
            } else {
                var shape = dataModel.shape();
                var sLen = shape.rowArray.length;
                var series = dataModel.getInitSeries();
                for(j = i; !bValue && j < series.length; j += sLen){
                    bValue =  series[j].some(function(e){
                        return e.valueAxis != null;
                    });
                }
            }
            return bValue;
        }
        var Scaler = {
            generateUniqueDomain:function(array, depth, meta, rowArray, dataModel, ingoreNoValue, type) {
                array = array.filter(function(lst, i) {
                    return !meta[i].hidden;
                });
                depth = Math.min(depth, meta.filter(function(n) {
                    return !n.hidden;
                }).length);
                if (array.length === 0) {
                    return [];
                }

                var returnArray = [];
                var itemNum = array[0].length;
                var i, j;
                var temp = {};
                for (i = 0; i < itemNum; ++i) {
                    if(ingoreNoValue && (type === "color" ? !hasValue(dataModel, i) : !hasShapeValue(dataModel, i))){
                        continue;
                    }
                    var values = [];

                    for (j = 0; j < depth; ++j) {
                        values.push(array[j][i]);
                    }

                    var key = DataUtils.valuesToString(values);
                    if (temp.hasOwnProperty(key)) {
                        temp[key].oriIndex.push(i);
                        continue;
                    }
                    values.oriIndex = [i];
                    temp[key] = values;
                    returnArray.push(values);

                }

                return returnArray;
            },

            getRoughTickNum: function(_scale) {
                var const_minTickNum = 1;
                var roughTickNum = -1;

                var rangeArray = _scale.getRange();
                var rangeLen = Math.abs(rangeArray[0] - rangeArray[rangeArray.length - 1]);
                if (rangeLen > 10) {
                    roughTickNum = const_minTickNum + Math.round(rangeLen / 100);
                } else {
                    roughTickNum = const_minTickNum;
                }


                if(!_scale.getAllowDecimals()){
                    var ticks = _scale.ticks(roughTickNum);
                    var MIN_TICK = 2;
                    var interval = ticks[1] - ticks[0];

                    if(NumberUtils.isFloat(interval)){
                        //Assumption: when interval is float, it is smaller than 1
                        roughTickNum = Math.floor(ticks.length * interval);

                        if(roughTickNum < MIN_TICK){
                            roughTickNum = Math.ceil(_scale._domain[1] - _scale._domain[0]);
                            roughTickNum = Math.max(roughTickNum, MIN_TICK);
                        }
                    }
                }

                _scale.setTickHint(roughTickNum);
                return roughTickNum;
            },

            nice: function(_scale, tickNum) {
                if (!_scale.isFixed()) {
                    return this.perfect(_scale, tickNum);
                } else {
                    var domainFixed = _scale.getDomainFixed();
                    if (!(domainFixed[0] && domainFixed[1])) {
                        var domain = _scale.getDomain();
                        var range = _scale.getRange();
                        var scaleClass = ScalesFactory.getScale(null, "value");
                        var helpScale = new scaleClass(domain, range, domainFixed);
                        this.perfect(helpScale);
                        var refDomain = helpScale.getDomain();
                        if (domainFixed[0]) {
                            _scale.setDomain([domain[0], refDomain[1]]);
                        } else { //if(domainFixed[1])
                            _scale.setDomain([refDomain[0], domain[1]]);
                        }
                    }
                    return this.getRoughTickNum(_scale);
                }
            },

            /**
             * @param _scale
             *    d3 quantitative scale
             *
             * @param _roughTickNum
             *    rough tick number
             *
             * @param _accurateTickNum
             *    accurate tick number
             *
             * @returns d3 quantitative scale which can be divided by ticks perfectly
             */
            perfect: function(_scale, tickNum) {
                var qScale = _scale.nice();

                //the function may change the domain, but never change the range.
                var const_minTickNum = 1;
                var const_extendNum = 100;

                var domainArray = _scale.getDomain(),
                    domainArrayLength = domainArray.length;
                domainArray = NumberUtils.preciseObject(domainArray);

                var originalDomainBegin = domainArray[0];
                var originalDomainEnd = domainArray[1];

                //if the domain is [0,0], we change it to [0,100]
                //if the domain is [-x,-x], we change it to [-x,0]
                //if the domain is [x,x], we change it to [0,x]
                //we do this in modules
                var roughTickNum = (tickNum || this.getRoughTickNum(_scale));
                var ticks = qScale.ticks(roughTickNum);
                ticks = NumberUtils.preciseObject(ticks);

                var adjustDomain = true;
                var distance;
                if (ticks.length === 0) {
                    adjustDomain = false;
                } else if (ticks.length > 1) {
                    distance = ticks[1] - ticks[0]; //>0
                } else { //ticks.length==1
                    var beginDis = Math.abs(domainArray[0] - ticks[0]); //>0
                    var endDis = Math.abs(domainArray[domainArrayLength - 1] - ticks[0]); //>0
                    if (beginDis > endDis) {
                        distance = beginDis;
                    } else {
                        distance = endDis;
                    }
                }

                var realTickNum = const_minTickNum;
                var ticksLength = ticks.length;
                if (adjustDomain) {
                    realTickNum = ticksLength;
                    var start, end;
                    if (domainArray[0] < domainArray[1]) {
                        start = 0;
                        end = domainArrayLength - 1;
                    } else {
                        start = domainArrayLength - 1;
                        end = 0;
                    }
                    if (ticks[0] !== domainArray[start]) {
                        domainArray[start] = ticks[0] - distance;
                        realTickNum++;
                    }
                    if (ticks[ticksLength - 1] !== domainArray[end]) {
                        domainArray[end] = ticks[ticksLength - 1] + distance;
                        realTickNum++;
                    }
                }

                qScale.tickNum = realTickNum;
                qScale.distance = distance;
                qScale.setTickHint(realTickNum - 1);
                var oDomainArray = NumberUtils.preciseObject(domainArray);
                qScale.setDomain(oDomainArray);
                qScale.setAutoDomain(oDomainArray);
                return realTickNum - 1;
            },

            /**
             * @param _scaleA
             *    d3 linear scale
             *
             * @param _scaleB
             *    d3 linear scale
             */
            sync: function(_scaleA, _scaleB) {

                var domainArrayA = _scaleA.getDomain();
                var domainArrayB = _scaleB.getDomain();

                if ((domainArrayA[0] > domainArrayA[1] && domainArrayB[0] < domainArrayB[1]) ||
                    (domainArrayA[0] < domainArrayA[1] && domainArrayB[0] > domainArrayB[1]) ||
                    (domainArrayA[0] < 0 && domainArrayA[1] < 0) ||
                    (domainArrayB[0] < 0 && domainArrayB[1] < 0) ||
                    (domainArrayA[0] > 0 && domainArrayA[1] > 0) ||
                    (domainArrayB[0] > 0 && domainArrayB[1] > 0)
                ) {
                    //we do not need to do anythings to support this "dual"
                    return;
                }

                //now make sure 
                //1. same tickNum before 0
                //2. same tickNum after 0
                var positiveTickNumA = 0;
                var negativeTickNumA = 0;

                var positiveTickNumB = 0;
                var negativeTickNumB = 0;

                var tickNumA = _scaleA.tickNum; //tickNumA >= const_minTickNum
                var tickNumB = _scaleB.tickNum; //tickNumB >= const_minTickNum

                var intervalA = (domainArrayA[1] - domainArrayA[0]) / (tickNumA - 1);
                intervalA = NumberUtils.preciseSimple(intervalA);
                var i, tickValue, moreInterNum;
                for (i = 0; i < tickNumA; i++) {
                    tickValue = NumberUtils.preciseSimple(domainArrayA[0] + i * intervalA);
                    if (tickValue > 0) {
                        positiveTickNumA++;
                    } else if (tickValue < 0) {
                        negativeTickNumA++;
                    }
                }

                var intervalB = (domainArrayB[1] - domainArrayB[0]) / (tickNumB - 1);
                intervalB = NumberUtils.preciseSimple(intervalB);

                for (i = 0; i < tickNumB; i++) {
                    tickValue = NumberUtils.preciseSimple(domainArrayB[0] + i * intervalB);
                    if (tickValue > 0) {
                        positiveTickNumB++;
                    } else if (tickValue < 0) {
                        negativeTickNumB++;
                    }
                }

                if (positiveTickNumA > positiveTickNumB) {
                    moreInterNum = positiveTickNumA - positiveTickNumB;
                    if (domainArrayB[0] < domainArrayB[1]) {
                        domainArrayB[1] += (moreInterNum * Math.abs(intervalB));
                        _scaleB.tickNum += moreInterNum;
                    } else if (domainArrayB[0] > domainArrayB[1]) {
                        domainArrayB[0] += (moreInterNum * Math.abs(intervalB));
                        _scaleB.tickNum += moreInterNum;
                    }
                } else if (positiveTickNumA < positiveTickNumB) {
                    moreInterNum = positiveTickNumB - positiveTickNumA;
                    if (domainArrayA[0] < domainArrayA[1]) {
                        domainArrayA[1] += (moreInterNum * Math.abs(intervalA));
                        _scaleA.tickNum += moreInterNum;
                    } else if (domainArrayA[0] > domainArrayA[1]) {
                        domainArrayA[0] += (moreInterNum * Math.abs(intervalA));
                        _scaleA.tickNum += moreInterNum;
                    }
                }

                //negative values
                if (negativeTickNumA > negativeTickNumB) {
                    moreInterNum = negativeTickNumA - negativeTickNumB;
                    if (domainArrayB[0] < domainArrayB[1]) {
                        domainArrayB[0] -= (moreInterNum * Math.abs(intervalB));
                        _scaleB.tickNum += moreInterNum;
                    } else if (domainArrayB[0] > domainArrayB[1]) {
                        domainArrayB[1] -= (moreInterNum * Math.abs(intervalB));
                        _scaleB.tickNum += moreInterNum;
                    }
                } else if (negativeTickNumA < negativeTickNumB) {
                    moreInterNum = negativeTickNumB - negativeTickNumA;
                    if (domainArrayA[0] < domainArrayA[1]) {
                        domainArrayA[0] -= (moreInterNum * Math.abs(intervalA));
                        _scaleA.tickNum += moreInterNum;
                    } else if (domainArrayA[0] > domainArrayA[1]) {
                        domainArrayA[1] -= (moreInterNum * Math.abs(intervalA));
                        _scaleA.tickNum += moreInterNum;
                    }
                }

                //to nice the domainArray, avoid the domain contains 0.00060000001
                domainArrayA[0] = NumberUtils.preciseSimple(domainArrayA[0]);
                domainArrayA[1] = NumberUtils.preciseSimple(domainArrayA[1]);
                domainArrayB[0] = NumberUtils.preciseSimple(domainArrayB[0]);
                domainArrayB[1] = NumberUtils.preciseSimple(domainArrayB[1]);

                _scaleA.setDomain(domainArrayA);
                _scaleB.setDomain(domainArrayB);

                _scaleA.setTickHint(_scaleA.tickNum - 1);
                _scaleB.setTickHint(_scaleB.tickNum - 1);
            },
            
            domainArrayCompare: function(lDomainArray, rDomainArray){
                function getDomainValue(domain){
                    var e = null;
                    if (typeof(domain) === 'string' || !domain) {
                        e = domain;
                    } else if (typeof(domain) === 'object' && (domain.d || domain.v)) {
                        e = domain.v || domain.d;
                    }
                    return e;
                }

                function getDomainIndex(array, element) {
                    var e = getDomainValue(element);
                    for (var i = 0; i < array.length; i++) {
                        var a = getDomainValue(array[i]);
                        if (e === a) {
                            return i;
                        }
                    }
                    return -1;
                }

                //Handle null and undefined
                if (lDomainArray === rDomainArray){
                    return true;
                }
                if (!lDomainArray || !rDomainArray){
                    return false;
                }

                if (lDomainArray.length !== rDomainArray.length){
                    return false;
                }

                var rCopy = rDomainArray.slice(0);

                for (var i = 0; i < lDomainArray.length; i++) {
                    var index = getDomainIndex(rCopy, lDomainArray[i]);
                    if (index === -1) {
                        return false;
                    } else {
                        rCopy.splice(index, 1);
                    }
                }
                return true;
            },



            findScaleResult: function(scale, targetDataContext, compareFunc){
                if (!scale){
                    return null;
                }
                compareFunc = compareFunc || Scaler.domainArrayCompare;

                var results = scale.results;
                var result, i;
                for (i = 0; i < results.length; i++){
                    result = results[i];
                    if (compareFunc(result.dataContext, targetDataContext)){
                        return result;
                    }
                }
                return null;
            },

            shrinkedDomainFromColumns: function(domain, columns){
                var retDomain = [];
                domain = domain || [];
                columns = columns || [];

                for (var iRow = 0; iRow < domain.length; iRow++){
                    var rowDomain = [];
                    for (var iColumnIndex = 0; iColumnIndex < columns.length; iColumnIndex++){
                        var iColumn = columns[iColumnIndex];
                        if (iColumn >= domain[iRow].length){
                            break;
                        }
                        rowDomain.push(domain[iRow][iColumn]);
                    }
                    if (rowDomain.length > 0){
                        retDomain.push(rowDomain);
                    }
                }
                return retDomain;
            },

            shrinkedDomain: function(domain, metaData){
                function checkSingleValues(meta){
                    var values = meta.values;
                    if (values.length > 1){
                        var firstValue = values[0];
                        for (var i = 1; i < values.length; i++){
                            if (firstValue !== values[i]){
                                return false;
                            }
                        }
                    }
                    return true;
                }

                var columns = [];
                if ( !TypeUtils.isExist(metaData) || metaData.length <= 1){
                    return domain;
                }
                for (var iMetaDataIndex = 0; iMetaDataIndex < metaData.length; iMetaDataIndex++){
                    var meta = metaData[iMetaDataIndex];
                    
                    if (MND_NAME.indexOf(meta.id) === -1 || !checkSingleValues(meta)){
                        columns.push(iMetaDataIndex);
                    }
                }
                return Scaler.shrinkedDomainFromColumns(domain, columns);
            },
          
        };

        return Scaler;
    });

define('sap/viz/chart/scales/ScaleConstant',[],function () {
    /**
     * Scale type.
     * @class sap.viz.scale.ScaleConstant
     */
    var ScaleConstant = {};

    // Mekko value scale type
    /**
     * @memberof sap.viz.scale.ScaleConstant
     * @member TYPE_VALUE_SCALE_MEKKO
     * @static
     */
    ScaleConstant.TYPE_VALUE_SCALE_MEKKO = "mekko";

    ScaleConstant.PATTERN_DEFAULT_VALUE = {
        "AC": {
            "color": "#323232"
        },
        "FC": {
            "color": "#3F3F3F",
            "pattern": "hatching",
            "stroke": "#ffffff",
            "strokeWidth": "1px"
        },
        "PY": {
            "color": "#969696"
        },
        "PL": {
            "color": "#ffffff",
            "pattern":"nonFill",
            "stroke": "#323232",
            "strokeWidth": "1px"
        }
    };


    ScaleConstant.DEFAULTPATTERN = "pattern";
    ScaleConstant.DEFAULTPATTERN2 = "pattern2";

    ScaleConstant.PATTERN_DEFAULT_VALUE[ScaleConstant.DEFAULTPATTERN] = {
        "color": "black",
        "pattern": "solid",
        "stroke": "rgb(187, 189, 191)",
        "strokeWidth": "1px"
    };

    ScaleConstant.PATTERN_DEFAULT_VALUE[ScaleConstant.DEFAULTPATTERN2] = {
        "color": "rgb(50, 50, 50)",
        "pattern": "nonFill",
        "stroke": "rgb(128, 128, 128)",
        "strokeWidth": "1px"
    };
    return ScaleConstant;
});
define('sap/viz/chart/scales/ValueScaleUtil',["sap/viz/framework/common/util/NumberUtils",
        "sap/viz/chart/scales/ScaleUtil",
        "sap/viz/chart/scales/ScaleConstant",
        "sap/viz/framework/common/util/TypeUtils",
        "sap/viz/chart/scales/ScalesFactory"
    ],
    function(NumberUtils,
            ScaleUtil,
            ScaleConstant,
            TypeUtils,
            ScalesFactory) {
        var ROLE_LAYOUT = 'layout';
        var DEFAULT_TICK_NUM = 7;
        
        var LABEL_OFFSET_V = 3; // vertical
        var LABEL_OFFSET_H = 6; // horizontal

        var ret = {};

        // opitons should the exising value scale instance.
        ret.getStackedArrayValues = function(data, range) {
            if (TypeUtils.isArray(data)) {
                var tmpRange = [0, 0];
                for (var i in data) {
                    if (data.hasOwnProperty(i)) {
                        ret.getStackedArrayValues(data[i], tmpRange);
                    }
                }
                if (tmpRange[0] < range[0]) {
                    range[0] = tmpRange[0];
                }
                if (tmpRange[1] > range[1]) {
                    range[1] = tmpRange[1];
                }
            } else {
                if (+data < 0) {
                    range[0] += +data;
                } else {
                    range[1] += +data;
                }
            }
        };
        ret.prepareValueScaleData = function(data, role, rangeIndex) {
            if (role === ROLE_LAYOUT) {
                var range = [];
                var getSum = function(data, index, range) {
                    if (data.values.hasOwnProperty(index)) {
                        range[index] = [];
                        range[index][0] = 0;
                        range[index][1] = 0;
                        ret.getStackedArrayValues(data.values[index], range[index]);
                    }                
                };
                if (rangeIndex && rangeIndex.length > 0) {
                    for (var j =0; j < rangeIndex.length; j++) {
                        getSum(data, rangeIndex[j], range);
                    }
                } else {
                    for (var i in data.values) {
                        if (data.values.hasOwnProperty(i)) {
                            getSum(data, i, range);
                        }
                    }               
                }
                data.range = range;
            }
        };
        ret.getTicksPosition = function(ticks, scale) {
            var ticksPosition = [];
            for (var i = 0, length = ticks.length; i < length; ++i) {
                ticksPosition.push(scale.scale(ticks[i]));
            }
            return ticksPosition;
        };

        ret.getTicks = function(_scale) {

            /* Function definition start */

            function getFullTicks(domain, ticks) {
                ticks = ticks.map(function(e) {
                    return NumberUtils.precise(e);
                });
                var beginTick;
                var endTick;
                var domainLength = domain.length;
                if (domain[0] <= domain[domainLength - 1]) {
                    beginTick = domain[0];
                    endTick = domain[domainLength - 1];
                } else {
                    beginTick = domain[domainLength - 1];
                    endTick = domain[0];
                }
                if (ticks.length > 0) {
                    if (ticks[0] !== beginTick) {
                        ticks.unshift(beginTick);
                    }
                    if (ticks[ticks.length - 1] !== endTick) {
                        ticks.push(endTick);
                    }
                }
                return ticks;
            }

            /* Function definition over */

            var tickNum = _scale.getTickHint() || DEFAULT_TICK_NUM;
            var ticks = _scale.ticks(tickNum);
            var fullTicks = getFullTicks(_scale.getDomain(), ticks);
            return NumberUtils.preciseObject(fullTicks);
        };

        ret.perfectTicks = function(scale, tickNum) {
            return ScaleUtil.nice(scale, tickNum);
        };

        ret.perfectTimeTicks = function(scale) {
            var domain = scale.getDomain();
            var hour = 1000 * 60 * 60;
            var day = hour * 24;
            var month = day * 30;
            var year = month * 12;
            if (NumberUtils.isNoValue(domain[0])) {
                domain[0] = 0;
            }
            if (NumberUtils.isNoValue(domain[1])) {
                domain[1] = domain[0] + 1;
            }
            var gap = domain[1] - domain[0];

            var startDate = new Date(domain[0]);
            var endDate = new Date(domain[1]);

            startDate.setMinutes(0);
            startDate.setSeconds(0);
            startDate.setMilliseconds(0);

            endDate.setMinutes(0);
            endDate.setSeconds(0);
            endDate.setMilliseconds(0);

            var timeUnit;
            if (gap < 3 * day) {
                endDate.setHours(endDate.getHours() + 1);
                timeUnit = {
                    get: Date.prototype.getHours,
                    set: Date.prototype.setHours,
                    format: "dd/mm/yyyy hh:mm"
                };
                gap = (endDate.getTime() - startDate.getTime()) / hour;
            } else if (gap < 3 * month) {
                startDate.setHours(0);
                endDate.setHours(0);
                endDate.setDate(endDate.getDate() + 1);
                timeUnit = {
                    get: Date.prototype.getDate,
                    set: Date.prototype.setDate,
                    format: "dd/mm/yyyy"
                };
                gap = (endDate.getTime() - startDate.getTime()) / day;
            } else if (gap < 3 * year) {
                startDate.setHours(0);
                startDate.setDate(1);
                endDate.setHours(0);
                endDate.setDate(1);
                endDate.setMonth(endDate.getMonth() + 1);
                timeUnit = {
                    get: Date.prototype.getMonth,
                    set: Date.prototype.setMonth,
                    format: "mm/yyyy"
                };
                gap = (endDate.getFullYear() - startDate.getFullYear()) * 12 + endDate.getMonth() -
                    startDate.getMonth();
            } else { // gap > 3 * year
                startDate.setHours(0);
                startDate.setDate(1);
                startDate.setMonth(0);
                endDate.setHours(0);
                endDate.setDate(1);
                endDate.setMonth(0);
                endDate.setFullYear(endDate.getFullYear() + 1);
                timeUnit = {
                    get: Date.prototype.getFullYear,
                    set: Date.prototype.setFullYear,
                    format: "yyyy"
                };
                gap = endDate.getFullYear() - startDate.getFullYear();
            }

            var tickNum = ScaleUtil.getRoughTickNum(scale);
            var i;
            var j = 1;
            if(tickNum > 2) {
                tickNum = NumberUtils.preciseSimple(tickNum);
                gap = NumberUtils.preciseSimple(gap);
                for (i = 0; i < tickNum - 1; i++) {
                    var isPerfect = false;
                    for (j = tickNum - 1; j > 1; j--) {
                        if ((gap + i) % j === 0) {
                            //get perfect tick number result
                            isPerfect = true;
                            break;
                        }
                    }
                    if(isPerfect) {
                        break;
                    }
                }
            }

            if (tickNum > 2) {
                scale.tickNum = j + 1;
                scale.timeUnitGap = (gap + i) / j; 
            } else {
                scale.tickNum = tickNum;
                scale.timeUnitGap = gap;
            }

            timeUnit.set.apply(endDate, [timeUnit.get.apply(endDate, []) + i]);

            var domainFixed = scale.getDomainFixed();
            if (!domainFixed[0] && !domainFixed[1]) {
                scale.setDomain([startDate.getTime(), endDate.getTime()]);
            } else if (!domainFixed[0]) {
                scale.setDomain([startDate.getTime(), domain[1]]);
            } else if (!domainFixed[1]) {
                scale.setDomain([domain[0], endDate.getTime()]);
            }

            scale.timeUnit = timeUnit;
        };

        ret.syncTicks = function(scaleA, scaleB) {
            if (!scaleA.isFixed() && !scaleB.isFixed()) {
                ScaleUtil.sync(scaleA, scaleB);
            }
        };

        ret.correctNoValueDomain = function(domain) {
            var result = domain.slice();
            result[0] = NumberUtils.isNoValue(result[0]) ? 0 : domain[0];
            result[1] = NumberUtils.isNoValue(result[1]) ? domain[0] + 1 : domain[1];
            return result;
        };
        
        ret.extendDomainForDataLabel = function(domain, range, textSizes, isHorizontal) {
            
            var result = domain.slice(), minValue, maxValue, r,  textHeight;
            //for hichert, we treat 4 letter width in horizontal case.
            if(result[0] > 0){
                result[0] = 0;
            } else if(result[1] < 0){
                result[1] = 0;
            }
            textHeight = isHorizontal ? [textSizes[0] ? textSizes[0].width : 0  , textSizes[1] ?
                    textSizes[1].width : 0] :
                [textSizes[0] ? textSizes[0].height : 0, textSizes[1] ? textSizes[1].height : 0];
            
            if(result[1]> 0 && result[0] < 0 ){
                if(textHeight[0] + textHeight[1] >= range[1] / 2 ){
                    result[1] = domain[1] + (domain[1] - domain[0]) / ( 1 + textHeight[0] / textHeight[1]);
                    result[0] = result[1] - 2 * (domain[1] - domain[0]);
                    
                }else{
                    var oDomain = [result[0], result[1]];
                    result[0] = (textHeight[0] * oDomain[1] - range[1] * oDomain[0] + textHeight[1] * oDomain[0])/
                    (textHeight[0] + textHeight[1] - range[1]);
                    result[1] = (range[1] * oDomain[1] - textHeight[1] * result[0] ) / ( range[1] - textHeight[1]);
                }
                
            }else if(result[1] > 0){
                if(textHeight[1] >= range[1] / 2 ){
                    result[1] = result[1] * 2;
                }else{
                    result[1] = (textHeight[1] * result[1]) / (range[1] - textHeight[1]) + result[1];
                }
            }else if(result[0] < 0){
            
                if(textHeight[0] > range[1] / 2){
                    result[0] = result[0] * 2;
                }else{
                    result[0]= (textHeight[0] * result[0]) / (range[1] - textHeight[0]) + result[0];
                }
            }
 
            //[Chrsity 2015-10-12] It's not correct to Math.round for upper scale value.
            //After confirmed with Jay, 0.5 is for a bug fix, no special reason.  
            // result[0] = Math.abs(result[0]) < 0.5 ? result[0] : Math.round(result[0]);
            // result[1] = result[1] < 0.5 ? result[1] : Math.round(result[1]);
            return result;
        };
        
        ret.generateValueScale = function(data, scaleOption) {
            var minSetting = null;
            var maxSetting = null;

            if (scaleOption){
                minSetting = +scaleOption.min;
                if (isNaN(minSetting)){
                    minSetting = null;
                }
                maxSetting = +scaleOption.max;
                if (isNaN(maxSetting)){
                    maxSetting = null;
                }
            }

            var minFixed = minSetting != null;
            var maxFixed = maxSetting != null;

            var minMax = scaleOption.minMax || {};
            if (minMax.min === undefined) {
                minMax.min = 0;
            }
            if (minMax.max === undefined) {
                minMax.max = 0;
            }
            var minValue = minFixed ? parseFloat(minSetting) : minMax.min;
            var maxValue = maxFixed ? parseFloat(maxSetting) : minMax.max;
            if (minValue >= maxValue) {
                if (minFixed === true) {
                    minFixed = false;
                    maxFixed = false;
                    minValue = minMax.min;
                    maxValue = minMax.max;
                } else if (maxFixed === true) {
                    minFixed = false;
                    maxFixed = true;
                    minValue = minMax.min;
                }
            }

            if (!minFixed && !maxFixed) {
                if (maxValue === 0 && minValue === 0 && !(scaleOption && scaleOption.allowZeroMinMax === true)) {
                    maxValue = 1;
                }
            }
            if (TypeUtils.isExist(scaleOption) && TypeUtils.isExist(scaleOption.allowZeroMinMax)) {
                delete scaleOption.allowZeroMinMax;
            }
            //Don't give value axis a fixedRange if it's an empty dataset.
            // if (!TypeUtils.isArray(data.values) || data.values.length === 0) { //for axis tick calc
            //     minFixed = true;
            //     maxFixed = true;
            // }
            var scale = null;
            scaleOption = scaleOption || {};
            scaleOption.maximizedDomain = data.maximizedDomain;
            var scaleClass = ScalesFactory.getScale(scaleOption.type, "value");
            
            scale = new scaleClass([minValue, maxValue], [0, 1], [minFixed, maxFixed],  scaleOption);
          
            scale.setAutoDomain([minMax.min, minMax.max]);
            return scale;
        };

        return ret;
    });

define('sap/viz/chart/components/util/ValueAxisUtils',[
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/scales/ValueScaleUtil", 
    "sap/viz/chart/scales/ScaleConstant",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/scales/ScalesFactory"
], function(
    ArrayUtils,
    NumberUtils,
    ValueScale,
    ValueScaleUtil,
    ScaleConstant,
    TypeUtils,
    ScalesFactory
) {

    var defaultDomian = [0, 1];
    var createValueScaleWithOptions = function(domain, range, domainFixed, options, type){
        var scaleClass = ScalesFactory.getScale(type, "value");
        var valueScale = new scaleClass(domain, range, domainFixed,
                { maximizedDomain: options && options.maximizedDomain,
                 mekkoValue: options && options.getMekkoValue && options.getMekkoValue()});
        if (options && options.getDomainChanged) {
            valueScale.setDomainChanged(options.getDomainChanged());
        }
        if (options && options.getZeroAdjusted) {
            valueScale.setZeroAdjusted(options.getZeroAdjusted());
        }
        if (options && options.getAllowDecimals) {
            valueScale.setAllowDecimals(options.getAllowDecimals());
        }
        return valueScale;
    };

    function findMinMax(multiArray, minmax){
        if(multiArray._minmax){
            return multiArray._minmax;
        }
        minmax = minmax || [Infinity, -Infinity];
        for(var i = multiArray.length; i--;){
            var item = multiArray[i];
            if(item instanceof Array){
                minmax = findMinMax(item, minmax);
            }else if(item != null){
                if(item < minmax[0]){
                    minmax[0] = item;
                }
                if(item > minmax[1]){
                    minmax[1] = item;
                }
            }
        }
        return minmax;
    }

    function domainConfig(scale, values) {
        if (scale && values) {
            var domain = scale.getDomain().slice();
            if (!domain.length){
                domain = defaultDomian.slice();
            }
            var domainFixed = scale.getDomainFixed().slice();
            var min, max;
            if(!domainFixed[0] || !domainFixed[1]){
                var minmax = [];
                var cachedMinMax = findMinMax(values);
                if (scale.getDomainChanged()) {
                    minmax = domain;
                } else {
                    minmax = cachedMinMax;
                }
                values._minmax = cachedMinMax;
                min = minmax[0];
                max = minmax[1];
            }
            var minValue = domainFixed[0] ? parseFloat(domain[0]) : min;
            var maxValue = domainFixed[1] ? parseFloat(domain[1]) : max;
            if (min > max) {
                domainFixed = [false, false];
                minValue = min;
                maxValue = max;
            }

            return {
                domain: [minValue, maxValue],
                domainFixed: domainFixed
            };
        } else {
            return null;
        }
    }

    function padDomain(domainCfg, bScale, zeroAdjusted) {
        var domain = domainCfg.domain.slice(),
            domainFixed = domainCfg.domainFixed.slice();

        if (!domainFixed[0]) {
            if (domain[0] < 0) {
                domain[0] = domain[0] * (1 + bScale);
            } else if (zeroAdjusted) {
                domain[0] = 0;
            } else {
                domain[0] = domain[0] * (1 - bScale);
            }
        }
        if (!domainFixed[1]) {
            if (domain[1] < 0) {
                if (zeroAdjusted) {
                    domain[1] = 0;
                } else {
                    domain[1] *= (1 - bScale);
                }
            } else {
                domain[1] *= (1 + bScale);
            }
        }
        return {
            domain: ValueScaleUtil.correctNoValueDomain(domain),
            domainFixed: domainFixed
        };
    }

    function padTimeDomain(domainCfg, bScale) {
        var domain = domainCfg.domain.slice(),
            domainFixed = domainCfg.domainFixed.slice(),
            buffer = domain[0] === domain[1] ? 1 : Math.floor((domain[1] - domain[0]) * bScale);

        domain[0] -= domainFixed[0] ? 0 : buffer;
        domain[1] += domainFixed[1] ? 0 : buffer;

        return {
            domain: ValueScaleUtil.correctNoValueDomain(domain),
            domainFixed: domainFixed
        };
    }

    function isOverLapped(item1, item2) {
        return (item1.start >= item2.start && item1.start <= item2.end) ||
            (item1.end >= item2.start && item1.end <= item2.end) ||
            (item2.start >= item1.start && item2.start <= item1.end) ||
            (item2.end >= item1.start && item2.end <= item1.end);
    }

    function calculateLabelsToDrawHelper(allTicksLabels, keepZero) {
        //allTicksLabels:
        //[0, X]
        //[-X, 0]
        //[X1, X2] (X1>0, X2>0)
        //[X1, X2] (X1<0, X2<0)

        //now we should decide which label to draw.
        //iBeyond = 0:0,1,2,3,4,5,6,...
        //iBeyond = 1:0, ,2, ,4, ,6,...
        //iBeyond = 2:0, , ,3, , ,6,...
        //...
        //iBeyond = (allTicksLabels.length - 1):0
        var allTicksLength = allTicksLabels.length;
        var ticksLabelsToDraw = [];
        for (var iBeyond = 0; iBeyond <= (allTicksLength - 1); iBeyond++) {
            var isDrawable = true;
            for (var i = 0; i < allTicksLength - 1; i += (iBeyond + 1)) {
                var item = allTicksLabels[i];
                if (i !== 0) {
                    var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length - 1];
                    if (isOverLapped(item, previousItem)) {
                        if (keepZero && item.value === 0) {
                            ticksLabelsToDraw.push(item);
                            continue;
                        }
                        //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                        if (ticksLabelsToDraw.length > 1) {
                            isDrawable = false;
                            break;
                        }
                    } else {
                        ticksLabelsToDraw.push(item);
                    }
                } else {
                    //add the first axis tick label
                    ticksLabelsToDraw.push(item);
                }
            }
            //for [.....5,5.1], always draw the last axis tick label
            if (allTicksLabels.length && ticksLabelsToDraw.length) {
                var lastItem = allTicksLabels[allTicksLength - 1];
                var lastToDraw = ticksLabelsToDraw[ticksLabelsToDraw.length - 1];
                if (isOverLapped(lastItem, lastToDraw)) {
                    if (!(keepZero && lastToDraw.value === 0)) {
                        ticksLabelsToDraw.pop();
                    }
                }
                ticksLabelsToDraw.push(lastItem);
            }
            if (isDrawable) { //find the labels
                break;
            } else {
                ticksLabelsToDraw = [];
            }
        }
        return ticksLabelsToDraw;
    }

    function adjustDomain(domain, scale){
        if(0 === domain[0] && 0 === domain[1]) {
            domain[1] = 1;
        }
        if(!scale.getAllowDecimals()){
            domain[0] = Math.floor(domain[0]);
            domain[1] = Math.ceil(domain[1]);
        } 
    }
    
    var ValueAxisUtils = {
        isOverLapped: isOverLapped,
        calculateLabelsToDrawHelper: calculateLabelsToDrawHelper,
        
        calcScale: function(scale, range, options) {
            var domain = scale.getDomain().slice();
            var domainFixed = scale.getDomainFixed();
            var autoDomain = scale.getAutoDomain().slice();
            var isFixed = scale.isFixed();
            if (domain[0] > 0 && !(isFixed && domainFixed[0])) {
                if (scale.getZeroAdjusted() || domain[0] === domain[1]) {
                    domain[0] = 0;
                }
            }
            if (domain[1] < 0 && !(isFixed && domainFixed[1])) {
                if (scale.getZeroAdjusted() || domain[0] === domain[1]){
                    domain[1] = 0;
                }
            }
            if (autoDomain[0] > 0) {//autoDomain is used for auto scale props
                autoDomain[0] = 0;
            }
            if (autoDomain[1] < 0) {
                autoDomain[1] = 0;
            }
            if(options.domain){
                if(!(isFixed && domainFixed[0]) && options.domain[0] != null){
                    domain[0] = options.domain[0];
                }
                if(!(isFixed && domainFixed[1]) && options.domain[1] != null){
                    domain[1] = options.domain[1];
                }
            }
            if (options.isLineChart) {
                var offset = Math.abs((domain[1] - domain[0]) * 5 / (range[1] - range[0]));
                if (domain[0] !== 0 && !(isFixed && domainFixed[0])) {
                    domain[0] -= offset;
                }
                if (domain[1] !== 0 && !(isFixed && domainFixed[1])) {
                    domain[1] += offset;
                }
                // Auto domain only needs to be calculated once
                if(!options.keepAutoScale){
                    var autoOffset = Math.abs((autoDomain[1] - autoDomain[0]) * 5 / (range[1] - range[0]));
                    if (autoDomain[0] !== 0) {
                        autoDomain[0] -= autoOffset;
                    }
                    if (autoDomain[1] !== 0) {
                        autoDomain[1] += autoOffset;
                    }
                }
            }

            adjustDomain(domain, scale);
            adjustDomain(autoDomain, scale);

            var type = scale && scale.getType && scale.getType();
            
            var helpScale = createValueScaleWithOptions([domain[0], domain[1]], range, domainFixed, scale, type);
            var autoScale = createValueScaleWithOptions([autoDomain[0], autoDomain[1]], 
                    range, [false, false], scale, type);

            var tickHint = ValueScaleUtil.perfectTicks(helpScale);
            ValueScaleUtil.perfectTicks(autoScale);
            if(helpScale.isFixed()){
                helpScale.setAutoDomain(autoScale.getDomain());
            }
            return {
                scale: helpScale,
                tickHint: tickHint,
                autoScale : autoScale
            };
        },

        calcPercentageScale: function(range) {
            var helpScale = createValueScaleWithOptions([0, 1], range);
            var tickHint = ValueScaleUtil.perfectTicks(helpScale);
            return {
                scale: helpScale,
                tickHint: tickHint
            };
        },
        
        updateScatterValueAxis : function(data, range, sizeRatio, isTimeBased){
            var padFn = isTimeBased ? padTimeDomain : padDomain;
            var perfectFn = isTimeBased ? ValueScaleUtil.perfectTimeTicks : ValueScaleUtil.perfectTicks;
            var scale = data.scale;
            var domainCfg = padFn(domainConfig(scale, data.values), sizeRatio, scale.getZeroAdjusted());
            var domain = domainCfg.domain;
            adjustDomain(domain, scale);
           
            var helpScale = createValueScaleWithOptions(domain, range, domainCfg.domainFixed, scale),
            tickHint = perfectFn(helpScale);

            var autoDomain = scale.getAutoDomain();
           

            var autoScale = createValueScaleWithOptions([autoDomain[0], autoDomain[1]], range, [false, false], scale);
            autoDomain = padFn(domainConfig(autoScale, data.values), sizeRatio, scale.getZeroAdjusted()).domain;
            adjustDomain(autoDomain, scale);
            autoScale = createValueScaleWithOptions(autoDomain, range, [false, false], scale);
            perfectFn(autoScale);
            helpScale.setAutoDomain(autoScale.getDomain());
            return {
                scale: helpScale,
                tickHint: tickHint
            };
        },
        
        getTrellisBaseValueIndex : function(start, end) {
            if(start === 0) {
                return 0;
            } else if(end === 0) {
                return 1;
            } else if(start < 0 && end < 0) {
                return (start > end) ? 0 : 1;
            } else if(start > 0 && end > 0){
                return (start < end) ? 0 : 1;
            } else {
                return -1;
            }
        },
        
        visibleRangeTransform: function(domain, start, end) {
            if (!TypeUtils.isNumeric(start) || start < domain[0]) {
                start = domain[0];
            }
            if (!TypeUtils.isNumeric(end) || end > domain[1]) {
                end = domain[1];
            }
            if (start >= end) {
                return null;
            }
            if (start > domain[1] || end < domain[0]) {
                return null;
            }
            return {
                ratio: (domain[1] - domain[0]) / (end - start),
                delta: (domain[0] - start) / (domain[1] - domain[0])
            };
        },
        
        getTimeAxisDomain: function(oSize, transform, oRealSize, oDomain, isHorizontal, isFiscal) {
            var size, realSize, offset;
            if (isHorizontal) {
                size = oSize.height;
                realSize = oRealSize.height;
                offset = transform.y;
            } else {
                size = oSize.width;
                realSize = oRealSize.width;
                offset = transform.x;
            }
            offset = Math.abs(offset);
            var domain = [],
                distance = oDomain[1] - oDomain[0];

            if (isFiscal) {
                //for fiscal, we cannot use int, or the deviation is accumulated.
                domain[0] = oDomain[0] + (distance * offset / realSize);
                domain[1] = oDomain[0] + (distance * (offset + size) / realSize);
            }
            else {
                domain[0] = oDomain[0] + parseInt(distance * offset / realSize);
                domain[1] = oDomain[0] + parseInt(distance * (offset + size) / realSize);
            }

            return domain;
        }

    };

    return ValueAxisUtils;
});

define('sap/viz/chart/components/util/SeriesUtil',[
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/util/ChartConstants',
    'sap/viz/framework/chartmodel/ContextBuilder'
], function(
    TypeUtils,
    Constants,
    NameColorUtils,
    ChartConstants,
    ContextBuilder
) {


    var convertColor = NameColorUtils.convertColor;
    
    var LINE_TYPE = Constants.LINE_TYPE; 


  
    function addRectSeriesPathPoints(points, dataItem, isNegative, isHorizontal, offset) {
        var position = dataItem.position;
        var dx = offset ? offset.x : 0;
        var dy = offset ? offset.y : 0;
        var x1 = position.x + dx;
        var y1 = position.y + dy;
        var x2 = x1 + position.width;
        var y2 = y1 + position.height;
        if (isHorizontal) {
            if (isNegative) {
                x1 = x2;
                x2 -= position.width;
            }
            points.push([x1, y1]);
            points.push([x2, y1]);
            points.push([x2, y2]);
            points.push([x1, y2]);
        } else {
            if (isNegative) {
                y2 = y1;
                y1 += position.height;
            }
            points.push([x1, y2]);
            points.push([x1, y1]);
            points.push([x2, y1]);
            points.push([x2, y2]);
        }
    }

    function prepareBarSeriesConfig(config, isHorizontal){
        config.graphic = {
            color: config.color,
            width: 1,
            opacity: 1
        };
        delete config.color;
        config.isHorizontal = isHorizontal;
    }

    function parseSemanticColor(dpConfig, semanticMgr) {
        var color = dpConfig.graphic.fill;
        var context = dpConfig.rawData.dp.context();
        var addCtx = dpConfig.rawData.dp.additionCtx();
        var semanticResult = semanticMgr.analyzeDataPoint("color", context, false, addCtx );
        if (semanticResult && semanticResult.color) {
            color = convertColor(semanticResult.color);
        }
        return color;
    }

 

  

    function parseSemanticLineColor(context, semanticMgr, defaultColor, addCtx) {
        var color = defaultColor;
        var semanticResult = semanticMgr.analyzeDataPoint("lineColor", context, false, addCtx);
        if (semanticResult && semanticResult.lineColor) {
            color = convertColor(semanticResult.lineColor);
        }
        return color;
    }

    function parseSemanticLineType(context, semanticMgr, seriesStyle, addCtx) {
        var type = seriesStyle || "solid";
        var semanticResult = semanticMgr.analyzeDataPoint("lineType", context, false, addCtx);
        if (semanticResult && (
            semanticResult.lineType === LINE_TYPE.DOT ||
            semanticResult.lineType === LINE_TYPE.DASHED ||
            semanticResult.lineType === LINE_TYPE.DOTTED)  ) {
            type = semanticResult.lineType;
        }
        return type;
    }
   

    function getMaxSeriesLength (series) {
        var seriesMaxLength = 0;
        if (series) {
            series.forEach(function(e) {
                var len = 0;
                for (var i = 0; i < e.length; i++) {
                    if (e[i].valueAxis) {
                        len++;
                    }
                }
                seriesMaxLength = Math.max(seriesMaxLength, len);
            });            
        }
        return seriesMaxLength;
    }

    function isBigDensityMode(size, seriesMaxLen) {
        return (size / seriesMaxLen < 10);
    }
    function parseSeriesLineType(data, seriesIndex, semanticMgr){
        var context = ContextBuilder.buildSeriesLineContext(data, seriesIndex);
        var semanticProps = semanticMgr.analyzeSeriesStyle(context, "line");
        return semanticProps && semanticProps.line && semanticProps.line.type;
    }

    var utils = {
        getMaxSeriesLength: getMaxSeriesLength,
        isBigDensityMode: isBigDensityMode,
        addRectSeriesPathPoints: addRectSeriesPathPoints,
        parseSemanticColor: parseSemanticColor,
        parseSemanticLineColor: parseSemanticLineColor,
        parseSemanticLineType: parseSemanticLineType,
        parseSeriesLineType: parseSeriesLineType,
        getSeriesType: function(item, dataShapes, combinationType) {
            var index;
            if (item) {
                switch (combinationType) {
                    case ChartConstants.COLUMN_COMBINATION:
                        index = item.color ? item.color.mndIndex : -1;
                        break;
                    case ChartConstants.STACKED_COMBINATION:
                        if (item.color){
                            index = item.color.mndIndex;
                        } else if (item.color2){
                            index = item.color2.mndIndex;
                        } else {
                            index = -1;
                        }
                        break;
                }
                return dataShapes[index] || ChartConstants.LINE;
            }
            return ChartConstants.LINE;
        }
    };
    return utils;
});

define('sap/viz/chart/components/trendline/algorithm/Linear',[], function() {
    function compute(data) {
        var xSum, ySum, xySum, xxSum, yySum,
            slope, intercept, fx,
            n = data.length;
        xSum = ySum = xySum = xxSum = yySum = 0;
        
        var minX = +data[0].x;
        data.forEach(function(d){
            minX = minX < +d.x ? minX : +d.x;
        });
        minX = minX < 0 ? -1*minX : minX;
        for (var i = 0; i < n; i++) {
            var dx = (+data[i].x - minX);
            xSum += dx;
            ySum += +data[i].y;
            xySum += dx * data[i].y;
            xxSum += dx * dx;
            yySum += data[i].y * data[i].y;
        }
        var rest = ((n * xxSum) - (xSum * xSum));
        if(rest === 0){
            return false;
        }
        slope = (((n * xySum) - (xSum * ySum))) / rest;
        
        intercept = (ySum - (slope * xSum)) / n - slope * minX;

        return function(x) {
            return slope * x + intercept;
        };
    }

    function validate(data) {
        return (data instanceof Array) && data.length > 1;
    }

    return {
        type: "Linear",
        compute: compute,
        validate: validate
    };
});

define('sap/viz/chart/components/trendline/Trendline',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/SeriesUtil',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/framework/common/util/ColorUtils',
    'sap/viz/framework/common/util/TypeUtils',
    './algorithm/Linear'
], function(
    Constants,
    ValueAxisUtils,
    ObjectUtils,
    SeriesUtil,
    DataUtils,
    TimeUtil,
    ColorUtils,
    TypeUtils,
    Linear
) {
    var getValue = DataUtils.getDimensionParsedValue;
    var DEAULT_COLOR_RATE = 0.1;
    function getFirstItem(series){
        for(var i = 0; i < series.length ; i++){
            if(series[i]){
                return series[i];
            }
        }
        return null;
    }
    var Utils = {
        seriesAxisId: function(series) {
            var firstItem = getFirstItem(series);
            if (firstItem) {
                return firstItem.hasOwnProperty("valueAxis") ? "valueAxis" : "valueAxis2";
            }
            return null;
        },
        indexOfObj: function(obj, list) {
            for (var i = 0; i < list.length; i++) {
                if (ObjectUtils.deepEqual(obj, list[i])) {
                    return i;
                }
            }
            return -1;
        },
        seriesAxisHasTime: function(series){
            var firstItem = getFirstItem(series);
            if (firstItem) {
                return firstItem.hasOwnProperty("timeAxis");
            }
            return false;
        },
        findMapObj: function(obj, list){
            var result = [];
            for(var i = 0; i < list.length; i++){
                if(ObjectUtils.deepEqual(obj, list[i])){
                    result.push(i);
                }
            }
            return result;
        }
    };
    function timeSeriesToData(series, dataPoint){
        return  series.map(function(d){
            return {
                x: getValue(d.timeAxis[0]),
                y: (d.valueAxis instanceof Array) ? d.valueAxis[0] : d.valueAxis
            };
        }).filter(function(d) {
            if(d){
                if(!TypeUtils.isExist(d.y) && dataPoint.invalidity){
                    if(dataPoint.invalidity === "connect"){
                        d.y = 0;
                        return true;
                    }else {
                        return false;
                    }
                }
            }
            return !!d;
        });
    }
    var SeriesToData = {
        yy: function(series, dataPoint) {
            var xys;
            if(Utils.seriesAxisHasTime(series)){
                xys = timeSeriesToData(series, dataPoint);
            }else {
                xys= series.map(function(d) {
                    return {
                        x: (d.valueAxis instanceof Array) ? d.valueAxis[0] : d.valueAxis,
                        y: (d.valueAxis2 instanceof Array) ? d.valueAxis2[0] : d.valueAxis2
                    };
                });
            }
            // remove duplicates
            xys = xys.sort(function(p, q) {
                return p.x < q.x ? -1 : (p.x > q.x ? 1 : 0);
            }).reduce(function(uniq, d) {
                var last = uniq[uniq.length - 1];
                if (last.x !== d.x || last.y !== d.y) {
                    uniq.push(d);
                }
                return uniq;
            }, [xys[0]]);
            return xys;
        },
        spread: function(series, dataPoint) {
            var xys;
            if(Utils.seriesAxisHasTime(series)){
                return timeSeriesToData(series, dataPoint);
            }else {
                var key = Utils.seriesAxisId(series);
                return series.map(function(d, i) {
                    return {
                        x: i + 1,
                        y: d[key]
                    };
                }).filter(function(d) {
                    return !!d;
                });
            }
        }
    };

    function SeriesforecastTrend(fx, forecastStep, series, raw, timeLevels){
        if(Utils.seriesAxisHasTime(series)){
            var lastTime = Math.max.apply(null, series.map(function(d){
                return getValue(d.timeAxis[0]);
            }));
            var minTimelevel = timeLevels[0];
            var timeStamp;
            for(var start = 1; start <= forecastStep; start++){
                timeStamp = TimeUtil.getNperiodByTimeLevel(minTimelevel, lastTime, start, true);
                raw.push({x: timeStamp, y: fx(timeStamp)});
            }
        }else {
            var lastValue = Math.max.apply(null, raw.map(function(d){
                return d.x;
            }));
            for(var stop = 0 ; stop < forecastStep; stop++, lastValue++){
                raw.push({x: lastValue + 1, y:fx(lastValue + 1)});
            }
        }
    }

    var Parser = (function() {
        var NAMES_STYLE2ATT = {
            color: {
                name: "stroke"
            },
            type: {
                name: "stroke-dasharray",
                fn: function(val, style) {
                    switch (val) {
                        case Constants.LINE_TYPE.DASHED:
                            return Constants.LINE_DASH_TYPE_ARRAY;
                        case Constants.LINE_TYPE.SOLID:
                            return val;
                        default:
                            return"1, " + (+style.size) * 2;
                    }
                }
            },
            size: {
                name: "stroke-width"
            }
        };

        function parseStyle(style) {
            return Object.keys(style).reduce(function(attrs, prop) {
                var val = style[prop],
                    converter = NAMES_STYLE2ATT[prop];
                if (converter) {
                    attrs[converter.name] = converter.fn ? converter.fn(val, style) : val;
                    if(converter.name === "stroke-dasharray" && val !== Constants.LINE_TYPE.DASHED &&
                        val !== Constants.LINE_TYPE.SOLID){
                        attrs["stroke-linecap"] = "round";
                    }
                }
                return attrs;
            }, {});
        }

        function getSContextOfAllSeries(dataModel){
            var lineSeriesContext = [];
            if(dataModel._seriesType === "yy"){
                // for bubble and scatter
                // remove duplicate context
                var hash = {};
                dataModel.seriesContext.forEach(function(d){
                    var str = JSON.stringify(d);
                    if(!hash[str]){
                        lineSeriesContext.push(d);
                        hash[str] = true;
                    }
                });
            }else {
                lineSeriesContext = dataModel.seriesContext;
            }
            return lineSeriesContext.map(function(line){
                return {seriesContext: line};
            });
        }
        function findSeries(dataModel, line){
            var seriesId, series;
            if(dataModel._seriesType === "yy"){
                // for bubble and scatter
                var seriesArr = Utils.findMapObj(line.seriesContext, dataModel.seriesContext);
                if(seriesArr.length > 0 ){
                    series = [];
                    seriesArr.forEach(function(ssId){
                        dataModel.series[ssId].forEach(function(sr){
                            series.push(sr);
                        });
                    });
                    seriesId = seriesArr[0];
                }
            }else {
                seriesId = Utils.indexOfObj(line.seriesContext, dataModel.seriesContext);
                if (seriesId !== -1 || seriesId < dataModel.series.length) {
                    series = dataModel.series[seriesId];
                }
            }
            return {
                series: series,
                seriesId: seriesId
            };
        }
        function getBasicSpecs(props, dataModel, dataPoint, timeLevel) {
            if (!props || !props.lines || (props.lines !== "all" && !TypeUtils.isArray(props.lines))) {
                return [];
            }
            var lines = props.lines;
            if(dataModel.seriesContext === null || dataModel.seriesContext.length === 0){
                // seriesContext === null => series[0] is set in a line
                if(lines === "all"&& dataModel.series && dataModel.series.length >0){
                    var seriesData = dataModel.series[0];
                    if(!seriesData || seriesData.length <2){
                        return null;
                    }
                    var raw = SeriesToData[dataModel._seriesType](seriesData, dataPoint),
                        fx = calculate(raw);
                    if(!fx){
                        return null;
                    }
                    var forecast = +props.defaultStyle.forecast||0;
                    if(forecast > 0) {
                        SeriesforecastTrend(fx, forecast, seriesData, raw, timeLevel);
                    }
                    return [{
                        seriesId: 0,
                        seriesContext: null,
                        series: seriesData,
                        raw: raw,
                        fx: fx,
                        forecast: forecast
                    }];
                }
            }else {
                var drawLines = lines === "all" ? getSContextOfAllSeries(dataModel) :lines;
                return drawLines.map(function(l) {
                    if(l && TypeUtils.isPlainObject(l)){
                        var raw, fx, seriesObj = findSeries(dataModel, l);
                        var series = seriesObj.series,  seriesId = seriesObj.seriesId;
                        if(!series || series.length < 2){
                            return null;
                        }
                        raw = SeriesToData[dataModel._seriesType](series, dataPoint);
                        fx = calculate(raw);
                        if(raw.length < 2 || !fx){
                            return null;
                        }
                        var forecast = +l.forecast || +props.defaultStyle.forecast || 0;
                        if(forecast > 0) {
                            SeriesforecastTrend(fx, forecast, series, raw, timeLevel);
                        }
                        return {
                            seriesId: seriesId,
                            seriesContext: l.seriesContext,
                            series: series,
                            raw: raw,
                            fx: fx,
                            forecast: forecast
                        };
                    }
                });
            }

        }

        function getSeriesColor(dataModel, serie, bindingName, effectManager){
            var color,
                colorModel = dataModel[bindingName];
            if (colorModel && colorModel.scale) {
                color = colorModel.scale.scale(serie[bindingName]);
                color = ColorUtils.fromCSSColor(color).lighter(DEAULT_COLOR_RATE).toString();
                if(effectManager){
                    color = effectManager.register({
                        fillColor: color
                    });
                }
            }
            return color;
        }

        function getColorSpecs(props, dataModel, seriesStyle, effectManager) {
            if (!props || !props.lines ||(props.lines !== "all" && !TypeUtils.isArray(props.lines))) {
                return [];
            }
            var lines = props.lines,
                defaultStyle = props.defaultStyle;

            var seriesStyleContext = seriesStyle && seriesStyle.rules && seriesStyle.rules.map(function(val){
                return val.dataContext && val.dataContext[0];
            });
            if(dataModel && dataModel.seriesContext === null || dataModel.seriesContext.length === 0){
                // seriesContext === null => all datapoint is set in a line
                if(lines === "all" && dataModel.series && dataModel.series.length >0){
                    var series = dataModel.series[0];
                    if(!series || series.length < 1){
                        return null;
                    }
                    var sample = getFirstItem(series);
                    if (!sample) {
                        return null;
                    }
                    var bindingName = sample.color2 ? "color2" : "color",
                        color = ColorUtils.isCSSColorString(defaultStyle.color) ? defaultStyle.color:
                                getSeriesColor(dataModel, sample, bindingName, effectManager);

                    return [{
                        style: parseStyle(ObjectUtils.extend(true, {}, defaultStyle, {color: color})),
                        colorBind: sample[bindingName]
                    }];
                }
            }else {
                var drawLines = lines === "all" ? getSContextOfAllSeries(dataModel) :lines;
                return drawLines.map(function(line){
                    if(line && TypeUtils.isPlainObject(line)){
                        var seriesObj = findSeries(dataModel, line),
                            series = seriesObj.series,
                            seriesId = seriesObj.seriesId;
                        if(!series || series.length < 1){
                            return null;
                        }
                        var style = {};
                        if(seriesStyleContext){
                            var seriesStyleId = Utils.indexOfObj(line.seriesContext, seriesStyleContext);
                            var sStyle = seriesStyleId === -1 ? null : seriesStyle.rules[seriesStyleId];
                            if(sStyle && sStyle.properties && sStyle.properties.line){
                                style.color = sStyle.properties.line.color;
                                style.color = ColorUtils.isCSSColorString(style.color) && style.color;
                                style.size = sStyle.properties.line.width;
                            }
                        }
                        if(line.type){
                            style.type = line.type;
                        }
                        if(line.size){
                            style.size = line.size;
                        }
                        var sample = getFirstItem(series);
                        if (!sample) {
                            return null;
                        }
                        var bindingName = sample.color2 ? "color2" : "color";
                        if(ColorUtils.isCSSColorString(line.color)){
                            style.color = line.color;
                        }else {
                            style.color = ColorUtils.isCSSColorString(defaultStyle.color) ? defaultStyle.color:
                                            getSeriesColor(dataModel, sample, bindingName, effectManager);
                        }
                        return {
                            text: line.displayName,
                            style: parseStyle(ObjectUtils.extend(true, {}, defaultStyle, style)),
                            colorBind: sample[bindingName],
                            seriesContext: line.seriesContext
                        };
                    }
                });
            }

        }
        return {
            basic: getBasicSpecs,
            color: getColorSpecs
        };
    })();

    function domainPerTrendline(fx, raw) {
        var vals = raw.map(function(d) {
                return fx(d.x);
            });
        return [Math.min.apply(null, vals), Math.max.apply(null, vals)];
    }


    function calculate(input) {
        var algo = Linear;
        if (!algo.validate(input)) {
            return null;
        }
        return algo.compute(input);
    }

    function updateValueScale(plot, rangeCfg, datamodel) {
        if (typeof plot._trendlineValueDomain !== "function") {
            return null;
        }
        var trendDomain = plot._trendlineValueDomain(datamodel),
            changedKeys = Object.keys(trendDomain).length;
        if (changedKeys === 0) {
            return null;
        }
        var isLineChart = /line/.test(plot._options.renderType);

        var updatedAxes = Object.keys(trendDomain).reduce(function(result, key) {
            var dm0 = datamodel[key].scale.getDomain(), // origin
                dm1 = trendDomain[key]; // changed by trendline
            if (dm0[0] > dm1[0] || dm0[1] < dm1[1]) {
                var min = Math.min(dm0[0], dm1[0]),
                    max = Math.max(dm0[1], dm1[1]);
                var updated = ValueAxisUtils.calcScale(datamodel[key].scale, rangeCfg[key], {
                    isLineChart: isLineChart,
                    domain: [min, max]
                });
                updated.scale.setRange([0, 1]);
                updated.metaData = datamodel[key].metaData;
                result[key] = updated;
            }
            return result;
        }, {});

        return updatedAxes;
    }

    function getValueScaleDomain(plot,valueAxisDomain, datamodel, xRange){
        if (typeof plot._trendlineValueDomain === "function") {
            var trendDomain = plot._trendlineValueDomain(datamodel, xRange),
                changedKeys = Object.keys(trendDomain).length;
            if (changedKeys !== 0) {
                var min = trendDomain.valueAxis[0];
                var max = trendDomain.valueAxis[1];
                min = valueAxisDomain[0] > min ? min : valueAxisDomain[0];
                max = valueAxisDomain[1] > max ? valueAxisDomain[1] : max;
                return [min, max];
            }
        }
        return valueAxisDomain;
    }

    function expandTimeAxisDomain(timeAxisDomain, trendlines){
        if(!timeAxisDomain || timeAxisDomain.length < 2 || !trendlines){
            return;
        }
        var maxforecast = 0;
        trendlines.forEach(function(trendline){
            if(trendline && trendline.fx && trendline.forecast){
                var len = trendline.raw.length;
                maxforecast = trendline.raw[len - 1].x > maxforecast ? trendline.raw[len - 1].x : maxforecast;
            }
        });
        if(maxforecast > 0){
            timeAxisDomain[1] = maxforecast;
        }
    }

    function expandCategoryDomain(dimensions, trendlines, statusManager){
        if(!dimensions || !trendlines){
            return;
        }
        var maxforecast= 0;
        trendlines.forEach(function(trendline){
            if(trendline && trendline.raw && trendline.fx && trendline.forecast){
                maxforecast = trendline.forecast < maxforecast ? maxforecast : trendline.forecast;
            }
        });
        for(var period = 0; period < maxforecast; period++){
            var virtualdimension = [];
            for(var step = 0 ; step < dimensions[0].length; step++){
                virtualdimension.push("");
            }
            dimensions.push(virtualdimension);
        }
    }
    return {
        calculate: calculate,
        Parser: Parser,
        updateValueScale: updateValueScale,
        Utils: Utils,
        domainPerTrendline: domainPerTrendline,
        getValueScaleDomain: getValueScaleDomain,
        expandTimeAxisDomain: expandTimeAxisDomain,
        expandCategoryDomain: expandCategoryDomain
    };
});
define('sap/viz/chart/components/trendline/mixin/legendItems',[
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/chart/components/trendline/Trendline',
], function(
    ObjectUtils,
    Constants,
    DataUtils,
    LangManager,
    Trendline
) {

    var _CLASS = {};
    _CLASS[Constants.CSS.CLASS.LEGENDITEM] = false;
    _CLASS["v-trendline-legend-item"] = true;
    function findLegendText(items, seriesContext){
        var keys = seriesContext && Object.keys(seriesContext);
        var result = [];
        if(keys){
            for(var i =0; i < items.length; i++){
                var find = true;
                keys.forEach(function(key){
                    var itemValue = items[i].context[key+DataUtils.DIMENSION_VALUE_SUFFIX] ||
                                    items[i].context[key];
                    if(seriesContext[key] !== itemValue){
                        find = false;
                        return;
                    }
                });
                if(find){
                    result = ObjectUtils.extend(true, [], items[i].data);
                    break;
                } 
            }
        }
        return result;
    }
    return function(legend, items) {
        var dataModel = legend._data,
            props = legend._properties.parentLevel.get("plotArea.trendLine"),
            dataPointStyleMode = legend._properties.parentLevel.get("plotArea.dataPointStyleMode"),
            seriesStyle = legend._properties.parentLevel.get("plotArea.seriesStyle"),
            dataPointStyle = this._properties.get("dataPointStyle"),
            specs = Trendline.Parser.color(props, dataModel, seriesStyle, legend._runtime._effectMgr),
            legendItems = [];
        if((!dataPointStyle || !dataPointStyleMode || dataPointStyleMode !== "override") && 
            specs && specs.length > 0){
            specs.map(function(sp) {
                if(!sp){
                    return null;
                }
                var style = ObjectUtils.extend(true, {}, sp.style, {
                    fill: "none"
                });
                var textData = sp.text;
                if (!textData) {
                    textData = findLegendText(items, sp.seriesContext);
                    textData.callback = function(val) {
                        if(val && val !== ""){
                            return LangManager.get("IDS_TRENDLINE_LINEAR") + ": " +  val;
                        }else{
                            return LangManager.get("IDS_TRENDLINE_LINEAR");
                        }
                    };
                }
                legendItems.push({
                    data: textData,
                    color: sp.style.stroke,
                    context: sp.seriesContext,
                    cls: _CLASS,
                    shape: {
                        type: "line",
                        style: style
                    }
                });
            });
        }
        return legendItems;
    };
});

define('sap/viz/chart/components/legend/ColorLegend',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/legend/BaseLegend',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/scrollbar/Scrollbar',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/behavior/config/SelectionUtil',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/chartmodel/DataSelector',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/scale/ColorShapeScaleMerger',
    'sap/viz/chart/components/util/StyleUtils',
    'sap/viz/framework/common/util/GeometryUtils',
    'sap/viz/chart/components/util/ColorUtil',
    "sap/viz/framework/common/util/StatusConstants",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/ColorLegendNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    'sap/viz/chart/components/trendline/mixin/legendItems'
], function(
    oo,
    BaseLegend,
    TextUtils,
    DrawUtil,
    NameColorUtils,
    Scrollbar,
    TypeUtils,
    SelectionUtil,
    ObjectUtils,
    Constants,
    DataUtils,
    DataSelector,
    NumberUtils,
    ColorShapeScaleMerger,
    StyleUtils,
    GeometryUtils,
    ColorUtil,
    StatusConstants,
    ChartNavigator,
    ItemNavigator,
    ChartConstants,
    TrendlineItems
) {

    "use strict";

    var HORIZONTAL_OFFSET = Constants.LEGEND.HORIZONTAL_OFFSET;
    var INTERACTION_CLASS =  Constants.CSS.CLASS.LEGENDITEM,
        ID_CLASS = "v-legend-element";

    function ColorLegend(runtime, options) {
        ColorLegend.superclass.constructor.apply(this, arguments);

        this._labelFont = {
            'fontFamily': null,
            'fontSize': null,
            'fontWeight': null,
            'color': null,
            'fontStyle': null
        };

        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.addDataPointChangeCallback(this._onDataPointChange.bind(this));

        this._defaultItemMargin = this._properties.getDefault("itemMargin");

        this._colorLabelSize = 1;
        this._markerMargin = {
            right: 0.5,
            bottom: 0.5,
            left: 1,
            top: 0
        };
        this._maxItemsNum = 12;
        this._maxItemTextWidth = 80; // For Horizontal layout

        this._colorScale = null;
        this._shapeScale = null;
        this._colorShapeScale = null;
        this._scrollBar = undefined;
        this._type = "ColorLegend";
        this._noFillSupport = options && options.options && options.options.noFillSupport;

        this._scrollThumbSpace = Scrollbar.getThumbSpace("legend");

        this._contentSize = 0;
        this._pageCount = 2;
        this._domID = ObjectUtils.guid();
        this._isOverflow = false;
        this._overflowOffset = 0;
        this._lastRowOffset = 0;
        this._markerSize = 0;
        this._cDomain = null;
        this._offset = {
            x: 0,
            y: 0
        };
        this.BGCOLORPROPS = [ "general.background.color"];
    }

    oo.extend(ColorLegend, BaseLegend);

    function createScaleAndBinding(colorLegend, dataModel) {
        var colorScales = [];
        var keys = Object.keys(dataModel).sort();
        for (var i = 0; i < keys.length; i++) {
            var data = dataModel[keys[i]];
            var type = data && data.scale && data.scale._type;
            if (type === "color") {
                colorScales.push(data);
            } else if (type === "shape") {
                colorLegend.setShapeScale(data);
            }
        }
        colorLegend.setColorScale(colorScales);
    }

    /**
     * To fix non property definition for standalone mode.
     */
    ColorLegend.prototype._addDefaultProperties = function() {
        ColorLegend.superclass._addDefaultProperties.call(this);
        this._properties.add({
            'drawingEffect': 'normal',
            'formatString': null,
            'hoverShadow': {
                'color': "#cccccc"
            },
            'isScrollable': false,
            'itemMargin': 0.5,
            'marker': {
                'size': null,
                'shape': "squareWithRadius"
            },
            'mouseDownShadow': {
                'color': "#808080"
            },
            'scrollbar': {
                'thumb': {
                    'fill': "#e5e5e5",
                    'hoverFill': "#dedede"
                },
                'track': {
                    'fill': "f7f7f7"
                }
            }
        });
    };

    ColorLegend.prototype._onDataPointChange = function() {
        this._colorShapeScale = null;
    };

    ColorLegend.prototype.setData = function(value) {
        this._data = value;
        createScaleAndBinding(this, value);
        return this;
    };

    ColorLegend.prototype.setColorScale = function(colorScale) {
        this._colorScale = TypeUtils.isArray(colorScale) ? colorScale : [colorScale];
        this._colorShapeScale = null;
        return this;
    };

    ColorLegend.prototype.setShapeScale = function(shapeScale) {
        this._shapeScale = shapeScale;
        return this;
    };

    ColorLegend.prototype.isVisible = function() {
        return ColorLegend.superclass.isVisible.apply(this, arguments) && this.hasData();
    };

    ColorLegend.prototype.getScrollbar = function(){
        return this._scrollBar;
    };

    ColorLegend.prototype.scroll = function(offset, isWheelEvent){
        if(this._scrollBar){
            this._scrollBar._scroll(offset, true, isWheelEvent);
            this._scrollBar.show();
        }
    };

    ColorLegend.prototype._scroll = function(options){
        if (options.reachMax) {
            this.loadMore();
        }

        var offset = options.offset;
        if (this.isHorizontal()){
            this._offset.x = offset;
            this._offset.y = 0;
        } else {
            this._offset.x = 0;
            this._offset.y = offset;
        }
        this._setTranslate();
    };

    ColorLegend.prototype.loadMore = function(number){
        number = +number;
        if(isNaN(number)){
            number = 2;
        }
        this._pageCount += number;
        this.render(this._parent, true);

        var tRuntime = this.runtime();
        if (tRuntime && tRuntime._interaction && tRuntime._interaction._service) {
            SelectionUtil.updateCorrespondingSelectedLegendItems(tRuntime._interaction._service);
        }
    };

    ColorLegend.prototype._setTranslate = function() {
        if(!this._isRTL()) {
            this._parent.select(".v-groups").attr('transform',
                'translate(' + this._offset.x + ', ' + this._offset.y + ')');
        }else {
            var groups = this._parent.select(".v-groups");
            var groupBBox = GeometryUtils.getBBox(groups.node());
            if(this._cDomain.width > groupBBox.width) {
                if(this._scrollBar && this._scrollBar._isVisible) {
                    groups.attr('transform', 'translate(' +
                        (this._offset.x + this._cDomain.width - groupBBox.width + HORIZONTAL_OFFSET -
                        this._scrollThumbSpace + (this._lastRowOffset ? 0 : this._overflowOffset)) +
                        ', ' + this._offset.y + ')');
                }else {
                    groups.attr('transform', 'translate(' +
                        (this._offset.x + this._cDomain.width - groupBBox.width + HORIZONTAL_OFFSET +
                        this._cDomain.markerMarginRight - this._scrollThumbSpace +
                        (this._lastRowOffset ? 0 : this._overflowOffset)) +
                        ', ' + this._offset.y + ')');
                }
            }
            else {
                groups.attr('transform', 'translate(' +
                    (this._offset.x + this._cDomain.markerMarginRight) + ', ' + this._offset.y + ')');
            }
        }
    };

    var drawSplitLine = function(selection, x, y, lineLen, isHorizontal) {
        var splitLineG = selection.select(".v-split-lines");
        if(splitLineG.empty()) {
            splitLineG = selection.append("g").classed('v-split-lines', true);
        }

        var splitLine = splitLineG.select("line");
        if(splitLine.empty()) {
            splitLine = splitLineG.append("line");
        }
        splitLine = splitLine.node();
        //we use value axis default color
        splitLine.setAttribute("stroke", "#d8d8d8");
        splitLine.setAttribute("stroke-width", 1);
        splitLine.setAttribute("shape-rendering", "crispEdges");

        splitLine.setAttribute("x1", x);
        splitLine.setAttribute("y1", y);

        if (isHorizontal) {
            splitLine.setAttribute("x2", x);
            splitLine.setAttribute("y2", y + lineLen);
        } else {
            splitLine.setAttribute("x2", x + lineLen);
            splitLine.setAttribute("y2", y);
        }
    };

    ColorLegend.prototype._drawSplitLine = function(groups, cDomain) {
        var isDrawSplitLine = false;
        if(cDomain._intervalIndex >= 0 && cDomain._intervalLen > 0 &&
           (cDomain.length - 1) > cDomain._intervalIndex) {
            isDrawSplitLine = true;
        }

        if(isDrawSplitLine) {
            if(!this.isHorizontal()) {
                var splitLineY = cDomain[cDomain._intervalIndex + 1].pos.y;
                splitLineY -= (cDomain._intervalLen / 2);
                var length = this._isScrollable() ? cDomain.width - this._scrollThumbSpace : cDomain.width;
                drawSplitLine(groups, 0, splitLineY, length, false);
            }
            else {
                var splitLineX = cDomain[cDomain._intervalIndex + 1].pos.x;
                splitLineX -= cDomain._intervalLen;//do not need /2
                drawSplitLine(groups, splitLineX, 0, cDomain.eachRowHeight, true);
            }
        }
        else {
            groups.selectAll(".v-split-lines").remove();
        }
    };

    ColorLegend.prototype._createLegendContent = function(parent, cDomain, loadMore){
        var labelFont = this._labelFont;
        // append container
        var legendContent = parent.selectAll('g.v-content').data(['content']);
        legendContent.enter().append('g')
            .classed('v-content', true);
        legendContent.exit().remove();
        legendContent.attr('transform', 'translate(0, ' + this._pos.y + ')')
            .attr('font-size', labelFont.fontSize)
            .attr('font-family', labelFont.fontFamily)
            .attr('font-weight', labelFont.fontWeight)
            .attr('fill', labelFont.color)
            .attr('font-style', labelFont.fontStyle);

        //append body bound
        var legendBodyBoundRect = legendContent.selectAll("rect.v-legend-body-bound").data(['bound']);
        legendBodyBoundRect.enter().append('rect')
            .classed('v-legend-body-bound', true)
            .attr("fill", "transparent");
        legendBodyBoundRect.exit().remove();
        legendBodyBoundRect.attr("x", this._isRTL() ? 0 : -HORIZONTAL_OFFSET);
        legendBodyBoundRect.attr("width", this._width + HORIZONTAL_OFFSET)
            .attr("height", this._height - this._pos.y);

        // append content groups
        var groups = legendContent.selectAll('g.v-groups').data(['groups']);
        groups.enter().append('g')
            .classed('v-groups', true)
            .classed('v-label', true)
            .classed('viz-legend-valueLabel', true);

        // for acc doc requirements
        groups.attr('role', 'listbox');
        groups.exit().remove();
        groups.attr('transform', 'translate(0, 0)');

        this._createGroupItems(groups, cDomain);

        // Draw overflow node "..."
        this._handleOverflow(legendContent, cDomain, loadMore);

        // Now we draw the split line
        this._drawSplitLine(groups, cDomain);

        if(this._properties.origin.get("legendGroup.layout.alignment") === "center" &&
           (this._position === "top" || this._position === "bottom")) {
            var legendItemsNode = groups.node();
            if(legendItemsNode) {
                var legendItemsWidth = legendItemsNode.getBoundingClientRect().width;
                if(this._width + HORIZONTAL_OFFSET > legendItemsWidth) {
                    legendBodyBoundRect.attr("width", parseFloat(legendItemsWidth));
                }
            }
        } else {
            if(this._isRTL()) {
                var groupBBox = GeometryUtils.getBBox(groups.node());
                if(cDomain.width > groupBBox.width) {
                    if(this._scrollBar && this._scrollBar._isVisible) {
                        groups.attr('transform', 'translate(' +
                            (cDomain.width - groupBBox.width + HORIZONTAL_OFFSET -
                            this._scrollThumbSpace + (this._lastRowOffset ? 0 : this._overflowOffset)) + ', 0)');
                    }else {
                        groups.attr('transform', 'translate(' +
                            (cDomain.width - groupBBox.width + HORIZONTAL_OFFSET +
                            cDomain.markerMarginRight + (this._lastRowOffset ? 0 : this._overflowOffset)) + ', 0)');
                    }
                }
                else {
                    groups.attr('transform', 'translate(' + cDomain.markerMarginRight + ', 0)');
                }
            }
        }

        return legendContent;
    };
    var PATTERNVALS = ["noFill", "solid"];
    // TODO: can we also put these calucations in cDomain creation logic?
    ColorLegend.prototype._getGroupItemInfo = function(cDomain){
        var that = this;
        var width = cDomain.width;
        var textHeight = cDomain.textHeight;
        var markerSize = cDomain.markerSize;
        var markerWidth = this._getMarkerWidth(markerSize);
        var isScrollable = this._isScrollable();
        var isHorizontal = this.isHorizontal();
        var markerMargin = this._markerMargin;
        var propMgr = this.runtime().propertyManager();
        var drawingEffect = this._properties.get("drawingEffect");
        var showFullLegend = this._properties.get('showFullLabel');
        var defaultMarkerShape = this._options && this._options.options ?
                this._options.options.defaultMarkerShape :
                null;

        var eachItemWidth = cDomain.eachItemWidth;
        if (!this.isHorizontal() || (!isScrollable && eachItemWidth > width)) {
            eachItemWidth = width;
            if (isScrollable) {
                eachItemWidth -= this._scrollThumbSpace;
            }
        }

        var expectedWidth = eachItemWidth - cDomain.miscWidth;
        if (isHorizontal) {
            expectedWidth = Math.min(expectedWidth, width);
        }

        // When there's only one item, the "..." should be shown next to it,
        // so the expectedWidth of this item will be different from other cases
        var needHandleOverflowNode = isHorizontal && cDomain.length === 1 && cDomain.columnCount === 2;
        var semanticMgr = this.runtime().semanticManager();
        return cDomain.map(function(d){
            // text string
            if (isHorizontal) {
                if(isScrollable && that._isOverflow){
                    expectedWidth = d.labelWidth;
                }else if(showFullLegend){
                    expectedWidth = Math.min(d.labelWidth, width - markerSize - markerMargin.right * textHeight);
                }
                if(needHandleOverflowNode){
                    expectedWidth = Math.min(expectedWidth,
                        width - cDomain.miscWidth - cDomain.ellipsisWidth);
                }
            }

            // eventLayer width
            var retWidth = 0;
            if (isHorizontal) {
                if(!isScrollable && showFullLegend){
                    retWidth = expectedWidth + markerWidth + markerMargin.right * textHeight + HORIZONTAL_OFFSET;
                }else{
                    var regularItemWidth = eachItemWidth + HORIZONTAL_OFFSET - markerMargin.right * textHeight;

                    if (that._isOverflow || isScrollable) {
                        var overflowItemWidth = HORIZONTAL_OFFSET + d.labelWidth + markerWidth +
                               (markerMargin.right + markerMargin.left / 2) * textHeight;
                        if (!isScrollable && regularItemWidth < overflowItemWidth) {
                            overflowItemWidth = regularItemWidth;
                        }
                        retWidth = overflowItemWidth;

                        if(needHandleOverflowNode){
                            // Also shrink the eventlayer if necessary
                            retWidth = Math.min(retWidth, expectedWidth + cDomain.miscWidth);
                        }
                    } else {
                        retWidth = regularItemWidth;
                    }
                }
            } else {
                retWidth = eachItemWidth + HORIZONTAL_OFFSET;
            }


            // shape options
            var shapeOptions = {
                drawingEffect: drawingEffect,
                borderWidth: 0,
                rx: markerSize / 2,
                ry: markerSize / 2,
                direction: 'vertical',
                fillColor: d.color,
                graphType: d.shape,
                defaultShape: defaultMarkerShape,
                borderColor: "transparent"
            };
            shapeOptions.dpPattern = d.pattern;
            if(!d.isSemantic){
                //  process one measure case , we should put measure value into context.

                var dpStyle = that._getSereisStyle(d.ctx, that._data, semanticMgr, "dataPoint");
                if(dpStyle && dpStyle.dataPoint){
                    if(dpStyle.dataPoint.pattern){
                        var pattern = dpStyle.dataPoint.pattern;
                        var chartType = semanticMgr._chartType;
                        if(d.seriesShape === "line" && PATTERNVALS.indexOf(pattern) === -1 ||
                            chartType === "info/area"){
                            pattern = null;
                        }
                        shapeOptions.patternEffect = shapeOptions.dpPattern = pattern;
                    }
                    if(dpStyle.dataPoint.color){
                        shapeOptions.fillColor = NameColorUtils.convertColor(dpStyle.dataPoint.color);
                    }
                }
            }
            if(shapeOptions.dpPattern === 'noFill' && !that._noFillSupport){
                shapeOptions.patternEffect = shapeOptions.dpPattern = null;
            }

            if(shapeOptions.dpPattern === 'noFill'){
                shapeOptions.borderColor = propMgr.get("plotArea.background.color");
                if(!shapeOptions.borderColor || shapeOptions.borderColor === 'transparent'){
                    shapeOptions.borderColor = propMgr.get("general.background.color");
                }
                shapeOptions.borderWidth = 1;
                if(propMgr.get("plotArea.dataPoint.stroke.visible")){
                    shapeOptions.borderColor = propMgr.get("plotArea.dataPoint.stroke.color");
                }
            }
            var useSemanticPattern = that.runtime().semanticManager().isUseSemanticPattern();
            if (useSemanticPattern && d.pattern) {
                shapeOptions.patternEffect = d.pattern;
            }
            return {
                eventLayerWidth: retWidth,
                shapeOptions: shapeOptions,
                expectedWidth: expectedWidth
            };
        });
    };

    ColorLegend.prototype._getSereisStyle = function(ctx, data, semanticMgr, styleType){
        var addedMND = false;
        var valueAxis = data && data.valueAxis;
        if(ctx && !ctx["measureNames"] && valueAxis && valueAxis.metaData && valueAxis.metaData.length === 1 ){
            ctx["measureNames"]  = valueAxis.metaData[0].id;
            addedMND = true;
        }
        var seriesStyle = semanticMgr.analyzeSeriesStyle(ctx, styleType);

        if(addedMND){
            delete  ctx["measureNames"];
        }
        return seriesStyle;
    };

    function trendlineLegendLength(cDomain){
        var len = 0;
        cDomain.forEach(function(cdomain){
            if(cdomain.cls){
                len++;
            }
        });
        return len;
    }
    ColorLegend.prototype._createGroupItems = function(groups, cDomain){
        var labelFont = this._labelFont;
        var itemInfos = this._getGroupItemInfo(cDomain);

        // append group items
        var groupItems = groups.selectAll('g.' + ID_CLASS).data(cDomain);
        groupItems.enter().append('g')
            .classed(ID_CLASS + " " + INTERACTION_CLASS, true);
        groupItems.each(function(d){
            if(!d.cls){
                d3.select(this).classed(INTERACTION_CLASS, true);
            }else {
                d3.select(this).classed(d.cls);
            }
        });
        groupItems.exit().remove();
        // for acc doc requirements
        groupItems.attr('role', 'option');
        groupItems.attr('transform', function(d) {
            return 'translate (' + (d.pos.x - HORIZONTAL_OFFSET) + ',' + d.pos.y + ')';
        });
        groupItems.attr('legendlabel-id', function(d) {
            return d.id;
        });
        if(this.isSelectable()){
            var total = this._colorShapeScale.getLength() - trendlineLegendLength(cDomain);
            groupItems.attr('aria-posinset', function(d) {
                return d.id + 1;
            }).attr('aria-setsize', total);
        }

        // assign global variable into local variable
        var eventLayers = groupItems.selectAll('rect').data(['rect']);
        eventLayers.enter().append('rect');
        eventLayers.exit().remove();
        eventLayers.attr('height', function(d, i, j) {
            return TypeUtils.isArray(cDomain[j].text) ?
                ((cDomain[j].line || cDomain[j].text.length) * cDomain.eachRowHeight) :
                cDomain.eachRowHeight;
        }).attr('fill', 'transparent').attr('width', function(d, i, j) {
            return itemInfos[j].eventLayerWidth;
        });

        // create shapes
        this._createShapeItems(groupItems, cDomain, itemInfos);

        // create texts
        var text, lineNum;

        var textNode = groupItems.selectAll('text').data(['text']);
        textNode.enter().append('text');
        textNode.exit().remove();

        var textAnchor = null;
        var envManager = this.runtime().envManager();
        if (envManager) {
            textAnchor = envManager.textAnchor();
        }
        textNode.attr("text-anchor", textAnchor);

        /** vertical align legend item in the center, since dominant-baseline isn't implemented in IE & Firefox
         * we have to use the dy hack, the dy value could be adjusted later */
        // texts.attr("dominant-baseline", "central");
        var that = this;
        textNode.each(function(d, i, j) {
            var node = d3.select(this);
            if(that._isRTL()) {
                node.attr("transform", "translate(" + 0 + ", " + cDomain.textY + ")");
            }
            else {
                node.attr("transform", "translate(" + cDomain.textX + ", " + cDomain.textY + ")");
            }
            if (TypeUtils.isArray(cDomain[j].text)) {
                text = cDomain[j].text.join("");
                lineNum = cDomain[j].line || cDomain[j].text.length;
            } else if (TypeUtils.isString(cDomain[j].text)){
                text = cDomain[j].text;
                lineNum = 1;
            } else {
                text = String(cDomain[j].text);
                lineNum = 1;
            }
            var options = {};
            options.isRTL = that._isRTL();
            options.ellipsisOptions = cDomain.ellipsisOptions;

            TextUtils.drawWrappedText(node, text, [" "], lineNum,
                that._isRTL() ?
                (itemInfos[j].eventLayerWidth - HORIZONTAL_OFFSET - that._markerSize - cDomain.markerMarginRight) :
                itemInfos[j].expectedWidth,
                cDomain.eachRowHeight, labelFont, options);
            node.selectAll("tspan").attr("dy", "0.85em");
        });

        // Although function TextUtils.ellipsis has added title tag,
        // eventLayer will overlap on text node.
        // So below code archived function that move title tag from text
        // node to event layer.
        eventLayers.each(function() {
            var textNode = this.parentNode.getElementsByTagName("text")[0];
            if (textNode) {
                while (this.childNodes.length !== 0) {
                    this.removeChild(this.childNodes[0]);
                }

                var titleNode = textNode.getElementsByTagName("title")[0];

                if (titleNode !== undefined && titleNode.textContent !== "") {
                    textNode.appendChild(titleNode);
                }
            }
        });
    };

    ColorLegend.prototype._cleanLegendItemsWithLine = function(groupItems){
        //Draw default legend. Clean legend.marker's line first.
        groupItems.selectAll('line').remove();
        groupItems.selectAll('g').remove();
    };

    ColorLegend.prototype._getBGColor = function() {
        var propMgr = this.runtime().propertyManager();
        var strokeColor = "plotArea.dataPoint.stroke.color";
        var strokeVisible = "plotArea.dataPoint.stroke.visible";
        return ColorUtil.getBgColor(propMgr,
            propMgr.get(strokeVisible) ? this.BGCOLORPROPS.concat(strokeColor) : this.BGCOLORPROPS);
    };

    ColorLegend.prototype._createShapeItems = function(groupItems, cDomain, itemInfos){
        var effectManager = this.runtime().effectManager();
        var propMgr = this.runtime().propertyManager();
        this._cleanLegendItemsWithLine(groupItems);

        var shapes = groupItems.selectAll('path').data(['shape']);
        shapes.enter().append('path');
        shapes.exit().remove();
        var isRTL = this._isRTL();
        if(!isRTL) {
            shapes.attr('transform', 'translate(' + cDomain.shapeX + ',' + cDomain.shapeY + ')');
        }

        var bgColor = this._getBGColor();
        shapes.each(function(d, i, j){
            var options = itemInfos[j].shapeOptions;
            options.node = this;
            options.bgColor =  bgColor;
            DrawUtil.drawGraph(options, effectManager);
            if(isRTL) {
                this.setAttribute('transform', 'translate(' +
                    (itemInfos[j].eventLayerWidth - HORIZONTAL_OFFSET - cDomain.markerSize / 2) +
                    ',' + cDomain.shapeY + ')');
            }
        });
        shapes.attr("class", "v-legend-marker");
    };

    function getLegendItemSize(index, cDomain, groupNode){
        var node = groupNode.querySelector('[legendlabel-id="' + cDomain[index].id + '"]');
        return node.getBoundingClientRect();
    }

    ColorLegend.prototype._handleOverflow = function(legendContent, cDomain, loadMore){
        var groupNode = legendContent.selectAll('.v-groups').node();
        var overflowIndicator = legendContent.selectAll('.v-overflow');
        if (this._isOverflow === true) {
            var width = cDomain.width;
            var height = cDomain.height;
            var isScrollable = this._isScrollable();
            var isHorizontal = this.isHorizontal();
            var textHeight = cDomain.textHeight;
            var colorMarkerSize = cDomain.colorMarkerSize;

            // Overflow
            if(overflowIndicator.empty()){
                overflowIndicator = legendContent.append('g').attr('class', 'v-overflow');
            }
            if (!isScrollable) {
                //remove scrollable legend
                if (!overflowIndicator.selectAll('g').empty()) {
                    legendContent.selectAll('defs').remove();
                    legendContent.attr('clip-path', null);
                    overflowIndicator.selectAll('g').remove();
                    overflowIndicator.attr('transform', 'translate(0, 0)');
                }
                // Show '...' to indicate that there is some hidden items
                if (cDomain.length !== 0) {
                    var overflowText = legendContent.selectAll('.v-overflow text');
                    if (overflowText.empty()) {
                        overflowText = overflowIndicator.append('text').text('...');
                        overflowText.attr('dy', '');
                    }
                    // Place the "..." at the right-bottom position
                    groupNode.appendChild(overflowIndicator.node());
                    var groupPos = groupNode.getBoundingClientRect();
                    var lastItem = cDomain[cDomain.length - 1];
                    var lastPos = getLegendItemSize(cDomain.length - 1, cDomain, groupNode);
                    var x = lastPos.left - groupPos.left;
                    var y = lastItem.pos.y;
                    var upperIndex, upperPos;
                    var offset;
                    if(cDomain.columnCount > 1){
                        offset = 0;
                        var maxNum = this._getMaxNumOfItems();
                        if (maxNum < this._colorShapeScale.getLength() &&
                            cDomain.rowCount > Math.floor(maxNum / cDomain.columnCount)) {
                            if (maxNum % cDomain.columnCount === 0) {
                                upperIndex = cDomain.columnCount * lastItem.rowIndex;
                                upperPos = getLegendItemSize(upperIndex, cDomain, groupNode);
                                x = upperPos.left - groupPos.left;
                                y += cDomain.eachRowHeight;
                            } else {
                                x = lastPos.right - groupPos.left + HORIZONTAL_OFFSET;
                            }
                        } else {
                            if(cDomain.length > cDomain.columnCount){
                                upperIndex = lastItem.rowIndex * cDomain.columnCount - 1;
                                upperPos = getLegendItemSize(upperIndex, cDomain, groupNode);
                                x = upperPos.left - groupPos.left;
                            }else{
                                x = lastPos.right - groupPos.left + HORIZONTAL_OFFSET;
                            }
                        }

                    }else{
                        offset = cDomain.textX - HORIZONTAL_OFFSET;
                        if (TypeUtils.isArray(lastItem.text)) {
                            y += (cDomain.eachRowHeight * (lastItem.line || lastItem.text.length));
                        } else {
                            y += cDomain.eachRowHeight;
                        }
                    }
                    if(!this._isRTL()) {
                        overflowIndicator.attr('transform', 'translate(' +
                            (x - HORIZONTAL_OFFSET + offset) + ',' + y + ')');
                    }else {
                        if(this._position === "top" || this._position === "bottom") {
                            if(cDomain.columnCount > 1) {
                                this._overflowOffset = 2 *overflowText.node().getComputedTextLength() +
                                    HORIZONTAL_OFFSET + offset;
                                overflowIndicator.attr('transform', 'translate(' +
                                    (-this._overflowOffset + this._lastRowOffset) + ',' +
                                     y + ')');
                            }else {
                                overflowIndicator.attr('transform', 'translate(' +
                                    (cDomain.eachItemWidth - 2 * overflowText.node().getComputedTextLength() -
                                    2 * HORIZONTAL_OFFSET - this._markerSize) + ',' + y + ')');
                            }
                        }
                        else {
                            overflowIndicator.attr('transform', 'translate(' +
                                (cDomain.width - 2 * overflowText.node().getComputedTextLength() -
                                HORIZONTAL_OFFSET - this._markerSize) + ',' + y + ')');
                        }
                    }
                    overflowText.attr('x', this._isRTL() ? 0 : HORIZONTAL_OFFSET)
                        .attr('y', cDomain.textY)
                        .attr('dy', '0.85em');
                    var textAnchor = null;
                    var envManager = this.runtime().envManager();
                    if (envManager) {
                        textAnchor = envManager.textAnchor();
                    }
                    overflowText.attr("text-anchor", textAnchor);
                }
            } else {
                legendContent.node().appendChild(overflowIndicator.node());
                if (!overflowIndicator.selectAll('text').empty()) {
                    //remove '...' for scrollable legend
                    overflowIndicator.selectAll('text').remove();
                }
                if (!loadMore) {
                    // reset scrollbar
                    this._scrollBar = undefined;
                }
                if(this._scrollBar === undefined){
                    this._scrollBar = new Scrollbar(this.runtime(), {
                        name: 'legend.scrollbar',
                        location:"legend"
                    });
                }

                // Append clipPath for Scrollable legend
                if (legendContent.selectAll('.legend-clip-rect').empty()) {
                    legendContent.insert('svg:defs', ":first-child")
                        .append('svg:clipPath')
                        .attr('id', 'legend_' + this._domID)
                        .append('rect')
                        .attr('class', 'legend-clip-rect')
                        .attr('x', isHorizontal ? 0 : -5)
                        .style('stroke','blue')
                        .style('fill', 'none');
                }
                var clipPathWidth = isHorizontal ? (width + 'px') : ((width + 5) + 'px');
                var clipPathHeight = isHorizontal ? ((height - this._pos.y + 5) + 'px') :
                                ((height - this._pos.y) + 'px');
                legendContent.selectAll('.legend-clip-rect')
                    .attr('width', clipPathWidth)
                    .attr('height', clipPathHeight)
                    .attr('y', isHorizontal ? -5 : 0);
                legendContent.attr('clip-path', 'url(#' + 'legend_' + this._domID + ')');
                var formerThumbPosition, formerRatio;
                var scrollbarProps = this._scrollBar._properties;
                var scrollbarBorder = parseFloat(scrollbarProps.get("border.width")) ||
                                      scrollbarProps.getDefault("border.width");
                scrollbarBorder = scrollbarBorder > 4 ? 4 : scrollbarBorder;
                scrollbarBorder = scrollbarBorder < 0 ? 0 : scrollbarBorder;
                if (loadMore){
                    formerThumbPosition = this._scrollBar.getThumbPosition();
                    formerRatio = this._scrollBar.getThumbRatio();
                }
                if (isHorizontal) {
                    this._scrollBar.setTrackSize(width - this._pos.x - 2*scrollbarBorder);
                    overflowIndicator.attr('transform',
                        'translate('+ scrollbarBorder +', ' + cDomain.eachRowHeight + ')');
                } else {
                    this._scrollBar.setTrackSize(height - this._pos.y - 2*scrollbarBorder);
                    overflowIndicator.attr('transform',
                        'translate(' + (width - this._scrollThumbSpace - scrollbarBorder/2) + ', '+
                            ''+ scrollbarBorder +')');
                }
                this._scrollBar.getDispatch().on("scroll.legend", this._scroll.bind(this));
                this._scrollBar.setPosition(this._orientation)
                    .setContentSize(this._contentSize)
                    .render(overflowIndicator);
                var ratio = this._scrollBar.getThumbRatio();
                if (loadMore && ratio !== formerRatio){
                    this._scrollBar.setThumbPosition(formerThumbPosition / ratio * formerRatio);
                    this._setTranslate();
                }
            }
        } else {
            // Not Overflow
            if (!overflowIndicator.empty()) {
                legendContent.selectAll('defs').remove();
                overflowIndicator.remove();
                this._scrollBar = undefined;
            }
            legendContent.attr('clip-path', null);
        }
    };

    ColorLegend.prototype.render = function(selection, loadMore) {
        this._parent = selection;
        this._overflowOffset = 0;
        this._lastRowOffset = 0;

        ColorLegend.superclass.render.apply(this, arguments);

        if ((!this.isVisible() && !this._isDedicated )|| !this._colorShapeScale) {
            selection.selectAll('g.v-content').remove();
            return this;
        }
        var cDomain = this._getAvailableDomain();

        var legendContentNode = this._createLegendContent(this._parent, cDomain, loadMore).node();

        if(this._properties.origin.get("legendGroup.layout.alignment") === "center" &&
            (this._position === "top" || this._position === "bottom")) {
            if(legendContentNode) {
                var legendContentWidth = legendContentNode.getBoundingClientRect().width;
                if(!this._renderedWidth || this._renderedWidth < legendContentWidth) {
                    this._renderedWidth = legendContentWidth;
                }
                if(this._bound) {
                    var boundWidth = this._bound.getAttribute("width");
                    this._bound.setAttribute("x", 0);
                    if(parseFloat(boundWidth) > 0) {
                        this._bound.setAttribute("width", Math.min(boundWidth, this._renderedWidth));
                        this._bound.setAttribute("x", -HORIZONTAL_OFFSET);
                        if(this._isRTL()) {
                            var legendBodyBound = selection.select('rect.v-legend-body-bound');
                            legendBodyBound.attr('x', parseFloat(legendBodyBound.attr('x')) +
                                (this._lastRowOffset ? 0 : this._overflowOffset));
                            var groups = selection.selectAll('g.v-groups');
                            var groupBBox = GeometryUtils.getBBox(groups.node());
                            groups.attr('transform', 'translate(' +
                                (Math.min(boundWidth, this._renderedWidth) - groupBBox.width +
                                (this._lastRowOffset ? 0 : this._overflowOffset)) + ', 0)');
                            if (this._properties.get("title.visible") === true) {
                                var titleWrapper = selection.select('.viz-legend-title');
                                var titleNode = titleWrapper.node();
                                titleWrapper.select('tspan').attr("x",
                                    Math.min(boundWidth, this._renderedWidth) -
                                    titleNode.getBoundingClientRect().width - this._markerSize);
                            }
                        }

                    }
                }
                if(!this._isScrollable() ||
                   (this._isScrollable() && this._width > this._renderedWidth)) {
                    this._width = this._renderedWidth;
                }
            }
        }

        this._postRenderer = this._properties.get("postRenderer");
        if(this._postRenderer) {
            var dataOption = {
                dataModel: this._data,
                DataSelector: DataSelector,
                domain: cDomain.slice(),
                effectManager: this.runtime().effectManager(),
                itemInfo: this._getGroupItemInfo(cDomain)
            };
            var rendererOption = {
                target: selection,
                x: cDomain.postRenderX,
                y: cDomain.postRenderY,
                markerSize: cDomain.markerSize
            };

            this._adjustRendererOption(rendererOption);
            this._postRenderer(dataOption, rendererOption);
        }

        return this;
    };

    // Create an array of context information for every legend item.
    ColorLegend.prototype._getContentDomain = function(bound){
        var wrap = this._getWrapText();
        var colorShapeScale = this._colorShapeScale;
        var hideNoValueLabel = this._properties.origin.get("general.hideNoValueLabel");
        var len;
        if (this._isScrollable()) {
            len = colorShapeScale.getLength();
        } else {
            len = Math.min(colorShapeScale.getLength(), this._getMaxNumOfItems());
        }

        var items = [];
        for (var i = 0; i < len; i++) {
            items.push(colorShapeScale.getItem(i));
        }
        items = this._sort(items);

        var cDomain = this._calcDomain(items, hideNoValueLabel);

        cDomain.width = bound.width;
        cDomain.height = bound.height;
        //use given height/width if no max height/width limit
        cDomain.maxWidth = bound.maxWidth || bound.width;
        cDomain.maxHeight = bound.maxHeight || bound.height;
        cDomain.wrap = wrap;
        cDomain.len = len;
        this._calcMetaInfo(cDomain);
        this._calcItemLayout(cDomain);
        this._calcItemPosition(cDomain);

        return cDomain;
    };

    ColorLegend.prototype._calcDomain = function(items, hideNoValueLabel){
        return items.map(function(item, i){
            item.id = i;
            var text = this._toValueString(item.data, hideNoValueLabel);
            var color = item.color;
            if(TypeUtils.isString(color) && color && color.indexOf("url") === -1) {
                color = NameColorUtils.convertColor(color);
            }
            return {
                id: i,
                val: item.data,
                text: text,
                ctx: item.context,
                color: color,
                cls: item.cls,
                shape: item.shape,
                pattern: item.pattern,
                isSemantic : item.isSemanticItem
            };
        }, this);
    };

    ColorLegend.prototype._getMarkerWidth = function(markerSize){
        return markerSize;
    };

    // Calculate all useful things that'll be used in layout and rendering.
    ColorLegend.prototype._calcMetaInfo = function(cDomain){
        var labelFont = this._labelFont;
        var fontSize = labelFont.fontSize;

        var textHeight = parseInt(labelFont.fontSize, 10);
        var markerMargin = this._markerMargin;
        var colorMarkerSize = this._properties.get("marker.size");
        colorMarkerSize = colorMarkerSize && parseFloat(colorMarkerSize);
        var isHorizontal = this.isHorizontal();
        var isScrollable = this._isScrollable();
        var paddingBottom = markerMargin.bottom * textHeight;
        var markerSize = this._colorLabelSize * textHeight;
        var markerWidth = this._getMarkerWidth(markerSize);
        var eachRowHeight = (1 + markerMargin.bottom) * textHeight;
        var paddingWidth = (isHorizontal ? markerMargin.left + markerMargin.right : markerMargin.right) * textHeight;

        if(colorMarkerSize && colorMarkerSize > textHeight){
            paddingBottom = markerMargin.bottom * colorMarkerSize;
            markerSize = colorMarkerSize;
            markerWidth = this._getMarkerWidth(markerSize);
            eachRowHeight = (1 + markerMargin.bottom) * colorMarkerSize;
        }
        this._markerSize = markerSize;

        var textWidthLimit = cDomain.maxWidth - paddingWidth - markerWidth;
        if (isScrollable) {
            textWidthLimit -= this._scrollThumbSpace;
        }

        var availableLabelCount;
        if(isHorizontal || isScrollable){
            availableLabelCount = cDomain.length;
        }else{
            if (!TypeUtils.isNumeric(cDomain.height)) {
                cDomain.height = eachRowHeight * cDomain.len;
            }
            availableLabelCount = Math.min(Math.floor(cDomain.height * 2 / eachRowHeight), cDomain.length);
        }

        var maxTextWidth = 0;
        for (var i = 0; i < availableLabelCount; i++) {
            var text = cDomain[i].text;
            //only width is used now
            var textSize = { width : TextUtils.getTextLength(text, StyleUtils.convertToCss(labelFont))};

            if (textSize.width > textWidthLimit && cDomain.wrap > 1) {
                var wrappedTextInfo = TextUtils.wrapText(cDomain[i].text, [" "], textWidthLimit, cDomain.wrap,
                    labelFont);
                cDomain[i].text = wrappedTextInfo.lines;
                textSize = {
                    height : textHeight * wrappedTextInfo.lines.length,
                    width : wrappedTextInfo.maxWidth
                };
            }
            cDomain[i].textSize = textSize;
            maxTextWidth = Math.max(maxTextWidth, textSize.width);
        }
        if(isHorizontal){
            maxTextWidth = Math.min(maxTextWidth, this._maxItemTextWidth);
        }


        var eachItemWidth = maxTextWidth + markerSize + paddingWidth;
        if (!isHorizontal && isScrollable) {
            eachItemWidth += this._scrollThumbSpace;
        }
        if(!TypeUtils.isNumeric(cDomain.width)) {
            cDomain.width = eachItemWidth;
        }

        var overallHeight = Math.max(markerSize, textHeight);
        var bottom = markerMargin.bottom * textHeight / 2;
        var shapeX = markerSize / 2 + HORIZONTAL_OFFSET;
        var shapeY = overallHeight / 2 + bottom;
        var textX = markerSize + markerMargin.right * textHeight + HORIZONTAL_OFFSET;
        var textY = ((overallHeight - textHeight) / 2 + bottom);
        var postRenderX = markerSize / 2 + HORIZONTAL_OFFSET;
        var postRenderY = overallHeight / 2 + bottom;

        cDomain.shapeX = shapeX;
        cDomain.shapeY = shapeY;
        cDomain.textX = textX;
        cDomain.textY = textY;
        cDomain.postRenderX = postRenderX;
        cDomain.postRenderY = postRenderY;
        cDomain.overallHeight = overallHeight;
        cDomain.maxHeight = cDomain.height - this._pos.y;
        cDomain.maxTextWidth = maxTextWidth;
        cDomain.minTextWidth = TextUtils.getTextLength("M...", StyleUtils.convertToCss(labelFont));
        cDomain.ellipsisWidth = TextUtils.getTextLength("...", StyleUtils.convertToCss(labelFont));
        cDomain.ellipsisItemWidth = cDomain.ellipsisWidth + HORIZONTAL_OFFSET;
        cDomain.eachRowHeight = eachRowHeight;
        cDomain.markerSize = markerSize;
        cDomain.textHeight = textHeight;
        cDomain.colorMarkerSize = colorMarkerSize;
        cDomain.paddingWidth = paddingWidth;
        cDomain.paddingBottom = paddingBottom;
        cDomain.miscWidth = markerSize + paddingWidth;
        cDomain.eachItemWidth = eachItemWidth;
        cDomain.availableLabelCount = availableLabelCount;
        cDomain.maxRowCount = Math.floor(cDomain.maxHeight / cDomain.eachRowHeight);
        cDomain._intervalLen = 0;
        var ellipsisOptions = {};
        var envManager = this.runtime().envManager();
        ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());
        cDomain.ellipsisOptions = ellipsisOptions;
        cDomain.markerMarginRight = markerMargin.right * textHeight;
        this._cDomain = cDomain;
        this._getIntervalInfo(cDomain);

        if (this._maxWidth !== 0) {
            cDomain.width = Math.min(this._maxWidth, cDomain.width);
        }

    };

    ColorLegend.prototype._calcHorizontalFullLegendLayout = function(cDomain){
        var totalCount = cDomain.length;
        if (this._getMaxNumOfItems() < this._colorShapeScale.getLength()) {
            totalCount++;
        }
        var columnCount = totalCount;
        var rowCount = 1;
        var i, j, k, item, index;
        var validInfo = [];
        var maxRowCount = cDomain.maxRowCount;
        // Check every possible column count to find out the best one
        for(columnCount = 1; columnCount <= totalCount; ++columnCount){
            var totalRowCount = Math.ceil(totalCount / columnCount);
            rowCount = Math.min(totalRowCount, maxRowCount);
            // Ensure there's at least one visible legend, the second one will be "..."
            var actualCount = Math.max(rowCount * columnCount, 2);

            var columnWidths = [];
            for(i = 0; i < columnCount; ++i){
                var columnMaxWidth = 0;
                for(j = 0; j < rowCount; ++j){
                    index = j * columnCount + i;
                    // If overflow, the right-bottom item should be replaced with "..."
                    // so we should not count in the width of the this last item
                    if(index !== actualCount - 1 || actualCount >= cDomain.length){
                        item = cDomain[index];
                        if(item){
                            columnMaxWidth = Math.max(columnMaxWidth, item.textSize.width);
                        }
                    }
                }
                columnWidths[i] = columnMaxWidth;
            }

            var widthSum = 0;
            for(j = 0; j < columnCount; ++j){
                widthSum += columnWidths[j] + cDomain.miscWidth;
            }
            // 1 column is always a valid option, so there always exists an option.
            if(widthSum <= cDomain.width || columnCount === 1){
                validInfo.push({
                    totalRowCount: totalRowCount,
                    columnCount: columnCount,
                    rowCount: rowCount,
                    // the actual visible item count
                    actualCount: actualCount < totalCount ? actualCount - 1 : totalCount,
                    // the blank count in the last incomplete row
                    holeCount: totalCount % columnCount && (columnCount - totalCount % columnCount),
                    columnWidths: columnWidths
                });
            }
        }
        // the best layout should show most legends, fewest rows, and minimal hole counts
        validInfo.sort(function(a, b){
            if(a.actualCount === b.actualCount){
                if(a.totalRowCount === b.totalRowCount){
                    return a.holeCount - b.holeCount;
                }
                return a.totalRowCount - b.totalRowCount;
            }
            return b.actualCount - a.actualCount;
        });
        var result = validInfo[0];
        for(i = cDomain.length; i--;){
            if(i < result.columnCount * result.rowCount){
                cDomain[i].labelWidth = result.columnWidths[i % result.columnCount];
            }
        }
        return {
            columnCount: result.columnCount,
            rowCount: result.rowCount
        };
    };

    // Determine rowCount and columnCount, and labelWidth and itemWidth for every item
    ColorLegend.prototype._calcItemLayout = function(cDomain){
        var totalCount = cDomain.availableLabelCount;
        var columnCount = 1;
        var rowCount = totalCount;
        var eachLabelWidth;
        var i, item;
        var intLen = cDomain.eachRowHeight * Constants.LEGEND.SEMANTIC_ITEMS_INTERVAL;

        if(this.isHorizontal()){
            if(this._isScrollable()){
                columnCount = totalCount;
                rowCount = 1;
            }else{
                if(this._properties.get('showFullLabel')){
                    var result = this._calcHorizontalFullLegendLayout(cDomain);
                    columnCount = result.columnCount;
                    rowCount = result.rowCount;
                }else{
                    var buffer;
                    if (this._getMaxNumOfItems() < this._colorShapeScale.getLength()) {
                        buffer = 1;
                    } else {
                        buffer = 0;
                    }
                    columnCount = Math.max(Math.floor((cDomain.width) /
                        cDomain.eachItemWidth), 1);
                    rowCount = Math.ceil((totalCount + buffer) / columnCount);

                    // Legend layout calculation will do twice, one is in getPreferredSize, the other is in render.
                    // The first time does not exclude the axis size, so there might be cases that
                    // the actual renderred row count is larger than the pre-calculated row count in getPreferredSize.
                    // So we keep the first-time row count, and ensure the second time row count does not exceed it.
                    if(this._maxRowCount && rowCount > this._maxRowCount){
                        rowCount = this._maxRowCount;
                    }
                    rowCount = Math.min(cDomain.maxRowCount, rowCount);

                    eachLabelWidth = Math.min(cDomain.maxTextWidth, this._maxItemTextWidth);
                }
                // If only allowed to show one legend, the ... should be shown beside it, so reserve a column for it.
                if(columnCount === 1 && totalCount > 1 && cDomain.eachRowHeight * 2 > cDomain.height - this._pos.y){
                    columnCount = 2;
                }

                if (this._getMaxNumOfItems() === columnCount && columnCount != this._colorShapeScale.getLength()) {
                    rowCount = Math.min(cDomain.maxRowCount, 2);
                }
            }
            if (rowCount === 1 && cDomain._intervalIndex >= 0) {
                cDomain._intervalLen = intLen;
            }
        } else {
            // vertical
            if (cDomain._intervalIndex >= 0) {
                cDomain._intervalLen = intLen;
            }
        }

        for(i = cDomain.length; i--;){
            item = cDomain[i];
            // labelWidth is the width of the legend text area
            item.labelWidth = item.labelWidth || eachLabelWidth || (item.textSize && item.textSize.width);
            // itemWidth is the total legend item width, including marker size and paddings
            item.itemWidth = item.labelWidth + cDomain.miscWidth;
        }
        // If there's only one row, and overflow, should try to put "..." on the same row,
        // and show as many legends as possible.
        if(this.isHorizontal() && cDomain.maxRowCount === 1 && totalCount > columnCount){
            var actualWidth = cDomain.ellipsisItemWidth;
            for(i = 0; i < columnCount; ++i){
                actualWidth += cDomain[i].itemWidth;
            }
            if(actualWidth <= cDomain.width - this._pos.x){
                columnCount++;
            }
        }
        for(i = cDomain.length; i--;){
            item = cDomain[i];
            item.colIndex = i % columnCount;
            item.rowIndex = Math.floor(i / columnCount);
        }
        cDomain.columnCount = columnCount;
        cDomain.rowCount = rowCount;
        if(!this._maxRowCount){
            this._maxRowCount = rowCount;
        }
    };

    // Determine coordinate x, y for every item.
    ColorLegend.prototype._calcItemPosition = function(cDomain){
        var isScrollable = this._isScrollable();
        var isHorizontal = this.isHorizontal();

        var labelsCount = this._colorShapeScale.getLength();
        var eachRowHeight = cDomain.eachRowHeight;
        var columnCount = cDomain.columnCount, rowCount = cDomain.rowCount;
        cDomain.lastRowIdxOffset = columnCount * rowCount - cDomain.length;
        if(cDomain.lastRowIdxOffset < 0) {
            // There is no enough space to show all items, then one position will be taken by '...'
            cDomain.lastRowIdxOffset = 1;
        }

        var xPos = 0;
        var yPos = 0;
        var end = cDomain.length;
        //please note if i is large enough, we may need to draw the Interval line
        var maxLine, itemInterval, textLength;

        this._isOverflow = Math.min(this._getMaxNumOfItems(), cDomain.length) < this._colorShapeScale.getLength();

        for (var i = 0; i < cDomain.length; i++) {
            var item = cDomain[i];

            if (isHorizontal) {
                // Horizontal Legend
                if (!isScrollable) {
                    // Horizontal - unScrollable
                    if(item.colIndex === 0 && i > 0){
                        xPos = 0;
                        yPos += eachRowHeight;
                    }
                    if(item.colIndex === cDomain.columnCount - 1 && (
                            // there is no space to show a new row
                            (labelsCount - i > 1 && yPos + eachRowHeight * 2 > cDomain.height - this._pos.y) ||
                            // this is the last item in this row, and it should be replace by "..."
                            (item.colIndex > 0 && xPos + item.itemWidth > cDomain.width - this._pos.x)
                        )){
                        this._isOverflow = true;
                        end = i;
                        if(i === 0){
                            // Ensure there's at least one legend
                            end = 1;
                            item.pos = {
                                x: xPos,
                                y: yPos
                            };
                        }
                        break;
                    }
                    item.pos = {
                        x: xPos,
                        y: yPos
                    };
                    if(this._isRTL()) {
                        if(rowCount > 1 && cDomain.lastRowIdxOffset > 0 && item.rowIndex === rowCount - 1) {
                            var row = item.rowIndex - 1, col = item.colIndex + cDomain.lastRowIdxOffset;
                            var idx = row * columnCount + col;
                            item.pos.x = cDomain[idx].pos.x;
                            item.itemWidth = cDomain[idx].itemWidth;
                            item.labelWidth = cDomain[idx].labelWidth;
                            if(item.colIndex === 0) {
                                this._lastRowOffset = item.pos.x;
                            }
                        }
                    }
                    xPos += item.itemWidth;
                    if(cDomain._intervalIndex >= 0 && i === cDomain._intervalIndex) {
                        xPos += cDomain._intervalLen;
                    }
                } else {
                    // Horizontal - scrollable
                    var maxWidth = cDomain.width - this._pos.x;
                    if (xPos + item.itemWidth > maxWidth) {
                        this._isOverflow = true;
                    }
                    maxWidth = cDomain._intervalLen + cDomain.width * this._pageCount - this._pos.x;
                    item.pos = {
                        x: xPos,
                        y: yPos
                    };
                    xPos += item.itemWidth;
                    if(cDomain._intervalIndex >= 0 && i === cDomain._intervalIndex) {
                        xPos += cDomain._intervalLen;
                    }
                    if (xPos > maxWidth) {
                        end = i + 1;
                        break;
                    }
                }
            } else {
                // Vertical
                var maxHeight = cDomain.height - this._pos.y;
                cDomain.lines = cDomain.lines !== undefined ? cDomain.lines : 0;
                itemInterval = 0;
                textLength = TypeUtils.isArray(item.text) ? item.text.length : 1;
                if(cDomain._intervalIndex >= 0 && i > cDomain._intervalIndex) {
                    itemInterval = cDomain._intervalLen;
                }
                maxLine = Math.floor((maxHeight + cDomain.paddingBottom - itemInterval) / eachRowHeight);
                if (TypeUtils.isArray(item.text)) {
                    //text has been wrapped to array
                    cDomain.lines += textLength;
                } else {
                    cDomain.lines += 1;
                }

                var legendTotalHeight = (eachRowHeight * cDomain.lines + itemInterval) - cDomain.paddingBottom;
                if (legendTotalHeight > maxHeight) {
                    this._isOverflow = true;
                }
                if(this._isOverflow){
                    maxHeight = isScrollable ?
                            cDomain.height * this._pageCount - this._pos.y :
                            maxHeight - cDomain.textHeight;
                }
                if (maxLine <= 0) {
                    end = 0;
                    break;
                }
                if (legendTotalHeight > maxHeight) {
                    // pop up one legend item
                    if (!isScrollable) {
                        if (TypeUtils.isArray(item.text) && (textLength > 1)) {
                            if (cDomain.lines === maxLine + textLength) {
                                break;
                            }

                            var line = maxLine + textLength - cDomain.lines;
                            if (i !== cDomain.length - 1) {
                                //Need reserve one line for "..."
                                line = line - 1;
                            } else {
                                this._isOverflow = false;
                            }
                            if (line === 0) {
                                end = i;
                            } else {
                                end = i + 1;
                            }

                            //decrease line sum to fit area if !isScrollable
                            item.line = line;
                            item.pos = {
                                x: 0,
                                y: eachRowHeight * (cDomain.lines - textLength) + itemInterval
                            };
                        } else {
                            end = i - 1;
                        }
                    } else {
                        cDomain.lines = cDomain.lines - 1;
                        end = i;
                    }
                    break;
                } else {
                    item.pos = {
                        x: 0,
                        y: eachRowHeight * (cDomain.lines -
                            (TypeUtils.isArray(item.text) ? textLength : 1)) + itemInterval
                    };
                    if (!isScrollable && cDomain.lines === maxLine && i !== cDomain.length - 1) {
                        if (TypeUtils.isArray(item.text) && (textLength > 1)) {
                            item.line = textLength - 1;
                            end = i + 1;
                        } else {
                            end = i;
                        }
                    }
                }
            }
        }
        cDomain.splice(end, cDomain.length - end);
    };

    ColorLegend.prototype._getItemCells = function(cDomain){
        var sortedCells = [];
        var row, i, j, trendLineLegend = trendlineLegendLength(cDomain);
        if (this._isScrollable()) {
            var isHorizontal = this.isHorizontal();
            var len = this._colorShapeScale.getLength() - trendLineLegend;
            var rowCount = isHorizontal ? 1 : len;
            var columnCount = isHorizontal ? len : 1;
            for(i = 0; i < rowCount; ++i){
                row = [];
                for(j = 0; j < columnCount; ++j){
                    row.push({
                        id: isHorizontal ? j : i
                    });
                }
                sortedCells.push(row);
            }
        } else {
            for (i = 0; i < cDomain.length - trendLineLegend; i++) {
                var item = cDomain[i];
                var rowIndex = item.rowIndex;
                var colIndex = item.colIndex;
                row = sortedCells[rowIndex] = sortedCells[rowIndex] || [];
                row[colIndex] = {
                    id: item.id
                };
            }
        }
        return sortedCells;
    };

    ColorLegend.prototype._getContentSize = function(cDomain){
        var contentSize = 0;
        if (this._isScrollable()) {
            if (this.isHorizontal()) {
                var last = cDomain[cDomain.length - 1];
                contentSize = last.pos.x + last.itemWidth;
            } else {
                contentSize = cDomain.eachRowHeight * cDomain.lines + cDomain._intervalLen;
            }
        }
        return contentSize;
    };

    ColorLegend.prototype._getAvailableDomain = function() {
        var cDomain = this._getContentDomain({height : this._height, width : this._width});
        this._cells = this._getItemCells(cDomain);
        this._contentSize = this._getContentSize(cDomain);
        return cDomain;
    };

    ColorLegend.prototype._getIntervalInfo = function(cDomain){
        //if _intervalIndex === n, it means the interval Line is displayed after the nth item,
        cDomain._intervalLen = 0;
        cDomain._intervalIndex = -1;

        var items = [];
        if (this._colorShapeScale.items) {
            items = this._colorShapeScale.items();
        }
        if (!this.getOrderByFunc() && items.length > 1) {
            for (var i = 0; i < items.length; ++i) {
                if (!items[i].isSemanticItem) {
                    cDomain._intervalIndex = i - 1;
                    break;
                }
            }
        }
    };

    ColorLegend.prototype.getOffset = function(){
        return {
            x: this._offset.x,
            y: this._offset.y
        };
    };

    ColorLegend.prototype.getActiveLevels = function() {
        return this._cells;
    };


    ColorLegend.prototype._getMaxNumOfItems = function() {
        var maxNumStr = this._properties.get("maxNumOfItems");
        var maxNum = parseInt(maxNumStr);

        if(maxNumStr == null) {
            maxNum = Number.POSITIVE_INFINITY;
        }
        else {
            if(maxNum.toString() !== maxNumStr.toString()) {
                maxNum = Number.POSITIVE_INFINITY;
            }
            else if(isNaN(maxNum)) {
                maxNum = Number.POSITIVE_INFINITY;
            }
            else if(maxNum < 1){
                maxNum = Number.POSITIVE_INFINITY;
            }
            else {
                maxNum = Math.floor(maxNum);
            }
        }
        return maxNum;
    };

    ColorLegend.prototype._getBodyPreferredSize = function(bound) {
        var maxHeight = 0;
        var maxWidth = 0;
        var minWidth = 0;
        var minHeight = 0;
        var cDomain;
        var isScrollable = this._isScrollable();
        var isHorizontal = this.isHorizontal();
        this._maxWidth = 0;
        this._setupThemeStyleDef();

        var labelsCount = this._colorShapeScale.getLength();
        this._maxRowCount = 0;
        if (labelsCount > 0) {
            var markerMargin = this._markerMargin;
            cDomain = this._getContentDomain(bound);
            //get actual lines in case of wrap text s
            var actualCount = cDomain.lines;
            actualCount = Math.min(actualCount, this._getMaxNumOfItems());
            var eachRowHeight = cDomain.eachRowHeight;
            minWidth = Math.min(cDomain.minTextWidth, cDomain.maxTextWidth) + cDomain.miscWidth;
            if (isHorizontal) {
                // horizontal layout
                maxWidth = bound.width;
                if (isScrollable) {
                    maxHeight = eachRowHeight + this._scrollThumbSpace;
                    minHeight = maxHeight;
                } else {
                    maxHeight = cDomain.rowCount * eachRowHeight;
                    minHeight = eachRowHeight;
                }
            } else {
                //vertical layout
                maxWidth = cDomain.eachItemWidth;
                if (isScrollable) {
                    minWidth += this._scrollThumbSpace;
                }
                if (!isScrollable && actualCount < labelsCount) {
                    actualCount++;
                }
                maxHeight = eachRowHeight * actualCount + cDomain._intervalLen;
                minHeight = eachRowHeight + (labelsCount > 1 ? cDomain.textHeight : 0);
            }
        }

        if (isScrollable && this._getMaxNumOfItems() < this._colorShapeScale.getLength()) {
            var splitLineInterval = 0;
            if (this._getMaxNumOfItems() - 1 > cDomain._intervalIndex && cDomain._intervalIndex > -1) {
                splitLineInterval = cDomain.eachRowHeight * Constants.LEGEND.SEMANTIC_ITEMS_INTERVAL;
            }
            if (isHorizontal) {
                var horizontalAccWidth = 0;
                var minNumOfItem = Math.min(this._getMaxNumOfItems(), cDomain.length);
                for (var j = 0; j < minNumOfItem; ++j) {
                    var singleItemWidth = cDomain[j].textSize.width + cDomain.markerSize + cDomain.paddingWidth;
                    horizontalAccWidth += singleItemWidth;
                }
                maxWidth = horizontalAccWidth + splitLineInterval;
                this._maxWidth = maxWidth;
                if (maxWidth < minWidth) {
                    minWidth = maxWidth;
                }
            } else {
                maxHeight = this._getMaxNumOfItems() * cDomain.eachRowHeight + splitLineInterval;
                if (maxHeight < minHeight) {
                    minHeight = maxHeight;
                }
            }
        }

        return {
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            minWidth: minWidth,
            minHeight: minHeight
        };
    };

    ColorLegend.prototype._sort = function(items) {
        var orderFn = this.getOrderByFunc();
        return orderFn ? items.sort(orderFn) : items;
    };

    ColorLegend.prototype.getOrderByFunc = function() {
        var orderBy = this._properties.get("order");
        if (typeof orderBy === "function") {
            var textify = this._toValueString.bind(this);
            return function(m, n) {
                return orderBy(textify(m.data), textify(n.data));
            };
        }
        return undefined;
    };

    ColorLegend.prototype._shouldInitColorShapeScale = function(){
        return !this._colorShapeScale && this._colorScale;
    };

    ColorLegend.prototype._initColorShapeScale = function() {
        if (this._shouldInitColorShapeScale()) {
            var merger = this._buildColorShapeScale(this._colorScale);
            this._colorShapeScale = merger;
            this.setBindingFields(merger.getBindingFields());
            if(this._properties && this._properties.parentLevel &&
                    this._properties.parentLevel.get("plotArea.trendLine"))
            {
                merger._items = merger._items.concat(this._ColorShapeItemHooks(this, merger._items));
            }
        }
    };

    ColorLegend.prototype._buildColorShapeScale = function(colorScales) {
        var semanticMgr = this.runtime().semanticManager();
        var markMgr = this.runtime().markManager();
        var defaultMarkerShape = this._getLegendMarkerShape();

        if (!defaultMarkerShape && markMgr.getMode() === "single"){
            defaultMarkerShape = markMgr.getShape();
        }
        var ignoreNoValue = this._properties.get('ignoreNoValue');

        if (defaultMarkerShape && !markMgr.locked()) {
            markMgr.setShape(defaultMarkerShape);
        }

        var colorShapeScaleMerger = new ColorShapeScaleMerger(markMgr);

        this._hasOnlyOneMeasure = false;
        if (semanticMgr.hasDataPointColorStyle() || semanticMgr.hasDataPointLineStyle()) {
            colorShapeScaleMerger.setSemanticColorScale(semanticMgr.getDataPointColorScale());
        }

        if(!semanticMgr.isOverrideMode() || (!semanticMgr.hasDataPointColorStyle() &&
            !semanticMgr.hasDataPointLineStyle())) {
            for (var index = 0; index < colorScales.length; index++) {
                colorShapeScaleMerger.addColorScale(colorScales[index]);
            }
        }

        if (this._shapeScale !== null) {
            colorShapeScaleMerger.setShapeScale(this._shapeScale);
        }

        colorShapeScaleMerger.merge(defaultMarkerShape, ignoreNoValue, this._data);

        return colorShapeScaleMerger;
    };

    ColorLegend.prototype._getLegendMarkerShape = function() {
        var shape = this._properties.get("marker.shape") ||
            this._properties.origin.get('plotArea.marker.shape');
        if(Constants.LEGEND_MARKER_SHAPE.indexOf(shape) === -1) {
            shape = this._properties.getDefault("marker.shape") ||
                this._properties.origin.getDefault('plotArea.marker.shape');
        }
        return shape;
    };

    ColorLegend.prototype._setupThemeStyleDef = function() {
        ColorLegend.superclass._setupThemeStyleDef.apply(this, arguments);
        var props = this._properties;
        this._markerMargin.bottom = NumberUtils.getPositiveNumber(props.get("itemMargin"),
                this._defaultItemMargin);

        var labelFont = this._labelFont;
        props = props.proxy('label.style');
        labelFont.color = props.get("color");
        labelFont.fontFamily = props.get("fontFamily");
        // add a "px" suffix to fontSize, otherwise IE & Firefox will incorrectly measures texts
        labelFont.fontSize = parseFloat(props.get("fontSize")) + "px";
        labelFont.fontWeight = props.get("fontWeight");
        labelFont.fontStyle = props.get("fontStyle");
    };

    ColorLegend.prototype._isScrollable = function() {
        return (this._properties.get('isScrollable') &&
            !this._properties.origin.get("interaction.noninteractiveMode"));
    };

    ColorLegend.prototype.setBindingFields = function(_) {
        ColorLegend.superclass.setBindingFields.apply(this, arguments);
        this._displayTextsConverter = DataUtils.getDisplayTextsConverter(this._bindingFields, this._mndIndex);
        return this;
    };

    ColorLegend.prototype.destroy = function() {
        ColorLegend.superclass.destroy.apply(this, arguments);

        this._colorScale = null;
        this._shapeScale = null;
        this._colorShapeScale = null;
        this._displayTextsConverter = null;
        this._properties = null;

        this._colorLabelSize = null;
        this._markerMargin = null;
        this._maxItemsNum = null;
        this._maxItemTextWidth = null; // For Horizontal layout

        if (this._scrollBar) {
            this._scrollBar.destroy();
        }

        this._scrollBar = null;
        this._hasOnlyOneMeasure = null;
        this._labelFont = null;
        this._type = null;
        this._scrollThumbSpace = null;

        this._contentSize = null;
        this._pageCount = null;
        this._domID = null;
        this._isOverflow = null;
        this._cDomain = null;
        this.BGCOLORPROPS = null;
    };

    ColorLegend.prototype._toValueString = function(values, hideNoValueLabel) {
        var ret = values;
        if (TypeUtils.isArray(values)) {
            if (hideNoValueLabel === true) {
                ret = this._displayTextsConverter(values, true).filter(function(e) {
                    return e !== undefined;
                });
            } else {
                ret = this._displayTextsConverter(values);
            }
            ret = ret.join(" / ");
        }
        if(values && values.callback && typeof values.callback === "function"){
            return values.callback(ret);
        }
        return ret;
    };

    ColorLegend.prototype.hasData = function() {
        this._initColorShapeScale();
        return this._colorShapeScale && this._colorShapeScale.getLength() > 0;
    };

    ColorLegend.prototype.statusChanged = function(status){
        if(status === StatusConstants.LOCALE_CHANGED){
            this._colorShapeScale = null;
        }
    };
    ChartNavigator.register(ChartConstants.COLORLEGEND_NAVIGATOR, null, ItemNavigator);
    ColorLegend.prototype._ColorShapeItemHooks = TrendlineItems;
    return ColorLegend;
});

define('sap/viz/chart/components/container/UIContainer',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/UIComponent",
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/framework/common/util/FunctionUtils'
], function (Constants,
        oo,
        UIComponent,
        LangManager,
        FunctionUtils) {
    var UIContainer = function (runtime, options) {
        UIContainer.superclass.constructor.apply(this, arguments);
        this._renderType = (options && options.renderType != null) ? options.renderType : null;
        this._children = {};
        this._layoutAlgorithm = null;
        this._layoutResult = null;
        this._selections = null;
    };
    oo.extend(UIContainer, UIComponent);

    UIContainer.prototype.setLayoutAlgorithm = function (la) {
        this._layoutAlgorithm = la;
        return this;
    };

    UIContainer.prototype.addAutoLayoutProperties = function (subModuleName) {
        var properties = this._properties;
        var that = this;
        [{
            name: "autoWidth",
            key: "width"
        }, {
            name: "autoHeight",
            key: "height"
        }].forEach(function(propDef) {
            var propName = subModuleName + ".layout." + propDef.name;
            properties.origin.add(propName, {
                defaultValue: 0,
                readonly: true,
                serializable: false,
                get: function() {
                    var layoutResult = that._layoutResult;
                    if (layoutResult) {
                        var moduleResult = layoutResult[subModuleName];
                        if (moduleResult && moduleResult[propDef.key]) {
                            return moduleResult[propDef.key];
                        }
                    }
                    return 0;
                }
            });
        });
    };

    UIContainer.prototype.setChild = function (key, module, option) {
        if (key && module instanceof UIComponent) {
            module.alias = key;
            var child = this._children[key] = this._children[key] || {};
            child.module = module;
            child.option = option || {};
            if(module.supportFixedLayout === true) {
                this.addAutoLayoutProperties(key);
            }
        }
        return this;
    };

    UIContainer.prototype.getChild = function (key) {
        if (key && this._children && this._children[key]) {
            return this._children[key];
        }
        return null;
    };

    UIContainer.prototype._configLayout = function () {

    };

    UIContainer.prototype._postLayout = function (layoutResult) {

    };

    UIContainer.prototype.layout = function (options) {
        var components = this._configLayout(options);
        options = options || {};

     
        options.isRTL = this._isRTL();
        if(this._layoutAlgorithm && this._layoutAlgorithm.layout) {
            this._layoutAlgorithm.config.add({
                isFixedPadding : this._properties.origin.get('general.layout.isFixedPadding')
            });
            this._layoutResult = this._layoutAlgorithm.layout(components || this._children, 
                    options);
            this._postLayout(this._layoutResult);
            return this._layoutResult;
        }
        return {};
    };

    UIContainer.prototype._initRenderBase = function (parentNode) {

        if (this._selections == null) {
            this._selections = {};
        }
        
        var node = parentNode.node();
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                
                if (this._selections[key] != null) {
                    continue;
                }
                var renderTo = this._children[key].module.renderTo();
                if (renderTo.toLowerCase() === 'div' || renderTo === 'BorderDIVFlow') {
                    if (node.tagName.toLowerCase() !== 'div') {
                        FunctionUtils.error(LangManager.getLogMessage('IDS_ERROR_NODE_DIV_IN_SVG'));
                    }
                    this._selections[key] = parentNode.append("div").attr('class', 'v-m-' + key)
                    .style('height', '100%').style('width', '100%');
                } else {
                    if (node.tagName.toLowerCase() === 'div') {
                        this._selections[key] = parentNode.append("svg").style({
                            'position':'absolute',
                            'width':'100%',
                            'height':'100%'
                        }).append(
                            "g").attr('class', 'v-m-' + key);
                    } else {
                        this._selections[key] = parentNode.append("g").attr('class', 'v-m-' + key);
                    }
                }
            }
        }
    };

    UIContainer.prototype.supportExportToContentType = function (options) {
        var length = this._children.length;
        for (var i = 0; i < length; i++) {
            if (this._children.supportExportToContentType) {
                return this._children.supportExportToContentType(options);
            }
        }
    };

    UIContainer.prototype.exportContent = function (options) {
        var length = this._children.length;
        for (var i = 0; i < length; i++) {
            if (this._children.exportContent) {
                return this._children.exportContent(options);
            }
        }
    };

    UIContainer.prototype.clearSize = function(keepSelfSize) {
        if(!keepSelfSize) {
            this._size.height = 0;
            this._size.width = 0;
        }        
        
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var child = this._children[key].module;
                if (child && child.clearSize) {
                    child.clearSize();
                }
            }
        }
        return this;
    };

    UIContainer.prototype.destroy = function () {
        UIContainer.superclass.destroy.call(this);

        var key;
        for (key in this._selections) {
            if (this._selections.hasOwnProperty(key) && this._selections[key]) {
                this._selections[key].remove();
            }
        }
        
        for (key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                
                if (this._children[key] == null) {
                    continue;
                }
                
                var child = this._children[key].module;
                
                if (child && child.destroy) {
                    child.destroy();
                }
                this._children[key] = null;
            }
        }
        
        this._selections = null;
        this._renderType = null;
        this._children = null;
        
        if (this._layoutAlgorithm && this._layoutAlgorithm.destroy) {
            this._layoutAlgorithm.destroy();
        }
        
        this._layoutAlgorithm = null;
    };

    UIContainer.prototype.calculatePaddingInPX = function(prop, width, height){
        var constantPaddingInPX, propertyPaddingInPX;
        var propertyPaddingTopInPX, propertyPaddingRightInPX;
        var propertyPaddingBottomInPX, propertyPaddingLeftInPX;

        var minEdge = Math.min(width, height);
        constantPaddingInPX = Constants.PADDING.DEFAULT;
        if(constantPaddingInPX < 1 && constantPaddingInPX > 0){
            constantPaddingInPX = constantPaddingInPX * minEdge;
        }
        propertyPaddingInPX = prop.get("general.layout.padding");
        if(propertyPaddingInPX < 1 && propertyPaddingInPX > 0){
            propertyPaddingInPX = propertyPaddingInPX * minEdge;
        }
        propertyPaddingTopInPX = prop.get("general.layout.paddingTop");
        if(propertyPaddingTopInPX < 1 && propertyPaddingTopInPX > 0){
            propertyPaddingTopInPX = propertyPaddingTopInPX * minEdge;
        }
        propertyPaddingRightInPX = prop.get("general.layout.paddingRight");
        if(propertyPaddingRightInPX < 1 && propertyPaddingRightInPX > 0){
            propertyPaddingRightInPX = propertyPaddingRightInPX * minEdge;
        }
        propertyPaddingBottomInPX = prop.get("general.layout.paddingBottom");
        if(propertyPaddingBottomInPX < 1 && propertyPaddingBottomInPX > 0){
            propertyPaddingBottomInPX = propertyPaddingBottomInPX * minEdge;
        }
        propertyPaddingLeftInPX = prop.get("general.layout.paddingLeft");
        if(propertyPaddingLeftInPX < 1 && propertyPaddingLeftInPX > 0){
            propertyPaddingLeftInPX = propertyPaddingLeftInPX * minEdge;
        }

        return {
            constantPaddingInPX: constantPaddingInPX,
            propertyPaddingInPX: propertyPaddingInPX,
            propertyPaddingTopInPX: propertyPaddingTopInPX,
            propertyPaddingRightInPX: propertyPaddingRightInPX,
            propertyPaddingBottomInPX: propertyPaddingBottomInPX,
            propertyPaddingLeftInPX: propertyPaddingLeftInPX
        };
    };

    UIContainer.prototype.statusChanged = function(status){
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                if (this._children[key].module.statusChanged) {
                    this._children[key].module.statusChanged(status);
                }
            }
        }
    };

    return UIContainer;

});

define('sap/viz/chart/layout/LegendLayout',[
    "sap/viz/framework/common/util/oo",
    'sap/viz/framework/common/util/PositionUtil',
    "sap/viz/chart/layout/BaseLayout"
], function(oo, PositionUtil, BaseLayout) {

    function LegendLayout(){
        LegendLayout.superclass.constructor.apply(this, arguments);
        this.config.add({
            position: '',
            spacing: 12,
            //TODO: this should be a part of the algorithm, instead of a config
            legendPreferSizes: null
        });
    }

    oo.extend(LegendLayout, BaseLayout);

    LegendLayout.prototype.layout = function(components) {
        var results = {},
            isEnough = false,
            config = this.config,
            width = config.get('totalWidth'),
            height = config.get('totalHeight'),
            legendPreferSizes = config.get('legendPreferSizes'),
            position = config.get('position'),
            spacing = config.get('spacing'),
            isHorizontal = PositionUtil.isHorizontal(position),
            componentsArray = this._dictToArray(components),
            preSizeInfo = _setSizeInfoByOrientation(componentsArray, width, height, legendPreferSizes, isHorizontal);

        var start = 0,
            _finalSize,
            _availableSize = preSizeInfo.availableSize,
            _referenceSize = preSizeInfo.referenceSize,
            _referenceMinSizes = preSizeInfo.referenceMinSizes,
            _maxSizes = preSizeInfo.maxSizes,
            _minSizes = preSizeInfo.minSizes;

        if (d3.sum(_maxSizes) <= _availableSize) {
            isEnough = true;
        }

        for (var index = 0, len = componentsArray.length; index < len; index++) {

            var module = componentsArray[index].module;

            var anchor = {
                x: 0,
                y: 0
            };

            var _maxSize = _maxSizes[index];
            var _minSize = _minSizes[index];

            if (isHorizontal) {
                anchor.x = start;
            } else {
                anchor.y = start;
            }

            if (isEnough && _referenceMinSizes[index] < _referenceSize) {
                start = start + _maxSize;
                _finalSize = _maxSize;
            } else {
                // No enough
                if (_availableSize < _minSize || _referenceMinSizes[index] > _referenceSize) {
                    anchor.width = anchor.height = 0;
                    results[module.alias] = anchor;
                    continue;
                } else if (_availableSize > _maxSize) {
                    start = start + _maxSize;
                    _finalSize = _maxSize;
                    _availableSize = _availableSize - _maxSize - spacing;
                } else {
                    start = start + _availableSize;
                    _finalSize = _availableSize;
                    _availableSize = 0;
                }
            }

            //Set module size
            if (isHorizontal) {
                anchor.width = _finalSize;
                anchor.height = height;
            } else {
                anchor.width = width;
                anchor.height = _finalSize;
            }

            start += spacing;
            
            results[module.alias] = anchor;
        }

        return results;

    };

    function _setSizeInfoByOrientation(components, width, height, legendPreferSizes, isHorizontal) {
        var availableSize, refSize, maxSizes = [],
            minSizes = [],
            refMinSizes = [];

        if (isHorizontal) {
            //Horizontal layout
            availableSize = width;
            refSize = height;

            components.forEach(function(component) {
                var preSize = legendPreferSizes[component.module.alias];
                maxSizes.push(preSize.maxWidth);
                minSizes.push(preSize.minWidth);
                refMinSizes.push(preSize.minHeight);
            });
        } else {
            //Vertical layout
            availableSize = height;
            refSize = width;

            components.forEach(function(component) {
                var preSize = legendPreferSizes[component.module.alias];
                maxSizes.push(preSize.maxHeight);
                minSizes.push(preSize.minHeight);
                refMinSizes.push(preSize.minWidth);
            });
        }
        return {
            'availableSize': availableSize,
            'referenceSize': refSize,
            'maxSizes': maxSizes,
            'minSizes': minSizes,
            'referenceMinSizes': refMinSizes
        };
    }

    return LegendLayout;
});

define('sap/viz/chart/components/legend/LegendGroup',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/container/UIContainer',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/PositionUtil',
    'sap/viz/chart/layout/LegendLayout',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/framework/common/util/ObjectUtils'
], function (oo,
    UIContainer,
    TypeUtils,
    DOM,
    PositionUtils,
    LegendLayout,
    Constants,
    NumberUtils, 
    ObjectUtils) {

    var LegendGroup = function(runtime, options) {
        LegendGroup.superclass.constructor.apply(this, arguments);

        var that = this;

        this._subSelection = {};
        this._position = null;
        this._defaultPosition = null;
        this._legendPreferSizes = null;
        this.setLayoutAlgorithm(new LegendLayout());

        // when having renderTo property, its value is true
        this._isDedicated = false;
        this._maxSize = {
            width: 0,
            height: 0
        };

        this._height = 0;
        this._width = 0;
        this._spacing = 12;

        var properties = this._properties;
        ['height', 'width'].forEach(function(e){
            var prop = {
                set: function(value, obj){
                    if(value === null || parseFloat(value)>=0){
                        return value;
                    }else{
                        return obj.value; /**no change*/
                    }
                }
            };
            properties.add('layout.' + e, prop);
        });

        properties.add('visible', {
            get: function(value, obj){
                var childModules = that._children;
                for (var key in childModules) {
                    if (childModules.hasOwnProperty(key)) {
                        var child = childModules[key].module;
                        if (child.visible()) {
                            return true;
                        }
                    }
                }
                return false;
            }
        });
        //Keep legend group's orientation.
        this.runtime().statusManager().add('legendGroup.isHorizontal');
    };
    oo.extend(LegendGroup, UIContainer);

    var VALID_POSITIONS = ["right", "left", "top", "bottom", "auto"];
    LegendGroup.prototype.getPosition = function () {
        var propId = "layout.position",
            pos = this._defaultPosition || this._position || this._properties.get(propId);
        return VALID_POSITIONS.indexOf(pos) !== -1 ? pos : this._properties.getDefault(propId);
    };

    LegendGroup.prototype.setPosition = function (position) {
        this._position = position;
    };

    LegendGroup.prototype.setDefaultPosition = function(position){
        this._defaultPosition = position;
    };

    LegendGroup.prototype.visible = function() {
        var childModules = this._children;
        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                if (child.visible()) {
                    return true;
                }
            }
        }
        return false;
    };

    LegendGroup.prototype._isPropVisible = function(){
        var childModules = this._children;
        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                if (child.properties('visible')) {
                    return true;
                }
            }
        }
        return false;
    };

    LegendGroup.prototype.isVisible = function() {
        var childModules = this._children;
        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                if (child.isVisible()) {
                    return true;
                }
            }
        }
        return false;
    };

    LegendGroup.prototype._configLayout = function() {
        var components = {};
        if(this._isPropVisible()){
            var childModules = this._children;
            var sizeInfo;
            if (this._isDedicated) {
                sizeInfo = {
                    width: this._maxSize.width,
                    height: this._maxSize.height + this._spacing
                };
            } else {
                sizeInfo = {
                    height: this._height,
                    width: this._width
                };
            }
            for (var key in childModules) {
                if (childModules.hasOwnProperty(key)) {
                    var child = childModules[key];
                    var module = child.module;
                    if (module.visible() || this._isDedicated) {
                        components[key] = child;
                    }
                }
            }

            this._layoutAlgorithm.config.set({
                totalWidth: sizeInfo.width,
                totalHeight: sizeInfo.height,
                position: this.getPosition() || this._properties.get('layout.position'),
                spacing: this._spacing,
                legendPreferSizes: this._legendPreferSizes
            });
        }

        return components;
    };

    LegendGroup.prototype._postLayout = function() {
        var results = this._layoutResult;
        for (var key in results) {
            if (results.hasOwnProperty(key)) {
                var legend = this._children[key].module;
                var size = results[key];
                if (size) {
                    legend.width(size.width).height(size.height);
                }
            }
        }
    };

    function getRenderBase(renderTo, rootElement) {
        if (renderTo === undefined || renderTo === null || 
            (TypeUtils.isFunction(renderTo) && !renderTo())) {
            return rootElement;
        }

        var renderBase = d3.select(renderTo());

        if (renderBase.empty()) {
            return rootElement;
        }
        return renderBase;
    }

    LegendGroup.prototype.render = function(rootElement) {
        var renderTo = this._properties.get('renderTo');
        rootElement = getRenderBase(renderTo, rootElement);
        rootElement.select('.v-m-highlight').remove();

        //add screenReader :role
        rootElement.attr('role','listbox');
        //Check legendGroup has renderTo function
        var renderToNewDom = this._isDedicated ? d3.select(renderTo()) : undefined;
        var childModules = this._children;
        var layoutInfos = null;
        // If set to not visible, ne need to layout
        if(this._isPropVisible()){
            layoutInfos = this.layout();
        }
        
        // Even if invisible, still need to render the v-bound for every legend
        var wrapperOffsets = [];
        var xOffset = 0;
        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                var wrapper = null;

                if (renderToNewDom && !renderToNewDom.empty()) {
                    wrapper = renderToNewDom.selectAll('.v-m-' + key);
                    if (wrapper.empty()) {
                        wrapper = renderToNewDom.append('g').attr('class', 'v-m-' + key);
                    }
                    rootElement.selectAll('.v-m-' + key).selectAll('*').remove();
                } else {
                    if (this._subSelection[key]) {
                        wrapper = rootElement.selectAll('.v-m-' + key);
                    } else {
                        this._subSelection[key] = rootElement.append('g').attr('class', 'v-m-' + key);
                        wrapper = this._subSelection[key];
                    }
                }

                if (this._isDedicated && renderToNewDom) {
                    var dedicatedHeight = child.height();
                    renderToNewDom.attr('height', dedicatedHeight).attr('width', this._maxSize.width);
                }
                child.render(wrapper);
                if (!child.visible()) {
                    continue;
                }
                if (layoutInfos && layoutInfos[key] &&
                        layoutInfos[key].x !== undefined &&
                        layoutInfos[key].y !== undefined) {
                    wrapper.attr('transform', 'translate(' + layoutInfos[key].x + ',' + layoutInfos[key].y + ')');
                }
                if (this._properties.get("layout.alignment") === "center" &&
                    (this._properties.get("layout.position") === "top" || 
                    this._properties.get("layout.position") === "bottom")) {
                    //if child._width is changed, we have to adjust x positon 
                    if (child._width < layoutInfos[key].width) {
                        xOffset += (layoutInfos[key].width - child._width)/2;
                    }      
                    var wrapperItem = {};
                    wrapperItem.wrapper = wrapper;
                    wrapperItem.layoutInfo = layoutInfos[key];
                    wrapperOffsets.push(wrapperItem);
                }
            }
        }

        //adjust all legend itmes location
        for(var i = 0; i < wrapperOffsets.length; i++) {
            var wrapperOffsetItem = wrapperOffsets[i];
            var layoutInfo = wrapperOffsetItem.layoutInfo;
            wrapperOffsetItem.wrapper.attr('transform', 'translate(' + (layoutInfo.x + xOffset) + 
                    ',' + layoutInfo.y + ')');
        }
        this._properties.setDefault("computedVisibility", this.isVisible(), true);
    };

    LegendGroup.prototype.setSize = function(size) {
        var childModules = this._children;

        this._height = size.height;
        this._width = size.width;
        
        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                if (child.visible()) {
                    child.setSize({
                        height: size.height,
                        width: size.width
                    });
                }
            }
        }
        return this;
    };

    LegendGroup.prototype.resetPreviousLimit = function(results) {
        if(this._width && (this._position === "left" ||
            this._position === "right")) {
            results.width = this._width;
            results.minWidth = this._width;
            results.maxWidth = this._width;
        }
        else if(this._height && (this._position === "top" ||
            this._position === "bottom")) {
            results.height = this._height;
            results.minHeight = this._height;
            results.maxHeight = this._height;
        }
    };
    
    LegendGroup.prototype.paginationOptions = function() {
        var dataModel = this._runtime && this._runtime._interaction &&
            this._runtime._interaction._service && this._runtime._interaction._service.getDataModel();
        var paginationOptions;
        if(dataModel && dataModel.getPaginationOptions) {
            paginationOptions = dataModel.getPaginationOptions();
        }
        return paginationOptions;
    };

    LegendGroup.prototype.getPreferredSize = function(bound, isTrellis, isFixSize, options) {
        var results = {
            width: 0,
            height: 0,
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0
        };

        if(!this._isPropVisible()){
            return results;
        }
        var props = this._properties;

        var isLegendGroupForceToShow = (!isTrellis && this._properties.origin.get("legendGroup.forceToShow"));

        var maxHeight = bound.maxHeight = NumberUtils.getSizeValue(props.get('layout.maxHeight'), bound.height);
        var maxWidth = bound.maxWidth = bound.maxWidth ||
            NumberUtils.getSizeValue(props.get('layout.maxWidth'), bound.width);
        var layoutPosition = props.get('layout.position');

        var minWidths = [],
            maxWidths = [],
            minHeights = [],
            maxHeights = [];

        var childModules = this._children;

        var currentWidth = 0;
        var currentHeight = 0;

        this._legendPreferSizes = {};

        var renderTo = props.get('renderTo');
        if (renderTo !== undefined && renderTo !== null && 
            TypeUtils.isFunction(renderTo) && renderTo()) {
            this._isDedicated = true;
        } else {
            this._isDedicated = false;
        }

        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                child.setDedicated(this._isDedicated);
                child.setPosition(this.getPosition());

                if (child.visible() || this._isDedicated) {
                    if (this._isDedicated) {
                        //Set legend properties
                        child.setOrientation('right');
                    } else {
                        child.setOrientation(this.getPosition() || layoutPosition);
                    }

                    var size = child.getPreferredSize(bound);
                    
                    this._legendPreferSizes[key] = size;
                    
                    //if legend group is forceToShow, we have to count the size of legend to 
                    //give the legend the min size.
                    if(!this._isDedicated && !isLegendGroupForceToShow){
                        if (child.isHorizontal()) {                            
                            if (size.minHeight > maxHeight || size.minWidth > bound.width) {
                                continue;
                            }
                        } else {
                            if (size.minWidth > maxWidth || size.minHeight > bound.height) {
                                continue;
                            }
                        }
                    }
                    
                    minWidths.push(size.minWidth);
                    minHeights.push(size.minHeight);
                    maxWidths.push(size.maxWidth);
                    maxHeights.push(size.maxHeight);
                }
            }
        }
        
        var minimums;
        if(isLegendGroupForceToShow) {
            //the min size should make sure all legend can be displayed.
            minimums = {
                width: d3.max(minWidths),
                height: d3.max(minHeights)
            };
        }
        else {
            minimums = {
                width: d3.min(minWidths),
                height: d3.min(minHeights)
            };
        }
        
        var maximums = {
                width: d3.max(maxWidths),
                height: d3.max(maxHeights)
            };

        if (minimums.width > 0 || minimums.height > 0 || maximums.width > 0 || maximums.height > 0) {
            
            if (this.isHorizontal()) {
                currentHeight = bound.maxHeight > maximums.height ? maximums.height : bound.maxHeight;
                currentWidth = maximums.width;

                this._maxSize.width = d3.sum(maxWidths);
                this._maxSize.height = maximums.height;
            } else {
                currentWidth = bound.maxWidth > maximums.width ? maximums.width : bound.maxWidth;
                currentHeight = maximums.height;

                this._maxSize.height = d3.sum(maxHeights);
                this._maxSize.width = maximums.width;
            }
        }

        if (!this._isDedicated) {
            if(isLegendGroupForceToShow) {
                if(currentWidth < minimums.width) {
                    currentWidth = minimums.width;
                }
                
                if(currentHeight < minimums.height) {
                    currentHeight = minimums.height;
                }
            }

            results = {
                width: currentWidth,
                height: currentHeight,
                minWidth: minimums.width,
                maxWidth: maximums.width,
                minHeight: minimums.height,
                maxHeight: maximums.height
            };
            if (this._isRTL() ||
                this._properties.get("layout.alignment") === "center") {
                //for "center" we have to use max height and width to align
                results.maxSize = ObjectUtils.clone(this._maxSize);
            }
        }
        
        var pOptions = options.pagination;
        if( (options.dataChanged && pOptions && pOptions.mode === Constants.PAGINATION_MODE.UPDATE) ||
            (!options.isSizeChanged && options.propertiesChanged === false &&
                pOptions && pOptions.mode === Constants.PAGINATION_MODE.UPDATE && !isFixSize)) {
            //we use "PreviousLimit" to keep plot location being "fixed".
            //please note for left/right legend we need to keep width, and for 
            //top/bottom legend we need to keep height
            this.resetPreviousLimit(results);
        }

        return results;
    };

    LegendGroup.prototype.isHorizontal = function() {
        var position = this.getPosition();
        if(!position) {
            position = this._properties.get("layout.position");
        }
        var isHorizontal = PositionUtils.isHorizontal(position);
        this.runtime().statusManager().set('legendGroup.isHorizontal', isHorizontal);
        return isHorizontal;
    };
    
    LegendGroup.prototype.setData = function() {

        var childModules = this._children;

        for (var key in childModules) {
            if (childModules.hasOwnProperty(key)) {
                var child = childModules[key].module;
                child.setData.apply(child, arguments);
            }
        }
    };
    
    LegendGroup.prototype.destroy = function() {
        LegendGroup.superclass.destroy.call(this);
        
        this.clear();
        
        this._position = null;
        this._subSelection = null;
        this._legendPreferSizes = null;

        this._isDedicated = null;
        this._maxSize = null;

        this._height = null;
        this._width = null;
    };
    
    LegendGroup.prototype.clear = function() {        
        for (var key in this._subSelection) {
            if (this._subSelection.hasOwnProperty(key) && this._subSelection[key]) {
                this._subSelection[key].remove();
                this._subSelection[key] = null;
            }
        }
    };

    LegendGroup.prototype.supportFixedLayout = true;

    return LegendGroup;
});


define('propertyDefs',[], function(){
return {
    "": {
        "general.accDescription": null,
        "general.background.border.bottom.visible": false,
        "general.background.border.left.visible": false,
        "general.background.border.right.visible": false,
        "general.background.border.stroke": "#d8d8d8",
        "general.background.border.strokeWidth": 1,
        "general.background.border.top.visible": false,
        "general.background.color": "transparent",
        "general.background.drawingEffect": "normal",
        "general.background.gradientDirection": "vertical",
        "general.background.visible": true,
        "general.layout.isFixedPadding": false,
        "general.layout.padding": 24,
        "general.layout.paddingBottom": null,
        "general.layout.paddingLeft": null,
        "general.layout.paddingRight": null,
        "general.layout.paddingTop": null,
        "general.tabIndex": 0,
        "legend.drawingEffect": "normal",
        "legend.isScrollable": false,
        "legend.itemMargin": 0.5,
        "legend.label.style.color": "#000000",
        "legend.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "legend.label.style.fontSize": "12px",
        "legend.label.style.fontStyle": "normal",
        "legend.label.style.fontWeight": "normal",
        "legend.marker.size": null,
        "legend.postRenderer": null,
        "legend.scrollbar.border.color": "white",
        "legend.scrollbar.border.width": 0,
        "legend.scrollbar.spacing": 0,
        "legend.scrollbar.thumb.fill": "#e5e5e5",
        "legend.scrollbar.thumb.hoverFill": "#dedede",
        "legend.scrollbar.track.fill": "#f7f7f7",
        "legend.showFullLabel": true,
        "legend.title.style.color": "#000000",
        "legend.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "legend.title.style.fontSize": "14px",
        "legend.title.style.fontStyle": "normal",
        "legend.title.style.fontWeight": "bold",
        "legend.title.text": null,
        "legend.title.visible": false,
        "legend.visible": true,
        "legendGroup.computedVisibility": {
            "defaultValue": true,
            "readonly": true,
            "serializable": false
        },
        "legendGroup.forceToShow": false,
        "legendGroup.layout.alignment": "topLeft",
        "legendGroup.layout.height": null,
        "legendGroup.layout.maxHeight": 0.25,
        "legendGroup.layout.maxWidth": 0.25,
        "legendGroup.layout.position": "right",
        "legendGroup.layout.width": null,
        "legendGroup.linesOfWrap": 1,
        "legendGroup.renderTo": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.dataPoint.stroke.color": "#000000",
        "plotArea.dataPoint.stroke.visible": false,
        "title.alignment": "center",
        "title.layout.height": null,
        "title.layout.maxHeight": 0.2,
        "title.layout.respectPlotPosition": true,
        "title.style.color": "#333333",
        "title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "title.style.fontSize": "16px",
        "title.style.fontStyle": "normal",
        "title.style.fontWeight": "bold",
        "title.text": null,
        "title.visible": false,
        "tooltip.background.borderColor": "#cccccc",
        "tooltip.background.color": "#ffffff",
        "tooltip.bodyDimensionLabel.color": "#666666",
        "tooltip.bodyDimensionValue.color": "#666666",
        "tooltip.bodyMeasureLabel.color": "#666666",
        "tooltip.bodyMeasureValue.color": "#000000",
        "tooltip.closeButton.backgroundColor": "#ffffff",
        "tooltip.closeButton.borderColor": "#cccccc",
        "tooltip.footerLabel.color": "#000000",
        "tooltip.formatString": null,
        "tooltip.layinChart": true,
        "tooltip.postRender": null,
        "tooltip.preRender": {
            "defaultValue": null,
            "serializable": false
        },
        "tooltip.separationLine.color": "#a7a9ac",
        "tooltip.showFullText": {
            "access": "internal",
            "defaultValue": false
        },
        "tooltip.unitFormatType": "FinancialUnits",
        "tooltip.visible": true
    },
    "_bullet": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.ignoreNoValue": false,
        "legend.label.text.target": null,
        "legend.maxNumOfItems": null,
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.actualColor": [
            "#748CB2",
            "#9CC677",
            "#EACF5E",
            "#F9AD79",
            "#D16A7C",
            "#8873A2",
            "#3A95B3",
            "#B6D949",
            "#FDD36C",
            "#F47958",
            "#A65084",
            "#0063B1",
            "#0DA841",
            "#FCB71D",
            "#F05620",
            "#B22D6E",
            "#3C368E"
        ],
        "plotArea.additionalColor": [
            "#A7BFE5",
            "#CFF9AA",
            "#FFFF91",
            "#FFE0AC",
            "#FF9DAF",
            "#BBA6D5",
            "#6DC8E6",
            "#E9FF7C",
            "#FFFF9F",
            "#FFAC8B",
            "#D983B7",
            "#3396E4",
            "#40DB74",
            "#FFEA50",
            "#FF8953",
            "#E560A1",
            "#6F69C1"
        ],
        "plotArea.background.border.bottom.visible": false,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": false,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": false,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.dataPoint.stroke.color": "#ffffff",
        "plotArea.dataPoint.stroke.visible": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": false,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.markerRenderer": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.target.shadowColor": "",
        "plotArea.target.valueColor": "#333333",
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "_dual": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.markerRenderer": null,
        "plotArea.primaryValuesColorPalette": {
            "defaultValue": [
                "#8FBADD",
                "#B8D4E9",
                "#7AAED6",
                "#A3C7E3",
                "#3D88C4",
                "#66A1D0",
                "#297CBE",
                "#5295CA",
                "#005BA3",
                "#146FB7",
                "#005395",
                "#0063B1"
            ],
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.secondaryValuesColorPalette": {
            "defaultValue": [
                "#F6A09B",
                "#F9C3C0",
                "#F58E88",
                "#F8B1AD",
                "#F05B52",
                "#F37D76",
                "#EE4A40",
                "#F16C64",
                "#D92419",
                "#ED382D",
                "#C52117",
                "#EB271B"
            ],
            "serializable": false
        },
        "plotArea.seriesStyle": null,
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#8FBADD",
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": true,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true,
        "valueAxis2.axisLine.size": 1,
        "valueAxis2.axisLine.visible": true,
        "valueAxis2.axisTick.visible": true,
        "valueAxis2.color": "#F6A09B",
        "valueAxis2.label.formatString": null,
        "valueAxis2.label.style.color": "#333333",
        "valueAxis2.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.label.style.fontSize": "12px",
        "valueAxis2.label.style.fontStyle": "normal",
        "valueAxis2.label.style.fontWeight": "normal",
        "valueAxis2.label.unitFormatType": "FinancialUnits",
        "valueAxis2.label.visible": true,
        "valueAxis2.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.height": null,
        "valueAxis2.layout.maxHeight": 0.25,
        "valueAxis2.layout.maxWidth": 0.25,
        "valueAxis2.layout.width": null,
        "valueAxis2.title.applyAxislineColor": true,
        "valueAxis2.title.style.color": "#000000",
        "valueAxis2.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.title.style.fontSize": "14px",
        "valueAxis2.title.style.fontStyle": "normal",
        "valueAxis2.title.style.fontWeight": "bold",
        "valueAxis2.title.style.letterSpacing": null,
        "valueAxis2.title.text": null,
        "valueAxis2.title.visible": false,
        "valueAxis2.visible": true
    },
    "_pie": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(0%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": false,
        "interaction.selected.stroke.width": "1px",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "plotArea.alignment.vertical": {
            "access": "internal",
            "defaultValue": "top"
        },
        "plotArea.background.border.bottom.visible": false,
        "plotArea.background.border.left.visible": false,
        "plotArea.background.border.right.visible": false,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": false,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.distance": 0.1,
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.line.color": "#a8a8a8",
        "plotArea.dataLabel.line.visible": true,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.type": "colorAndPercentage",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.highlight.contextInfos": [],
        "plotArea.markerRenderer": null,
        "plotArea.radius": 0.38,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "tooltip.bodyMeasureValue.type": "value"
    },
    "_scatter": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.adjustScale": false,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorDepth": 1,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPoint.opacity": 0.8,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.markerRenderer": null,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.shapeDepth": 1,
        "plotArea.shapePalette": {
            "defaultValue": [
                "circle",
                "square",
                "diamond",
                "triangleUp",
                "triangleDown",
                "triangleLeft",
                "triangleRight",
                "cross",
                "intersection"
            ],
            "serializable": false
        },
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "_trellis": {},
    "_xy": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.markerRenderer": null,
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.seriesStyle": null,
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "_xySimple": {},
    "info/100_area": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.areaRenderer": null,
        "plotArea.areaStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.markerRenderer": null,
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.seriesStyle": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "tooltip.bodyMeasureValue.type": "percentage",
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "info/100_dual_stacked_bar": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "legend.marker.shape": "squareWithRadius",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "tooltip.bodyMeasureValue.type": "percentage"
    },
    "info/100_dual_stacked_column": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.overlapBehavior": "hideExceededLabels",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "tooltip.bodyMeasureValue.type": "percentage"
    },
    "info/100_horizontal_area": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.areaRenderer": null,
        "plotArea.areaStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.markerRenderer": null,
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.seriesStyle": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "tooltip.bodyMeasureValue.type": "percentage",
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "info/100_stacked_bar": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "legend.marker.shape": "squareWithRadius",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "tooltip.bodyMeasureValue.type": "percentage"
    },
    "info/100_stacked_column": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.overlapBehavior": "hideExceededLabels",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "tooltip.bodyMeasureValue.type": "percentage"
    },
    "info/DEFAULT": {
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        }
    },
    "info/area": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.area.stroke.color": "#000000",
        "plotArea.area.stroke.visible": false,
        "plotArea.areaRenderer": null,
        "plotArea.areaStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.markerRenderer": null,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.seriesStyle": null,
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "info/bar": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.position": "outsideFirst",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "valueAxis.label.allowDecimals": true
    },
    "info/bubble": {
        "plotArea.dataLabel.respectShapeWidth": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "bubbleWidth",
        "plotArea.minMarkerSize": null,
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "plotArea.showNegativeValues": true,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "sizeLegend.drawingEffect": "normal",
        "sizeLegend.formatString": null,
        "sizeLegend.label.style.color": "#000000",
        "sizeLegend.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "sizeLegend.label.style.fontSize": "12px",
        "sizeLegend.label.style.fontStyle": "normal",
        "sizeLegend.label.style.fontWeight": "normal",
        "sizeLegend.title.style.color": "#000000",
        "sizeLegend.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "sizeLegend.title.style.fontSize": "14px",
        "sizeLegend.title.style.fontStyle": "normal",
        "sizeLegend.title.style.fontWeight": "bold",
        "sizeLegend.title.text": null,
        "sizeLegend.title.visible": false,
        "sizeLegend.unitFormatType": "FinancialUnits",
        "sizeLegend.visible": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis2.axisLine.size": 1,
        "valueAxis2.axisLine.visible": true,
        "valueAxis2.axisTick.visible": true,
        "valueAxis2.color": "#6c6c6c",
        "valueAxis2.label.allowDecimals": true,
        "valueAxis2.label.formatString": null,
        "valueAxis2.label.style.color": "#333333",
        "valueAxis2.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.label.style.fontSize": "12px",
        "valueAxis2.label.style.fontStyle": "normal",
        "valueAxis2.label.style.fontWeight": "normal",
        "valueAxis2.label.unitFormatType": "FinancialUnits",
        "valueAxis2.label.visible": true,
        "valueAxis2.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.height": null,
        "valueAxis2.layout.maxHeight": 0.25,
        "valueAxis2.layout.maxWidth": 0.25,
        "valueAxis2.layout.width": null,
        "valueAxis2.title.applyAxislineColor": false,
        "valueAxis2.title.style.color": "#000000",
        "valueAxis2.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.title.style.fontSize": "14px",
        "valueAxis2.title.style.fontStyle": "normal",
        "valueAxis2.title.style.fontWeight": "bold",
        "valueAxis2.title.style.letterSpacing": null,
        "valueAxis2.title.text": null,
        "valueAxis2.title.visible": false,
        "valueAxis2.visible": true
    },
    "info/bullet": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "legend.label.text.negativeGap": null,
        "legend.label.text.positiveGap": null,
        "plotArea.forecastColor": [
            "#D5DADC"
        ],
        "plotArea.gap.negativeColor": "#e34352",
        "plotArea.gap.positiveColor": "#87c27e",
        "plotArea.gap.type": "both",
        "plotArea.gap.visible": false,
        "valueAxis.layout.position": "top"
    },
    "info/column": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.position": "outside",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "valueAxis.label.allowDecimals": true
    },
    "info/combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "valueAxis.label.allowDecimals": true
    },
    "info/donut": {
        "plotArea.highlight.centerName.style.color": null,
        "plotArea.highlight.centerName.style.fontFamily": "Arial, Helvetica, sans-serif",
        "plotArea.highlight.centerName.style.fontSize": "14px",
        "plotArea.highlight.centerName.style.fontStyle": "normal",
        "plotArea.highlight.centerName.style.fontWeight": "normal",
        "plotArea.highlight.centerName.visible": true,
        "plotArea.highlight.centerValue.style.color": null,
        "plotArea.highlight.centerValue.style.fontFamily": "Arial, Helvetica, sans-serif",
        "plotArea.highlight.centerValue.style.fontSize": "22px",
        "plotArea.highlight.centerValue.style.fontStyle": "normal",
        "plotArea.highlight.centerValue.style.fontWeight": "normal",
        "plotArea.highlight.centerValue.visible": true,
        "plotArea.highlight.highlightContext": [],
        "plotArea.highlight.unhighlightSliceColor": "#dddddd",
        "plotArea.innerRadiusRatio": 0.5
    },
    "info/dual_bar": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.position": "outsideFirst",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "value",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "valueAxis.label.allowDecimals": true,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_column": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.position": "outside",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "valueAxis.label.allowDecimals": true,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.dataShape.secondaryAxis": [
            "line",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_horizontal_combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.dataShape.secondaryAxis": [
            "line",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_horizontal_stacked_combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.dataShape.secondaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_line": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.showLine": false,
        "plotArea.callout.label.formatString": null,
        "plotArea.callout.label.style.color": "#333333",
        "plotArea.callout.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.callout.label.style.fontSize": "12px",
        "plotArea.callout.label.style.fontStyle": "normal",
        "plotArea.callout.label.style.fontWeight": "normal",
        "plotArea.callout.label.unitFormatType": "FinancialUnits",
        "plotArea.callout.left": null,
        "plotArea.callout.line.color": "#343434",
        "plotArea.callout.top": null,
        "plotArea.isSmoothed": false,
        "plotArea.lineRenderer": null,
        "plotArea.lineStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.lineVisible": true,
        "plotArea.marker.displayMode": "manual",
        "plotArea.marker.shape": "circle",
        "plotArea.marker.size": 6,
        "plotArea.marker.visible": true,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "plotArea.width": 2,
        "valueAxis.label.allowDecimals": true,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_stacked_bar": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.showTotal": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "valueAxis.label.allowDecimals": true,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_stacked_column": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.overlapBehavior": "hideExceededLabels",
        "plotArea.dataLabel.showTotal": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "valueAxis.label.allowDecimals": true,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_stacked_combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.dataShape.secondaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis2.label.allowDecimals": true
    },
    "info/dual_timeseries_combination": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataLabel.position": "outside",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPoint.invalidity": "break",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.5,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis2.label.allowDecimals": true
    },
    "info/heatmap": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "categoryAxis2.axisLine.size": 1,
        "categoryAxis2.axisLine.visible": true,
        "categoryAxis2.axisTick.shortTickVisible": null,
        "categoryAxis2.axisTick.visible": true,
        "categoryAxis2.color": "#6c6c6c",
        "categoryAxis2.hoverShadow.color": "#cccccc",
        "categoryAxis2.label.alignment": "top",
        "categoryAxis2.label.hideSubLevels": false,
        "categoryAxis2.label.parentStyle.color": null,
        "categoryAxis2.label.parentStyle.fontFamily": null,
        "categoryAxis2.label.parentStyle.fontSize": null,
        "categoryAxis2.label.parentStyle.fontStyle": null,
        "categoryAxis2.label.parentStyle.fontWeight": null,
        "categoryAxis2.label.style.color": "#333333",
        "categoryAxis2.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis2.label.style.fontSize": "12px",
        "categoryAxis2.label.style.fontStyle": "normal",
        "categoryAxis2.label.style.fontWeight": "normal",
        "categoryAxis2.label.visible": true,
        "categoryAxis2.labelRenderer": null,
        "categoryAxis2.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis2.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis2.layout.height": null,
        "categoryAxis2.layout.maxHeight": 0.3,
        "categoryAxis2.layout.maxWidth": 0.3,
        "categoryAxis2.layout.width": null,
        "categoryAxis2.mouseDownShadow.color": "#808080",
        "categoryAxis2.title.applyAxislineColor": false,
        "categoryAxis2.title.style.color": "#000000",
        "categoryAxis2.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis2.title.style.fontSize": "14px",
        "categoryAxis2.title.style.fontStyle": "normal",
        "categoryAxis2.title.style.fontWeight": "bold",
        "categoryAxis2.title.style.letterSpacing": null,
        "categoryAxis2.title.text": null,
        "categoryAxis2.title.visible": false,
        "categoryAxis2.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "legend.formatString": null,
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.marker.shape": "squareWithRadius",
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.onlyShowStartEndLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.selectionFeedback": false,
        "legend.unitFormatType": "FinancialUnits",
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.autoLegendValues": {
            "access": "internal",
            "defaultValue": [],
            "readonly": true,
            "serializable": false
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.border.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": "0.0",
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "white",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.dimensionLabel.renderer": null,
        "plotArea.dimensionLabel.style.color": null,
        "plotArea.dimensionLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dimensionLabel.style.fontSize": "12px",
        "plotArea.dimensionLabel.style.fontStyle": "normal",
        "plotArea.dimensionLabel.style.fontWeight": "normal",
        "plotArea.dimensionLabel.visible": true,
        "plotArea.endColor": {
            "defaultValue": "#73C03C",
            "serializable": false
        },
        "plotArea.legendValues": {
            "defaultValue": [],
            "serializable": false
        },
        "plotArea.nullColor": {
            "access": "internal",
            "defaultValue": "#e0e0e0"
        },
        "plotArea.startColor": "#C2E3A9",
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        }
    },
    "info/horizontal_area": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.areaRenderer": null,
        "plotArea.areaStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.markerRenderer": null,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.seriesStyle": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "info/horizontal_stacked_combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "valueAxis.label.allowDecimals": true
    },
    "info/horizontal_waterfall": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.label.text.negativeValue": null,
        "legend.label.text.positiveValue": null,
        "legend.label.text.total": null,
        "legend.marker.shape": "squareWithRadius",
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPoint.color.isSemanticColoring": true,
        "plotArea.dataPoint.color.negative": "#EB271B",
        "plotArea.dataPoint.color.positive": "#67AC36",
        "plotArea.dataPoint.color.total": "#848f94",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.linkline.color": "#333333",
        "plotArea.linkline.size": 1,
        "plotArea.linkline.type": "solid",
        "plotArea.linkline.visible": true,
        "plotArea.markerRenderer": null,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "info/line": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.showLine": false,
        "plotArea.adjustScale": false,
        "plotArea.callout.label.formatString": null,
        "plotArea.callout.label.style.color": "#333333",
        "plotArea.callout.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.callout.label.style.fontSize": "12px",
        "plotArea.callout.label.style.fontStyle": "normal",
        "plotArea.callout.label.style.fontWeight": "normal",
        "plotArea.callout.label.unitFormatType": "FinancialUnits",
        "plotArea.callout.left": null,
        "plotArea.callout.line.color": "#343434",
        "plotArea.callout.top": null,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.isSmoothed": false,
        "plotArea.lineRenderer": null,
        "plotArea.lineStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.lineVisible": true,
        "plotArea.marker.displayMode": "manual",
        "plotArea.marker.shape": "circle",
        "plotArea.marker.size": 6,
        "plotArea.marker.visible": true,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "plotArea.width": 2,
        "valueAxis.label.allowDecimals": true,
        "valueAxis.layout.direction": "bottomUp"
    },
    "info/pie": {},
    "info/radar": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.area.color": null,
        "interaction.deselected.area.opacity": 0.12,
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.area.color": null,
        "interaction.selected.area.opacity": 0.4,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.area.opacity": 0.3,
        "plotArea.area.visible": false,
        "plotArea.areaStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "darken(20%)",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.visible": true,
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.lineStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.marker.shape": "circle",
        "plotArea.marker.size": 6,
        "plotArea.marker.visible": true,
        "plotArea.polarAxis.axisLine.size": 1,
        "plotArea.polarAxis.axisLine.visible": true,
        "plotArea.polarAxis.color": "#999999",
        "plotArea.polarAxis.hoverShadow.color": "#cccccc",
        "plotArea.polarAxis.label.style.color": "#666666",
        "plotArea.polarAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.polarAxis.label.style.fontSize": "12px",
        "plotArea.polarAxis.label.style.fontStyle": "normal",
        "plotArea.polarAxis.label.style.fontWeight": "normal",
        "plotArea.polarAxis.label.visible": true,
        "plotArea.polarAxis.labelRenderer": null,
        "plotArea.polarAxis.mouseDownShadow.color": "#808080",
        "plotArea.polarAxis.title.style.color": "#000000",
        "plotArea.polarAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.polarAxis.title.style.fontSize": "14px",
        "plotArea.polarAxis.title.style.fontStyle": "normal",
        "plotArea.polarAxis.title.style.fontWeight": "bold",
        "plotArea.polarAxis.title.style.letterSpacing": null,
        "plotArea.polarAxis.title.text": null,
        "plotArea.polarAxis.title.visible": false,
        "plotArea.polarAxis.visible": true,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.seriesStyle": null,
        "plotArea.valueAxis.label.allowDecimals": true,
        "plotArea.valueAxis.label.formatString": null,
        "plotArea.valueAxis.label.style.color": "#333333",
        "plotArea.valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.valueAxis.label.style.fontSize": "12px",
        "plotArea.valueAxis.label.style.fontStyle": "normal",
        "plotArea.valueAxis.label.style.fontWeight": "normal",
        "plotArea.valueAxis.label.unitFormatType": "FinancialUnits",
        "plotArea.valueAxis.label.visible": true,
        "plotArea.valueAxis.title.style.color": "#000000",
        "plotArea.valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.valueAxis.title.style.fontSize": "14px",
        "plotArea.valueAxis.title.style.fontStyle": "normal",
        "plotArea.valueAxis.title.style.fontWeight": "bold",
        "plotArea.valueAxis.title.style.letterSpacing": null,
        "plotArea.valueAxis.title.text": null,
        "plotArea.valueAxis.title.visible": false,
        "plotArea.valueAxis.visible": true,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        }
    },
    "info/scatter": {
        "plotArea.markerSize": 10,
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "valueAxis.label.formatString": null,
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis2.axisLine.size": 1,
        "valueAxis2.axisLine.visible": true,
        "valueAxis2.axisTick.visible": true,
        "valueAxis2.color": "#6c6c6c",
        "valueAxis2.label.allowDecimals": true,
        "valueAxis2.label.formatString": null,
        "valueAxis2.label.style.color": "#333333",
        "valueAxis2.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.label.style.fontSize": "12px",
        "valueAxis2.label.style.fontStyle": "normal",
        "valueAxis2.label.style.fontWeight": "normal",
        "valueAxis2.label.unitFormatType": "FinancialUnits",
        "valueAxis2.label.visible": true,
        "valueAxis2.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.height": null,
        "valueAxis2.layout.maxHeight": 0.25,
        "valueAxis2.layout.maxWidth": 0.25,
        "valueAxis2.layout.width": null,
        "valueAxis2.title.applyAxislineColor": false,
        "valueAxis2.title.style.color": "#000000",
        "valueAxis2.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.title.style.fontSize": "14px",
        "valueAxis2.title.style.fontStyle": "normal",
        "valueAxis2.title.style.fontWeight": "bold",
        "valueAxis2.title.style.letterSpacing": null,
        "valueAxis2.title.text": null,
        "valueAxis2.title.visible": false,
        "valueAxis2.visible": true
    },
    "info/stacked_bar": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.alignment": "top",
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.background.gradientDirection": "horizontal",
        "plotArea.dataLabel.showTotal": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "valueAxis.label.allowDecimals": true
    },
    "info/stacked_column": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.overlapBehavior": "hideExceededLabels",
        "plotArea.dataLabel.showTotal": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.series": null,
        "valueAxis.label.allowDecimals": true
    },
    "info/stacked_combination": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "valueAxis.label.allowDecimals": true
    },
    "info/time_bubble": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.timePeriodStyle": null,
        "interaction.selectability.axisLabelSelection": true,
        "plotArea.dataLabel.respectShapeWidth": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "bubbleWidth",
        "plotArea.minMarkerSize": null,
        "plotArea.secondaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.secondaryScale.fixedRange": false,
        "plotArea.secondaryScale.maxValue": null,
        "plotArea.secondaryScale.minValue": null,
        "plotArea.showNegativeValues": true,
        "sizeLegend.drawingEffect": "normal",
        "sizeLegend.formatString": null,
        "sizeLegend.label.style.color": "#000000",
        "sizeLegend.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "sizeLegend.label.style.fontSize": "12px",
        "sizeLegend.label.style.fontStyle": "normal",
        "sizeLegend.label.style.fontWeight": "normal",
        "sizeLegend.title.style.color": "#000000",
        "sizeLegend.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "sizeLegend.title.style.fontSize": "14px",
        "sizeLegend.title.style.fontStyle": "normal",
        "sizeLegend.title.style.fontWeight": "bold",
        "sizeLegend.title.text": null,
        "sizeLegend.title.visible": false,
        "sizeLegend.unitFormatType": "FinancialUnits",
        "sizeLegend.visible": true,
        "valueAxis.axisTick.fixedTicks": null,
        "valueAxis2.axisLine.size": 1,
        "valueAxis2.axisLine.visible": true,
        "valueAxis2.axisTick.visible": true,
        "valueAxis2.color": "#6c6c6c",
        "valueAxis2.label.allowDecimals": true,
        "valueAxis2.label.formatString": null,
        "valueAxis2.label.style.color": "#333333",
        "valueAxis2.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.label.style.fontSize": "12px",
        "valueAxis2.label.style.fontStyle": "normal",
        "valueAxis2.label.style.fontWeight": "normal",
        "valueAxis2.label.unitFormatType": "FinancialUnits",
        "valueAxis2.label.visible": true,
        "valueAxis2.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis2.layout.height": null,
        "valueAxis2.layout.maxHeight": 0.25,
        "valueAxis2.layout.maxWidth": 0.25,
        "valueAxis2.layout.width": null,
        "valueAxis2.title.applyAxislineColor": false,
        "valueAxis2.title.style.color": "#000000",
        "valueAxis2.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis2.title.style.fontSize": "14px",
        "valueAxis2.title.style.fontStyle": "normal",
        "valueAxis2.title.style.fontWeight": "bold",
        "valueAxis2.title.style.letterSpacing": null,
        "valueAxis2.title.text": null,
        "valueAxis2.title.visible": false,
        "valueAxis2.visible": true
    },
    "info/timeseries_100_stacked_column": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.zoom.direction": "categoryAxis",
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.overlapBehavior": "hideExceededLabels",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.color": null
    },
    "info/timeseries_bubble": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.plotLassoMode": "standard",
        "plotArea.dataLabel.respectShapeWidth": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.type": "bubbleWidth",
        "plotArea.minMarkerSize": null,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "sizeLegend.drawingEffect": "normal",
        "sizeLegend.formatString": null,
        "sizeLegend.label.style.color": "#000000",
        "sizeLegend.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "sizeLegend.label.style.fontSize": "12px",
        "sizeLegend.label.style.fontStyle": "normal",
        "sizeLegend.label.style.fontWeight": "normal",
        "sizeLegend.title.style.color": "#000000",
        "sizeLegend.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "sizeLegend.title.style.fontSize": "14px",
        "sizeLegend.title.style.fontStyle": "normal",
        "sizeLegend.title.style.fontWeight": "bold",
        "sizeLegend.title.text": null,
        "sizeLegend.title.visible": false,
        "sizeLegend.unitFormatType": "FinancialUnits",
        "sizeLegend.visible": true,
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.unitFormatType": "FinancialUnits"
    },
    "info/timeseries_bullet": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "plotArea.background.border.left.visible": false,
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.color": null
    },
    "info/timeseries_column": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.position": "outside",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.5,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.label.allowDecimals": true
    },
    "info/timeseries_combination": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataLabel.position": "outside",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPoint.invalidity": "break",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.5,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.label.allowDecimals": true
    },
    "info/timeseries_line": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "legend.marker.showLine": false,
        "plotArea.adjustScale": false,
        "plotArea.callout.label.formatString": null,
        "plotArea.callout.label.style.color": "#333333",
        "plotArea.callout.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.callout.label.style.fontSize": "12px",
        "plotArea.callout.label.style.fontStyle": "normal",
        "plotArea.callout.label.style.fontWeight": "normal",
        "plotArea.callout.label.unitFormatType": "FinancialUnits",
        "plotArea.callout.left": null,
        "plotArea.callout.line.color": "#343434",
        "plotArea.callout.top": null,
        "plotArea.dataPoint.invalidity": "break",
        "plotArea.isSmoothed": false,
        "plotArea.lineRenderer": null,
        "plotArea.lineStyle": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.lineVisible": true,
        "plotArea.marker.hoverOnlyMode": {
            "access": "internal",
            "defaultValue": true,
            "serializable": false
        },
        "plotArea.marker.shape": "circle",
        "plotArea.marker.size": 6,
        "plotArea.marker.visible": true,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.scrollbar.visible": {
            "access": "internal",
            "defaultValue": true
        },
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "plotArea.width": 2,
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.interval.keyLabel": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.interval.number": {
            "access": "internal",
            "defaultValue": 1
        },
        "timeAxis.interval.unit": {
            "access": "internal",
            "defaultValue": ""
        },
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.5,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.label.allowDecimals": true
    },
    "info/timeseries_scatter": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.plotLassoMode": "standard",
        "plotArea.markerSize": 10,
        "plotArea.trendLine.defaultStyle.color": null,
        "plotArea.trendLine.defaultStyle.forecast": 0,
        "plotArea.trendLine.defaultStyle.size": 2,
        "plotArea.trendLine.defaultStyle.type": "dot",
        "plotArea.trendLine.lines": null,
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.unitFormatType": "FinancialUnits"
    },
    "info/timeseries_stacked_column": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "legend.marker.shape": "squareWithRadius",
        "plotArea.dataLabel.overlapBehavior": "hideExceededLabels",
        "plotArea.dataLabel.showTotal": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.color": null,
        "valueAxis.label.allowDecimals": true
    },
    "info/timeseries_stacked_combination": {
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.hideNoValueLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "categoryAxis",
        "legend.groupByShape": false,
        "legend.marker.shape": "squareWithRadius",
        "legend.marker.showLine": false,
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataPoint.invalidity": "break",
        "plotArea.dataPoint.savingMode": true,
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataShape.primaryAxis": [
            "bar",
            "line",
            "line"
        ],
        "plotArea.gap.barSpacing": 1,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.line.isSmoothed": false,
        "plotArea.line.lineRenderer": null,
        "plotArea.line.marker.shape": "circle",
        "plotArea.line.marker.size": 6,
        "plotArea.line.marker.visible": true,
        "plotArea.line.style": {
            "access": "internal",
            "defaultValue": null
        },
        "plotArea.line.visible": true,
        "plotArea.line.width": 2,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.color": null,
        "valueAxis.label.allowDecimals": true
    },
    "info/timeseries_waterfall": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.defaultTimePeriodColor": "#ff0000",
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "general.showAsUTC": false,
        "general.timePeriodStyle": null,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectByTimeAxisGroup": {
            "access": "internal",
            "defaultValue": true
        },
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoMode": "standard",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.syncValueAxis": false,
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.label.text.negativeValue": null,
        "legend.label.text.positiveValue": null,
        "legend.marker.shape": "squareWithRadius",
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.recapTitle": "",
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.showRecap": false,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPoint.color.isSemanticColoring": true,
        "plotArea.dataPoint.color.negative": "#EB271B",
        "plotArea.dataPoint.color.positive": "#67AC36",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.linkline.color": "#333333",
        "plotArea.linkline.size": 1,
        "plotArea.linkline.type": "solid",
        "plotArea.linkline.visible": true,
        "plotArea.markerRenderer": null,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.startValue": 0,
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "timeAxis.axisLine.size": 1,
        "timeAxis.axisLine.visible": true,
        "timeAxis.axisTick.visible": true,
        "timeAxis.color": "#6c6c6c",
        "timeAxis.combinationConfig": null,
        "timeAxis.fiscal.periodNumbers": {
            "access": "internal",
            "defaultValue": null
        },
        "timeAxis.hoverShadow.color": "#EBEBEB",
        "timeAxis.label.forceToShowFirstLastData": false,
        "timeAxis.label.showFirstLastDataOnly": false,
        "timeAxis.label.style.color": "#333333",
        "timeAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.label.style.fontSize": "12px",
        "timeAxis.label.style.fontStyle": "normal",
        "timeAxis.label.style.fontWeight": "normal",
        "timeAxis.label.style.parentColor": "#A6A6A6",
        "timeAxis.label.visible": true,
        "timeAxis.layout.height": null,
        "timeAxis.layout.maxHeight": 0.3,
        "timeAxis.levelConfig": null,
        "timeAxis.levels": [
            "day",
            "month",
            "year"
        ],
        "timeAxis.mouseDownShadow.color": "#808080",
        "timeAxis.title.style.color": "#000000",
        "timeAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "timeAxis.title.style.fontSize": "14px",
        "timeAxis.title.style.fontStyle": "normal",
        "timeAxis.title.style.fontWeight": "bold",
        "timeAxis.title.style.letterSpacing": null,
        "timeAxis.title.text": null,
        "timeAxis.title.visible": false,
        "timeAxis.visible": true,
        "tooltip.applyTimeAxisFormat": true,
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": null,
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    },
    "info/treemap": {
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "legend.formatString": null,
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.marker.shape": "squareWithRadius",
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.onlyShowStartEndLabel": {
            "access": "internal",
            "defaultValue": false
        },
        "legend.selectionFeedback": false,
        "legend.unitFormatType": "FinancialUnits",
        "plotArea.autoLegendValues": {
            "access": "internal",
            "defaultValue": [],
            "readonly": true,
            "serializable": false
        },
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.border.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": "0.0",
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "white",
        "plotArea.dataLabel.style.colorRange": "all",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.text": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.dataLabel.truncationBehavior": "truncate",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPointStyle": null,
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.dimensionLabel.renderer": null,
        "plotArea.dimensionLabel.style.color": null,
        "plotArea.dimensionLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dimensionLabel.style.fontSize": "12px",
        "plotArea.dimensionLabel.style.fontStyle": "normal",
        "plotArea.dimensionLabel.style.fontWeight": "normal",
        "plotArea.dimensionLabel.visible": true,
        "plotArea.endColor": {
            "defaultValue": "#73C03C",
            "serializable": false
        },
        "plotArea.labelPosition": "center",
        "plotArea.legendValues": {
            "defaultValue": [],
            "serializable": false
        },
        "plotArea.nullColor": {
            "access": "internal",
            "defaultValue": "#e0e0e0"
        },
        "plotArea.startColor": "#C2E3A9",
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        }
    },
    "info/vertical_bullet": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "legend.label.text.negativeGap": null,
        "legend.label.text.positiveGap": null,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.forecastColor": [
            "#D5DADC"
        ],
        "plotArea.gap.negativeColor": "#e34352",
        "plotArea.gap.positiveColor": "#87c27e",
        "plotArea.gap.type": "both",
        "plotArea.gap.visible": false
    },
    "info/waterfall": {
        "categoryAxis.axisLine.size": 1,
        "categoryAxis.axisLine.visible": true,
        "categoryAxis.axisTick.shortTickVisible": null,
        "categoryAxis.axisTick.visible": true,
        "categoryAxis.color": "#6c6c6c",
        "categoryAxis.hoverShadow.color": "#cccccc",
        "categoryAxis.label.angle": 90,
        "categoryAxis.label.hideSubLevels": false,
        "categoryAxis.label.linesOfWrap": 1,
        "categoryAxis.label.overlapBehavior": "auto",
        "categoryAxis.label.parentStyle.color": null,
        "categoryAxis.label.parentStyle.fontFamily": null,
        "categoryAxis.label.parentStyle.fontSize": null,
        "categoryAxis.label.parentStyle.fontStyle": null,
        "categoryAxis.label.parentStyle.fontWeight": null,
        "categoryAxis.label.rotation": "auto",
        "categoryAxis.label.style.color": "#333333",
        "categoryAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.label.style.fontSize": "12px",
        "categoryAxis.label.style.fontStyle": "normal",
        "categoryAxis.label.style.fontWeight": "normal",
        "categoryAxis.label.truncatedLabelRatio": 0.2,
        "categoryAxis.label.visible": true,
        "categoryAxis.labelRenderer": null,
        "categoryAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.categoryWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.height": null,
        "categoryAxis.layout.maxHeight": 0.3,
        "categoryAxis.layout.maxWidth": 0.3,
        "categoryAxis.layout.offsetToChart": {
            "defaultValue": null,
            "readonly": true
        },
        "categoryAxis.layout.width": null,
        "categoryAxis.mouseDownShadow.color": "#808080",
        "categoryAxis.title.applyAxislineColor": false,
        "categoryAxis.title.style.color": "#000000",
        "categoryAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "categoryAxis.title.style.fontSize": "14px",
        "categoryAxis.title.style.fontStyle": "normal",
        "categoryAxis.title.style.fontWeight": "bold",
        "categoryAxis.title.style.letterSpacing": null,
        "categoryAxis.title.text": null,
        "categoryAxis.title.visible": false,
        "categoryAxis.visible": true,
        "feedingZone": {
            "defaultValue": [
                {
                    "bindDef": [
                        {
                            "id": null
                        }
                    ],
                    "bound": [
                        [
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ],
                            [
                                0,
                                0
                            ]
                        ]
                    ],
                    "name": null
                }
            ],
            "readonly": true,
            "serializable": false
        },
        "general.enableScalingFactor": {
            "access": "internal",
            "defaultValue": false
        },
        "general.groupData": false,
        "general.respectOrderInGroup": false,
        "interaction.behaviorType": null,
        "interaction.decorations": {
            "defaultValue": null,
            "serializable": false
        },
        "interaction.deselected.color": null,
        "interaction.deselected.opacity": 0.4,
        "interaction.deselected.stroke.color": "darken(20%)",
        "interaction.deselected.stroke.visible": false,
        "interaction.deselected.stroke.width": "1px",
        "interaction.enableDeselectAll": true,
        "interaction.enableInternalEvents": {
            "access": "internal",
            "defaultValue": false
        },
        "interaction.enableKeyboard": false,
        "interaction.extraEventInfo": {
            "access": "internal",
            "defaultValue": false,
            "readonly": false,
            "serializable": true
        },
        "interaction.hover.color": null,
        "interaction.hover.opacity": 1,
        "interaction.hover.stroke.color": "darken(20%)",
        "interaction.hover.stroke.visible": true,
        "interaction.hover.stroke.width": "2px",
        "interaction.keyboard.color": "#000000",
        "interaction.keyboard.width": "1px",
        "interaction.noninteractiveMode": false,
        "interaction.selectability.axisLabelSelection": true,
        "interaction.selectability.behavior": {
            "access": "internal",
            "defaultValue": "DATAPOINT",
            "serializable": false
        },
        "interaction.selectability.legendSelection": true,
        "interaction.selectability.mode": "INCLUSIVE",
        "interaction.selectability.plotLassoSelection": true,
        "interaction.selectability.plotStdSelection": true,
        "interaction.selected.color": null,
        "interaction.selected.stroke.color": "darken(20%)",
        "interaction.selected.stroke.visible": true,
        "interaction.selected.stroke.width": "1px",
        "interaction.zoom.direction": "all",
        "interaction.zoom.enablement": "auto",
        "legend.hoverSelectedShadow.color": "#dde8f1",
        "legend.hoverShadow.color": "#f0f0f0",
        "legend.ignoreNoValue": false,
        "legend.label.text.negativeValue": null,
        "legend.label.text.positiveValue": null,
        "legend.label.text.total": null,
        "legend.marker.shape": "squareWithRadius",
        "legend.maxNumOfItems": null,
        "legend.mouseDownShadow.color": "#e8eff6",
        "legend.order": {
            "defaultValue": null,
            "serializable": false
        },
        "legend.selectionFeedback": false,
        "legendGroup.layout.respectPlotPosition": true,
        "plotArea.background.border.bottom.visible": true,
        "plotArea.background.border.left.visible": true,
        "plotArea.background.border.right.visible": true,
        "plotArea.background.border.stroke": "#d8d8d8",
        "plotArea.background.border.strokeWidth": 1,
        "plotArea.background.border.top.visible": true,
        "plotArea.background.color": "transparent",
        "plotArea.background.drawingEffect": "normal",
        "plotArea.background.gradientDirection": "vertical",
        "plotArea.background.visible": true,
        "plotArea.colorPalette": {
            "defaultValue": [
                "#748CB2",
                "#9CC677",
                "#EACF5E",
                "#F9AD79",
                "#D16A7C",
                "#8873A2",
                "#3A95B3",
                "#B6D949",
                "#FDD36C",
                "#F47958",
                "#A65084",
                "#0063B1",
                "#0DA841",
                "#FCB71D",
                "#F05620",
                "#B22D6E",
                "#3C368E",
                "#8FB2CF",
                "#95D4AB",
                "#EAE98F",
                "#F9BE92",
                "#EC9A99",
                "#BC98BD",
                "#1EB7B2",
                "#73C03C",
                "#F48323",
                "#EB271B",
                "#D9B5CA",
                "#AED1DA",
                "#DFECB2",
                "#FCDAB0",
                "#F5BCB4"
            ],
            "serializable": false
        },
        "plotArea.dataLabel.formatString": null,
        "plotArea.dataLabel.hideWhenOverlap": false,
        "plotArea.dataLabel.renderer": null,
        "plotArea.dataLabel.style.color": "#333333",
        "plotArea.dataLabel.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "plotArea.dataLabel.style.fontSize": "12px",
        "plotArea.dataLabel.style.fontStyle": "normal",
        "plotArea.dataLabel.style.fontWeight": "normal",
        "plotArea.dataLabel.unitFormatType": "FinancialUnits",
        "plotArea.dataLabel.visible": false,
        "plotArea.dataPoint.color.isSemanticColoring": true,
        "plotArea.dataPoint.color.negative": "#EB271B",
        "plotArea.dataPoint.color.positive": "#67AC36",
        "plotArea.dataPoint.color.total": "#848f94",
        "plotArea.dataPointSize.max": 96,
        "plotArea.dataPointSize.min": 24,
        "plotArea.dataPointStyle": null,
        "plotArea.dataPointStyleMode": "update",
        "plotArea.defaultOthersStyle.color": "#000000",
        "plotArea.drawingEffect": "normal",
        "plotArea.gap.barSpacing": 1,
        "plotArea.gap.groupSpacing": 1,
        "plotArea.gap.innerGroupSpacing": 0.125,
        "plotArea.gridline.color": "#d8d8d8",
        "plotArea.gridline.size": 1,
        "plotArea.gridline.type": "solid",
        "plotArea.gridline.visible": true,
        "plotArea.gridline.zeroLine.color": null,
        "plotArea.gridline.zeroLine.highlight": true,
        "plotArea.gridline.zeroLine.unhighlightAxis": true,
        "plotArea.isFixedDataPointSize": false,
        "plotArea.linkline.color": "#333333",
        "plotArea.linkline.size": 1,
        "plotArea.linkline.type": "solid",
        "plotArea.linkline.visible": true,
        "plotArea.markerRenderer": null,
        "plotArea.primaryScale.autoMaxValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.autoMinValue": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "plotArea.primaryScale.fixedRange": {
            "defaultValue": false,
            "serializable": false
        },
        "plotArea.primaryScale.maxValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.primaryScale.minValue": {
            "defaultValue": null,
            "serializable": false
        },
        "plotArea.referenceLine.defaultStyle.color": "#666666",
        "plotArea.referenceLine.defaultStyle.label.background": "#333333",
        "plotArea.referenceLine.defaultStyle.label.color": "#ffffff",
        "plotArea.referenceLine.defaultStyle.label.fontFamily": "\"Open Sans\", Arial, Helvetica, sans-serif",
        "plotArea.referenceLine.defaultStyle.label.fontSize": "11px",
        "plotArea.referenceLine.defaultStyle.label.fontStyle": "normal",
        "plotArea.referenceLine.defaultStyle.label.fontWeight": "normal",
        "plotArea.referenceLine.defaultStyle.size": 2,
        "plotArea.referenceLine.defaultStyle.type": "dash",
        "plotArea.referenceLine.line": null,
        "plotArea.scrollbar.border.color": "white",
        "plotArea.scrollbar.border.width": 0,
        "plotArea.scrollbar.spacing": 0,
        "plotArea.scrollbar.thumb.fill": "#e5e5e5",
        "plotArea.scrollbar.thumb.hoverFill": "#dedede",
        "plotArea.scrollbar.track.fill": "#f7f7f7",
        "plotArea.window.end": null,
        "plotArea.window.start": null,
        "propertyZone": {
            "defaultValue": null,
            "readonly": true,
            "serializable": false
        },
        "valueAxis.axisLine.size": 1,
        "valueAxis.axisLine.visible": true,
        "valueAxis.axisTick.visible": true,
        "valueAxis.color": "#6c6c6c",
        "valueAxis.label.allowDecimals": true,
        "valueAxis.label.formatString": null,
        "valueAxis.label.style.color": "#333333",
        "valueAxis.label.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.label.style.fontSize": "12px",
        "valueAxis.label.style.fontStyle": "normal",
        "valueAxis.label.style.fontWeight": "normal",
        "valueAxis.label.unitFormatType": "FinancialUnits",
        "valueAxis.label.visible": true,
        "valueAxis.layout.autoHeight": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.autoWidth": {
            "defaultValue": null,
            "readonly": true
        },
        "valueAxis.layout.height": null,
        "valueAxis.layout.maxHeight": 0.25,
        "valueAxis.layout.maxWidth": 0.25,
        "valueAxis.layout.width": null,
        "valueAxis.title.applyAxislineColor": false,
        "valueAxis.title.style.color": "#000000",
        "valueAxis.title.style.fontFamily": "'Open Sans', Arial, Helvetica, sans-serif",
        "valueAxis.title.style.fontSize": "14px",
        "valueAxis.title.style.fontStyle": "normal",
        "valueAxis.title.style.fontWeight": "bold",
        "valueAxis.title.style.letterSpacing": null,
        "valueAxis.title.text": null,
        "valueAxis.title.visible": false,
        "valueAxis.visible": true
    }
};
});
define('sap/viz/chart/metadata/properties/PropertyLoader',[
    'propertyDefs',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/core/ChartPropertyRegistry',
    "sap/viz/framework/property/PropertyManager",
    "sap/viz/framework/core/ChartViewRegistry",
    "sap/viz/framework/common/util/Constants"
], function(
    propertyDefs,
    ObjectUtils,
    TypeUtils,
    PropertyRegistry,
    PropertyManager,
    ChartViewRegistry,
    Constants
){

    var propDefsList = [];
    var propsByType = {};

    var blackRegs = ['Title', 'Legend', 'Tooltip', 'Interaction','plotArea'];
    var blackListForBackward = ['Title', 'Legend', 'Tooltip', 'Interaction'];

    function extend(propDefs, chartType, props, category, checker){
        if((!checker || checker(chartType)) && propDefs[category]){
            ObjectUtils.extend(true, props, formatPropertyValue(propDefs[category]));
        }
        return props;
    }

    function formatPropertyValue(propertyDef) {
        for(var name in propertyDef){
            if(PropertyManager.isValidValue(propertyDef[name])) {
                propertyDef[name] = {
                    defaultValue: propertyDef[name]
                };
            }
        }
        return propertyDef;
    }

    function mergeCustomProperties(props, customPropertyMeta, isExtension) {
        if(customPropertyMeta.isEmpty) {
            return props;
        }
        var blackList = blackListForBackward;

        if(isExtension){
            blackList = blackRegs;
        }

        if (blackList.length){
            props = ObjectUtils.extend(true, {}, props);
        }

        blackList.forEach(function(d){
            var flag = customPropertyMeta.metadata['extend'+d];
            if(flag){
                return;
            }
            var reg = new RegExp("^"+d,"i");
            for(var prop in props) {
                if(reg.test(prop)) {
                    delete props[prop];
                }
            }
        });
        if(customPropertyMeta.metadata['extendInteraction']){
            props['interaction.behaviorType'] = {
                defaultValue : null
            };
        }

        return ObjectUtils.extend(false, props, customPropertyMeta.properties);
    }

    function getCoreProperties(type, force){
        var propDefs = getPropertyDefs(type);
        if(!propDefs[type]) {
            type = "info/DEFAULT";
        }
        var props = propsByType[type];
        if(!props || force){
            props = propsByType[type] = {};
            extend(propDefs, type, props, '');
            extend(propDefs, type, props, '_xy', function(type){
                return (/bar|column|line|combination/).test(type) && !(/dual/).test(type);
            });
            extend(propDefs, type, props, '_xySimple', function(type){
                return (/bar|column|line|combination/).test(type) && !(/trellis/).test(type);
            });
            extend(propDefs, type, props, '_dual', function(type){
                return (/dual/).test(type);
            });
            extend(propDefs, type, props, '_trellis', function(type){
                return (/trellis/).test(type);
            });
            extend(propDefs, type, props, '_scatter', function(type){
                return (/scatter|bubble/).test(type);
            });
            extend(propDefs, type, props, '_pie', function(type){
                return (/pie|donut/).test(type);
            });
            extend(propDefs, type, props, '_bullet', function(type){
                return (/bullet/).test(type);
            });
            extend(propDefs, type, props, '_mekko', function(type){
                return (/mekko/).test(type);
            });
            extend(propDefs, type, props, type);
        }
        return props;
    }

    function getProperties(type){
        var metadata = ChartViewRegistry.getMetadataWithFamily(type);
        var isExtension = metadata && metadata.family === Constants.EXTENSION.FAMILYNAME;
        var customPropertyMeta = PropertyRegistry.get(type);
        // If we have more than 1 propDefs, disable cache to allow newly added extension props
        var props = getCoreProperties(type, propDefsList.length > 1);
        return mergeCustomProperties(props, customPropertyMeta, isExtension);
    }

    // Add standalone property defs of new chart types.
    function addPropertyDefs(propDefs) {
        var i;
        for (i = 0; i < propDefsList.length; i++) {
            if (propDefsList[i].propDefs === propDefs) {
                return;
            }
        }

        var content = {
            propDefs: propDefs,
            chartTypes : []
        };

        for (i in propDefs) {
            if (propDefs.hasOwnProperty(i)) {
                if (i.indexOf("info/") >= 0 && i !== "info/DEFAULT") {
                    content.chartTypes.push(i);
                }
            }
        }

        propDefsList.push(content);
    }

    // Get property defs for one chart type.
    function getPropertyDefs(type) {
        var propDefs = propDefsList[0].propDefs;

        if (propDefsList.length > 1) {
            for (var i = 0; i < propDefsList.length; i++) {
                if (propDefsList[i].chartTypes.indexOf(type) >= 0) {
                    propDefs = propDefsList[i].propDefs;
                    break;
                }
            }
        }        
        return propDefs;
    }

    // Add info core chart property defs.
    if (TypeUtils.isArray(propertyDefs)) {
        propertyDefs.forEach(function(defs) {
            addPropertyDefs(defs);
        });
    } else {
        addPropertyDefs(propertyDefs);
    }

    return {
        getProperties: getProperties,
        addPropertyDefs: addPropertyDefs
    };
});

define('sap/viz/chart/components/util/ScrollbarUtil',[
    "sap/viz/framework/common/util/TypeUtils"
], function Setup(TypeUtils) {

    function getOffsetRatio(event) {
        var ratio = 0;
        switch (event.name) {
            case "wheelmove":
                ratio = 0.1;
                if (event.data.wheelDelta > 0) {
                    ratio = -ratio;
                }
                break;
            case "leftarrow":
            case "uparrow":
                ratio = -0.06;
                break;
            case "rightarrow":
            case "downarrow":
                ratio = 0.06;
                break;
        }
        return ratio;
    }

    function setScrollBar(event, scrollBar, module, bLegend, isHorizontal, service) {
        if (scrollBar) {
            var offset = getOffsetRatio(event) * scrollBar.getThumbSize();
            if (!scrollBar.isThumbOverTrack(offset)) {
                event.data.originalEvent.preventDefault();
                var ratio = scrollBar.getThumbRatio();
                offset *= (TypeUtils.isNumber(ratio) ? ratio : 1);
                if (bLegend) {
                    module.scroll(offset);
                } else {
                    var offsetXY = module.getOffset();
                    if (isHorizontal) {
                        offsetXY.y -= offset;
                    } else {
                        offsetXY.x -= offset;
                    }
                    module.scroll(offsetXY);
                    service.fireEvent("hideDetail", {
                        mode: "actionMode"
                    });
                }
            }
        }
    }

    var ret = {
        showScrollbar: function(service, force) {
            var mainModule = service.getModule("main");
            if (!mainModule) {
                mainModule = service.getModule("plot");
            }
            if (mainModule) {
                var vScrollbar, hScrollbar;
                if (mainModule.getVScrollbar && mainModule.getVScrollbar()) {
                    vScrollbar = mainModule.getVScrollbar();
                    vScrollbar.show(null, force);
                }
                if (mainModule.getHScrollbar && mainModule.getHScrollbar()) {
                    hScrollbar = mainModule.getHScrollbar();
                    hScrollbar.show(null, force);
                }
            }
        },
        onScrollKeyboardHandler: function(event, service) {

            var module = service.getModule("main") || service.getModule("plot");
            if (!module || !TypeUtils.isFunction(module.scroll)) {
                return;
            }

            var isHorizontal;
            var scrollBar;
            var eventName = event.name;

            if (["leftarrow", "rightarrow"].indexOf(eventName) > -1) {
                scrollBar = module.getHScrollbar();
                isHorizontal = false;
            } else if (["wheelmove", "uparrow", "downarrow"].indexOf(eventName) > -1) {
                scrollBar = module.getVScrollbar();
                isHorizontal = true;
            } else {
                return;
            }
            setScrollBar(event, scrollBar, module, false, isHorizontal, service);
        },
        onLegendScrollWheelHandler: function(event, service){
            var module = service.getModule("legendGroup.legend");
            if (!module || !TypeUtils.isFunction(module.scroll)) {
                return;
            }
            var position = module.getPosition();
            if (position === "left" || position === "right") {
                setScrollBar(event, module.getScrollbar(), module, true);
            }
        }
    };

    return ret;
});
define('sap/viz/chart/components/plots/PlotGeometryKeeper',[
    "sap/viz/framework/common/util/ObjectUtils"
], function(
    ObjectUtils
) {
    function hasRangeChange(service) {
        var old = service.getStatus("plotArea.window") || {},
            now = service.getStatusManager().get("plotArea.window") || {};
        return !ObjectUtils.deepEqual(old, now);
    }

    var plot_size_keeper = {
        key: "plot.realsize",
        save: function(service) {
            if (service.getStatusManager().get("hasCustomization")) {
                return;
            }
            var realsize = service.getModule("main.plot").getRealSize(),
                scale = service.getStatusManager().get("plot.transform.scale");
            if (scale.x === 1) {
                delete realsize.width;
            }
            if (scale.y === 1) {
                delete realsize.height;
            }
            service.setStatus(this.key, realsize);
        },
        load: function(service) {
            if (service.getStatusManager().get("hasCustomization")) {
                return;
            }
            var plotSize = service.getStatus(this.key),
                main = service.getModule("main"),
                plot = service.getModule("main.plot");
            if (plotSize && main && plot) {
                var viewSize = plot.getSize();
                if (viewSize.width > 0 && viewSize.height > 0) {
                    
                    var limits = main.getZoomer().limits();
                    var sizeChanged = service.getStatusManager().get("sizeChanged");
                    var xMax = sizeChanged ? Number.MAX_VALUE : limits.x.max || Number.MAX_VALUE;
                    var yMax = sizeChanged ? Number.MAX_VALUE : limits.y.max || Number.MAX_VALUE;
                    service.getStatusManager().set("plot.transform.scale", {
                        x: Math.max(1, Math.min((plotSize.width || 0) / viewSize.width, xMax )),
                        y: Math.max(1, Math.min((plotSize.height || 0) / viewSize.height, yMax ))
                    });
                }
            }
        },
        clear: function(service) {
            service.removeStatus(this.key);
        }
    };

    var plot_scroll_keeper = {
        key: "plot.scroll",
        save: function(service) {
            if (service.getStatusManager().get("hasCustomization")) {
                return;
            }
            var pxloff = service.getModule("main.plot").getOffset(),
                valoff = service.getStatusManager().get("plot.offsetInValue");
            service.setStatus(this.key + ".pixel", pxloff);
            service.setStatus(this.key + ".value", valoff);
        },
        load: function(service) {
            if (service.getStatusManager().get("hasCustomization")) {
                return;
            }
            var plotarea = service.getModule("main"),
                pxloff = service.getStatus(this.key + ".pixel"),
                valoff = service.getStatus(this.key + ".value");
            if (pxloff && plotarea) {
                plotarea.scroll(pxloff);
            }
            if (valoff) {
                service.getStatusManager().set("plot.offsetInValue", valoff);
            }
        },
        clear: function(service) {
            service.removeStatus(this.key + ".pixel");
            service.removeStatus(this.key + ".value");
        }
    };

    function offsetInValue(scales, offset, size) {
        var h = scales.h,
            v = scales.v;
        return {
            x: h ? h._scale.invert(-offset.x / size.width) : null,
            y: v ? v._scale.invert((size.height + offset.y) / size.height) : null
        };
    }

    return {
        hasRangeChange: hasRangeChange,
        size: plot_size_keeper,
        scroll: plot_scroll_keeper,
        offsetInValue: offsetInValue
    };
});

define('sap/viz/chart/behavior/config/PlotScrollBehaviorConfig',[
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/chart/components/util/ScrollbarUtil",
    "sap/viz/chart/components/plots/PlotGeometryKeeper"
], function(
    UADetector,
    ScrollbarUtil,
    PlotGeometryKeeper
) {

    var supportedChartTypes = [
        "info/bar", "info/column", "info/dual_bar", "info/dual_column",
        "info/stacked_bar", "info/stacked_column", "info/dual_stacked_bar",
        "info/dual_stacked_column",
        "info/100_stacked_bar", "info/100_stacked_column", "info/100_dual_stacked_bar",
        "info/100_dual_stacked_column",
        "info/line", "info/horizontal_line", "info/dual_line", "info/dual_horizontal_line",
        "info/combination", "info/combinationEx", "info/horizontal_combination",
        "info/bullet", "info/vertical_bullet",
        "info/stacked_combination", "info/horizontal_stacked_combination",
        "info/dual_stacked_combination", "info/dual_horizontal_stacked_combination",
        "info/bullet","info/vertical_bullet",
        "info/mekko","info/100_mekko","info/horizontal_mekko","info/100_horizontal_mekko",
        "info/area", "info/horizontal_area", "info/100_area", "info/100_horizontal_area",
        "info/dual_combination", "info/dual_horizontal_combination",
        "info/timeseries_scatter", "info/timeseries_bubble"
    ];

    var extra = ["info/bubble", "info/scatter", "info/waterfall", "info/horizontal_waterfall"];

    function hasVScrollbar(service) {
        return service.getModule("main").getVScrollbar().isExist();
    }

    var plotScrollHandler = function(event, service) {
        if (UADetector.isMobile() || !service.getProperties().get("plotArea.isFixedDataPointSize")) {
            return;
        }
        ScrollbarUtil.onScrollKeyboardHandler(event, service);
    };

    return [{
        "id": "wheel_move_on_eventLayer_single",
        "triggerEvent": {
            "name": "wheelmove",
            "targets": ["v-m-plot", "v-m-action-layerrange", "v-m-datapoints"],
            "supportedChartTypes": supportedChartTypes.concat(extra)
        },
        "handler": function(event, service) {
            if (!event.data.originalEvent.ctrlKey && hasVScrollbar(service)) {
                //disable mouse wheel for horizontal plot when pagination
                if(!service.getDataModel().getPaginationOptions()) {
                    ScrollbarUtil.onScrollKeyboardHandler(event, service);
                    PlotGeometryKeeper.scroll.save(service);
                }
            }
        }
    }, {
        "id": "on_plot_scroll",
        "triggerEvent": {
            "name": "plotScroll"
        },
        "handler": function(event, service) {
            service.fireEvent('hideDetail', {
                mode: 'actionMode'
            });
        }
    }, {
        id: "save_scroll_position_on_scrollbar_release",
        triggerEvent: {
            name: "scrollbarReleased"
        },
        handler: function(e, service) {
            service.fireEvent("saveZoom", {scroll: true});
        }
    }];
});

define('sap/viz/chart/behavior/config/handler/AxisBehaviorHandler',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/interaction/Constants',
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DataGraphics'
], function(Constants, SDKConstants, UADetector, ObjectUtils, DOM, DataPointUtils, SelectionUtil, TypeUtils, 
        DataGraphics) {
    var BehaviorConstants = SDKConstants.BEHAVIOR;
    var CSS_CLASS = Constants.CSS.CLASS;
    var HIGHLIGHT_COLOR = '#333333';
    var DIMENSION_PARSED_VALUE = 'parsedValue';

    function Handler() {
    }

    var proto = Handler.prototype;

    function isTriggerable(service) {
        var selectability = service.getProperties().get("interaction.selectability");
        if (!selectability) {
            return false;
        }
        var tempSelectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        var currentSelectionBehavior = tempSelectionBehavior ? tempSelectionBehavior.toUpperCase()
        : tempSelectionBehavior;
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        var axisNode = service.getNodes(service.NodeType.AXIS_ITEM);
        if (!selectability.axisLabelSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE ||
            (selectionMode === SDKConstants.SELECTION_MODE.SINGLE &&
             currentSelectionBehavior !== SDKConstants.SELECTION_BEHAVIOR.CATEGORY) ||
             !axisNode.node()) {
            return false;
        } else {
            return true;
        }
    }

    function isTimeAxisTriggerable(service) {
        var selectability = service.getProperties().get("interaction.selectability");
        if (!selectability) {
            return false;
        }
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        var axisNode = service.getNodes(service.NodeType.TIMEAXIS_ITEM) ||
            service.getNodes(service.NodeType.TIMEAXIS_ITEM_UPPERLEVEL);
        if (!selectability.axisLabelSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE ||
            selectionMode === SDKConstants.SELECTION_MODE.SINGLE || !axisNode.node()) {
            return false;
        } else {
            return true;
        }
    }

    function getAxisRoot(axisItem){
        var axisRoot = axisItem; // find axis container
        while (axisRoot && axisRoot.getAttribute) {
            if (DOM.hasClass(axisRoot, CSS_CLASS.AXIS.CONTAINER)) {
                break;
            }
            axisRoot = axisRoot.parentNode;
        }

        return axisRoot;
    }

    function getAxisName(event){
        var axisItem = event.data.currentTarget;
        var axisRoot = getAxisRoot(axisItem);
        var rootCtx = DataPointUtils.getContext(axisRoot);
        if(rootCtx && rootCtx.name){
            return rootCtx.name;
        } else{
            return "categoryAxis";
        }
    }

    function isOnFirstLastOnlyAxis(event, service){
        var axisName = getAxisName(event);
        if(axisName && axisName.toLowerCase() === "categoryaxis"){
            var axisBody = service.getModule("main.categoryAxis.axisBody");
            return axisBody && axisBody.isOnlyShowingFirstAndLastLabel &&
                axisBody.isOnlyShowingFirstAndLastLabel();
        }
        return false;
    }

    var getTargetsForTime = function (event, service) {
        var axisItem = event.data.currentTarget, axisCtx = DataPointUtils.getContext(axisItem);
        if (!axisCtx.hasOwnProperty('rectX')) {
            return;
        }
        SelectionUtil.cleanRangeSelection(service);
        var ctx = {}, dateField = service.getDataModel()._timeAxis.metaData[0].id;
        ctx[dateField + '.' + DIMENSION_PARSED_VALUE] = axisCtx.range;
        return SelectionUtil.getDataPointIds(ctx, service);
    };

    proto.getTargetsAndCtxs = function (axisItem, axisRoot, service) {
        var targetsAndCtxs = {};
        var rootCtx;
        var ctx1 = ObjectUtils.extendByRepalceArray({}, DataPointUtils.getContext(axisItem).ctx);
        if (axisRoot) {
            //special handling for trellis chart: attach axis container's context if available
            rootCtx = DataPointUtils.getContext(axisRoot);
            if (rootCtx) {
                if (ctx1 && ctx1.or && TypeUtils.isArray(ctx1.or)) {
                    ctx1.or.forEach(function (c) {
                        ObjectUtils.extendByRepalceArray(c, rootCtx.ctx);
                    });
                } else {
                    ObjectUtils.extendByRepalceArray(ctx1, rootCtx.ctx);
                }
            }
        }
        targetsAndCtxs.targets = SelectionUtil.getDataPointIds(ctx1, service);
        targetsAndCtxs.ctxs = this.filterCtx(ctx1, rootCtx);
        return targetsAndCtxs;
    };

    proto.hoverOnAxisLabel = function (event, service) {
        if (service.getStatus("rangeSelection")) {
            return;
        }
        if (!isTriggerable(service) || isOnFirstLastOnlyAxis(event, service)) {
            return;
        }

        var isRadarChart = service._getRenderType().indexOf("radar") > -1;
        var polarAxis = "plotArea.polarAxis";
        var axisName = isRadarChart ? polarAxis : getAxisName(event);
        service.fireEvent("processUnhighlight");
        var color = service.getProperties().get(axisName + ".hoverShadow.color");
        if (color) {
            d3.select(event.data.currentTarget).select("rect")
            .attr("fill", event.data.byKeyboard ? "transparent" : color)
            .classed(CSS_CLASS.HOVER_SHADOW, true);
        }

        //get targets. Hovering on data points does not support trellis.
        var highlighted = this.getTargetsAndCtxs(event.data.currentTarget, null,
            service).targets;
        service.fireEvent("processHighlight", {
            targets: highlighted,
        });
    };

    proto.hoverOnTimeAxisLabel = function (event, service) {
        if (service.getStatus("rangeSelection")) {
            return;
        }
        if (!isTimeAxisTriggerable(service)) {
            return;
        }
        service.fireEvent("processUnhighlight");
        var color = service.getProperties().get("timeAxis.hoverShadow.color");
        if (color) {
            d3.select(event.data.currentTarget).select("rect")
            .attr("fill", event.data.byKeyboard ? "transparent" : color)
            .classed(CSS_CLASS.HOVER_SHADOW, true);
        }

        var axisItem = event.data.currentTarget;
        var ctx = DataPointUtils.getContext(axisItem);
        var axisRoot = getAxisRoot(axisItem);
        if (axisRoot) {
            var upperlabel = axisRoot.querySelector(".v-label-upperLevel[timelabel-id='" + ctx.id + "']");
            if(upperlabel) {
                var highlightColor = service.getProperties().get("timeAxis.label.style.color") || HIGHLIGHT_COLOR;
                var effectMgr = service.getEffectManager();
                highlightColor = effectMgr.register({
                    fillColor: highlightColor
                });
                upperlabel.setAttribute("fill", highlightColor);
            }
        }
        //get targets
        var highlighted = getTargetsForTime(event, service);
        service.fireEvent("processHighlight", {
            targets: highlighted,
        });
    };

    proto.hoverOnNonAxisLabel = function(event, service) {
        if (!(isTriggerable(service) || isTimeAxisTriggerable(service))) {
            return;
        }
        service.fireEvent("processUnhighlight");
    };

    var blurNode = function(mainNode, service) {
        var highlightNodes = mainNode.selectAll(".v-m-highlight")[0];
        if (highlightNodes.length > 0) {
            var numOfSelected = service.getStatus("selectedDataPoints").length;
            switch (numOfSelected) {
                case 0:
                    d3.select(highlightNodes[highlightNodes.length - 1]).remove();
                    break;
                case 1:
                    if (highlightNodes.length === 1) {
                        var data = DataGraphics.getData(highlightNodes[0].parentNode) || {};
                        if (!data.isZeroValue) {
                            d3.select(highlightNodes[0]).remove();
                        }
                    }
                    break;
            }
        }
    };

    var isValidNode = function(d3Node) {
        if (d3Node.node()) {
            return d3Node;
        }
        return null;
    };

    proto.cleanAxisHoverEffect = function(event, service) {
        service.getNodes(service.NodeType.AXIS_ITEM_BACKGROUND)
        .attr("fill", "transparent")
        .classed(CSS_CLASS.HOVER_SHADOW, false)
        .classed(CSS_CLASS.FOCUS_SHADOW, false);

        var axisNodes = service.getNodes(service.NodeType.TIMEAXIS_ITEM_UPPERLEVEL, false);
        if(axisNodes && axisNodes.length > 0) {
            var axisRoot = getAxisRoot(axisNodes[0]);
            var upperLabels = axisRoot.querySelectorAll(".v-label-upperLevel");
            var upperLevelTextColor = service.getProperties().get("timeAxis.label.style.parentColor");
            for(var i = 0; i < upperLabels.length; i++) {
                upperLabels[i].setAttribute("fill", upperLevelTextColor);
            }
        }

        var mainNode = isValidNode(service.getNodes(service.NodeType.MAIN_NODE)) || 
            isValidNode(service.getNodes(service.NodeType.PLOT_NODE));
        blurNode(mainNode, service);
    };

    proto.clickOnAxisLabel = function(event, service) {
        if (!isTriggerable(service) || isOnFirstLastOnlyAxis(event, service)) {
            return;
        }
        var axisItem = event.data.currentTarget;
        var axisRoot = getAxisRoot(axisItem); // find axis container
        var targetsAndCtxs = this.getTargetsAndCtxs(axisItem, axisRoot, service);
        var targets = targetsAndCtxs.targets;
        var ctx1 = targetsAndCtxs.ctxs;
        service.fireEvent("processSelection", {
            ctx: ctx1,  // sFinBehavior will check ctx to trigger category/series selection
            targets: targets,
            deselectable: true,
            ctrlKeyPressed: event.data.ctrlKey
        });
        service.fireEvent("processMultipleSelectionTooltip", {
            targets: targets,
            point: event.data.point
        });
    };

    proto.clickOnTimeAxisLabel = function(event, service) {
        if (!isTimeAxisTriggerable(service)) {
            return;
        }
        var targets = getTargetsForTime(event, service);
        service.fireEvent("processSelection", {
            targets: targets,
            deselectable: true,
            ctrlKeyPressed: event.data.ctrlKey
        });
        service.fireEvent("processMultipleSelectionTooltip", {
            targets: targets,
            point: event.data.point
        });
    };

    proto.filterCtx = function(ctx) {
        return ctx;
    };

    proto.downOnAxisLabel = function(event, service) {
        if(isOnFirstLastOnlyAxis(event, service)){
            return;
        }

        var color;
        if(isTriggerable(service)) {
            var axisName = getAxisName(event);
            color = service.getProperties().get(axisName+".mouseDownShadow.color");
        }
        else if(isTimeAxisTriggerable(service)) {
            color = service.getProperties().get("timeAxis"+".mouseDownShadow.color");
        }
        else {
            return;
        }
        service.getNodes(service.NodeType.AXIS_ITEM_BACKGROUND)
        .attr("fill", "transparent")
        .classed(CSS_CLASS.HOVER_SHADOW, false);
        if (color) {
            d3.select(event.data.currentTarget).select("rect")
            .attr("fill", color)
            .classed(CSS_CLASS.FOCUS_SHADOW, true);
        }
    };

    proto.upOnAxisLabel = function(event, service) {
        if(isOnFirstLastOnlyAxis(event, service)){
            return;
        }
        var color;
        if(isTriggerable(service)) {
            var axisName = getAxisName(event);
            color = service.getProperties().get(axisName+".hoverShadow.color");
        }
        else if(isTimeAxisTriggerable(service)) {
            color = service.getProperties().get("timeAxis"+".hoverShadow.color");
        }
        else {
            return;
        }
        var axisBackground = service.getNodes(service.NodeType.AXIS_ITEM_BACKGROUND);
        axisBackground.attr("fill", "transparent").classed(CSS_CLASS.FOCUS_SHADOW, false);

        if (UADetector.isMobile()) {
            axisBackground.classed(CSS_CLASS.HOVER_SHADOW, false);
        } else {
            if (color) {
                d3.select(event.data.currentTarget).select("rect")
                .attr("fill", color)
                .classed(CSS_CLASS.HOVER_SHADOW, true);
            }
        }
    };

    return Handler;

});

define('sap/viz/chart/behavior/config/AxisBehaviorConfig',[
    "sap/viz/chart/behavior/config/handler/AxisBehaviorHandler",
    'sap/viz/framework/common/util/Constants'
], function (AxisBehaviorHandler,
    Constants) {
    var axisItemPattern = "v-axis-item";
    var mbcAxisItemPattern = "v-mbc-axis-item";
    var timeAxisItemPattern = "v-timeaxis-item";
    var timeAxisUpperLevelItemPattern = "v-timeaxis-item-upperLevel";
    var mekkoSpecialAxisItem = "v-axis-mekko-item";

    return [{
        "id": "axisBehaviorDefinition",
        "handler": AxisBehaviorHandler,
        "handlerType": "class",
        "triggerEvent": [{
            "name": "hover",
            "targets": axisItemPattern,
            "excludeTargets": mekkoSpecialAxisItem,
            "method": "hoverOnAxisLabel"
        }, {
            "name": "hover",
            //legend items should be excluded.
            "excludeTargets": [axisItemPattern, timeAxisItemPattern, timeAxisUpperLevelItemPattern,
                Constants.CSS.CLASS.LEGENDITEM],
            "method": "hoverOnNonAxisLabel"
        }, {
            "name": "hover",
            "targets": [timeAxisItemPattern, timeAxisUpperLevelItemPattern],
            "method": "hoverOnTimeAxisLabel"
        }, {
            "name": "cleanAxisHoverEffect",
            "method": "cleanAxisHoverEffect"
        }, {
            "name": "click",
            "targets": axisItemPattern,
            "excludeTargets": [mekkoSpecialAxisItem, mbcAxisItemPattern],
            "method": "clickOnAxisLabel"
        }, {
            "name": "click",
            "targets": [timeAxisItemPattern, timeAxisUpperLevelItemPattern],
            "method": "clickOnTimeAxisLabel"
        }, {
            "name": "down",
            "targets": [axisItemPattern, timeAxisItemPattern, timeAxisUpperLevelItemPattern],
            "excludeTargets": mekkoSpecialAxisItem,
            "method": "downOnAxisLabel"
        }, {
            "name": "up",
            "targets": [axisItemPattern, timeAxisItemPattern, timeAxisUpperLevelItemPattern],
            "excludeTargets": mekkoSpecialAxisItem,
            "method": "upOnAxisLabel"
        }]
    }];
});
define('sap/viz/chart/behavior/config/HighlightHelper',[
    "sap/viz/chart/components/util/DrawUtil",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/RuleUtil",
    'sap/viz/framework/common/util/DOM',
    "sap/viz/framework/common/effect/EffectManager",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/components/util/ChartConstants"
], function(
    DrawUtil,
    DataGraphics,
    TypeUtils,
    DataPointUtils,
    RuleUtil,
    DOM,
    EffectManager,
    UADetector,
    Constants,
    ChartConstants
) {
    var getColors = function(service, e, prop, usrDefaultColor, drawingEffect, options, point){
        var data = point ? point : DataGraphics.getData(e);
        var color, defaultColor =
            usrDefaultColor ? usrDefaultColor : data.color,
            effectMgr = service.getEffectManager();
        if(prop){
            if(TypeUtils.isFunction(prop)){
                color = prop(defaultColor);
            } else if(TypeUtils.isString(prop)){
                color = effectMgr.parseColorProperty(prop, defaultColor);
            }
        }

        var isHorizontal = service.isHorizontal();
        var direction = null;
        //If isReverse is true, color changing direction is the same as its chart type direction.
        if (options && options.isReverse) {
            direction = direction === isHorizontal ? null : (isHorizontal ? 'horizontal' : 'vertical');
        } else {
            direction = direction === isHorizontal ? null : (isHorizontal ? 'vertical' : 'horizontal');
        }
        var shape = data.shape;
        var outerRadius = data.r;
        if(drawingEffect && defaultColor) {
            defaultColor = effectMgr.register({
                drawingEffect : drawingEffect,
                fillColor : defaultColor,
                patternEffect : data.pattern,
                isNegative: data.isNegative,
                direction : direction,
                graphType : shape,
                radius : outerRadius
            });

        }
        if(drawingEffect && color) {
            color = effectMgr.register({
                drawingEffect : drawingEffect,
                fillColor : color,
                patternEffect : data.pattern,
                isNegative: data.isNegative,
                direction : direction,
                graphType : shape,
                radius : outerRadius
            });
        }
        return {
            defaultColor : defaultColor,
            customizedColor : color
        };
    };

    var getWidth = function(prop, defaultWidth, ratio) {
        var width;
        if(defaultWidth == null){
            defaultWidth = 0;
        }
        if(!TypeUtils.isNumber(defaultWidth)){
            defaultWidth = +defaultWidth.match(/[0-9]+/);
        }
        if(!prop) {
            width = defaultWidth;
        } else if(TypeUtils.isNumber(prop)) {
            width = prop;
        } else {
            if(!TypeUtils.isNumber(width)){
                width = +prop.match(/[0-9]+/);
            }
        }
        if(width > 4) {
            width = defaultWidth;
        }
        return (ratio === undefined ? width : width * ratio) + 'px';
    };

    function transformColor(colorString, ratio) {
        return DrawUtil.rgb2Hex(DrawUtil.colorLinerTransform(new EffectManager(), {
            constant: 0,
            factor: ratio ? ratio : 1
        }, colorString));
    }

    function turnToArray(elem) {
        return TypeUtils.isArray(elem) ? elem : [elem];
    }

    function drawStroke(service, e, selector, prop, defaultWidth, selectAll, extraData) {
        var zeroHoverNode = d3.select('.' + Constants.CSS.CLASS.ZEROVALUEHOVER).node();
        var child = d3.select(e).selectAll(selector);
        if (TypeUtils.isExist(zeroHoverNode) && TypeUtils.isExist(extraData)) {
            if (extraData.isZeroOnFirstTab) {
                child = d3.select(zeroHoverNode).selectAll(selector);
            }
        }
        if(!selectAll && child && child[0] && child[0].length > 1){
            var temp = child[0];
            child = d3.select(temp[temp.length - 1]);
        }
        var isZeroValue = TypeUtils.isExist(extraData) ? extraData.isZeroValue : false;
        if (!isZeroValue) {
            child.attr("stroke-dasharray", undefined);
        }
        if(prop.visible === true) {
            var colors = getColors(service, e, prop.color);
            var color = colors.customizedColor || colors.defaultColor;
            child.attr("stroke", color);
            child.attr("stroke-width", getWidth(prop.width, defaultWidth));
        } else {
            child.attr("stroke", undefined);
            child.attr("stroke-width", undefined);
        }
    }

    function drawFill(service, e, childType, prop, hasMarkerRenderer, setChildOpacity) {
        var data = DataGraphics.getData(e);
        var opacity = TypeUtils.isExist(prop.opacity) ? prop.opacity : 1;
        e.setAttribute("fill-opacity", opacity);
        var child = d3.select(e).selectAll(childType);
        if(setChildOpacity) {
            child.attr("fill-opacity", opacity);
        }
        child.attr("stroke-opacity", opacity);
        if(!hasMarkerRenderer) {
            var drawingEffect = (data.pattern === 'noFill' ? null :
                service.getProperties().get('plotArea.drawingEffect'));
            var colors = getColors(service, e, prop.color, null, drawingEffect);
            var color = colors.customizedColor || colors.defaultColor;
            if(data.pattern === 'noFill'){
                child[0][0].setAttribute("stroke", color);
            }else{
                child.attr('fill', color);
            }
        }
    }

    function getDeselAllExTargets() {
        var results = [
            'v-datapoint',
            'v-legend-item',
            'v-axis-item',
            'v-timeaxis-item',
            'v-timeaxis-item-upperLevel',
            'v-datalabel',
            'v-mbc-legend-item',
            'v-m-scrollbarTrack',
            'v-area',
            'v-area-point',
            'v-area-ref-line',
            'v-area-ref-line-selected',
            'v-selected-area',
            'v-nonLeafDimensionLabel'
        ];
        if(!UADetector.isMobile()){
            results.push('v-m-action-layerrange');
        }
        return results;
    }


    function mousePosition(e) {
        var event = e || window.event;
        return {
            x: event.layerX || event.offsetX,
            y: event.layerY || event.offsetY
        };
    }

    function getLayerCoord(point, box) {

        // var target = e.target || e.srcElement;

        // var mousePos = mousePosition(e);

        // return {
        //     x: mousePos.x - offsetFromRoot.e,
        //     y: mousePos.y - offsetFromRoot.f
        // };
        return {
            left: point.x - box.x,
            top: point.y - box.y
        };
    }

    function tryToFindNode(cssClass, node, rootNode) {
        if (!node || !node.getAttribute) {
            return null;
        }
        if (DOM.hasClass(node, cssClass)) {
            return node;
        }

        if (node !== rootNode.node()) {
            //not found in this level, try its parent node
            return tryToFindNode(cssClass, node.parentNode, rootNode);
        }
        return null;
    }

    var helper = {
        transformColor: transformColor,
        turnToArray: turnToArray,
        getColors : getColors,
        drawStroke : drawStroke,
        drawFill : drawFill,
        getWidth : getWidth,
        getDeselAllExTargets: getDeselAllExTargets,
        getLayerCoord: getLayerCoord,
        tryToFindNode: tryToFindNode
    };

    return helper;
});

define('sap/viz/chart/behavior/config/ContextualDataUtil',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/behavior/config/SelectionUtil',
    "sap/viz/framework/common/util/DataContextUtils"
    
], function(
    Constants, 
    ObjectUtils, 
    DataGraphics,
    DataPointUtils, 
    DataUtils,
    SelectionUtil,
    DataContextUtils
) {

    function getTimeField(dataModel){
        var timeField;
        if (dataModel && dataModel.timeAxis && dataModel.timeAxis()) {
            timeField = dataModel.timeAxis().metaData.map(function(e) {
                return e.id;
            });
        }
        return timeField;
    }
    function convertBigNumString(dataModel, context){
        var measureNames = dataModel && dataModel._rawData && dataModel._rawData.measures &&
            dataModel._rawData.measures();
        return DataContextUtils.convertBigNumString(measureNames, context);
    }
    function removeTimeSuffix(data, timeField){
        var ret = data;
        if (timeField && timeField.length){
            ret = ObjectUtils.extend(true, {}, data);
            timeField.forEach(function(t){
                delete ret[t + DataUtils.DIMENSION_PARSED_VALUE_SUFFIX];
            });
        }
        return ret;
    }
    
  

    function fireContextualDataEvent(shapes, type, point, service, dateTimeRange) {
        var dataModel = service.getDataModel();
        var timeField = getTimeField(dataModel);
        var isDatapoint = type === "datapoint";
        var selectData = shapes.map(function (shape){
            var id = DataPointUtils.getDataPointId(shape);
            if(!id){
                return;
            }
            var data = isDatapoint ? 
                dataModel.getDataPoint(id).context() :
                DataGraphics.getContext(shape);
            data = convertBigNumString(dataModel, data);
            data = removeTimeSuffix(data, timeField);
            return {
                target: shape,
                data: data
            };
        });
        if(dateTimeRange) {
            selectData.dateTimeRange = dateTimeRange;
        }

        service.fireExternalEvent("contextualData", {
            name: Constants.Event.ContextualData.name,
            type: type,
            data: selectData,
            point: point
        });
    }

    function fireContextualDataEventByIDs(ids, type, point, service, dateTimeRange) {
        var dataModel = service.getDataModel();
        var timeField = getTimeField(dataModel);
        var selectData = ids.map(function (id){
            if(!id){
                return;
            }
            var data = dataModel.getDataPoint(id).context();
            
            data = convertBigNumString(dataModel, data);
            data = removeTimeSuffix(data, timeField);
            return {
                target: null,
                data: data
            };
        });
        if(dateTimeRange) {
            selectData.dateTimeRange = dateTimeRange;
        }
  
        service.fireExternalEvent("contextualData", {
            name: Constants.Event.ContextualData.name,
            type: type,
            data: selectData,
            point: point
        });
    }

    function fireContextualDataEventForArea(event, type, service) {
        var selectData = [];
        var point = getHitDataPoint(event, event.data.currentTarget, service);
        var data = convertBigNumString(service.getDataModel(), DataGraphics.getContext(point));
        selectData.push({
            target: point,
            data: data
        });
        service.fireExternalEvent("contextualData", {
            name: Constants.Event.ContextualData.name,
            type: type,
            data: selectData,
            point: event.data.point
        });
    }

    function fireContextualDataEventForLegendItem(event, type, point, service) {
        var context = {
            context: DataGraphics.getContext(event.data.currentTarget).ctx,
            target: event.data.currentTarget
        };
        service.fireExternalEvent("contextualData", {
            name: Constants.Event.ContextualData.name,
            type: type,
            data: [],
            context: context,
            point: event.data.point
        });
    }

    function getHitDataPoint(event, areaNode, service) {
        var mousePosition = getMousePosition(event.data.originalEvent);
        var relatedPoints = getRelatedPoints(areaNode);
        return getDataPointByMousePoint(mousePosition, relatedPoints, service);
    }

    function getDataPointByMousePoint(point, nodes, service) {
        var isHorizontal = service.isHorizontal();
        var coord = isHorizontal ? "y" : "x";
        var temp, result, position;
        nodes.forEach(function(item) {
            position = getDataPointCoord(item);
            var less = Math.abs(position[coord] - point[coord]);
            if (!result || !temp) {
                result = item;
                temp = less;
                return;
            }
            if (less < temp) {
                temp = less;
                result = item;
            }
        });
        return result;
    }

    function getRelatedPoints(target) {
        if (target) {
            var dataPoints = DataGraphics.getData(target).dataPoints;
            return dataPoints;
        }
    }

    function getMousePosition(e) {
        var event = e || window.event;
        return {
            x: event.pageX,
            y: event.pageY
        };
    }

    function getDataPointCoord(dataPoint) {
        var rect = dataPoint.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
    }

    function getDataPointsByTimeField(target, service) {
        var context = DataGraphics.getContext(target);
        var data = DataGraphics.getData(target);
        if(!data){
            return null;
        }
        var timeField = data.timeField, condition = {};
        if(!timeField || timeField.length === 0) {
            return null; 
        }
        timeField = timeField[0];
        condition[timeField] = context[timeField];
        return SelectionUtil.getDataPointNodes(condition, service)
            .sort(function(nodeA, nodeB){
                var seriesIndexA = DataGraphics.getData(nodeA).seriesIndex;
                var seriesIndexB = DataGraphics.getData(nodeB).seriesIndex;
                return seriesIndexA - seriesIndexB;
            });
    }

    return {
        getTimeField: getTimeField,
        removeTimeSuffix: removeTimeSuffix,
        fireContextualDataEvent: fireContextualDataEvent,
        fireContextualDataEventByIDs: fireContextualDataEventByIDs,
        fireContextualDataEventForArea: fireContextualDataEventForArea,
        fireContextualDataEventForLegendItem: fireContextualDataEventForLegendItem,
        getDataPointsByTimeField: getDataPointsByTimeField
    };
});

define('sap/viz/chart/behavior/config/ContextualDataConfig',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/chart/behavior/config/ContextualDataUtil",
    "sap/viz/framework/common/util/DataGraphics"
], function(
    Constants,
    ObjectUtils,
    DOM,
    DataPointUtils,
    HighlightHelper,
    SelectionUtil,
    ContextualDataUtil,
    DataGraphics
) {

    var axisLabelPattern = "v-axis-item",
        axisLabelPatternForTreemap = "v-nonLeafDimensionLabel",
        valueAxisPattern = "v-m-valueAxis",
        valueAxis2Pattern = "v-m-valueAxis2",
        categoryAxisPattern = "v-m-categoryAxis",
        categoryAxis2Pattern = "v-m-categoryAxis2",
        timeAxisPattern = "v-m-timeAxis";
    var legendPattern = "v-m-legend",
        sizeLegendPattern = "v-m-sizeLegend",
        legendItemPattern = "v-legend-item";
    var titlePattern = "v-m-title";
    var dataPointPattern = "v-datapoint",
        dataLabelPattern = "v-datalabel",
        selectedAreaPattern = "v-selected-area",
        areaPattern = "v-area";
    var plotPattern = "v-m-plot",
        plotBoundPattern = "v-m-plot-bound";
    var backgroundPattern = "v-m-background",
        subtitlePattern  = "v-subtitle";
    var lassoBoxPattern = "v-m-action-layerrange-content";

    var trellistitleLeft = "v-trellistitle-left",
        trellistitleRight = "v-trellistitle-right",
        trellistitleBottom = "v-trellistitle-bottom",
        trellistitleTop = "v-trellistitle-top";

    var CSS_CLASS = Constants.CSS.CLASS;

    var getTimeField = ContextualDataUtil.getTimeField,
        removeTimeSuffix = ContextualDataUtil.removeTimeSuffix,
        fireContextualDataEvent = ContextualDataUtil.fireContextualDataEvent,
        fireContextualDataEventByIDs = ContextualDataUtil.fireContextualDataEventByIDs,
        fireContextualDataEventForArea = ContextualDataUtil.fireContextualDataEventForArea;


    return [{
        id: "right_click_anywhere",
        triggerEvent: {
            name: "contextmenu"
        },
        handler: function(event, service) {
            service.fireEvent("hideDetail", {
                mode: "actionMode"
            }).fireEvent("hideDetail", {
                mode: "infoMode"
            });
        }
    }, {
        "id": "right_click_on_axis",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [
                valueAxisPattern,
                valueAxis2Pattern,
                categoryAxisPattern,
                categoryAxis2Pattern,
                timeAxisPattern
            ],
            "excludeTargets": [axisLabelPattern, axisLabelPatternForTreemap]
        },
        "handler": function(event, service) {
            var type;
            var target = event.data.currentTarget;

            if (DOM.hasClass(target, valueAxisPattern)) {
                type = 'valueAxis';
            } else if (DOM.hasClass(target, valueAxis2Pattern)) {
                type = 'valueAxis2';
            } else if (DOM.hasClass(target, categoryAxisPattern)) {
                type = 'categoryAxis';
            } else if (DOM.hasClass(target, categoryAxis2Pattern)) {
                type = 'categoryAxis2';
            } else if (DOM.hasClass(target, timeAxisPattern)) {
                type = 'timeAxis';
            }

            fireContextualDataEvent([], type, event.data.point, service);
        }
    }, {
        "id": "right_click_on_axis_label",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [axisLabelPattern, axisLabelPatternForTreemap]
        },
        "handler": function(event, service) {
            var axisItem = event.data.currentTarget;

            var axisRoot = axisItem; // find axis container
            while (axisRoot && axisRoot.getAttribute) {
                if (DOM.hasClass(axisRoot, CSS_CLASS.AXIS.CONTAINER)) {
                    break;
                }
                axisRoot = axisRoot.parentNode;
            }
            var ctx1 = ObjectUtils.extendByRepalceArray({},
                DataPointUtils.getContext(axisItem).ctx);
            if (axisRoot) {
                // special handling for trellis chart: attach axis container's
                // context if available
                var rootCtx = DataPointUtils.getContext(axisRoot);
                if (rootCtx) {
                    ObjectUtils.extendByRepalceArray(ctx1, rootCtx.ctx);
                }
            }

            if (service.isBigDataMode()) {
                var ids = SelectionUtil.getDataPointIds(ctx1, service);
                fireContextualDataEventByIDs(ids, 'axisLabel', event.data.point, service);
            } else {
                var targets = SelectionUtil.getDataPointNodes(ctx1, service);
                fireContextualDataEvent(targets, 'axisLabel', event.data.point, service);
            }
        }
    }, {
        "id": "right_click_on_axis_label_treemap",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [axisLabelPattern, axisLabelPatternForTreemap],
            "supportedChartTypes": "info/treemap"
        },
        "handler": function (event, service) {
            var axisItem = event.data.currentTarget;
            var ctx1 = DataPointUtils.getContext(axisItem);
            var targets = SelectionUtil.getDataPointNodes(ctx1, service);
            fireContextualDataEvent(targets, 'axisLabel', event.data.point, service);
        }
    }, {
        "id": "right_click_on_legend",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [legendItemPattern, legendPattern, sizeLegendPattern]
        },
        "handler": function(event, service) {
            var target = event.data.currentTarget;
            if (DOM.hasClass(target, legendItemPattern)) {
                ContextualDataUtil.fireContextualDataEventForLegendItem(event, 'legend', event.data.point, service);
            } else {
                fireContextualDataEvent([], 'legend', event.data.point, service);
            }
        }
    }, {
        "id": "right_click_on_title",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets":  titlePattern
        },
        "handler": function(event, service) {
            fireContextualDataEvent([], 'title', event.data.point, service);
        }
    }, {
        "id": "right_click_on_trellis_title",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets":  [trellistitleLeft, trellistitleRight, trellistitleBottom, trellistitleTop ]
        },
        "handler": function(event, service) {
            fireContextualDataEvent([], 'trellis_title', event.data.point, service);
        }
    }, {
        "id": "right_click_on_chartarea",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [backgroundPattern, subtitlePattern]
        },
        "handler": function(event, service) {
            fireContextualDataEvent([], 'chartArea', event.data.point, service);
        }
    }, {
        "id": "right_click_on_datapoint",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [dataPointPattern, dataLabelPattern]
        },
        "handler": function(event, service) {
            if(!service.getStatus('rangeSelection')) {
                var targets;
                if(service.getProperties().get('interaction.selectByTimeAxisGroup')) {
                    targets = ContextualDataUtil.getDataPointsByTimeField(event.data.currentTarget, service);
                }else {
                    targets = HighlightHelper.turnToArray(event.data.currentTarget);
                }
                if(targets) {
                    fireContextualDataEvent(targets, 'datapoint', event.data.point, service);
                }
            }else {
                fireContextualDataEvent([], 'plot', event.data.point, service);
            }
        }
    }, {
        "id": "right_click_on_area",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [areaPattern, selectedAreaPattern]
        },
        "handler": function(event, service) {
            fireContextualDataEventForArea(event, 'datapoint', service);
        }
    }, {
        "id": "right_click_on_lasso_box",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [lassoBoxPattern]
        },
        "handler": function(event, service) {
            var selectedDataPoints = service.getStatus('selectedDataPoints');
            var targets = DataPointUtils.getNodes(selectedDataPoints, service);
            var rangeDomain = service.getStatus('rangeDomain');
            var dateField = service.getDataModel()._timeAxis.metaData[0].id;
            var dateTimeRange = rangeDomain && rangeDomain.length === 2 ? {
                    start: {},
                    end: {}
                } : null;
            if(dateTimeRange) {
                dateTimeRange.start[dateField] = rangeDomain[0];
                dateTimeRange.end[dateField] = rangeDomain[1];
            }
            fireContextualDataEvent(targets, 'plot', event.data.point, service, dateTimeRange);
        }
    }, {
        "id": "right_click_on_plot",
        "declaredEvents": "contextualData",
        "triggerEvent": {
            "name": "contextmenu",
            "targets": [plotPattern, plotBoundPattern],
            "excludeTargets": [
                dataPointPattern,
                dataLabelPattern,
                axisLabelPattern,
                axisLabelPatternForTreemap,
                areaPattern,
                selectedAreaPattern
            ]
        },
        "handler": function(event, service) {
            if (!service.isBigDataMode()) {
                fireContextualDataEvent([], 'plot', event.data.point, service);
                return;
            }

            var originalEvent = event.data.originalEvent;
            var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);

            // hit test
            /* to get x/y relative to chart plot with un-scaled value */
            var coord = {
                left: event.data.pointToChart.x - matrix.e,
                top: event.data.pointToChart.y - matrix.f
            };
            var plot = service.getModule("main.plot");
            var offset = plot.getOffset();
            coord.left -= offset.x;
            coord.top -= offset.y;
            var points = plot.hitTest(coord);

            if (points.length === 0) {
                fireContextualDataEvent([], 'plot', event.data.point, service);
                return;
            }

            // obtain data point instance in dataModel and point info in plot.
            var dataModel = service.getDataModel();
            var point, data, dataPoint;

            for (var i = 0; i < points.length; i++) {
                point = points[i];
                dataPoint = dataModel.getDataPoint(point.dataId);
                if (dataPoint) {
                    var timeField = getTimeField(dataModel);
                    data = removeTimeSuffix(dataPoint.context(), timeField);
                    break;
                }
            }

            if (dataPoint == null) {
                fireContextualDataEvent([], 'plot', event.data.point, service);
            } else {
                service.fireExternalEvent("contextualData", {
                    name: Constants.Event.ContextualData.name,
                    type: 'datapoint',
                    data: [{
                        target: null,
                        data: data
                    }],
                    point: event.data.point
                });
            }
        }
    }];
});

define('sap/viz/chart/behavior/config/AlignToUtil',[
    "sap/viz/framework/common/util/TypeUtils"
], function(
    TypeUtils
) {
    var CALC = {
        l: function(bound) {
            return {
                x: bound.left,
                y: bound.top + bound.height / 2
            };
        },
        r: function(bound) {
            return {
                x: bound.right,
                y: bound.top + bound.height / 2
            };
        }
    };

    function calcOffset(config) {
        if (!TypeUtils.isArray(config)) {
            config = [config];
        }
        var offset = {};
        config.forEach(function(cfg) {
            var srcPos = CALC[cfg.source.pos](cfg.source.dom.getBoundingClientRect()),
                tgtPos = CALC[cfg.target.pos](cfg.target.dom.getBoundingClientRect());
            merge(offset, {
                x: tgtPos.x - srcPos.x,
                y: tgtPos.y - srcPos.y
            }, cfg.aspects || "xy");
        });

        return offset;
    }

    function merge(oldPos, newPos, aspects) {
        aspects.split("").forEach(function(prop) {
            if (newPos.hasOwnProperty(prop)) {
                oldPos[prop] = newPos[prop];
            }
        });
    }

    function buildTooltipEventData(event, service, targets, ref) {
        var tooltipEventData = {
            isAnchored: true,
            point: event.data.point,
            targets: targets,
            forceStyle: {
                padding: "0px"
            }
        };
        var legendGroup = service.getModule('legendGroup');
        var legendPos = legendGroup ? legendGroup.getPosition().charAt(0) : null;
        if (legendPos === 'l' || legendPos === 'r') {

            tooltipEventData.point.offset = {
                x: legendPos === "l" ? 10 : -10
            };
            tooltipEventData.point.alignTo = {
                source: {
                    pos: legendPos
                },
                target: {
                    dom: ref,
                    pos: legendPos === 'l' ? 'r' : 'l'
                }
            };
        }

        return tooltipEventData;
    }

    function buildMBCTooltipEventData(event, service, targets, yref, xref) {
        var tooltipEventData = {
            isAnchored: true,
            point: event.data.point,
            targets: targets,
            forceStyle: {
                padding: "0px"
            }
        };
        var legendGroup = service.getModule('legendGroup');
        var legendPos = legendGroup ? legendGroup.getPosition().charAt(0) : null;
        if (legendPos === 'l' || legendPos === 'r') {

            tooltipEventData.point.offset = {
                x: legendPos === "l" ? 10 : -10
            };
            tooltipEventData.point.alignTo = [{
                aspects: "y",
                source: {
                    pos: legendPos
                },
                target: {
                    dom: yref,
                    pos: legendPos === 'l' ? 'r' : 'l'
                }
            }, {
                aspects: "x",
                source: {
                    pos: legendPos
                },
                target: {
                    dom: xref,
                    pos: legendPos === 'l' ? 'r' : 'l'
                }
            }];
        }

        return tooltipEventData;
    }

    var AlignToUtil = {
        calculate: calcOffset,
        getTooltipData: buildTooltipEventData,
        getMBCTooltipData: buildMBCTooltipEventData
    };

    return AlignToUtil;
});

define('sap/viz/chart/behavior/config/handler/LegendBehaviorHandler',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/interaction/Constants',
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/AlignToUtil",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/components/util/ScrollbarUtil"
], function(Constants,
        SDKConstants,
        UADetector,
        DataPoints,
        SelectionUtil,
        DataPointUtils,
        AlignToUtil,
        DOM,
        ScrollbarUtil) {
    var BehaviorConstants = SDKConstants.BEHAVIOR;
    var CSS_CLASS = Constants.CSS.CLASS;
    var LEGEND_PAN_POS_STATUS = "legendPanLastPos";

    var LegendBehaviorHandler = function () { };



    LegendBehaviorHandler.prototype = {

        /**
         * Only invoked in standalone mode.
         */
        standAloneInitialized: function(event, service) {
            service.getProperties().origin.add({
                legend: {
                    mouseDownShadow: {
                        color: "#808080"
                    },
                    hoverShadow: {
                        color: "#cccccc"
                    }
                },
                interaction : {
                    selectability : {
                        legendSelection : true
                    }
                }
            });
        },

        getTargetsFromCtx: function (ctx, event, service) {
            if (service.isBigDataMode()) {
                var plot = service.getModule("main.plot");
                if (plot.setLastSeries) {
                    plot.setLastSeries(ctx, true);
                }
            }
            return this._getTargets(ctx, event, service);
        },

        dragStart: function(event, service) {
            if (!service.getProperties().get("legend.isScrollable") ||
                    service.getProperties().get("interaction.noninteractiveMode")||
                    !UADetector.isMobile()){
                return;
            }
            event.data.originalEvent.preventDefault();
            var point = event.data.point;
            var module = service.getModule('legendGroup.legend');
            var pos = module.isHorizontal() ? point.x : point.y;
            service.setStatus(LEGEND_PAN_POS_STATUS, pos);

            service.fireEvent("hideDetail", {
                mode: "infoMode"
            }).fireEvent("hideDetail", {
                mode: "actionMode"
            });
        },
        dragMove: function(event, service) {
            if (!service.getProperties().get("legend.isScrollable") ||
                    service.getProperties().get("interaction.noninteractiveMode") ||
                    !UADetector.isMobile()) {
                return;
            }
            if (!service.getStatus(LEGEND_PAN_POS_STATUS)) {
                return;
            }
            var module = service.getModule('legendGroup.legend');
            if (!module) {
                return;
            }
            event.data.originalEvent.preventDefault();
            var point = event.data.point;
            var pos = service.getStatus(LEGEND_PAN_POS_STATUS);
            var offset;
            if(module.isHorizontal()){
                offset = pos - point.x;
                service.setStatus(LEGEND_PAN_POS_STATUS, point.x);
            } else {
                offset = pos - point.y;
                service.setStatus(LEGEND_PAN_POS_STATUS, point.y);
            }
            if (module.scroll) {
                module.scroll(offset);
            }
        },
        dragEnd: function(event, service) {
            service.removeStatus(LEGEND_PAN_POS_STATUS);
        },
        hover: function (event, service) {
            if(service.getStatus("rangeSelection")){
                return;
            }
            service.fireEvent("processUnhighlight");
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.LEGEND_ITEM)) {
                return;
            }
            this.highlightLegendItem(event, service);

            //add data point hightlight effects.
            var ctx = DataPoints.getContext(event.data.currentTarget).ctx;
            var highlighted = this.getTargetsFromCtx(ctx, event, service);

            service.setStatus("hoveringLegend", true);
            service.fireEvent("processHighlight", {
                targets: highlighted,
            });
        },
        highlightLegendItem: function (event, service) {
            var targetItem = d3.select(event.data.currentTarget);
            targetItem.select("rect")
                .attr("fill", event.data.byKeyboard ? "transparent" :
                    service.getProperties().get("legend.hoverShadow.color"))
                .classed(CSS_CLASS.HOVER_SHADOW, true);

            if (!event.data.byKeyboard) {
                SelectionUtil.resetLegendSelectionEffect(service);
            }
        },
        syncSelectedLegendItems: function (event, service) {
            SelectionUtil.updateCorrespondingSelectedLegendItems(service);
        },
        nonHover: function (event, service) {
            //To clean hover state. So highlighting datapoint does not high light legend again.
            service.fireEvent("processUnhighlight");
            service.setStatus("hoveringLegend", false);
        },
        cleanLegendHoverEffect: function(event, service) {

            var legendItems = service.getNodes(service.NodeType.LEGEND_ITEM);

            legendItems
                .selectAll("rect")
                .attr("fill", "transparent")
                .classed(CSS_CLASS.HOVER_SHADOW, false)
                .classed(CSS_CLASS.FOCUS_SHADOW, false);

            SelectionUtil.resetLegendSelectionEffect(service);

            service.getNodes(service.NodeType.LEGEND_GROUP).select(".v-m-highlight").remove();
        },
        click: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.LEGEND_ITEM)) {
                return;
            }
            SelectionUtil.cleanRangeSelection(service);
            var ctx = DataPoints.getContext(event.data.currentTarget).ctx;
            var targets = this.getTargetsFromCtx(ctx, event, service);

            service.fireEvent("processSelection", {
                ctx: {series: ctx},  // sFinBehavior will check ctx to trigger category/series selection
                targets: targets,
                deselectable: true,
                ctrlKeyPressed: event.data.ctrlKey
            });
            var alignTarget = DOM.parent(event.data.target, ".v-legend-item") || event.data.target;
            var eventData = AlignToUtil.getTooltipData(event, service, targets, alignTarget);
            service.fireEvent("processMultipleSelectionTooltip", eventData);
        },

        _getTargets: function(ctx, event, service){
            return SelectionUtil.getDataPointIds(ctx, service);
        },

        mouseDown: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.LEGEND_ITEM)) {
                return;
            }
            service.getNodes(service.NodeType.LEGEND_ITEM)
                .selectAll("rect")
                .attr("fill", "transparent")
                .classed(CSS_CLASS.HOVER_SHADOW, false);
            SelectionUtil.resetLegendSelectionEffect(service);

            d3.select(event.data.currentTarget).select("rect")
                .attr("fill", service.getProperties().get("legend.mouseDownShadow.color"))
                .classed(CSS_CLASS.FOCUS_SHADOW, true);
        },

        mouseUp: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.LEGEND_ITEM)) {
                return;
            }
            var legendNode = service.getNodes(service.NodeType.LEGEND_ITEM);
            legendNode.selectAll("rect")
                .classed(CSS_CLASS.FOCUS_SHADOW, false);

            if (UADetector.isMobile()) {
                legendNode.selectAll("rect")
                    .attr("fill", "transparent")
                    .classed(CSS_CLASS.HOVER_SHADOW, false);
            } else {
                this.highlightLegendItem(event, service);
            }

            SelectionUtil.resetLegendSelectionEffect(service);
        },

        mouseWheel: function(event, service) {
            if(service.getProperties().get("legend.isScrollable")){
                ScrollbarUtil.onLegendScrollWheelHandler(event, service);
            }
        }
    };

    return LegendBehaviorHandler;
});

define('sap/viz/chart/behavior/config/LegendBehaviorConfig',[
    "sap/viz/chart/behavior/config/handler/LegendBehaviorHandler",
    'sap/viz/framework/common/util/Constants'
], function (LegendBehaviorHandler,
    Constants) {

    var CLASS_LEGEND_ITEM = "v-legend-item";
    //For bullet only, bulle has "v-legend-item" class, but need pinch and pan work, should listen drag event
    var CLASS_LEGEND_BULLET = "v-legend-bullet";

    return [
        {
            "id": "legendBehaviorDefinition",
            "handler": LegendBehaviorHandler,
            "handlerType": "class",
            "triggerEvent": [{
                "name": "standAloneInitialized",
                "method": "standAloneInitialized"
            }, {
                "name": "dragstart",
                "targets": [CLASS_LEGEND_ITEM, CLASS_LEGEND_BULLET],
                "method": "dragStart"
            }, {
                "name": "dragmove",
                "targets": [CLASS_LEGEND_ITEM, CLASS_LEGEND_BULLET],
                "method": "dragMove"
            }, {
                "name": "dragend",
                "targets": [CLASS_LEGEND_ITEM, CLASS_LEGEND_BULLET],
                "method": "dragEnd"
            }, {
                "name": "hover",
                "targets": CLASS_LEGEND_ITEM,
                "method": "hover"
            }, {
                "name": "highlightLegendItem",
                "excludeTargets": CLASS_LEGEND_ITEM,
                "method": "highlightLegendItem"
            }, {
                "name": "syncSelectedLegendItems",
                "excludeTargets": CLASS_LEGEND_ITEM,
                "method": "syncSelectedLegendItems"
            }, {
                "name": "hover",
                //data points (for pie) and axis items should be excluded.
                "excludeTargets": [CLASS_LEGEND_ITEM,
                    Constants.CSS.CLASS.DATAPOINT,
                    Constants.CSS.CLASS.DATALABEL,
                    Constants.CSS.CLASS.AXIS.LABEL_SELECTION,
                    Constants.CSS.CLASS.AXIS.LABEL_SELECTION_TIMEAXIS,
                    Constants.CSS.CLASS.AXIS.LABEL_SELECTION_TIMEAXIS_UPPERLEVEL],
                "method": "nonHover"
            }, {
                "name": "cleanLegendHoverEffect",
                "method": "cleanLegendHoverEffect"
            }, {
                "name": "click",
                "targets": CLASS_LEGEND_ITEM,
                "method": "click"
            }, {
                "name": "down",
                "targets": CLASS_LEGEND_ITEM,
                "method": "mouseDown"
            }, {
                "name": "up",
                "targets": CLASS_LEGEND_ITEM,
                "method": "mouseUp"
            }, {
                "name": "wheelmove",
                "targets": ["v-content"],
                "method": "mouseWheel"
            }]
        }
    ];
});

define('sap/viz/chart/behavior/config/LassoDecoration',["sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/interaction/Constants'
], function (DataPointUtils,
    FiscalUtil,
    Constants) {

    var LS_LAYER = "lasso";
    var RS_LAYER = "range";
    var RS_FILL_COLOR = 'rgba(102,151,231, 0.25)';
    var RS_FILL_COLOR_DRAG = 'rgba(102,151,231, 0.5)';
    var RS_STROKE = "rgb(102,151,231)";
    var RS_STROKE_WIDTH = 1;
    var RS_LINE_WIDTH = "3px";
    var RS_LINE_WIDTH_CLEAR = "0px";
    
    var DRAGOFFSET = Constants.RANGE_SELECTION.OFFSET;

    var LassoDecoration = function(actionLayer, service) {
        this._actionLayer = actionLayer;
        this._startPoint = null;
        this._shapeModel = null;
        this._service = service;
        // this line for range selection only 
        this._shapeLine = {points:[],  width:RS_LINE_WIDTH_CLEAR, color: RS_STROKE, pointerEvent: "none"};

    };

   // when we change property,decoration will keep, so we have to get mode dynamic
    LassoDecoration.prototype.start = function(parentCoord, point, baseCoord, mode) {
        // For range selection, we need add clippath
        var clip;
        this._startPoint = convertPointToParentCoordination(parentCoord, point);
        var layer;
        //range selection extra line position
        var lineX;
        if(mode === 'range'){
            this._mode = RS_LAYER;
        }else{
            this._mode = LS_LAYER;
        }
        var service = this._service;
        var shapeModel = this._shapeModel;
        layer = this._actionLayer.createLayer(this._mode);
        var shapeLine = this._shapeLine;
        if(this._mode === RS_LAYER){  
            var bPointInRange = false;
            service.fireEvent("hideDetail", {
                mode : "actionMode"
            });
           
            if(shapeModel && service.getStatus("rangeSelection")){
                
                if(shapeModel.x - DRAGOFFSET <= this._startPoint.x  &&
                  this._startPoint.x <= shapeModel.x + shapeModel.width + DRAGOFFSET){   
                    bPointInRange = true;
                    var startDelta = Math.abs(this._startPoint.x - shapeModel.x);
                    var endDelta = Math.abs(shapeModel.x + shapeModel.width - this._startPoint.x);
                    if(startDelta <= endDelta && startDelta <= DRAGOFFSET ){
                        this._direction = "right";
                        lineX = shapeModel.x;
                    }else if(endDelta <= DRAGOFFSET){
                        this._direction = "left";
                        lineX = shapeModel.x + shapeModel.width;
                    }else{
                        this._direction = "drag";
                    }
                }
                
                if(lineX){
                    shapeLine.points = [[lineX, shapeModel.y], [lineX, shapeModel.y + shapeModel.height]];
                    shapeLine.width = RS_LINE_WIDTH;
                    layer.addPolyLine(shapeLine);
                }
            }
                        
            if(!bPointInRange){
                service.setStatus("rangeSelection", true);
                this._direction = null;
                this._actionLayer.clear(this._mode);
          
                // In order to make top and bottom border invisible, make the rect top and bottom extra 2 px 
                shapeModel = this._shapeModel = {
                    x: this._startPoint.x,
                    y: baseCoord.y - parentCoord.y - RS_STROKE_WIDTH,
                    width: 0,
                    height: baseCoord.height + RS_STROKE_WIDTH * 2,
                    fill : RS_FILL_COLOR,
                    strokeWidth : RS_STROKE_WIDTH + "px",
                    stroke : RS_STROKE
                   
                };
                
                lineX = shapeModel.x;
                
                shapeLine.points = [[lineX, shapeModel.y], [lineX, shapeModel.y + shapeModel.height]];
                shapeLine.width = RS_LINE_WIDTH;
                layer.addPolyLine(shapeLine);
                clip = {};
                clip.x = baseCoord.x - parentCoord.x;
                clip.y = baseCoord.y - parentCoord.y;
                clip.width = baseCoord.width;
                clip.height = baseCoord.height;
                layer.addRect(this._shapeModel);
                this._actionLayer.drawLayer(layer, clip);
            }

        }else{
            
            this._actionLayer.clear(this._mode);
            layer = this._actionLayer.createLayer(this._mode);
            this._shapeModel = {
                x: this._startPoint.x,
                y: this._startPoint.y,
                width: 0,
                height: 0,
                pointerEvent: 'none',
                fill: 'rgba(64,176,240, 0.4)',
                strokeWidth: '2px',
                stroke: 'rgb(64, 176, 240)'
            };
            
            layer.addRect(this._shapeModel);
            this._direction = null;
            
            this._actionLayer.drawLayer(layer);
        }
    };

    function convertPointToParentCoordination(parentCoord, point) {
        var x = point.x - (parentCoord.x || parentCoord.left);
        var y = point.y - (parentCoord.y || parentCoord.top);
        return {
            'x': x,
            'y': y
        };
    }

    LassoDecoration.prototype.moveTo = function(parentCoord, point, baseCoord, event) {
        var service = this._service;
        if (this._startPoint && this._shapeModel) {
            var startPoint = this._startPoint;
            var shapeModel = this._shapeModel;
            // when in geo baseCoord is null
            var leftPoint;
            if(this._mode === RS_LAYER){
                leftPoint = convertPointToParentCoordination(parentCoord, baseCoord);
            }
            var convertedPoint = convertPointToParentCoordination(parentCoord, point);
            var tooltipPoint = {x:point.x, y:point.y};
            // range selection extra line position
            var lineX;
            if(this._direction){
                if(this._direction === 'right'){
                    // change start position of range selection
                    if(convertedPoint.x <= leftPoint.x){
                        shapeModel.width = shapeModel.width - leftPoint.x + shapeModel.x;
                        shapeModel.x = leftPoint.x;
                        tooltipPoint.x = baseCoord.x;
                    }else if(convertedPoint.x < shapeModel.x + shapeModel.width){
                        shapeModel.width = shapeModel.width - convertedPoint.x + shapeModel.x;
                        shapeModel.x = convertedPoint.x;
                    }else{
                        shapeModel.x =  shapeModel.x +  shapeModel.width - 2;
                        shapeModel.width = 2;                   
                    }
                    lineX = shapeModel.x;

                    
                }else if(this._direction === 'left'){
                    if(convertedPoint.x >= leftPoint.x + baseCoord.width){
                        shapeModel.width = leftPoint.x + baseCoord.width-  shapeModel.x;
                        tooltipPoint.x = baseCoord.x + baseCoord.width;
                    }else
                    if(convertedPoint.x > shapeModel.x){
                        shapeModel.width = convertedPoint.x -  shapeModel.x;
                    }else{

                        shapeModel.width = 2;
                    }
                    lineX = shapeModel.x + shapeModel.width;
                    
                }else if(this._direction === 'drag'){
                    this._startPoint = convertedPoint;
                    var deltaX = convertedPoint.x - startPoint.x;
                    
                    // range selection has fulfill the whole visible plot, can not move
                    if((shapeModel.x <= leftPoint.x  && 
                            shapeModel.x + shapeModel.width >= leftPoint.x + baseCoord.width) ||
                            (shapeModel.x <= leftPoint.x && deltaX < 0)  ||
                            (shapeModel.x + shapeModel.width >= leftPoint.x + baseCoord.width && deltaX > 0)){
                        return;
                    }

                    if(shapeModel.x < leftPoint.x){
                        if(shapeModel.x + shapeModel.width + deltaX <= leftPoint.x + baseCoord.width){
                            shapeModel.x =  shapeModel.x + deltaX;
                        }else{
                            shapeModel.x = leftPoint.x + baseCoord.width - shapeModel.width;
                        }
                        
                    }else if(shapeModel.x + shapeModel.width >= leftPoint.x + baseCoord.width){
                        
                        if(shapeModel.x + deltaX >= leftPoint.x){
                            shapeModel.x = shapeModel.x + deltaX;
                        }else{
                            shapeModel.x = leftPoint.x;
                        }
                    }else{
                        if(shapeModel.x + deltaX < leftPoint.x){
                            shapeModel.x = leftPoint.x;
                        }else if(shapeModel.x + shapeModel.width + deltaX > leftPoint.x + baseCoord.width){
                            shapeModel.x = leftPoint.x + baseCoord.width - shapeModel.width;
                        }else{
                            shapeModel.x = shapeModel.x + deltaX;
                        }
                    }
                    shapeModel.fill = RS_FILL_COLOR_DRAG;

                }
            }else{
                lineX = convertedPoint.x;
                var x = Math.min(convertedPoint.x, startPoint.x);
                var y = Math.min(convertedPoint.y, startPoint.y);
                var w = Math.abs(convertedPoint.x - startPoint.x);
                var h = Math.abs(convertedPoint.y - startPoint.y);
                shapeModel.x = x;
                shapeModel.width = w;
                if(this._mode === LS_LAYER){
                    shapeModel.y = y;
                    shapeModel.height = h;
                }else{
                    if(x < leftPoint.x){
                        shapeModel.x = leftPoint.x;
                        shapeModel.width -= leftPoint.x - x;
                    }
                    if(shapeModel.x +  shapeModel.width > leftPoint.x + baseCoord.width){
                        shapeModel.width = leftPoint.x + baseCoord.width - shapeModel.x;
                    }
                    
                    if(tooltipPoint.x < baseCoord.x){
                        tooltipPoint.x = baseCoord.x;
                    }
                    
                    if(tooltipPoint.x > baseCoord.x + baseCoord.width){
                        tooltipPoint.x = baseCoord.x + baseCoord.width;
                    }
                    
                    if(lineX < shapeModel.x){
                        lineX = shapeModel.x;
                    }
                    if(lineX > shapeModel.x + shapeModel.width){
                        lineX = shapeModel.x + shapeModel.width;
                    }
                }
            }
            
            var layer = this._actionLayer.createLayer(this._mode);
            layer.addRect(shapeModel);
            if(lineX && this._mode === RS_LAYER){
                this._shapeLine.points = [[lineX, shapeModel.y], [lineX, shapeModel.y + shapeModel.height]];
                this._shapeLine.width = RS_LINE_WIDTH;
                layer.addPolyLine(this._shapeLine);
            }
            this._actionLayer.drawLayer(layer);
            if(this._mode === RS_LAYER){
                service.fireEvent("timeRangeChanged", {
                    mode : "actionMode",
                    point : tooltipPoint,
                    target:event.data.target,
                    bTimeRange: true
                });
            }
        }
    };

    LassoDecoration.prototype.end = function() {
        
        if(this._mode === LS_LAYER){
            this._actionLayer.clear(LS_LAYER);
        }else{
            // we need to clear extra line and revert range selection opacity back to 0.25 
            var layer = this._actionLayer.createLayer(this._mode);
            this._shapeModel.fill = RS_FILL_COLOR;
            layer.addRect(this._shapeModel);
            this._shapeLine.points = [];
            this._shapeLine.width = RS_LINE_WIDTH_CLEAR;
            layer.addPolyLine(this._shapeLine); 
            this._actionLayer.drawLayer(layer);
        }
    };
    
    // 
    LassoDecoration.prototype.rangeRecover = function(event){
        var service = this._service;
        this._actionLayer.clear();
        var domain = service.getStatus("rangeDomain");
        if(!domain){
            return;
        }

        var startValue = domain[0];
        var endValue = domain[1];

        var dataModel = service.getDataModel();
        if (dataModel && dataModel._rawData && FiscalUtil.isFiscal(dataModel._rawData)) {
            startValue = FiscalUtil.fiscalToQuantity(startValue, service.getProperties());
            endValue = FiscalUtil.fiscalToQuantity(endValue, service.getProperties());
        }

        var mainPlot = service.getModule("main.plot");
        var axis = service.getModule("main.timeAxis.axisBody");
        var timeScale = axis.getScale();
        var totalRange = timeScale.getRange();
        //need to normalize range to [0, 1]
        var rangeDistance = totalRange[1] - totalRange[0];

        var bbox = service.getBBox(service.BoxType.PLOT_BOUND_NODE);
        var baseBox = service.getBBox(service.BoxType.ROOT_NODE);
        if(!bbox || !baseBox){
            return; //they do not exist when the chart is really tiny (e.g height 5)
        }

        var leftPoint = convertPointToParentCoordination(baseBox, bbox);
        var realSize = mainPlot.getRealSize();
        var offset = mainPlot.getOffset();
        var scaleRatio = service.getTransformScaleRatio();
        // for bug BITSDC1-7628, need to include scale ratio when calcuation.
        var startPos = timeScale.scale(startValue)/rangeDistance * realSize.width + offset.x;
        startPos *= scaleRatio.x;
        var difRatio = (timeScale.scale(endValue) - timeScale.scale(startValue))/rangeDistance;
        var width = difRatio  * realSize.width * scaleRatio.x;

        // In order to make top and bottom border invisible, make the rect top and bottom extra 2 px 
        this._shapeModel = {
            x : startPos + leftPoint.x,
            y : leftPoint.y - RS_STROKE_WIDTH,
            width : width,
            height : bbox.height + RS_STROKE_WIDTH * 2,
            fill : RS_FILL_COLOR,
            strokeWidth : RS_STROKE_WIDTH + "px",
            stroke : RS_STROKE
        };
        this._mode = RS_LAYER;
        var layer = this._actionLayer.createLayer(this._mode);
        layer.addRect(this._shapeModel);
        service.setStatus("rangeSelection", true);
        this._actionLayer.drawLayer(layer, {x:leftPoint.x, y:leftPoint.y, width: bbox.width, height:bbox.height});
    
    };
    
    LassoDecoration.prototype.changeRangeEffect = function(event){
        var direction = event.data.direction;
        if(direction === 'up'){
            this._shapeModel.fill = RS_FILL_COLOR;
        }else {
            this._shapeModel.fill = RS_FILL_COLOR_DRAG;
        }
        var layer = this._actionLayer.createLayer(this._mode);
        layer.addRect(this._shapeModel);
        this._actionLayer.drawLayer(layer);
    };

    LassoDecoration.prototype.getBoundingClientRect = function() {
        return this._actionLayer.getBoundingClientRect(this._shapeModel);
    };
    
    LassoDecoration.prototype.getShapeModel = function(){
        return this._shapeModel;
    };

    LassoDecoration.prototype.destroy = function() {
        this._actionLayer = null;
        this._shapeModel = null;
        this._startPoint = null;
        this._mode = null;
        this._shapeLine = null;
    };

    return LassoDecoration;
});

define('sap/viz/chart/components/util/BoundingBoxUtils',[],

    function Setup() {
        var boundingbox = {};

        // return true if the two boxes intersect
        boundingbox.intersects = function(a, b) {
            return (a.left <= (b.left + b.width) &&
                b.left <= (a.left + a.width) &&
                a.top <= (b.top + b.height) &&
                b.top <= (a.top + a.height));
        };

        // returns a box representing the intersection of box1 and box2 if it exists, otherwise null
        boundingbox.intersection = function(box1, box2) {
            if (boundingbox.intersects(box1, box2)) {
                var x1 = Math.max(box1.left, box2.left),
                    x2 = Math.min(box1.left + box1.width, box2.left + box2.width),
                    y1 = Math.max(box1.top, box2.top),
                    y2 = Math.min(box1.top + box1.height, box2.top + box2.height);

                return {
                    x: x1,
                    y: y1,
                    left: x1,
                    top: y1,
                    width: x2 - x1,
                    height: y2 - y1
                };
            }

            return null;
        };

        boundingbox.contains = function(box, point) {
            /*jshint laxbreak:true*/
            return point.x >= box.left && point.x <= (box.left + box.width) && point.y >= box.top &&
                point.y <= (box.top + box.height);

        };

        return boundingbox;
    });

define('sap/viz/chart/behavior/config/handler/LassoBehaviorHandler',[
    "sap/viz/framework/interaction/Constants",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/chart/behavior/config/LassoDecoration",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/components/util/BoundingBoxUtils",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/chart/behavior/config/SelectionUtil"
], function(
    Constants,
    UADetector,
    LassoDecoration,
    DataPointUtils,
    BoundingBox,
    DOM,
    TypeUtils,
    DataGraphics,
    ArrayUtils,
    SelectionUtil
) {

    var isMobile = UADetector.isMobile;

    function getRelativeRectInPlot(lassoRect, plotRect){
        return {
            left: lassoRect.left - plotRect.left,
            top: lassoRect.top - plotRect.top,
            width: lassoRect.width,
            height: lassoRect.height
        };
    }

    function getMousePosition(e) {
        if (isMobile()) {
            return e.data.point;
        }
        var event = e.data.originalEvent || window.event;
        return {
            x: event.pageX,
            y: event.pageY
        };
    }

    function LassoBehaviorHandler() {}

    LassoBehaviorHandler.prototype = {

        standAloneInitialized: function(event, service) {
            service.getProperties().origin.add({
                interaction: {
                    selectability: {
                        plotLassoSelection: true
                    }
                }
            });
        },

        initialized: function(event, service) {
            this._lassoDecoration = new LassoDecoration(service._getActionLayer(),  service);
            service.setStatus("lassoStartPoint", null);
            service.setStatus("lassoEndPoint", null);
            service.setStatus("lassoCoveredDataPoints", []);
        },
        unloadClear: function(event, service) {
            if (this._lassoDecoration) {
                this._lassoDecoration.destroy();
                this._lassoDecoration = null;
                delete this._lassoDecoration;
            }
            service.removeStatus("lassoStartPoint");
            service.removeStatus("lassoEndPoint");
            service.removeStatus("lassoCoveredDataPoints");
            service.removeStatus("rangeDomain");
            service.removeStatus("rangeSelection");
        },


        lassoStart: function(event, service) {
            var lassoDecoration = this._lassoDecoration;
            if (!lassoDecoration) {
                return;
            }
            var selectability = service.getProperties().get("interaction.selectability");
            if (!selectability) {
                return;
            }
            var mode = service.getProperties().get("interaction.selectability.plotLassoMode");
            var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
            if (!selectability.plotLassoSelection ||
                    selectionMode === Constants.SELECTION_MODE.NONE ||
                    selectionMode === Constants.SELECTION_MODE.SINGLE) {
                return;
            }
            var point = event.data.point;

            var bbox = service.getBBox(mode === 'range' ?  service.BoxType.PLOT_BOUND_NODE : service.BoxType.ROOT_NODE);
            var baseBox = service.getBBox(service.BoxType.ROOT_NODE);

            if (!BoundingBox.contains(bbox, point)) {
                return;
            }
            //start lasso
            service.setStatus("lassoStartPoint", getMousePosition(event));
            lassoDecoration.start(baseBox, point, bbox, mode);
            service.fireEvent("hideDetail", {
                mode: "infoMode",
                action: "interrupt"
            }).fireEvent("hideDetail", {
                mode: "actionMode",
                action: "interrupt"
            }).fireEvent("cleanLegendHoverEffect")
                .fireEvent("cleanAxisHoverEffect")
                  .fireExternalEvent("lassoStart");
        },
        lassoMove: function(event, service) {
            this._drawLassoRect(event, service);
        },
        _getStartEnd: function(service, ranges){
            return ranges;
        },
        _postProcessTargets: function(service, targets){
            if(service._getChartType() && service._getChartType().indexOf("bullet") > -1){
                targets = ArrayUtils.unique(targets);
            }
            return targets;
        },
        lassoEnd : function(event, service) {
            if (this._validLasso(service)) {
                var byTimeseriesGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');
                var lassoDecoration = this._lassoDecoration;
                var point = event.data.point;
                service.setStatus("lassoEndPoint", point);
                var includedTargets = null;
                var dataPointNodes = service.getNodes(service.NodeType.DATA_POINT);
                var lassoRect = this._lassoDecoration.getBoundingClientRect();
                var mainPlot = service.getModule("main.plot");

                if(service.getStatus("rangeSelection") && mainPlot &&
                            mainPlot.hitTestForRangeSelection ){
                    var RS = service.getStatus("rangeDomain");
                    var ranges = this._getStartEnd(service, {start:RS[0], end:RS[1]});
                    includedTargets = mainPlot.hitTestForRangeSelection(ranges);
                }else if (service.isBigDataMode() && mainPlot && mainPlot.hitTest ) {
                    var rect = getRelativeRectInPlot(lassoRect, service.getBBox(service.BoxType.PLOT_BOUND_NODE));
                    includedTargets = mainPlot.hitTest(rect).map(function(e){
                        return (e.dataId).toString();
                    });
                } else {
                    includedTargets = findLassoCoveredDataPoints.call(this, service);
                }

                includedTargets = this._postProcessTargets(service, includedTargets);

                if(service.getStatus("rangeSelection")){
                    var selectedDataPoints =  service.getStatus("selectedDataPoints");
                    service.setStatus("selectedDataPoints", []);
                    var  unselected = selectedDataPoints.filter( function( el ) {
                        return includedTargets.indexOf( el ) < 0;
                    });
                    if(unselected && unselected.length > 0){

                        service.fireEvent("deselectDataPoint", {
                            targets : DataPointUtils.getNodes(unselected, service),
                            isAnyOtherSelected : includedTargets.length > 0
                        });
                        service.fireEvent("dispatchDataEvent", {
                            targets: unselected,
                            isSelected: false
                        });
                        if(includedTargets.length === 0){
                            service.fireEvent("clearPlot", {
                                isGray : false,
                                rangeSelection: "clear"
                            });
                        }

                    }

                    if(includedTargets.length === 0){

                        service.fireEvent("dispatchDataEvent", {
                            targets: [],
                            isSelected: true
                        });
                    }
                }
                lassoDecoration.end();

                if(!service.getStatus("rangeSelection") || includedTargets.length > 0 ){
                    this._fireEvent(event, service, includedTargets, point, true);
                }else if(service.getStatus("rangeSelection") && includedTargets.length === 0){
                    service.fireEvent("showDetail", {
                        mode: "actionMode",
                        point: point,
                        bLassoEnd: true
                    });
                }

                service.fireExternalEvent("lassoEnd");

            }
            service.setStatus("lassoStartPoint", null);
            SelectionUtil.processTimeCursor(event, service);
        },




        lassoEndForArea: function(event, service) {
            if (this._validLasso(service)) {
                var lassoDecoration = this._lassoDecoration;
                //event.data.originalEvent.preventDefault();
                var startPoint = service.getStatus("lassoStartPoint");
                var endPoint = getMousePosition(event);
                service.setStatus("lassoEndPoint", endPoint);
                var includedTargets = null;
                includedTargets = findLassoCoveredDataPointsForArea.call(this, service, startPoint, endPoint);
                lassoDecoration.end();
                this._fireEvent(event, service, includedTargets, event.data.point, true);
                service.setStatus("lassoStartPoint", null);
                service.fireExternalEvent("lassoEnd");
            }
        },

        lassoEndForComboEx: function(event, service) {
            if (this._validLasso(service)) {
                var startPoint = service.getStatus("lassoStartPoint"),
                    endPoint = getMousePosition(event);

                service.setStatus("lassoEndPoint", endPoint);

                var includedTargets = findLassoCoveredDataPoints.call(this, service);
                var allDps = Array.prototype.slice.call(service.getNodes(service.NodeType.DATA_POINT, false)),
                    areaSeriesIdx = service.getStatusManager().get("plotArea.series").map(function(sr, i) {
                        return sr.type === "area";
                    }),
                    areaDps = [].filter.call(allDps, function(node) {
                        return areaSeriesIdx[DataGraphics.getData(node).seriesIndex];
                    });

                var areaTargets = findLassoCoveredDataPointsForArea.call(this, service, startPoint, endPoint, areaDps);
                includedTargets = includedTargets.concat(areaTargets.filter(function(t) {
                    return includedTargets.indexOf(t) === -1;
                }));

                this._lassoDecoration.end();
                this._fireEvent(event, service, includedTargets, event.data.point, true);
                service.setStatus("lassoStartPoint", null);
                service.fireExternalEvent("lassoEnd");
            }
        },

        _validLasso : function(service) {
            var lassoDecoration = this._lassoDecoration;
            if (!lassoDecoration) {
                return false;
            }

            var selectability = service.getProperties().get("interaction.selectability");
            if (!selectability) {
                return false;
            }
            var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
            if (!selectability.plotLassoSelection || selectionMode === Constants.SELECTION_MODE.NONE ||
                selectionMode === Constants.SELECTION_MODE.SINGLE || !service.getStatus("lassoStartPoint")) {
                return false;
            }
            return true;
        },

        _fireEvent : function(event, service, includedTargets, point, showDetail) {
            service.fireEvent("processSelection", {
                targets: includedTargets,
                deselectable: false,
                ctrlKeyPressed: event.data.ctrlKey
            });
            var selectedDataPoints = service.getStatus("selectedDataPoints");
            if (selectedDataPoints.length && includedTargets.length) {
                var dpTarget = event.data.target;
                while (dpTarget) {
                    if (dpTarget.getAttribute) {
                        if (DOM.hasClass(dpTarget, "v-datalabel")) {
                            dpTarget = DataPointUtils.getDataPointByDataLabel(dpTarget, service);
                            //BITSDC1-7828, there is no hover state in mobile,
                            //we should not set "hoveringDataPoint" state.
                            //Otherwise, when drag, hovering data point will take effect
                            if(!isMobile()){
                                service.setStatus("hoveringDataPoint", dpTarget);
                            }
                            break;
                        }
                        if (DOM.hasClass(dpTarget, "v-datapoint")) {
                            if(!isMobile()){
                                service.setStatus("hoveringDataPoint", dpTarget);
                            }
                            break;
                        }
                        dpTarget = dpTarget.parentNode;
                    } else {
                        dpTarget = undefined;
                    }
                }
                if (!dpTarget) {
                    dpTarget = this._getShowDetailTarget(selectedDataPoints, service);
                }
                if (showDetail) {
                    this._fireShowDetail(service, dpTarget, point);
                }
            } else {
                this._fireHideDetail(service);
            }
        },

        _fireShowDetail: function(service, dpTarget, point) {
            service.fireEvent("showDetail", {
                target: dpTarget,
                mode: "actionMode",
                point: point,
                bLassoEnd: true,
                action: "select"
            });
        },

        _fireHideDetail: function(service) {
            service.fireEvent("hideDetail", {
                mode: "actionMode"
            });
        },

        _drawLassoRect : function(event, service) {
            var lassoDecoration = this._lassoDecoration;
            if (!lassoDecoration) {
                return;
            }
            var selectability = service.getProperties().get("interaction.selectability");
            if (!selectability) {
                return;
            }
            var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
            if (!selectability.plotLassoSelection || selectionMode === Constants.SELECTION_MODE.NONE ||
                selectionMode === Constants.SELECTION_MODE.SINGLE || !service.getStatus("lassoStartPoint")) {
                return;
            }
            event.data.originalEvent.preventDefault();
            lassoDecoration.moveTo(service.getBBox(service.BoxType.ROOT_NODE), event.data.point,
                    service.getBBox( service.BoxType.PLOT_BOUND_NODE ), event);
        },

        _getBoundSelection : function(service) {
            return service.getNodes(service.NodeType.PLOT_BOUND_SELECTION, false);
        },

        _isCovered : function(node, plotBoundRects) {
            var rect = node.getBoundingClientRect();
            for (var i = -1; ++i < plotBoundRects.length;) {
                if (BoundingBox.intersects(rect, plotBoundRects[i])) {
                    return true;
                }
            }
            return false;
        },

        _getShowDetailTarget : function(selectedDataPoints, service) {
            var selectByTimeAxisGroup = service.getProperties().get("interaction.selectByTimeAxisGroup");
            var selectedPeriods = [];
            if (selectByTimeAxisGroup) {
                selectedPeriods = SelectionUtil.getSelectedPeriods(service, selectedDataPoints);
            }
            if (selectedDataPoints.length === 1 || (
                selectByTimeAxisGroup && selectedPeriods.length === 1)) {
                var node = service.getNodes(service.NodeType.DATA_POINT_GROUP, false)[0];
                return DataPointUtils.findByDataPointId(node, selectedDataPoints[0]);
            }
        },

        _getTargets : function(plotBoundRects, service) {
            var allDataPoints = service.getNodes(service.NodeType.DATA_POINT, false);
            return [].slice.call(allDataPoints).filter(function(dataPoint) {
                return this._isCovered(dataPoint, plotBoundRects);
            }, this).map(function(node){
                var data = DataGraphics.getData(node);

                // unify with big data mode.
                return DataPointUtils.getDataPointId(node);
            });
        }
    };

    function crossMul(v1,v2) {
        return v1.x*v2.y-v1.y*v2.x;
    }

    function lineCross(lineA, lineB) {
        var x1 = lineA.point1.x;
        var y1 = lineA.point1.y;
        var x2 = lineA.point2.x;
        var y2 = lineA.point2.y;
        var x3 = lineB.point1.x;
        var y3 = lineB.point1.y;
        var x4 = lineB.point2.x;
        var y4 = lineB.point2.y;

        var v1={"x": x1 - x3, "y": y1 - y3};
        var v2={"x": x2 - x3, "y": y2 - y3};
        var v3={"x": x4 - x3, "y": y4 - y3};
        var v = crossMul(v1,v3) * crossMul(v2,v3);

        v1 = {"x": x3 - x1, "y": y3 - y1};
        v2 = {"x": x4 - x1, "y": y4 - y1};
        v3 = {"x": x2 - x1, "y": y2 - y1};

        return (v <= 0 && crossMul(v1,v3) * crossMul(v2,v3) <= 0) ? true : false;
    }

    //Check if target point be covered by a ploygon
    LassoBehaviorHandler._isContains = function(target, points) {
        var i, j;
        var result = false;
        for (i = 0, j = points.length - 1; i < points.length; j = i++) {
            if ((points[i].y > target.y) != (points[j].y > target.y) &&
                (target.x < (points[j].x - points[i].x) * (target.y - points[i].y) /
                (points[j].y-points[i].y) + points[i].x)) {
                result = !result;
            }
        }
        return result;
    };

    function convertCoord(points, offset) {
        var result = [];
        points.forEach(function(item) {
            result.push({"x": item.x + offset.x, "y": item.y + offset.y});
        });
        return result;
    }

    //Check if two ploygon are intersected
    LassoBehaviorHandler._isIntersect = function(detection, lassoArea) {
        var i, j, lineA, lineB;
        for (i = 1; i < detection.length; i++) {
            for (j = 1; j < lassoArea.length; j++) {
                lineA = {
                    "point1": detection[i -1],
                    "point2": detection[i]
                };
                lineB = {
                    "point1": lassoArea[j -1],
                    "point2": lassoArea[j]
                };
                if (lineCross(lineA, lineB)) {
                    return true;
                }
            }
        }
        return false;
    };

    function buildLassoArea(startPoint, endPoint) {
        var lassoArea = [];
        lassoArea.push({"x": startPoint.x, "y": startPoint.y});
        lassoArea.push({"x": endPoint.x, "y": startPoint.y});
        lassoArea.push({"x": endPoint.x, "y": endPoint.y});
        lassoArea.push({"x": startPoint.x, "y": endPoint.y});
        lassoArea.push({"x": startPoint.x, "y": startPoint.y});
        return lassoArea;
    }

    function findLassoCoveredDataPointsForArea(service, startPoint, endPoint, areaDataPoints) {
        var plotBoundRects = getPlotBoundRects.call(this, service);
        var allDataPoints = areaDataPoints || service.getNodes(service.NodeType.DATA_POINT, false);
        var lassoArea = buildLassoArea(startPoint, endPoint);
        var plaBound = service.getNodes(service.NodeType.PLOT_BOUND_SELECTION, false)[0].getBoundingClientRect(),
            plaPageOffset = {
                x: plaBound.left + window.pageXOffset,
                y: plaBound.top + window.pageYOffset
            };
        return [].slice.call(allDataPoints).filter(function(dataPoint) {
            var isCovered = this._isCovered(dataPoint, plotBoundRects);
            if (isCovered) {
                return true;
            } else {
                var shape = DataGraphics.getGraphicInfo(dataPoint);

                var detection = convertCoord(shape.areaPath, plaPageOffset);
                if (LassoBehaviorHandler._isIntersect(detection, lassoArea) ||
                    LassoBehaviorHandler._isContains(startPoint, detection)) {
                    return true;
                }
            }
            return false;
        }, this).map(function(node){
            // unify with big data mode.
            return DataPointUtils.getDataPointId(node);
        });
    }

    function getPlotBoundRects(service) {
        // find the intersection of the plot rectangle with the lasso rectangle
        var lassoBBox = this._lassoDecoration.getBoundingClientRect();

        var plotBoundRects = [];

        var boundSelections = this._getBoundSelection(service);

        // if boundSelections is not an array or querySelector's result
        if (!(boundSelections instanceof window.NodeList) &&
                !TypeUtils.isArray(boundSelections)) {
            boundSelections = [boundSelections];
        }

        boundSelections.forEach(function(item) {
            var plotBoundRect = BoundingBox.intersection(lassoBBox,
                item.getBoundingClientRect());
            if (plotBoundRect) {
                plotBoundRects.push(plotBoundRect);
            }
        });

        return plotBoundRects;
    }

    function findLassoCoveredDataPoints(service) {
        var plotBoundRects = getPlotBoundRects.call(this, service);
        return this._getTargets(plotBoundRects, service);
    }

    return LassoBehaviorHandler;
});

define('sap/viz/chart/behavior/config/LassoBehaviorConfig',[
    "sap/viz/chart/behavior/config/handler/LassoBehaviorHandler"
], function(LassoBehaviorHandler) {

    var eventLayerPattern = "v-m-root";
    var allTimeCharts = ['info/timeseries_line', 'info/timeseries_column', 'info/timeseries_scatter', 
                        'info/timeseries_bubble', "info/timeseries_combination","info/dual_timeseries_combination",
                        "info/timeseries_stacked_column", "info/timeseries_stacked_combination", 
                        "info/timeseries_100_stacked_column",
                        "info/timeseries_bullet", "info/timeseries_waterfall"];

    return [{
        "id": "lassoBehaviorDefinition",
        "handler": LassoBehaviorHandler,
        "handlerType": "class",
        //"supportedChartTypes": [],
        "triggerEvent": [{
            "name": "standAloneInitialized",
            "method": "standAloneInitialized"
        }, {
            "name": "afterBehaviorLoaded",
            "method": "initialized"
        }, {
            "name": "beforeBehaviorUnloaded",
            "method": "unloadClear"
        }, {
            "name": "lassostart",
            "targets": eventLayerPattern,
            "excludeTargets": "v-m-scrollbarThumb",
            "method": "lassoStart"
        }, {
            "name": "lassomove",
            "targets": eventLayerPattern,
            "method": "lassoMove"
        }, {
            "name": "lassoend",
            "targets": eventLayerPattern,
            "method": "lassoEnd"
        }, {
            "name": "lassoend",
            "targets": eventLayerPattern,
            "supportedChartTypes": ["info/area", "info/horizontal_area",
                "info/100_area", "info/100_horizontal_area",
                "info/trellis_area", "info/trellis_horizontal_area",
                "info/trellis_100_area", "info/trellis_100_horizontal_area"],
            "method": "lassoEndForArea"
        }, {
            "name": "lassoend",
            "targets": eventLayerPattern,
            "supportedChartTypes": ["info/combinationEx"],
            "method": "lassoEndForComboEx"
        }]
    }];

});

define('sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler',[
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/interaction/Constants',
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/chart/components/util/SeriesUtil",
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DOM',
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/ContextualDataUtil"
], function(
    Constants,
    SDKConstants,
    UADetector,
    DataPointUtils,
    HighlightHelper,
    SelectionUtil,
    SeriesUtil,
    SVG,
    DOM,
    DataGraphics,
    TypeUtils,
    ContextualDataUtil
) {
    var BehaviorConstants = SDKConstants.BEHAVIOR;
    var CSS_CLASS = Constants.CSS.CLASS;
    var LINE_TYPE = Constants.LINE_TYPE;
    var DP_LAYER = "datapoint";
    var DL_LAYER = "dataline";

    var DEFAULT_STROKE_WIDTH = 2;
    var CLASS_LIGHT_LINE = CSS_CLASS.LIGHT_LINE;
    var DATA_ATTR_FROM = "data-from";
    var DATA_ATTR_TO = "data-to";

    var getColors = HighlightHelper.getColors;

    function getShape(plot, dataPoint){
        return plot && plot.getDataPointShape && plot.getDataPointShape(dataPoint);
    }

    function lightLine(service, node, before, flag, lineRenderer) {
        var data = DataGraphics.getData(node);


        var anotherNodeId = data[before ? "next" : "prev"];
        if (!anotherNodeId) {
            return;
        }

        var parentNode = node.parentNode;
        var anotherNode = DataPointUtils.findByDataPointId(parentNode, anotherNodeId);

        var nodeId = DataPointUtils.getDataPointId(node);
        var ids = before ? [nodeId, anotherNodeId] : [anotherNodeId, nodeId];

        var lightLineNode = parentNode.querySelector(
            "." + CLASS_LIGHT_LINE +
            "[" + DATA_ATTR_FROM + "='" + ids[0] + "']" +
            "[" + DATA_ATTR_TO + "='" + ids[1] + "']"
        );

        if (flag && anotherNode && DataPointUtils.isHighlighted(anotherNode)) {
            var lineGroup = parentNode.querySelector("." + CSS_CLASS.LINES_GROUP);
            var lineData = DataGraphics.getData(lineGroup);
            var isHorizontal = service.isHorizontal();

            var pointsToLink = [
                DataGraphics.getData(anotherNode).translate.slice(),
                data.translate.slice(),
            ];
            if (before) {
                pointsToLink.reverse();
            }
            pointsToLink[0].id = ids[0];
            pointsToLink[1].id = ids[1];

            var semanticMgr = service.getSemanticManager();

            var color = lineData.color;
            var dash = null;
            var linecap;
            var dataModel = service.getDataModel();
            var plot = Handler.getPlot(service, node);
            var defaultLineRenderer = null;
            if (plot.getDefaultLineRenderer) {
                defaultLineRenderer = plot.getDefaultLineRenderer() ?
                plot.getDefaultLineRenderer().expose : null;
            }
            var type = SeriesUtil.parseSeriesLineType(plot.getData(), data.seriesIndex, semanticMgr);

            if (semanticMgr.hasDataPointLineStyle()){
                var effectMgr = service.getEffectManager();
                var ctx = [
                    DataPointUtils.getContextByDataModel(node, dataModel),
                    DataPointUtils.getContextByDataModel(anotherNode, dataModel)
                ];

                var additionCtx = [
                    DataPointUtils.getAdditionCtxByDataModel(node, dataModel),
                    DataPointUtils.getAdditionCtxByDataModel(anotherNode, dataModel)
                ];
                color = effectMgr.register({
                    fillColor: SeriesUtil.parseSemanticLineColor(ctx, semanticMgr, color, additionCtx)
                });
                var lineType = SeriesUtil.parseSemanticLineType(ctx, semanticMgr, null, additionCtx);
                if (lineType === LINE_TYPE.DASHED || lineType === LINE_TYPE.DOTTED ||
                        lineType === LINE_TYPE.DOT){
                    type = lineType;
                }
            }

            var config = {
                graphic: {
                    color: color,
                    width: lineData.width
                },
                points: pointsToLink,
                isHorizontal: isHorizontal,
                ctx: DataGraphics.getContext(node)
            };

            if(type === Constants.LINE_TYPE.DASHED || type === Constants.LINE_TYPE.DOTTED){
                dash = Constants.LINE_DASH_TYPE_ARRAY;
            }else if(type === Constants.LINE_TYPE.DOT){
                dash = "0," + (lineData.width * 2);
                config.graphic.linecap = "round";
            }


            if (dash){
                config.graphic.dash = dash;

            }
            var lightLineContent;
            if (lineRenderer){
                lightLineContent = lineRenderer(config, defaultLineRenderer) || defaultLineRenderer.renderer(config);
            }

            if (lightLineContent) {
                if (lightLineNode) {
                    DOM.empty(lightLineNode);
                } else {
                    lightLineNode = SVG.create("g");
                    lightLineNode.setAttribute("class", CLASS_LIGHT_LINE);
                    lightLineNode.setAttribute("fill-opacity", "1");
                    lightLineNode.setAttribute("stroke-opacity", "1");
                }
                lightLineNode.setAttribute(DATA_ATTR_FROM, ids[0]);
                lightLineNode.setAttribute(DATA_ATTR_TO, ids[1]);
                lightLineNode.appendChild(lightLineContent);
                parentNode.insertBefore(lightLineNode, lineGroup.nextElementSibling);
            }
        } else {
            if (lightLineNode) {
                parentNode.removeChild(lightLineNode);
            }
        }
    }

    function dataPointClickHandler(event, service, target) {
        var selectByTimeAxisGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');
        var selectability = isSelectable(service);
        if (!selectability) {
            return false;
        }
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        if (!selectability.plotStdSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE || !target) {
            return;
        }

        var selectedDataPoints = service.getStatus("selectedDataPoints");
        if(service.getStatus("rangeSelection")){
            service.setStatus("selectedDataPoints", []);
            service.fireEvent("clearPlot").fireEvent("deselectDataPoint", {
                targets : DataPointUtils.getNodes(selectedDataPoints, service),
                isAnyOtherSelected : false
            });
            service.setStatus("rangeSelection", false);

        }

        var config = event.data;
        var eventTarget;
        if(selectByTimeAxisGroup) {
            var dps = ContextualDataUtil.getDataPointsByTimeField(target, service);
            var len = dps.length, that = this;
            eventTarget = [];
            dps.forEach(function(dp) {
                eventTarget.push(that._getDataPoint(dp, service));
            });
        }else {
            eventTarget = this._getDataPoint(target, service);
        }
        var selectedBefore = this._hasDataPoint(service.getStatus("selectedDataPoints"),
            this._getDataPoint(target, service));

        service.fireEvent("processSelection", {
            targets : eventTarget,
            deselectable : true,
            ctrlKeyPressed : config.ctrlKey
        });

        if (this._hasDataPoint(service.getStatus("selectedDataPoints"),
            this._getDataPoint(target, service))) {
            service.fireEvent("showDetail", {
                target : target,
                mode : "actionMode",
                point : config.point,
                action: "select"
            });
        } else {
            service.fireEvent("hideDetail", {
                target : target,
                mode : "actionMode",
                action: "deselect"
            }).setStatus("isHoveringDeselectedDataPoint", selectedBefore);
        }
    }

    function isSelectable(service) {
        return service.getProperties().get("interaction.selectability");
    }

    function addMask2Layer(plot, matrix, layer){
        var plotMainBBox = plot.getSize();
        var maskMgr = layer.getMaskManager();
        var mask = {
            x: matrix.e,
            y: matrix.f,
            width: plotMainBBox.width,
            height: plotMainBBox.height
        };
        maskMgr.addRect(mask);
    }

    function dataPointHoverHandler(event, service, target) {
        if(!target){
            return;
        }
        var point = event.data.point;
        if(service.getStatus("rangeSelection")){
            return;
        }
        var hoveringDataPoint = service.getStatus("hoveringDataPoint");
        var dp = this._getDataPoint(target, service);
        var selected = this._hasDataPoint(service.getStatus("selectedDataPoints"), dp);
        if (hoveringDataPoint) {
            if (hoveringDataPoint === target) {
                if (!service.getStatus("isHoveringDeselectedDataPoint")) {
                    service.fireEvent("showDetail", {
                        target : target,
                        mode : selected ? "actionMode" : "infoMode",
                        point : point,
                        action: "hover"
                    });
                }
                return;
            }
            service.fireEvent("unhoverOnDataPoint", {
                targets : hoveringDataPoint,
                byKeyboard : event.data.byKeyboard
            });
        }
        if (hoveringDataPoint !== target) {
            service.setStatus("isHoveringDeselectedDataPoint", false);
        }
        hoveringDataPoint = target;
        service.setStatus("hoveringLegend", false);
        service.fireEvent("hoverOnDataPoint", {
            targets : hoveringDataPoint,
            byKeyboard : event.data.byKeyboard
        }).fireEvent("showDetail", {
            target : target,
            mode : selected ? "actionMode" : "infoMode",
            point : point,
            action: "hover"
        }).setStatus("hoveringDataPoint", hoveringDataPoint)
        .setStatus("hoveredDataPointId", DataPointUtils.getDataPointId(hoveringDataPoint));
    }

    function Handler() {
    }

    var proto = Handler.prototype;

    proto.standAloneInitialized = function(event, service) {
        service.getProperties().origin.add({
            interaction : {
                selectability : {
                    plotStdSelection : true
                }
            }
        });
    };

    proto.initialize = function(event, service) {
        service.setStatus("hoveringDataPoint", null);
        service.setStatus("isHoveringDeselectedDataPoint", false);
    };

    proto.clickOnDataPoint = function(event, service) {
        dataPointClickHandler.call(this, event, service, event.data.currentTarget);
    };

    proto.hoverOnDataPoint = function(event, service) {
        dataPointHoverHandler.call(this, event, service, event.data.currentTarget);
    };

    proto.clickOnDataLabel = function(event, service) {
        dataPointClickHandler.call(this, event, service,
                DataPointUtils.getDataPointByDataLabel(event.data.currentTarget, service));
    };

    proto.hoverOnDataLabel = function(event, service) {
        dataPointHoverHandler.call(this, event, service,
                DataPointUtils.getDataPointByDataLabel(event.data.currentTarget, service));
    };

    proto.isHoveringDataPointHighlighted = function (service) {
        var lastHighlighted = service.getStatus("highlightedDataPoints");
        var hoveringDataPoint = service.getStatus("hoveringDataPoint");
        var dataPointHighlighted = false;
        var dpId;
        if (hoveringDataPoint) {
            dpId = DataPointUtils.getDataPointId(hoveringDataPoint);
            if (lastHighlighted && lastHighlighted.length > 0 &&
                lastHighlighted.indexOf(dpId) >= 0) {
                dataPointHighlighted = true;
            }
        }
        return dataPointHighlighted;
    };

    proto.hoverOnNonDataPoint = function (event, service) {
        service.setStatus("isHoveringDeselectedDataPoint", false);
        var hoveringDataPoint = service.getStatus("hoveringDataPoint");
        if (hoveringDataPoint && !this.isHoveringDataPointHighlighted(service)) {
            service.fireEvent("unhoverOnDataPoint", {
                targets: hoveringDataPoint
            });
        }
        service.setStatus("hoveringDataPoint", null);
        service.fireEvent("hideDetail", {
            mode: "infoMode",
            target: "nonDataPoint",
            action: "interrupt"
        });
    };

    proto.hoverOnTimeArea = function(event, service) {

        SelectionUtil.processTimeCursor(event,service);
    };

    proto.selectDataPoint = function(event, service) {
        var elements = HighlightHelper.turnToArray(event.data.targets);
        elements.forEach(function(e) {
            var d3Node = d3.select(e);
            d3Node.classed(CSS_CLASS.DATAPOINTDEFAULT, false);
            d3Node.classed(CSS_CLASS.DATAPOINTSELECTED, true);
        });
    };

    proto.deselectDataPoint = function(event, service) {
        var elements = HighlightHelper.turnToArray(event.data.targets);
        elements.forEach(function(e) {
            var d3Node = d3.select(e);
            d3Node.classed(CSS_CLASS.DATAPOINTSELECTED, false);
            if (!d3Node.classed(CSS_CLASS.DATAPOINTHOVER)) {
                d3Node.classed(CSS_CLASS.DATAPOINTDEFAULT, true);
            }
        });
    };

    proto.hoverEffectOnDataPoint = function(event, service) {
        var elements = HighlightHelper.turnToArray(event.data.targets);
        elements.forEach(function(e) {
            var d3Node = d3.select(e);
            d3Node.classed(CSS_CLASS.DATAPOINTDEFAULT, false);
            d3Node.classed(CSS_CLASS.DATAPOINTHOVER, true);
        });
    };

    proto.unhoverOnDataPoint = function(event, service) {
        service.setStatus("hoveringDataPoint", null);
        var elements = HighlightHelper.turnToArray(event.data.targets);
        elements.forEach(function(e) {
            var d3Node = d3.select(e);
            d3Node.classed(CSS_CLASS.DATAPOINTHOVER, false);
            if (!d3Node.classed(CSS_CLASS.DATAPOINTSELECTED)) {
                d3Node.classed(CSS_CLASS.DATAPOINTDEFAULT, true);
            }
        });
    };

    function highLightLineDuringBigData(dpInfos, dlLayer, offset, service, plotModule){
        var seriesStyle, dpInfo, currentColor, lastColor, currentType, lastType,
            nextDpInfo, ctx, point, nextPoint, addCtx;
        var previousSeriesIndex = null;
        var previousSeqId = null;
        var semanticMgr = service.getSemanticManager();
        var pathCandidates = [];
        var pathCandidate = {
            points: []
        };
        var i = 0, length = dpInfos.length;
        if (semanticMgr.hasDataPointLineStyle()) {
            var effectMgr = service.getEffectManager();
            semanticMgr.beginSession();
            for (; i < length; i++) {
                dpInfo = dpInfos[i];
                if (previousSeqId !== dpInfo.seqId - 1 ||
                    previousSeriesIndex !== dpInfo.seriesIndex) {
                    if (pathCandidate.points.length >= 2) {
                        seriesStyle = plotModule.getSeriesStyle(previousSeriesIndex);
                        pathCandidate.width = seriesStyle.lineWidth;
                        pathCandidate.color = lastColor;
                        pathCandidate.type = lastType;
                        pathCandidates.push(pathCandidate);
                    }
                    nextPoint = null;
                    pathCandidate = {
                        points: []
                    };
                }
                ctx = [dpInfo.rawData.dp.context()];
                addCtx = [dpInfo.rawData.dp.additionCtx()];

                nextDpInfo = dpInfos[i + 1];

                point = dpInfo.data.translate.slice();
                point.id = dpInfo.dataId;
                if (nextPoint == null){
                    pathCandidate.points.push(point);
                }
                nextPoint = null;
                if (nextDpInfo &&
                    dpInfo.seqId === nextDpInfo.seqId - 1 &&
                    dpInfo.seriesIndex === nextDpInfo.seriesIndex
                ){
                    ctx.push(nextDpInfo.rawData.dp.context());
                    addCtx.push(nextDpInfo.rawData.dp.additionCtx());
                    nextPoint = nextDpInfo.data.translate.slice();
                    nextPoint.id = nextDpInfo.dataId;
                }

                seriesStyle = plotModule.getSeriesStyle(dpInfo.seriesIndex);
                currentColor = effectMgr.register({
                    fillColor: SeriesUtil.parseSemanticLineColor(ctx, semanticMgr, seriesStyle.color, addCtx)
                });
                currentType = SeriesUtil.parseSemanticLineType(ctx, semanticMgr, null, addCtx);
                if (pathCandidate.points.length >= 2 &&
                    (lastColor !== currentColor ||
                        lastType !== currentType)
                ) {
                    seriesStyle = plotModule.getSeriesStyle(previousSeriesIndex);
                    pathCandidate.width = seriesStyle.lineWidth;
                    pathCandidate.color = lastColor;
                    pathCandidate.type = lastType;
                    pathCandidates.push(pathCandidate);
                    nextPoint = null;
                    pathCandidate = {
                        points: [point]
                    };
                } else if (nextPoint){
                    pathCandidate.points.push(nextPoint);
                }

                lastColor = currentColor;
                lastType = currentType;
                previousSeriesIndex = dpInfo.seriesIndex;
                previousSeqId = dpInfo.seqId;
            }
            if (pathCandidate.points.length >= 2) {
                seriesStyle = plotModule.getSeriesStyle(previousSeriesIndex);
                pathCandidate.width = seriesStyle.lineWidth;
                pathCandidate.color = lastColor;
                pathCandidate.type = lastType;
                pathCandidates.push(pathCandidate);
            }
            semanticMgr.endSession();
        } else {
            for (; i < length; i++) {
                dpInfo = dpInfos[i];
                if (pathCandidate.points.length > 0 &&
                    (previousSeqId !== dpInfo.seqId - 1 ||
                        previousSeriesIndex !== dpInfo.seriesIndex)
                ) {
                    seriesStyle = plotModule.getSeriesStyle(previousSeriesIndex);
                    pathCandidate.width = seriesStyle.lineWidth;
                    pathCandidate.color = seriesStyle.color;
                    pathCandidate.type = seriesStyle.lineType;
                    pathCandidates.push(pathCandidate);

                    pathCandidate = {
                        points: []
                    };
                }

                point = dpInfo.data.translate.slice();
                point.id = dpInfo.dataId;
                pathCandidate.points.push(point);

                previousSeriesIndex = dpInfo.seriesIndex;
                previousSeqId = dpInfo.seqId;
            }

            if (pathCandidate.points.length > 0) {
                seriesStyle = plotModule.getSeriesStyle(previousSeriesIndex);
                pathCandidate.width = seriesStyle.lineWidth;
                pathCandidate.color = seriesStyle.color;
                pathCandidate.type = seriesStyle.lineType;
                pathCandidates.push(pathCandidate);
            }
        }
        var isHorizontal = service.isHorizontal();
        var lineRenderer = Handler.getLineRenderer(service);
        var defaultLineRenderer = null;
        if (plotModule.getDefaultLineRenderer) {
            defaultLineRenderer = plotModule.getDefaultLineRenderer().expose;
        }

        pathCandidates.forEach(function(e) {
            if (e.type === LINE_TYPE.DASHED || e.type === LINE_TYPE.DOTTED){
                e.strokeDashArray = Constants.LINE_DASH_TYPE_ARRAY;
            } else if(e.type === LINE_TYPE.DOT){
                e.strokeDashArray = "0," + (e.width * 2);
                e.linecap = "round";
            }
            delete e.type;
            e.isHorizontal = isHorizontal;
            e.offset = offset;
            e.renderer = lineRenderer;
            e.defaultLineRenderer = defaultLineRenderer;
            dlLayer.addPolyLine(e);
        });
    }

    function highLightBarDuringBigData(dpInfos, dlLayer, offset, service, plotModule){
        var properties = service.getProperties();
        var dpInfo, colors, lastColor, currentColor;
        var previousSeriesIndex = null;

        var propertyColor = properties.get('interaction.selected.color');
        var isHorizontal = service.isHorizontal();
        var semanticMgr = service.getSemanticManager();

        var pathCandidates = [];
        var pathCandidate = {
            points: []
        };
        var i = 0, length = dpInfos.length;
        if (semanticMgr.hasDataPointColorStyle()) {
            var effectMgr = service.getEffectManager();
            semanticMgr.beginSession();

            for (; i < length; i++) {
                dpInfo = dpInfos[i];
                colors = HighlightHelper.getColors(service, null, propertyColor,
                    null, null, null, {
                        color: SeriesUtil.parseSemanticColor(dpInfo, semanticMgr)
                    });
                currentColor = colors.customizedColor || colors.defaultColor;

                if (pathCandidate.points.length !== 0 &&
                    (previousSeriesIndex !== dpInfo.seriesIndex ||
                    lastColor !== currentColor)) {
                    pathCandidate.color = lastColor;
                    pathCandidates.push(pathCandidate);

                    pathCandidate = {
                        points: []
                    };
                }
                SeriesUtil.addRectSeriesPathPoints(pathCandidate.points, dpInfo, !!
                    dpInfo.negative, isHorizontal);

                previousSeriesIndex = dpInfo.seriesIndex;
                lastColor = currentColor;
            }
            semanticMgr.endSession();
        } else {
            for (; i < length; i++) {
                dpInfo = dpInfos[i];
                if (pathCandidate.points.length !== 0 &&
                    previousSeriesIndex !== dpInfo.seriesIndex) {
                    pathCandidate.color = lastColor;
                    pathCandidates.push(pathCandidate);

                    pathCandidate = {
                        points: []
                    };
                    lastColor = null;
                }
                SeriesUtil.addRectSeriesPathPoints(pathCandidate.points, dpInfo, !!
                    dpInfo.negative, isHorizontal);
                if (!lastColor) {
                    colors = HighlightHelper.getColors(service, null, propertyColor,
                        null, null, null, {
                            color: dpInfo.graphic.fill
                        });
                    lastColor = colors.customizedColor || colors.defaultColor;
                }
                previousSeriesIndex = dpInfo.seriesIndex;
            }
        }

        if (pathCandidate.points.length > 0) {
            pathCandidate.color = lastColor;
            pathCandidates.push(pathCandidate);
        }

        pathCandidates.forEach(function(e) {
            e.isHorizontal = isHorizontal;
            e.offset = offset;
            e.width = 1;
            e.pointerEvent = "none";
            dlLayer.addPolyLine(e);
        });
    }

    function showDetailForRangeSelectionWhenHover(event, service){
        if (!service.getStatus("rangeSelection")) {
            return;
        }
        var rangeRect = service.getBBox(service.BoxType.RANGE_SELECTION);
        var point = event.data.point;
        if (!(point.x >= rangeRect.left && point.x <= rangeRect.right &&
            point.y >= rangeRect.top && point.y <= rangeRect.bottom)) {
            return;
        }
        service.fireEvent("showDetail", {
            mode: 'actionMode',
            point: event.data.point,
            bLassoEnd: true
        });
    }

    function showDetailForRangeSelection(event, service){
        if(service.getStatus("rangeSelection")){
            // In mobile, we need to display tooltip if customer click range selection rectangle.
            var shapeBox = service.getBBox(service.BoxType.RANGE_SELECTION);
            var pos = event.data.point;
            if(!!shapeBox && !!pos && pos.x >= shapeBox.x &&
                pos.x <= shapeBox.x + shapeBox.width &&
                pos.y >= shapeBox.y && pos.y <= shapeBox.y + shapeBox.height){
                service.fireEvent("showDetail",  {mode: 'actionMode', point: pos, bLassoEnd: true});
                return true;
            }
        }
        return false;
    }

    Handler.showDetailForRangeSelectionWhenHover = showDetailForRangeSelectionWhenHover;
    Handler.showDetailForRangeSelection = showDetailForRangeSelection;

    Handler.updateRangeEffect = function(event, service) {
        if (!isPointInRangeSelection(event, service)) {
            return;
        }
        //when mouse click down, change color and etc
        service.fireEvent({
            name: "changeRangeEffect",
            data: {
                direction: "down",
                target: event.data.target
            }
        });
    };

    Handler.recoverRangeEffect = function(event, service) {
        if (!isPointInRangeSelection(event, service)) {
            return;
        }
        //when mouse click up, change color and etc
        service.fireEvent({
            name: "changeRangeEffect",
            data: {
                direction: "up",
                target: event.data.target
            }
        });
    };

    Handler.renderLightLine = function (service, node, flag, lineRenderer) {
        lightLine(service, node, true, flag, lineRenderer);
        lightLine(service, node, false, flag, lineRenderer);
    };

    Handler.getLineRenderer = function(service, element) {
        var plotModule = Handler.getPlot(service, element);
        return plotModule? plotModule.getLineRenderer(): null;
    };

    Handler.getPlot = function(service, element){
        var plotModule;
        var trellisInfo;
        if (element && DataGraphics.getData(element)) {
            trellisInfo = DataGraphics.getData(element).trellisInfo;
        }
        if (trellisInfo) {
            plotModule = service.getModule("main").getChildPlot(trellisInfo);
        } else {
            plotModule = service.getModule("main.plot");
        }
        return plotModule;
    };

    Handler.selectOnLineOnNormalMode = function(event, service){
        var elements = HighlightHelper.turnToArray(event.data.targets);
        var properties = service.getProperties();
        service._getDecorationLayer().clear();
        service.fireEvent(event, true);
        var prop = properties.get('interaction.selected');
        var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
        var lineRenderer;
        elements.forEach(function(e) {
            var extraData = DataGraphics.getData(e);
            var bSetChildOpacity = !extraData.isZeroValue;
            DataPointUtils.highlight(e);
            lineRenderer = Handler.getLineRenderer(service, e);
            Handler.renderLightLine(service, e, true, lineRenderer);
            HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, 1, undefined, extraData);
            HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRenderExist, bSetChildOpacity);
        });
    };

    function drawHighlightForLineBigData(targets, service) {
        var pre = predrawHighlight(targets, service);
        if(!pre){
            return;
        }

        var elements = pre.elements;
        var dlLayer = pre.dlLayer;
        var offset = pre.offset;
        var plotModule = pre.plotModule;
        var actionLayer = pre.actionLayer;

        var dpInfos = SelectionUtil.getDpInfos(plotModule, elements);
        highLightLineDuringBigData(dpInfos, dlLayer, offset, service, plotModule);

        actionLayer.drawLayer(dlLayer);
    }

    Handler.selectOnLineDuringBigData = function (event, service) {
        return drawHighlightForLineBigData(event.data.targets, service);
    };

    Handler.highlightOnLineDuringBigData = function (event, service) {
        var selectedDataPoints = service.getStatus('selectedDataPoints');
        var allHighlightedItems = selectedDataPoints.concat(event.data.targets);
        return drawHighlightForLineBigData(allHighlightedItems, service);
    };

    Handler.unhighlightOnLineDuringBigData = function (event, service) {
        //should high light all selected items
        var selectedDataPoints = service.getStatus('selectedDataPoints');
        return drawHighlightForLineBigData(selectedDataPoints, service);
    };

    Handler.selectOnBarOnNormalMode = function(event, service){
        var elements = HighlightHelper.turnToArray(event.data.targets);
        var properties = service.getProperties();
        service._getDecorationLayer().clear();
        service.fireEvent(event, true);
        var prop = properties.get('interaction.selected');
        var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
        elements.forEach(function(e) {
            var extraData = DataGraphics.getData(e);
            var tag = "rect";
            if (extraData.pattern === "noFill") {
                tag = "rect, path";
            }
            HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 1, undefined, extraData);
            HighlightHelper.drawFill(service, e, tag, prop, isMarkerRendererExist);
        });
    };

    Handler.highlightOnCombDuringBigData = function (event, service) {
        var selectedDataPoints = service.getStatus('selectedDataPoints');
        var allHighlightedItems = selectedDataPoints.concat(event.data.targets);
        return drawHighlightForCombBigData(allHighlightedItems, service);
    };

    Handler.unhighlightOnCombDuringBigData = function (event, service) {
        //should high light all selected items
        var selectedDataPoints = service.getStatus('selectedDataPoints');
        return drawHighlightForCombBigData(selectedDataPoints, service);
    };

    function predrawHighlight(targets, service){
        var elements = HighlightHelper.turnToArray(targets);

        var actionLayer = service._getDecorationLayer();
        actionLayer.clear(DL_LAYER);

        var plotModule = service.getModule("main.plot");
        if (!plotModule) {
            return null;
        }

        var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);
        var offset = plotModule.getOffset();
        offset.x += matrix.e;
        offset.y += matrix.f;

        var dlLayer = actionLayer.createLayer(DL_LAYER);
        addMask2Layer(plotModule, matrix, dlLayer);

        return {
            elements: elements,
            dlLayer: dlLayer,
            offset: offset,
            plotModule: plotModule,
            actionLayer: actionLayer
        };
    }

    function drawHighlightForCombBigData(targets, service) {
        var pre = predrawHighlight(targets, service);
        if(!pre){
            return;
        }

        var elements = pre.elements;
        var dlLayer = pre.dlLayer;
        var offset = pre.offset;
        var plotModule = pre.plotModule;
        var actionLayer = pre.actionLayer;

        var dpInfos = SelectionUtil.getDpInfos(plotModule, elements);
        var barInfos = [];
        var lineInfos = [];

        var dataModel = service.getDataModel();

        for (var i = 0; i < dpInfos.length; i++) {
            var point = dpInfos[i];
            var dataPoint = dataModel.getDataPoint(point.dataId);
            if (dataPoint) {
                var shape = getShape(plotModule, dataPoint);
                if(shape === "line"){
                    lineInfos.push(point);
                }else if(shape === "bar"){
                    barInfos.push(point);
                }
            }
        }

        highLightBarDuringBigData(barInfos, dlLayer, offset, service, plotModule);
        highLightLineDuringBigData(lineInfos, dlLayer, offset, service, plotModule);

        actionLayer.drawLayer(dlLayer);
    }


    function drawHighlightForBarBigData(targets, service) {
        var pre = predrawHighlight(targets, service);
        if(!pre){
            return;
        }

        var elements = pre.elements;
        var dlLayer = pre.dlLayer;
        var offset = pre.offset;
        var plotModule = pre.plotModule;
        var actionLayer = pre.actionLayer;

        var dpInfos = SelectionUtil.getDpInfos(plotModule, elements);
        highLightBarDuringBigData(dpInfos, dlLayer, offset, service, plotModule);

        actionLayer.drawLayer(dlLayer);
    }

    Handler.selectOnBarDuringBigData = function (event, service) {
        return drawHighlightForBarBigData(event.data.targets, service);
    };

    Handler.highlightOnBarDuringBigData = function (event, service) {
        var selectedDataPoints = service.getStatus('selectedDataPoints');
        var allHighlightedItems = selectedDataPoints.concat(event.data.targets);
        return drawHighlightForBarBigData(allHighlightedItems, service);
    };

    Handler.unhighlightOnBarDuringBigData = function (event, service) {
        //should high light all selected items
        var selectedDataPoints = service.getStatus('selectedDataPoints');
        return drawHighlightForBarBigData(selectedDataPoints, service);
    };

    Handler.hoverOnLineDuringBigData = function(event, service, point){
        if (!service.isBigDataMode() || service.getStatus("rangeSelection")) {
            return;
        }

        var originalEvent = event.data.originalEvent;
        var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);

        // hit test
        /* to get x/y relative to chart plot with un-scaled value */
        var coord = {
            left: event.data.pointToChart.x - matrix.e,
            top: event.data.pointToChart.y - matrix.f
        };
        var plot = service.getModule("main.plot");
        var offset = plot.getOffset();
        coord.left -= offset.x;
        coord.top -= offset.y;

        // clear action layer
        var actionLayer = service._getDecorationLayer();
        actionLayer.clear(DP_LAYER);

        var translate, dataPoint;
        var dataModel = service.getDataModel();
        if(!point){
            var points = plot.hitTest(coord);
            if (points.length === 0) {
                service.fireEvent("hideTooltipHoverOnPlot", {
                    mode: "infoMode",
                    action: "interrupt"
                });
                return;
            }
            // obtain data point instance in dataModel and point info in plot.
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                dataPoint = dataModel.getDataPoint(point.dataId);
                if (dataPoint) {
                    translate = point.data.translate;
                    break;
                }
            }
        }else{
            dataPoint = dataModel.getDataPoint(point.dataId);
            translate = point.data.translate;
        }

        if (dataPoint == null) {
            return;
        }

        // render point
        offset = plot.getOffset();
        offset.x += matrix.e + translate[0];
        offset.y += matrix.f + translate[1];

        var prop = service.getProperties().get('interaction.hover');
        var semanticMgr = service.getSemanticManager();
        var result = semanticMgr.analyzeDataPoint("color", dataPoint.context(),false, dataPoint.additionCtx());
        if (result && result.color) {
            point.graphic.fill = result.color;
        }

        var shape = {
            color: point.graphic.fill,
            shape: point.graphic.shape,
            r: point.graphic.size
        };
        var strokeColors = HighlightHelper.getColors(service, null, prop.stroke.color, null,
                point.graphic.drawingEffect, null, shape),
            fillColors = HighlightHelper.getColors(service, null, prop.color, null,
                point.graphic.drawingEffect, null, shape);
        var layer = actionLayer.createLayer(DP_LAYER, offset);
        /*
         * [TODO] to change the interface to layer.addMarker({type:...,rx:...,ry:...,borderWidth:...,......})
         * and use svg.generatepath internally.
         */
        var strokeVisible = prop.stroke && prop.stroke.visible === false;
        layer.addPath({
            d: SVG.generateMarkerPath({
                type: point.graphic.shape,
                rx: point.graphic.size / 2,
                ry: point.graphic.size / 2,
                borderWidth: 2
            }),
            stroke: strokeVisible ?
                'none' : (strokeColors.customizedColor ? strokeColors.customizedColor : strokeColors.defaultColor),
            pointerEvent: "none",
            fill: fillColors.customizedColor ? fillColors.customizedColor : fillColors.defaultColor,
            opacity: prop.opacity ? prop.opacity : 1,
            strokeWidth: strokeVisible ?
                'none' : (prop.stroke && prop.stroke.width ? prop.stroke.width : "2px")
        });

        actionLayer.drawLayer(layer);

        var tooltipMode = "infoMode";

        if (SelectionUtil.hasDataPoint(service.getStatus("selectedDataPoints"), dataPoint.id)) {
            tooltipMode = "actionMode";
        }

        service.fireEvent("showTooltipHoverOnPlot", {
            target: dataPoint.id,
            mode: tooltipMode,
            point: {
                x: event.data.point.x,
                y: event.data.point.y - coord.top + translate[1]
            },
            action: "hover"
        });
    };

    var  getGroupTargets = Handler.getGroupTargets = function(event, service) {
        var targets = HighlightHelper.turnToArray(event.data.targets), groupTargets = [];
        targets.forEach(function(target) {
            if(groupTargets.indexOf(target) === -1) {
                var dps = ContextualDataUtil.getDataPointsByTimeField(target, service);
                groupTargets = groupTargets.concat(dps);
            }
        });
        return groupTargets;
    };

    //for bar and comb chart
    Handler.hoverEffectDuringNormalMode = function(event, service){
        var selectByTimeAxisGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');
        if (selectByTimeAxisGroup) {
            var groupTargets = getGroupTargets(event, service);
            if (groupTargets.length > 0) {
                event.data.targets = groupTargets;
            }
        }
        service.fireEvent(event, true);
        var props = service.getProperties();
        var elements = HighlightHelper.turnToArray(event.data.targets);
        var prop = props.get('interaction.hover');
        var isMarkerRendererExist = TypeUtils.isExist(props.get('plotArea.markerRenderer'));

        var plot = service.getModule("main.plot");
        var dataModel = service.getDataModel();

        elements.forEach(function (e) {
            if(service.isTrellis()){
                //bar
                HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 2);
                HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
            }else{
                var dataId = DataPointUtils.getDataPointId(e);
                var dataPoint = dataModel.getDataPoint(dataId);
                if (dataPoint) {
                    var shape = getShape(plot, dataPoint);
                    if(shape === "line"){
                        HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, 2);
                        HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRendererExist, true);
                    } else {
                        //bar
                        if (!event.data.byKeyboard) {
                            var extraData = DataGraphics.getData(e);
                            HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 2, undefined, extraData);
                        }
                        HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
                    }
                }
            }
        });
    };

    //for bar and comb chart
    Handler.unhoverEffectDuringNormalMode = function(event, service){
        var selectByTimeAxisGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');
        if (selectByTimeAxisGroup) {
            var groupTargets = getGroupTargets(event, service);
            if (groupTargets.length > 0) {
                event.data.targets = groupTargets;
            }
        }
        service.fireEvent(event, true);
        var targetNode = TypeUtils.isArray(event.data.targets) ? event.data.targets[0] : event.data.targets;
        if (TypeUtils.isExist(targetNode)) {
            var parentNode = targetNode.parentNode;
            var zeroValueHoverNode = d3.select(parentNode).selectAll('.' + CSS_CLASS.ZEROVALUEHOVER);
            zeroValueHoverNode.remove();
        }
        var elements = HighlightHelper.turnToArray(event.data.targets);
        var props = service.getProperties();
        var prop;
        var isMarkerRendererExist = TypeUtils.isExist(props.get('plotArea.markerRenderer'));

        var plot = service.getModule("main.plot");
        var dataModel = service.getDataModel();

        elements.forEach(function (e) {
            var dataId = DataPointUtils.getDataPointId(e);
            var dataPoint = dataModel.getDataPoint(dataId);
            var shape = getShape(plot, dataPoint);

            var visible;
            var width = 1;
            var extraData;
            if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                prop = props.get('interaction.selected');
                visible = true;
            } else {
                if (service.shouldUseDeselectedColor()) {
                    prop = props.get('interaction.deselected');
                } else {
                    prop = props.get('plotArea.dataPoint');
                    extraData = DataGraphics.getData(e);
                    if (extraData) {
                        width = extraData.strokeWidth;
                    }
                }
                visible = false;
            }

            if(shape === "line"){
                HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, width);
                HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRendererExist, true);
                if (!visible) {
                    setMakerOpacity(service, e);
                }
            }else{
                extraData = DataGraphics.getData(e);
                HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, width, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
            }
        });
    };

    Handler.hoverOnBarDuringBigData = function(event, service, point) {
        service.setStatus("hoveringOnPlotEvent", null);
        if (!service.isBigDataMode() || service.getStatus("rangeSelection")) {
            return;
        }

        var originalEvent = event.data.originalEvent;
        var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);

        // hit test
        /* to get x/y relative to chart plot with un-scaled value */
        var coord = {
            left: event.data.pointToChart.x - matrix.e,
            top: event.data.pointToChart.y - matrix.f
        };
        var plot = service.getModule("main.plot");
        var offset = plot.getOffset();
        coord.left -= offset.x;
        coord.top -= offset.y;


        // clear action layer
        var actionLayer = service._getDecorationLayer();
        actionLayer.clear(DP_LAYER);
        var layer = actionLayer.createLayer(DP_LAYER);
        addMask2Layer(plot, matrix, layer);

        var position ,dataPoint;
        var dataModel = service.getDataModel();
        if(!point){
            var points = plot.hitTest(coord);
            if (points.length === 0) {
                service.fireEvent("hideTooltipHoverOnPlot", {
                    mode: "infoMode",
                    action: "interrupt"
                });
                return;
            }
            // obtain data point instance in dataModel and point info in plot.
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                dataPoint = dataModel.getDataPoint(point.dataId);
                if (dataPoint) {
                    position = point.position;
                    break;
                }
            }
        }else{
            dataPoint = dataModel.getDataPoint(point.dataId);
            position = point.position;
        }

        if (dataPoint == null) {
            return;
        }


        service.setStatus("hoveringOnPlotEvent", event);
        // render point
        offset = plot.getOffset();
        offset.x += matrix.e;
        offset.y += matrix.f;

        var prop = service.getProperties().get('interaction.hover');
        var semanticMgr = service.getSemanticManager();
        var result = semanticMgr.analyzeDataPoint("color", dataPoint.context(), false, dataPoint.additionCtx());
        if (result && result.color) {
            point.graphic.fill = result.color;
        }

        var shape = {
            color: point.graphic.fill
        };
        var strokeColors = HighlightHelper.getColors(service, null, "darken(20%)",
            null,
            point.graphic.drawingEffect, null, shape);
        var fillColors = HighlightHelper.getColors(service, null, prop.color, null,
            point.graphic.drawingEffect, null, shape);
        var rectFillColor = fillColors.defaultColor;
        var rectStrokeColor = strokeColors.customizedColor;
        if (fillColors.customizedColor) {
            rectFillColor = rectStrokeColor = fillColors.customizedColor;
        }
        layer.addRect({
            x: position.x + offset.x,
            y: position.y + offset.y,
            width: position.width,
            height: position.height,
            stroke: rectStrokeColor,
            pointerEvent: "none",
            fill: rectFillColor,
            opacity: !isNaN(+prop.opacity) ? +prop.opacity : 1,
            strokeWidth: "2px"
        });

        actionLayer.drawLayer(layer);

        var tooltipMode = "infoMode";

        if (SelectionUtil.hasDataPoint(service.getStatus("selectedDataPoints"),
            dataPoint.id)) {
            tooltipMode = "actionMode";
        }

        service.fireEvent("showTooltipHoverOnPlot", {
            target: dataPoint.id,
            mode: tooltipMode,
            point: {
                x: event.data.point.x,
                y: event.data.point.y
            },
            action: "hover"
        });
    };

    // isLine, point is optional
    function handleClickedDP(service, event, dataPoint, coord, isLine, point){
        if(service.getStatus("rangeSelection")){
            var selectedDataPoints = service.getStatus("selectedDataPoints");
            service.setStatus("selectedDataPoints", []);
            service.fireEvent("clearPlot").fireEvent("deselectDataPoint", {
                targets : DataPointUtils.getNodes(selectedDataPoints, service),
                isAnyOtherSelected : false
            });
            service.setStatus("rangeSelection", false);
            service.setStatus("rangeDomain" , null);
        }
        service.fireEvent("processSelection", {
            //selection item id should be converted to string
            targets: [(dataPoint.id).toString()],
            deselectable: true,
            ctrlKeyPressed: event.data.ctrlKey
        });

        if (SelectionUtil.hasDataPoint(service.getStatus("selectedDataPoints"), dataPoint.id)) {
            var y;
            if(isLine){
                y = event.data.point.y - coord.top + point.data.translate[1];
            }else{
                y = event.data.point.y;
            }
            service.fireEvent("showTooltipClickBigData", {
                target: dataPoint.id,
                mode: "actionMode",
                point: {
                    x: event.data.point.x,
                    y: y
                }
            });
        } else {
            service.fireEvent("hideTooltipClickBigData", {
                target: dataPoint.id,
                mode: "actionMode"
            });
            service._getDecorationLayer().clear(DP_LAYER);
        }
    }

    function clearRangeSelectionAfterClick(service, event){
        service.setStatus("rangeSelection", false);
        service.setStatus("rangeDomain" , null);
        service.fireEvent(event, true);
    }

    Handler.clickOnCombDuringBigData = function(event, service){
        if(showDetailForRangeSelection(event, service)){
            return;
        }
        if (service.isBigDataMode()) {
            var originalEvent = event.data.originalEvent;
            var eventTarget = originalEvent.target;

            var found = HighlightHelper.tryToFindNode("v-m-plot", eventTarget,
                service._rootNode);
            if (found) {
                var box = service.getBBox(service.BoxType.PLOT_NODE);
                // hit test
                var coord = HighlightHelper.getLayerCoord(event.data.point, box);
                var plot = service.getModule("main.plot");
                var points = plot.hitTest(coord, true);
                var dataModel = service.getDataModel();
                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    var dataPoint = dataModel.getDataPoint(point.dataId);
                    if (dataPoint) {
                        var shape = getShape(plot, dataPoint);
                        if(shape === "line"){
                            handleClickedDP(service, event, dataPoint, coord, true, point);
                            return;
                        }else if(shape === "bar"){
                            handleClickedDP(service, event, dataPoint, coord);
                            return;
                        }
                    }
                }
            }
        }
        if(!service.getProperties().get("interaction.enableDeselectAll")){
            return;
        }
        clearRangeSelectionAfterClick(service, event);
    };

    Handler.clickOnLineDuringBigData = function(event, service) {
        if(showDetailForRangeSelection(event, service)){
            return;
        }

        if (service.isBigDataMode() &&
            service.getProperties().get("interaction.selectability.plotStdSelection")) {
            var originalEvent = event.data.originalEvent;
            var eventTarget = originalEvent.target;
            //use private variable to limit the search scope.
            //when target is child of v-m-plot, start hit test selection

            var found = HighlightHelper.tryToFindNode("v-m-plot", eventTarget, service._rootNode);
            if (found){
                var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);
                // hit test
                /* to get x/y relative to chart plot with un-scaled value */
                var coord = {
                    left: event.data.pointToChart.x - matrix.e,
                    top: event.data.pointToChart.y - matrix.f
                };
                var plot = service.getModule("main.plot");
                var offset = plot.getOffset();
                coord.left -= offset.x;
                coord.top -= offset.y;
                var points = plot.hitTest(coord, service.isCombChart());
                var dataModel = service.getDataModel();
                for (var i = 0; i < points.length; i++) {
                    var dataPoint = dataModel.getDataPoint(points[i].dataId);
                    if (!dataPoint) {
                        continue;
                    }

                    handleClickedDP(service, event, dataPoint, coord, true, points[i]);
                    return;
                }
            }
        }
        clearRangeSelectionAfterClick(service, event);
    };

    Handler.clickOnBarDuringBigData = function(event, service) {
        if(showDetailForRangeSelection(event, service)){
            return;
        }

        if (!service.isBigDataMode() ||
            !service.getProperties().get("interaction.selectability.plotStdSelection")) {
            service.setStatus("rangeSelection", false);
            service.setStatus("rangeDomain" , null);
            service.fireEvent(event, true);
            return;
        }
        var originalEvent = event.data.originalEvent;
        var eventTarget = originalEvent.target;
        //use private variable to limit the search scope.
        //when target is child of v-m-plot, start hit test selection
        var found = HighlightHelper.tryToFindNode("v-m-plot", eventTarget, service._rootNode);
        if (found){
            var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);
            // hit test
            /* to get x/y relative to chart plot with un-scaled value */
            var coord = {
                left: event.data.pointToChart.x - matrix.e,
                top: event.data.pointToChart.y - matrix.f
            };
            var plot = service.getModule("main.plot");
            var offset = plot.getOffset();
            coord.left -= offset.x;
            coord.top -= offset.y;
            var points = plot.hitTest(coord,  service.isCombChart());
            var dataModel = service.getDataModel();
            for (var i = 0; i < points.length; i++) {
                var dataPoint = dataModel.getDataPoint(points[i].dataId);
                if (!dataPoint) {
                    continue;
                }

                handleClickedDP(service, event, dataPoint, coord, false);
                return;
            }
        }
        clearRangeSelectionAfterClick(service, event);
    };


    Handler.hoverOnCombDuringBigData = function(event, service) {
        service.setStatus("hoveringOnPlotEvent", null);
        if (!service.isBigDataMode() || service.getStatus("rangeSelection")) {
            return;
        }

        var originalEvent = event.data.originalEvent;
        var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);

        // hit test
        /* to get x/y relative to chart plot with un-scaled value */
        var coord = {
            left: event.data.pointToChart.x - matrix.e,
            top: event.data.pointToChart.y - matrix.f
        };
        var plot = service.getModule("main.plot");
        var offset = plot.getOffset();
        coord.left -= offset.x;
        coord.top -= offset.y;
        var points = plot.hitTest(coord, true);
        var actionLayer = service._getDecorationLayer();

        // clear action layer
        if (points.length === 0) {
            actionLayer.clear(DP_LAYER);
            service.fireEvent("hideTooltipHoverOnPlot", {
                mode: "infoMode",
                action: "interrupt"
            });
            return;
        }

        var dataPoint, point;
        var dataModel = service.getDataModel();
        // obtain data point instance in dataModel and point info in plot.
        for (var i = 0; i < points.length; i++) {
            point = points[i];
            dataPoint = dataModel.getDataPoint(point.dataId);
            if(dataPoint){
                break;
            }
        }

        if(dataPoint){
            if(getShape(plot, dataPoint) === "bar"){
                Handler.hoverOnBarDuringBigData(event, service, point);
            }else{
                Handler.hoverOnLineDuringBigData(event, service, point);
            }
        }else{
            actionLayer.clear(DP_LAYER);
        }
    };

    Handler.selectOnCombinationDuringBigData = function(event, service){
        var elements = HighlightHelper.turnToArray(event.data.targets);
        var properties = service.getProperties();
        var actionLayer = service._getDecorationLayer();
        actionLayer.clear(DL_LAYER);
        var plotModule = service.getModule("main.plot");
        if (!plotModule) {
            return;
        }

        var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);
        var offset = plotModule.getOffset();
        offset.x += matrix.e;
        offset.y += matrix.f;

        var layer = actionLayer.createLayer(DL_LAYER);
        addMask2Layer(plotModule, matrix, layer);

        var barDps = [];
        var lineDps = [];
        // obtain data point info by dataId
        for (var i = 0; i < elements.length; i++) {
            var part = plotModule.mappingDataPointInfo(elements[i]);
            if (part) {
                var shape = getShape(plotModule, part.seriesIndex);
                if (shape === "line") {
                    lineDps.push(part);
                } else if (shape === "bar") {
                    barDps.push(part);
                }
            }
        }

        // sort
        barDps = barDps.sort(function(one, two) {
            return one.seqId - two.seqId;
        });

        lineDps = lineDps.sort(function(one, two) {
            return one.seqId - two.seqId;
        });

        highLightBarDuringBigData(barDps, layer, offset, service, plotModule);
        highLightLineDuringBigData(lineDps, layer, offset, service, plotModule);

        actionLayer.drawLayer(layer);
    };

    var RANGE_OFFSET = SDKConstants.RANGE_SELECTION.OFFSET;

    function isPointInRangeSelection(event, service) {
        var point = event.data.point;
        var bbox = service.getBBox(service.BoxType.RANGE_SELECTION);
        var result = false;
        if (bbox && bbox.x + RANGE_OFFSET < point.x && point.x < bbox.x + bbox.width - RANGE_OFFSET) {
            result = true;
        }
        return result;
    }

    proto.clearPlot = function(event, service) {
        var mainNode = service.getNodes(service.NodeType.DATA_POINT_GROUP);

        function setGray() {
            var props = service.getProperties();
            if(props){
                var opacity = props.get('interaction.deselected.opacity');
                mainNode.each(function() {
                    this.setAttribute("fill-opacity", opacity);
                    this.setAttribute("stroke-opacity", opacity);
                });
            }
        }

        function removeGray() {
            mainNode.each(function() {
                this.removeAttribute("fill-opacity");
                this.removeAttribute("stroke-opacity");
            });
        }
        var gray = event.data.isGray;
        if (UADetector.isIE() && UADetector.version() <= 9) {
            // IE9 need refresh if you want to change an attribute on
            // parent node and affect its childnodes.
            // Bad pratice but we need to support.
            if (gray) {
                window.setTimeout(setGray, 0);
            } else {
                window.setTimeout(removeGray, 0);
            }
        } else {
            if (gray) {
                setGray();
            } else {
                removeGray();
            }
        }
    };

    proto._getDataPoint = function(target, service) {
        return DataPointUtils.getDataPointId(target);
    };

    proto._hasDataPoint = function(dataPoints, dataPoint) {
        return SelectionUtil.hasDataPoint(dataPoints, dataPoint);
    };


    Handler.clearForTime = function(event, service){
        service.fireEvent(event, true);
        if (!event.data.rangeSelection) {
            service._getDecorationLayer().clear();
            service._getActionLayer().clear();
        }
    };

    Handler.clickOnNonSelection = function(event, service, timeCharts){
        if(!service.getProperties().get("interaction.enableDeselectAll")){
            return;
        }

        if(timeCharts.indexOf(service._getChartType()) > -1){
            if(showDetailForRangeSelection(event, service)){
                return;
            }
            service.setStatus("rangeSelection", false);
            service.setStatus("rangeDomain" , null);
        }
        service.fireEvent(event, true);
    };

    Handler.cleanBar = function(event, service){
        var gray = event.data.isGray;
        var rangeSelection = event.data.rangeSelection;
        var bUseRange = rangeSelection && rangeSelection !== "clear";
        var props = service.getProperties();
        if (service.isBigDataMode()) {
            var barPaths = service.getNodes(service.NodeType.BAR_SERIES, false);
            if (gray || bUseRange) {
                var deselColor = props.get('interaction.deselected.color');
                barPaths.forEach(function(path) {
                    var colors = getColors(service, path, deselColor);
                    var color = colors.customizedColor || colors.defaultColor;
                    path.setAttribute("stroke", color);
                });
            } else {
                barPaths.forEach(function(path) {
                    var data = DataGraphics.getData(path);
                    var color = data.color;
                    path.setAttribute("stroke", color);
                });
            }
        }
    };

    Handler.cleanLine = function(event, service){
        var gray = event.data.isGray;
        var rangeSelection = event.data.rangeSelection;
        var bUseRange = rangeSelection && rangeSelection !== "clear";
        var properties = service.getProperties();
        var prop = properties.get('interaction.deselected');

        var lineNodes = service.getNodes(service.NodeType.LINE, false);
        lineNodes.forEach(function(e) {
            var colors = getColors(service, e, prop.color);
            if ((gray || bUseRange) && colors.customizedColor) {
                e.setAttribute('stroke', colors.customizedColor);
            } else {
                e.setAttribute('stroke', colors.defaultColor);
            }
        });
    };

    var setMakerOpacity = Handler.setMakerOpacity = function(service, e) {
        var data = DataGraphics.getData(e);
        if (!(data.type && data.type.toLowerCase() === 'line')) {
            return;
        }
        var properties = service.getProperties();
        var markerVisible = properties.has("plotArea.line.marker.visible") ?
            properties.get("plotArea.line.marker.visible") :
            properties.get("plotArea.marker.visible");

        var plotModule = service.getModule("main.plot");
        if (plotModule && plotModule.isMarkerVisible) {
            markerVisible = plotModule.isMarkerVisible();
        }
        var child = e.firstChild;
        if (!markerVisible) {
            child.setAttribute("fill-opacity", "0");
            child.setAttribute("stroke-opacity", "0");
        }
    };

    return Handler;
});

define('sap/viz/chart/behavior/config/DataPointBehaviorConfig',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler"
], function(
    Constants,
    DataPointBehaviorHandler
) {
    var CSS_CLASS = Constants.CSS.CLASS;

    var dataPointPattern = CSS_CLASS.DATAPOINT;
    var dataLabelPattern = CSS_CLASS.DATALABEL;
    var areaPattern = CSS_CLASS.AREA;
    var areaPointPattern = CSS_CLASS.AREA_POINT;
    var selectedAreaPattern = CSS_CLASS.AREA_SELECTED;

    var allTimeCharts = ["info/timeseries_line", "info/timeseries_column",
                         "info/timeseries_scatter", "info/timeseries_bubble",
                         "info/timeseries_combination","info/dual_timeseries_combination",
                         "info/timeseries_stacked_column", "info/timeseries_stacked_combination",
                         "info/timeseries_100_stacked_column",
                         "info/timeseries_bullet", "info/timeseries_waterfall"];

    return [
        {
            "id" : "dataPointBehaviorDefinition",
            "handler" : DataPointBehaviorHandler,
            "handlerType" : "class",
            "triggerEvent" : [
                {
                    "name" : "standAloneInitialized",
                    "method" : "standAloneInitialized"
                }, {
                    "name" : "afterBehaviorLoaded",
                    "method" : "initialize"
                }, {
                    "name" : "click",
                    "targets" : dataPointPattern,
                    "excludeTargets":["v-m-action-layerrange"],
                    "method" : "clickOnDataPoint"
                }, {
                    "name" : "hover",
                    "targets" : dataPointPattern,
                    "method" : "hoverOnDataPoint"
                }, {
                    "name" : "click",
                    "targets" : dataLabelPattern,
                    "excludeTargets":["v-m-action-layerrange"],
                    "method" : "clickOnDataLabel"
                }, {
                    "name" : "hover",
                    "targets" : dataLabelPattern,
                    "method" : "hoverOnDataLabel"
                }, {
                    "name" : "hover",
                    "excludeTargets": [
                        dataPointPattern,
                        dataLabelPattern,
                        areaPattern,
                        areaPointPattern,
                        selectedAreaPattern,

                    ],
                    "method" : "hoverOnNonDataPoint"
                }, {
                    "name" : "selectDataPoint",
                    "method" : "selectDataPoint"
                }, {
                    "name" : "deselectDataPoint",
                    "method" : "deselectDataPoint"
                }, {
                    "name" : "hoverOnDataPoint",
                    "method" : "hoverEffectOnDataPoint"
                }, {
                    "name" : "unhoverOnDataPoint",
                    "method" : "unhoverOnDataPoint"
                }, {
                    "name" : "clearPlot",
                    "method" : "clearPlot"
                }, {
                    "name" : "hover",
                    "supportedChartTypes": allTimeCharts,
                    "targets" : ["v-m-root", "v-m-action-layerrange"],
                    "method" : "hoverOnTimeArea"
                }
            ]
        }
    ];
});

define('sap/viz/chart/behavior/config/tooltip/TooltipUtils',[
    "sap/viz/framework/common/format/FormatManager",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/format/UnitFormat"
], function(
    FormatManager,
    TypeUtils,
    LangManager,
    UnitFormat
) {
    var INVALID_DATE = "Invalid date";
    var FORMAT_KEY = UnitFormat.SUPPORT_CUSTOM_COMPONENTS.TOOLTIP;
    function generateFormatForBoth(bothValue, formatString, unitFormatType, id, unit) {
        if (!bothValue) {
            return "";
        }

        var realValueFormat, percentageFormat;

        //then getting from format string
        if (TypeUtils.isString(formatString)) {
            realValueFormat = formatString;
        } else if (TypeUtils.isPlainObject(formatString)) {
            var sub = formatString[id];
            if (TypeUtils.isArray(sub)) {
                realValueFormat = sub[0];
                percentageFormat = sub[1];
            } else if (TypeUtils.isString(sub)) {
                realValueFormat = sub;
            }
        } else if (TypeUtils.isArray(formatString)) {
            realValueFormat = formatString[0];
            percentageFormat = formatString[1];
        }

        percentageFormat = percentageFormat ||FormatManager.getPercentagePattern(2);

        var options = {
            decimalFormatString: UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.TOOLTIP)
        };
        //generate it
        var result = UnitFormat.format(bothValue.value, realValueFormat, unitFormatType, options);
        if (unit) {
            result += " " + unit;
        }
        result += " (";
        result += UnitFormat.format(bothValue.percentage, percentageFormat, unitFormatType, options);
        result += ")";
        return result;
    }

    function format(data, props, service, noUnit, formatFun) {
        if (!TypeUtils.isArray(data.data)) {
            return data;
        }

        var body = data.data;
        var showType = props.get("tooltip.bodyMeasureValue.type");
        var isUTC = props.get('general.showAsUTC');
        for (var i = -1, k = 0; ++i < body.length;) {
            var rowItem = body[i];
            var value = rowItem.value;
            var valueD = rowItem["value.d"];
            var id = rowItem.id;
            if (value === null) {
                continue;
            }

            var formatString = props.get("tooltip.formatString");

            var rawMetaDataFormatString = rowItem.formatString;
            var metaDataFormatString = rowItem.formatString;
            if (TypeUtils.isArray(metaDataFormatString)) {
                metaDataFormatString = metaDataFormatString[0];
            }

            var appliedFormatString = null;
            var bothVal = rowItem.bothValue;

            if (!rowItem.bTimeRange && rowItem.type === "Measure") {
                if(rowItem.strValue != null){
                    value = rowItem.strValue;
                }

                if (body.timeMeasure !== undefined && body.timeMeasure === k) {
                    rowItem.value = FormatManager.format(new Date(parseInt(value)),
                        metaDataFormatString || FormatManager.DEFAULT_FORMAT_DATE_TIME, isUTC);
                } else {
                    var unitFormatType = props.get("tooltip.unitFormatType");
                    formatString = formatString || rawMetaDataFormatString;

                    if (bothVal && showType && showType === "valueAndPercentage") {
                        rowItem.value = generateFormatForBoth(bothVal, formatString, unitFormatType, id, rowItem.unit);
                    } else {
                        var percentageOnly = bothVal && showType === "percentage";
                        // For timeseries_100_stacked_column chart, show the percentage value by default.
                        if (service) {
                            var chartType = service._getChartType();
                            if (chartType && chartType.indexOf("timeseries_100_stacked_column") > -1) {
                                percentageOnly = true;
                                showType = "percentage";
                            }
                        }
                        
                        var valueOnly = bothVal && showType === "value";

                        if (TypeUtils.isPlainObject(formatString)) {
                            appliedFormatString = formatString[id];
                            if (TypeUtils.isArray(appliedFormatString)) {
                                appliedFormatString = percentageOnly ? appliedFormatString[1] : appliedFormatString[0];
                            }
                        } else if (TypeUtils.isString(formatString)) {
                            appliedFormatString = formatString;
                        } else if (TypeUtils.isArray(formatString)) {
                            appliedFormatString = percentageOnly ? formatString[1] : formatString[0];
                        }

                        if (percentageOnly) {
                            appliedFormatString = appliedFormatString ||
                            FormatManager.getPercentagePattern(2);    
                            value = bothVal ? bothVal[showType] : value;
                        } else if (valueOnly) {
                            value = bothVal ? bothVal[showType] : value;
                        }
                        var options = {
                            decimalFormatString: UnitFormat.getDecimalFormatString(FORMAT_KEY)
                        };

                        var actualFormatFun = formatFun || UnitFormat.format;
                        rowItem.value = actualFormatFun(value, appliedFormatString, unitFormatType, options);

                        if (!noUnit && rowItem.unit && (!bothVal || valueOnly)) {
                            rowItem.value += " " + rowItem.unit;
                        }
                    }
                }
                ++k;
            } else if (rowItem.type === "Dimension" &&
                ((body.timeDimensions !== undefined && body.timeDimensions.indexOf(i) >= 0))) {
                formatTimeDimension(rowItem, formatString, isUTC);

            }
        }
        return data;
    }
    
    function formatTimeDimension(rowItem, formatString, isUTC) {
        var valueD = rowItem["value.d"], appliedFormatString,
            metaDataFormatString = rowItem.formatString;
        if (rowItem.timeAxis) {
            if (valueD && TypeUtils.isString(valueD)) {
                //use value d if possible
                rowItem.value = {
                    day: valueD
                };
            } else {
                //if not, use default
                rowItem.value = rowItem.timeAxis.getFormatTimeValue(rowItem.value);
            }
        } else {
            var defaultFormat = FormatManager.DEFAULT_FORMAT_DATE_TIME;
            var oDate = new Date(rowItem.value);

            if (!isNaN(oDate.getTime())) {
                if (TypeUtils.isExist(formatString) && TypeUtils.isExist(formatString[rowItem.id])) {
                    appliedFormatString = formatString[rowItem.id];
                }
                appliedFormatString = appliedFormatString || metaDataFormatString || defaultFormat;
                rowItem.value = {
                    day: FormatManager.format(oDate, appliedFormatString, isUTC)
                };
            } else {
                rowItem.value = {
                    day: LangManager.get('IDS_INVALID_DATE') || INVALID_DATE
                };
            }

            if (valueD != null) {
                rowItem.value = {
                    day: valueD
                };
            }
        }
    }

    function buildEventGraphicInfo(service, extraData, result){
        var evtGraphic = {};
        if (extraData) {

            if(extraData.patternFill){
                evtGraphic.pattern = extraData.patternFill;
            }else if(extraData.pattern){
                evtGraphic.pattern = extraData.pattern;
            }

            if (extraData.color) {
                evtGraphic.color = extraData.color;

                if(extraData.actual && evtGraphic.color["v-primary"]){
                    evtGraphic.color["v-primary"]["id"] = extraData.actual;
                }
                if(extraData.additional && evtGraphic.color["v-additional"]){
                    evtGraphic.color["v-additional"]["id"] = extraData.additional;
                }
                if(extraData.forecast && evtGraphic.color["v-forecast"]){
                    evtGraphic.color["v-forecast"]["id"] = extraData.forecast;
                }
            }
            if (extraData.fill) {
                evtGraphic.color = extraData.fill;
            }
            if (extraData.shape) {
                evtGraphic.shape = extraData.shape;
            }
            if (extraData.type) {
                evtGraphic.type = extraData.type;
            }

            if(extraData.type === 'line'){
                buildLineSeriesEvtData(service, evtGraphic, extraData, result);
            }
        }
        return evtGraphic;
    }

    function buildLineSeriesEvtData(service, evtData, extraData, result){
        //Set specific info for popover with line
        var semanticMgr = service.getSemanticManager();
        var seriesIndex = extraData.seriesIndex;
        var plot = service.getModule("main.plot");
        var seriesStyle = plot.getSeriesStyle(seriesIndex, null, true);
        evtData.lineInfo = {};


        if(result){
            //Has semantic rule
            var otherStyle = semanticMgr.getOthersStyle('color,lineType,lineColor');

            if (result.properties && result.properties.lineColor){
                evtData.lineInfo.lineColor = result.properties.lineColor;
            } else {
                if(!semanticMgr.isOverrideMode()){
                    //Update Mode - Draw line with data point color
                    evtData.lineInfo.lineColor = extraData.color;
                } else {
                    evtData.lineInfo.lineColor = otherStyle.properties.lineColor || otherStyle.properties.color;
                    if(!evtData.lineInfo.lineColor){
                        evtData.lineInfo.lineColor = seriesStyle && seriesStyle.color || "#000000";
                    }
                }
            }

            evtData.lineInfo.lineType = seriesStyle && seriesStyle.lineType;
            if (result.properties && result.properties.lineType){
                evtData.lineInfo.lineType = result.properties.lineType;
            } else if(otherStyle.lineType){
                evtData.lineInfo.lineType = otherStyle.lineType;
            }
        } else {
            if(seriesStyle) {
                //Has lineStyle settings
                evtData.lineInfo.lineColor = seriesStyle.color;
                evtData.lineInfo.lineType = seriesStyle.lineType;
            }

        }

        var propsMgr = service.getProperties();
        if(propsMgr.get("plotArea.dataPoint.stroke.visible")){
            evtData.stroke = {};
            evtData.stroke.visible = true;
            evtData.stroke.color = propsMgr.get("plotArea.dataPoint.stroke.color");
        }
    }

    return {
        format: format,
        formatTimeDimension: formatTimeDimension,
        buildEventGraphicInfo : buildEventGraphicInfo
    };
});

define('sap/viz/chart/behavior/config/handler/TooltipTimerHandler',[
    'sap/viz/framework/core/config'
], function Setup(config) {
        var STATES_DEF = {
            Cleared: "Cleared",
            Active: "Active",
            Standby: "Standby",
            Appeared: "Appeared",
            Selected: "Selected",
            Deselected: "Deselected"
        };

        var SHOW_BASIC_MODE_TIMER = 1000;

        var SHOW_TOOLTIP_MODE_TIMER = 100;

        var HIDE_TIMER = 5000;

        var DURATION = 1000;

        function TooltipTimerHandler() {
            this._init();
        }

        TooltipTimerHandler.prototype.setShowTooltipHandler = function(callback) {
            this._showHandler = callback;
        };

        TooltipTimerHandler.prototype.setHideTooltipHandler = function(callback) {
            this._hideHandler = callback;
        };

        TooltipTimerHandler.prototype.setMode = function(mode) {
            this._mode = mode;
        };

        TooltipTimerHandler.prototype._setStatus = function(state) {
            // console.log(state);
            this._status = state;
            var handlerName = "_" + STATES_DEF[state].toLowerCase() + "Handler";
            this[handlerName]();
        };

        TooltipTimerHandler.prototype._clearedHandler = function() {
            this._isFirstShow = true;
            this._hideHandler();
        };

        TooltipTimerHandler.prototype._activeHandler = function() {
            this._hideHandler();
            this._currentTime = Date.now();
            if (!this._isFirstShow && this._currentTime - this._lastTime < DURATION) {
                this._timer = SHOW_TOOLTIP_MODE_TIMER;
            } else {
                this._timer = SHOW_BASIC_MODE_TIMER;
            }
            if (this._showTimeOut) {
                clearTimeout(this._showTimeOut);
            }
            function showTooltip() {
                this._setStatus(STATES_DEF.Appeared);
            }
            var disableTooltipTimer = config.globalSetting("disableTooltipTimer");
            //internal flag to disable tooltip timer for ST automation use
            if (disableTooltipTimer) {
                showTooltip.call(this);
            } else {
                this._showTimeOut = setTimeout(showTooltip.bind(this), this._timer);
            }
        };

        TooltipTimerHandler.prototype._standbyHandler = function() {
            if (this._showTimeOut) {
                clearTimeout(this._showTimeOut);
                this._showTimeOut = null;
            }
            if (this._hideTimeOut) {
                clearTimeout(this._hideTimeOut);
                this._hideTimeOut = null;
            }
            this._hideHandler();
        };

        TooltipTimerHandler.prototype._appearedHandler = function() {
            this._lastTime = Date.now();
            this._isFirstShow = false;
            this._showHandler();
            if (this._mode !== "actionMode") {
                if (this._hideTimeOut) {
                    clearTimeout(this._hideTimeOut);
                }
                var hideTooltip = function() {
                    this._setStatus(STATES_DEF.Cleared);
                };
                var disableTooltipTimer = config.globalSetting("disableTooltipTimer");
                //internal flag to disable tooltip timer for ST automation use
                if (!disableTooltipTimer) {
                    this._hideTimeOut = setTimeout(hideTooltip.bind(this), this._hideTimer);
                }
            }
        };

        TooltipTimerHandler.prototype._selectedHandler = function() {
            if (this._showTimeOut) {
                clearTimeout(this._showTimeOut);
                this._showTimeOut = null;
            }
            if (this._hideTimeOut) {
                clearTimeout(this._hideTimeOut);
                this._hideTimeOut = null;
            }
            this._showHandler();
            this._lastTime = Date.now();
        };

        TooltipTimerHandler.prototype._deselectedHandler = function() {
            if (this._showTimeOut) {
                clearTimeout(this._showTimeOut);
                this._showTimeOut = null;
            }
            if (this._hideTimeOut) {
                clearTimeout(this._hideTimeOut);
                this._hideTimeOut = null;
            }
            this._hideHandler();
        };

        TooltipTimerHandler.prototype.hover = function(target) {
            switch (this._status) {
                case STATES_DEF.Cleared:
                    if (target !== "nonDataPoint") {
                        this._setStatus(STATES_DEF.Active);
                    }
                    break;
                case STATES_DEF.Active:
                    if (target === "nonDataPoint") {
                        this._setStatus(STATES_DEF.Standby);
                    } else {
                        this._setStatus(STATES_DEF.Active);
                    }
                    break;
                case STATES_DEF.Appeared:
                    if (target === "nonDataPoint") {
                        this._setStatus(STATES_DEF.Standby);
                    } else if (isTargetEqual(this._target, target)) {
                        if (this._mode !== "actionMode") {
                            //hover on self
                            this._setStatus(STATES_DEF.Appeared);
                        }
                    } else {
                        this._setStatus(STATES_DEF.Active);
                    }
                    break;
                case STATES_DEF.Standby:
                    if (target !== "nonDataPoint") {
                        this._setStatus(STATES_DEF.Active);
                    }
                    break;
                case STATES_DEF.Selected:
                case STATES_DEF.Deselected:
                    if (target !== "nonDataPoint" && !isTargetEqual(this._target, target)) {
                        this._setStatus(STATES_DEF.Active);
                    }
                    break;
            }
            this._target = target;
        };

        function isTargetEqual(oldTarget, newTarget) {
            //target can be a dom or id number
            var oldId = oldTarget && oldTarget.getAttribute? oldTarget.getAttribute("data-datapoint-id"): oldTarget;
            var newId = newTarget && newTarget.getAttribute? newTarget.getAttribute("data-datapoint-id"): newTarget;
            return newId === oldId;
        }

        TooltipTimerHandler.prototype.select = function(target) {
            this._setStatus(STATES_DEF.Selected);
            this._target = target;
        };

        TooltipTimerHandler.prototype.deselect = function(target) {
            this._setStatus(STATES_DEF.Deselected);
            this._target = target;
        };

        TooltipTimerHandler.prototype.interrupt = function() {
            this._setStatus(STATES_DEF.Standby);
        };

        TooltipTimerHandler.prototype._init = function() {
            this._status = STATES_DEF.Cleared;
            this._showTimeOut = null;
            this._hideTimeOut = null;
            this._timer = SHOW_BASIC_MODE_TIMER;
            this._hideTimer = HIDE_TIMER;
            this._showHandler = null;
            this._hideHandler = null;
            this._currentTime = null;
            this._lastTime = null;
            this._target = null;
            this._isFirstShow = true;
        };

        TooltipTimerHandler.prototype.reset = function() {
            // ensure to be invoked when chart is destroyed
            clearTimeout(this._showTimeOut);
            clearTimeout(this._hideTimeOut);
            this._init();
        };

        return TooltipTimerHandler;
    }
);
define('sap/viz/chart/behavior/config/tooltip/Tooltip',[
    "sap/viz/chart/behavior/config/tooltip/TooltipUtils",
    "sap/viz/framework/common/util/CSSUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/log/Logger",
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/FiscalUtil',
    "sap/viz/chart/behavior/config/AlignToUtil",
    "sap/viz/chart/components/util/TextUtils"
], function Setup(
    TooltipUtils,
    CSSUtils,
    TypeUtils,
    ObjectUtils,
    langManager,
    UADetector,
    Logger,
    NumberUtils,
    Constants,
    FiscalUtil,
    AlignToUtil, 
    TextUtils) {
    var DEFAULT_SELECTED_NOTIFICATION = "values selected";
    var DEFAULT_SINGULAR_SELECTED_NOTIFICATION = "value selected";
    var TOOLTIP_MODE = {
        INFO_MODE: "infoMode",
        ACTION_MODE: "actionMode"
    };

    var DEFAULT_PADDING_BOTTOM_NUM = 8;
    var DEFAULT_PADDING_BOTTOM = DEFAULT_PADDING_BOTTOM_NUM + "px";

    var DEFAULT_DISPLAY_CONFIG = {
        padding: "10px",
        paddingNum: 10, //the number for padding
        paddingBottom: "10",
        paddingTop: "10",
        horizontalLine: {
            borderBottom: "solid 1px",
            borderBottomNum: 1,
            marginTop: "10px",
            marginTopNum: 10
        },
        dimensionName: {
            fontSize: "12px",
            fontFamily: "Arial",
            paddingBottom: DEFAULT_PADDING_BOTTOM,
            paddingBottomNum: DEFAULT_PADDING_BOTTOM_NUM,
            whiteSpace: "nowrap",
            overflow: "hidden"
        },
        dimensionValue: {
            fontSize: "13px",
            fontFamily: "Arial",
            fontWeight: "bold",
            paddingBottom: DEFAULT_PADDING_BOTTOM,
            paddingBottomNum: DEFAULT_PADDING_BOTTOM_NUM,
            paddingLeft: "7px",
            paddingLeftNum: 7,
            whiteSpace: "nowrap",
            overflow: "hidden"
        },
        measureName: {
            fontSize: "12px",
            fontFamily: "Arial",
            paddingBottom: DEFAULT_PADDING_BOTTOM,
            paddingBottomNum: DEFAULT_PADDING_BOTTOM_NUM,
            whiteSpace: "nowrap",
            overflow: "hidden"
        },
        measureValue: {
            fontSize: "13px",
            fontFamily: "Arial",
            fontWeight: "bold",
            paddingBottom: DEFAULT_PADDING_BOTTOM,
            paddingBottomNum: DEFAULT_PADDING_BOTTOM_NUM,
            paddingLeft: "7px",
            paddingLeftNum: 7,
            whiteSpace: "nowrap",
            overflow: "hidden"
        },
        selectedText: {
            fontSize: "12px",
            fontFamily: "Arial",
            fontWeight: "bold",
            marginTop: "8px",
            marginTopNum: 8
        },
        closeButton: {
            size: 20,
            borderSize: 2,
            borderStyle: "solid",
            forkSize: 10
        },
        mouseMarginTop: 3,
        truncatedWidth: 140,
        contentMaxSize: "42px",
        truncatedHeight: 12,
        borderWidth: "1px",
        borderWidthNum: 1, //number for borderWidth
        borderStyle: "solid",
        borderRadius: "3px",
        boxShadow: "1px 1px #AFAFAF"
    };

    var getPositiveNumber = NumberUtils.getPositiveNumber;

    function setRendererFunc(value, config) {
        if (TypeUtils.isFunction(value)) {
            return value;
        } else {
            return config.defaultValue;
        }
    }

    var Tooltip = function(properties) {
        this._properties = properties;
        this._properties.add({
            "tooltip": {
                "preRender": {
                    //defaultValue: null,
                    set: setRendererFunc
                },
                "postRender": {
                    //defaultValue: null,
                    set: setRendererFunc
                },
                "formatString": {
                    //defaultValue: nul,
                    set: function(value, config) {
                        if (TypeUtils.isString(value) ||
                            TypeUtils.isPlainObject(value) || 
                            TypeUtils.isArray(value) ) {
                            return value;
                        } else {
                            return config.defaultValue;
                        }
                    }
                },
                "unitFormatType": {
                    //defaultValue: FinancialUnits,
                    set: function(value, config) {
                        if (TypeUtils.isString(value)) {
                            return value;
                        } else {
                            return config.defaultValue;
                        }
                    }
                }
            }
        });
        this._display = ObjectUtils.extend(true, {}, DEFAULT_DISPLAY_CONFIG);
        this._tooltipMode = ObjectUtils.extend(true, {}, TOOLTIP_MODE);

        this._defaultToolTipColors = {
            backgroundColor: "",
            borderTopColor: "",
            borderBottomColor: "",
            borderLeftColor: "",
            borderRightColor: "",
            dimensionName: "",
            dimensionValue: "",
            measureName: "",
            measureValue: "",
            separationLineSingleColor: "",
            footerLabelColor: "",
            closeButtonBackground: "#ffffff", //for hichert chart.
            closeButtonBorderColor: "#cccccc" 
        };

        this._data = null;
        this._semanticResult = null;
        this._div = null;
        this._borderDiv = null;
        this._mainDiv = null;
        this._isShown = false;
        this._closeButtonDiv = null;
        this._extensionDiv = null;
        this._mode = null;
        this._dimensionOrMeasureTitles = [];

        this._maxRatio = 0.75;
        this._isRTL = false;

        if (UADetector.isWindowsSurface()) {
            this._touchEvent = {
                touchstart: "pointerdown",
                touchend: "pointerup"
            };
        } else {
            this._touchEvent = {
                touchstart: "touchstart",
                touchend: "touchend"
            };
        }
    };

    function handleNull(_) {
        if (_ == null) {
            return langManager.get("IDS_ISNOVALUE");
        } else {
            return _;
        }
    }

    Tooltip.prototype.isActionMode = function(){
        return this._mode === TOOLTIP_MODE.ACTION_MODE;
    };

    Tooltip.prototype.isInfoMode = function(){
        return this._mode === this._tooltipMode.INFO_MODE;
    };

    Tooltip.prototype.shouldShowFullText = function(){
        return this._properties.get("tooltip.showFullText");
    };

    Tooltip.prototype._willHaveScrollbar = function(){
        return this.isActionMode() && this._isTextTooTall && !this.shouldShowFullText();
    };

    Tooltip.prototype.onClose = function(cb){
        this._onClose = cb;
    };

    Tooltip.prototype._clearGlobalValues = function() {
        this._dimensionOrMeasureTitles = [];
    };

    Tooltip.prototype._getTooltipContainer = function(){
        return this._div.node().parentNode;
    };

    Tooltip.prototype._getRootParent = function(){
        //BITSDC1-8876, the parent of chart
        return this._rootNode && this._rootNode.parentNode;
    };


    Tooltip.prototype.createNode = function(selection) {
        if (selection !== null && selection !== undefined) {
            var sel = d3.select(selection);
            this._div = sel.select(".v-m-tooltip");
            if (this._div.node() === null) {
                this._div = sel.append("div").attr("class", "v-m-tooltip"); //.attr("id", "v-m-tooltip");
            }
        }
        return this;
    };

    Tooltip.prototype._formatTooltipData = function(data, service) {
        return TooltipUtils.format(data, this._properties, service);
    };

    var triggerCallback = function(callback, vis, eventData) {
        if (callback) {
            try {
                return callback(vis, eventData);
            } catch (e) {
                Logger.error("ERROR in Tooltip callback");
            }
        }
    };

    Tooltip.prototype.showTooltip = function(eventData, semanticResult, isRTL, service) {
        if (!this._div || this._getTooltipContainer() === null) {
            this.createNode(eventData.container);
        }

        this._rootNode = eventData.root;
        this._mode = eventData.mode;
        this._data =  this._formatTooltipData(eventData, service);
        this._semanticResult = semanticResult;
        if (this._borderDiv !== null) {
            this._borderDiv.remove();
        }

        //It's for tooltip's layout in RTL mode.
        this._isRTL = isRTL;

        this._isTextTooTall = false;
        this._isTextTooLong = false;
        this._maxUntruncatedTextWidth = null;

        //according to PO's requirement, we add ar and he RTL setting.
        var addRTL = false;
        var i;
        for(i = 0; i < Constants.RTL_LANG.length; i++) {
            if(langManager.currentLanguage.indexOf(Constants.RTL_LANG[i]) === 0) {
                addRTL = true;
                break;
            }
        }

        if (this._properties.get("tooltip.visible")) { 
            this._borderDiv = this._div.append("div").attr("class", "v-background");
            if(this._data.data && this._data.data.rangeSelectionStage === "inLasso"){
                this._div.node().style["pointer-events"] = "none";
            }else{
                this._div.node().style["pointer-events"] = "";
                // set to "" means that reset style to default value
            }
            //we do not set direction, because we use text-anthor:middle to 
            //keep language directiohn neutral
            this._mainDiv = this._borderDiv.append("div").attr("class", "v-tooltip-mainDiv")
                .style("position", "relative")
                .style("direction", addRTL? "rtl" :  null);
    
            if (isMobile()) {
                this._borderDiv.style('-webkit-overflow-scrolling', 'auto');
                
                //we do not set direction, because we use text-anthor:middle to 
                //keep language directiohn neutral
                this._closeButtonDiv = this._borderDiv.append("div").attr("class",
                    "v-closeButton")
                    .style("position", "absolute")
                    .style("direction", addRTL? "rtl" : null);
                
                var that = this;
                this._closeButtonDiv.on(this._touchEvent.touchstart, function() {
                    d3.event.stopPropagation();
                    d3.event.preventDefault();
                }, true).on(this._touchEvent.touchend, function() {
                    if (that._onClose && TypeUtils.isFunction(that._onClose)){
                        that._onClose.call(that);
                    }
                    that.hideTooltip(that._mode);
                    d3.event.stopPropagation();
                    d3.event.preventDefault();
                }, true);
            }

            this._extensionDiv = this._borderDiv.append("div")
                                 .attr("class", "v-tooltip-extension")
                                 .style("position", "relative")
                                 .style("display", "block")
                                 .style("margin-top","10px");
            this._updateTooltipColor();
            
            if (this.isActionMode()) { // show action bottom in action mode
                var result = triggerCallback(this._properties.get("tooltip.preRender"), this._extensionDiv);
                if(TypeUtils.isExist(result) && (result instanceof Object) && 
                    TypeUtils.isExist(result.then) && TypeUtils.isFunction(result.then)) {
                    var doneCallback = function(){
                        this._renderTooltip();
                    };
                    result.then(doneCallback.bind(this));
                }else{
                    this._renderTooltip();
                }
            }else{
                this._renderTooltip();
            }

            triggerCallback(this._properties.get("tooltip.postRender"), this._borderDiv);
            this._isShown = true;
        }
    };

    Tooltip.prototype.isShown = function(){
        return this._isShown;
    };

    Tooltip.prototype.hideTooltip = function(mode) {
        if (mode == null || mode === this._mode) {
            if (this._borderDiv) {
                this._borderDiv.remove();
                this._borderDiv = null;
            }
            if (this._mainDiv) {
                this._mainDiv = null;
            }
            if (this._extensionDiv) {
                this._extensionDiv = null;
            }

            if (this._closeButtonDiv) {
                this._closeButtonDiv.on(this._touchEvent.touchend, null);
                this._closeButtonDiv.on(this._touchEvent.touchstart, null);
                this._closeButtonDiv = null;
            }
            this._defaultToolTipColors.background = "";
            this._defaultToolTipColors.border = "";
            this._defaultToolTipColors.dimensionName = "";
            this._defaultToolTipColors.dimensionValue = "";
            this._defaultToolTipColors.measureName = "";
            this._defaultToolTipColors.measureValue = "";
            this._defaultToolTipColors.separationLineSingleColor = "";
            if (this._div) {
                this._div.style("visibility", "hidden")
                    .style("padding", "0px")
                    .style("max-height", "")
                    .style("top", "-65535px")
                    .style("left", "-65535px");
            }
            this._clearGlobalValues();
            this._isShown = false;
        }
    };

    Tooltip.prototype._calculateDesktopPos = function(limit, position) {
        var x = position.x;
        var y = position.y;

        var paddingBottom = +this._display.paddingBottom;
        var paddingTop = +this._display.paddingTop;
        var mouseMarginTop = this._display.mouseMarginTop;

        var divNode = this._div.node();
        var offsetWidth = divNode.offsetWidth;
        var offsetHeight = divNode.offsetHeight;

        if ((x + offsetWidth / 2) > limit.right) {
            x = limit.right - offsetWidth;
        } else if (x - offsetWidth / 2 < limit.left) {
            x = limit.left;
        } else {
            x = x - offsetWidth / 2;
        }
        if (!this.isInfoMode() && (y - mouseMarginTop - offsetHeight) < limit.top) {
            y = y + 13 - paddingTop;
        } else if (this.isInfoMode() && (y - paddingBottom - mouseMarginTop -
            offsetHeight) < limit.top) {
            //remove to size of mouse, it is a estimation value not the actual value. comes from UX evian zhang.
            y = y + 13;
        } else {
            y = y - mouseMarginTop - offsetHeight;
            if (this.isInfoMode()) {
                y = y - paddingBottom;
            }
        }
        if (y + offsetHeight > limit.bottom) {
            //handle the case chart height is very limited
            if (position.y <= (limit.bottom + limit.top) / 2) {
                y = position.y + 13;
                if (!this.isInfoMode()) {
                    y = y - paddingTop;
                }
            } else {
                y = position.y - mouseMarginTop - offsetHeight;
                if (this.isInfoMode()) {
                    y = y - paddingBottom;
                }
            }
        }

        return {
            "x": x,
            "y": y
        };
    };

    Tooltip.prototype._calculateMobilePos = function(limit, position) {
        var x = position.x;
        var y = position.y;

        var closeButtonSize = this._display.closeButton.size;
        var mouseMarginTop = this._display.mouseMarginTop;

        var divNode = this._div.node();
        var offsetWidth = divNode.offsetWidth;
        var offsetHeight = divNode.offsetHeight;

        if ((x + offsetWidth / 2 + closeButtonSize / 2) > limit.right) {
            x = limit.right - offsetWidth - closeButtonSize / 2;
        } else if (x - offsetWidth / 2 < limit.left) {
            x = limit.left;
        } else {
            x = x - offsetWidth / 2 - closeButtonSize / 2;
        }
        if ((y - mouseMarginTop - offsetHeight - closeButtonSize / 2) < limit.top) {
            y = y + 13 + closeButtonSize / 2; //remove to bottom of mouse
        } else {
            y = y - mouseMarginTop - offsetHeight;
        }

        if (y + offsetHeight + closeButtonSize / 2 > limit.bottom) {
            if (position.y <= (limit.bottom + limit.top) / 2) {
                y = position.y + 13 + closeButtonSize / 2;
            } else {
                y = position.y - mouseMarginTop - offsetHeight;
            }
        }

        return {
            "x": x,
            "y": y
        };
    };

    function isMobile(){
        return UADetector.isMobile() && (!UADetector.isIE() || UADetector.isPointerEnabled());
    }

    Tooltip.prototype._calculatePos = function(position) {
        var pos;
        if (TypeUtils.isExist(position.alignTo)) {
            var rootNode = this._div.node();
            [].concat(position.alignTo).forEach(function(alignTo) {
                if(alignTo.source.dom) {
                    return;
                } else if (!alignTo.source.selector) {
                    alignTo.source.dom = rootNode;
                } else {
                    alignTo.source.dom = rootNode.querySelector(alignTo.source.selector);
                }
            });

            pos = AlignToUtil.calculate(position.alignTo);
        } else {
            var limit = this._getLimit();
            var boundRect = this._getTooltipContainer().getBoundingClientRect();
            var calcFunc = isMobile() ? this._calculateMobilePos : this._calculateDesktopPos;
            var res = calcFunc.call(this, limit, position);
            pos = {
                "x": res.x - boundRect.left,
                "y": res.y - boundRect.top
            };
        }

        if (position.offset) {
            pos.x += position.offset.x || 0;
            pos.y += position.offset.y || 0;
        }

        return pos;
    };

    Tooltip.prototype._getMaxWidth = function(){
        var parentWidth = (this._getRootParent() && +this._getRootParent().offsetWidth) || 0;
        var containerWidth = getPositiveNumber(this._getTooltipContainer().getAttribute("actualWidth"), 0);
        return Math.max(parentWidth, containerWidth) * this._maxRatio;
    };

    Tooltip.prototype._getMaxWidthForText = function(){
        var maxWidth = Math.max(this._getMaxWidth() - 2 * (this._display.paddingNum + this._display.borderWidthNum), 0);
        if(willHaveSelectionRegion(this._data)){
            maxWidth = Math.max(this._getReservedSpaceForSelection().width, maxWidth);
        }
        return Math.max(maxWidth, this._maxUntruncatedTextWidth); 
    };

    Tooltip.prototype._getMaxHeight = function(){
        var parentHeight = (this._getRootParent() && +this._getRootParent().offsetHeight) || 0;
        var containerHeight = getPositiveNumber(this._getTooltipContainer().getAttribute("actualHeight"), 0);
        var result =  Math.max(parentHeight, containerHeight)  * this._maxRatio;

        if(willHaveSelectionRegion(this._data)){
            result -= this._getReservedSpaceForSelection().height;
        }
        return Math.max(result, 0);
    };

    Tooltip.prototype._getMaxHeightForText = function(){
        return  Math.max(this._getMaxHeight() - 2 * this._display.paddingNum, 0); 
    };

    Tooltip.prototype._getLimit = function() {
        function getSize(node, key, altKey){
            if(!node){
                return 0;
            }
            return node.hasAttribute(key) ? getPositiveNumber(node.getAttribute(key), 0) : node[altKey];
        }
        var limit;
        if (this._properties.get("tooltip.layinChart") && !this.shouldShowFullText()) {
            var container =  this._getTooltipContainer();
            var boundRect = container.getBoundingClientRect();
            var containerWidth = getSize(container, "actualWidth", "offsetWidth");
            var containerHeight = getSize(container, "actualHeight", "offsetHeight");

            limit = {
                top: boundRect.top,
                left: boundRect.left,
                bottom : boundRect.top + containerHeight,
                right : boundRect.left + containerWidth
            };
        } else {
            var winWidthHeight = [0, 0];
            ["clientWidth", "clientHeight"].forEach(function(e, i) {
                if (document.documentElement[e]) {
                    winWidthHeight[i] = document.documentElement[e];
                } else if ((document.body) && (document.body[e])) {
                    winWidthHeight[i] = document.body[e];
                }
            });
            limit = {
                top: 0,
                left: 0,
                bottom: winWidthHeight[1],
                right: winWidthHeight[0]
            };
        }
        return limit;
    };

    Tooltip.prototype._adjustTooltipHeight = function(winHeight) {
        this._div.style("max-height", (winHeight / 2 - this._display.truncatedHeight) + "px");
    };

    Tooltip.prototype._renderTooltip = function() {
        if (!this._extensionDiv.node() || this._extensionDiv.node().childNodes.length === 0) {
            this._extensionDiv.remove();
        }

        var parsedData = this._getTextsAndStyles();
        if(parsedData){
            if(this.shouldLayout()){
                parsedData = this.layout(parsedData);
            }
            this._drawContent(parsedData); 
            this._postUpdateTable(this._data.data);
        }

        this._updateSelection();
        this._updateBorderDiv();
        this._updateDiv();
        this._adjustCloseBtnForMobile();
    };


    Tooltip.prototype._postUpdateTable = function(data){
        //will be overrided by geo 
    };

    Tooltip.prototype._updateBorderDiv = function(){
        this._borderDiv.style("background", this._defaultToolTipColors.backgroundColor);
        this._borderDiv.style("border-color", this._defaultToolTipColors.border);

        var keys = ["borderTopColor", "borderBottomColor", "borderLeftColor", "borderRightColor"];
        var cssKeys = [ "border-top-color", "border-bottom-color","border-left-color", "border-right-color"];
        for(var ii = 0; ii < keys.length; ii++){
            if (this._defaultToolTipColors[keys[ii]] !== "") {
                this._borderDiv.style([cssKeys[ii]], this._defaultToolTipColors[keys[ii]]);
            }
        }

        this._borderDiv.style("border-style", this._display.borderStyle)
            .style("border-width", this._display.borderWidth)
            .style("border-radius", this._display.borderRadius)
            .style("box-shadow", this._display.boxShadow)
            .style("overflow-x", "hidden")
            .style("overflow-y", "auto")
            .style("padding", this._display.padding);
    };

    Tooltip.prototype._updateDiv = function(){    
        this._div.style("position", "absolute")
            .style("left", "0px")
            .style("top", "0px")
            .style("width", "auto")
            .style("height", "auto")
            .style("float", "left")
            .style("visibility", "hidden")
            .style("line-height", "normal");
        this._addPadding();
        if (this.isActionMode()) {
            this._div.style("padding-bottom", this._display.paddingBottom + "px");
            if(!isMobile()){
                this._div.style("padding-top", this._display.paddingTop + "px");
            }
        }else{
            this._div.style("padding-top", "0px");
        }

        var winHeight;
        if (document.documentElement.clientHeight) {
            winHeight = document.documentElement.clientHeight;
        } else if ((document.body) && (document.body.clientHeight)) {
            winHeight = document.body.clientHeight;
        }
        if (this._div.node().offsetHeight > winHeight) {
            this._adjustTooltipHeight(winHeight);
        }

        this._div.style("visibility", "visible").style("white-space", "nowrap");

        if (this._data.forceStyle) {
            this._div.style(this._data.forceStyle);
        }

        //set up the position
        var tooltipPos = this._calculatePos(this._data.position);
        this._div.style("left", tooltipPos.x + "px")
            .style("top", tooltipPos.y + "px");
    };

    Tooltip.prototype._adjustCloseBtnForMobile = function(){
        if (isMobile()) {
            //the goal of the line is to avoid the incorrect display of the closeButton when zoom out the page on pad.
            var divNode = this._div.node();
            var padding = this._getPaddingForCloseBtn(divNode);
            var offw = divNode.offsetWidth - parseInt(padding.paddingRight);
            var closeButtonSize = this._display.closeButton.size,
                closeButtonRadius = closeButtonSize / 2;
            var forkSize = this._display.closeButton.forkSize,
                forkRadius = forkSize / 2;
            var borderSize = this._display.closeButton.borderSize;
            var forkX = closeButtonRadius - forkRadius;
            var forkY = closeButtonRadius - borderSize / 2;
            var transformName = "-webkit-transform";
            if (UADetector.isWindowsSurface()) {
                transformName = "transform";
            }

            var styleObj = {
                "position": "absolute",
                "height": this._display.closeButton.borderSize,
                "width": forkSize + "px",
                "border-bottom-color": this._defaultToolTipColors.closeButtonBorderColor,
                "border-bottom-width": this._display.closeButton.borderSize + "px",
                "border-bottom-style": this._display.closeButton.borderStyle,
                "top": forkY + "px",
                "left": forkX + "px"
            };
            styleObj[transformName] = "rotate(-45deg)";
            this._closeButtonDiv.append("div").style(styleObj);
            styleObj[transformName] = "rotate(45deg)";
            this._closeButtonDiv.append("div").style(styleObj);
            var buttonTop = closeButtonRadius - parseInt(padding.paddingTop);
            this._closeButtonDiv.style("left", offw - closeButtonRadius - this._display.closeButton.borderSize+'px')
                .style("top", -buttonTop + "px")
                .style("width", closeButtonSize + "px")
                .style("height", closeButtonSize + "px")
                .style("border-width", this._display.closeButton.borderSize + "px")
                .style("border-radius", closeButtonSize + "px")
                .style("border-style", this._display.closeButton.borderStyle)
                .style("border-color", this._defaultToolTipColors.closeButtonBorderColor)
                .style("background", this._defaultToolTipColors.closeButtonBackground);
        }
    };

    Tooltip.prototype._getPaddingForCloseBtn = function(node) {
        if (node) {
            var regexp = /(\d*)px/i;
            var style = node.style;
            var paddingRight = style.paddingRight;
            var paddingTop =  style.paddingTop;
            var result = regexp.exec(paddingRight);
            paddingRight = (result && result[1]) || 0;
            result = regexp.exec(paddingTop);
            paddingTop = (result && result[1]) || 0;
            return {
                "paddingRight": paddingRight,
                "paddingTop": paddingTop
            };
        }
        return {
            "paddingRight": 0,
            "paddingTop": 0
        };
    };

    // Override this function to add top/left/right/bottom padding by tooltip position
    Tooltip.prototype._addPadding = function() {
        if (this.isActionMode()) {
            this._div.style("padding-bottom", this._display.paddingBottom + "px");
        }
    };

    Tooltip.prototype._getReservedSpaceForSelection = function(){
        var style = this._getStyleForSelection();
        var text = this._getTextForSelection();
        var size = this.measure(text, style);
        var height  = size.height + 
               this._display.horizontalLine.borderBottomNum + this._display.horizontalLine.marginTopNum + 
               this._display.selectedText.marginTopNum;
        return {
            height: height,
            width: size.width
        };
    };

    Tooltip.prototype._getReservedSpaceForScrollbar = function(){
        //we use native scrollbar
        if(this.shouldShowFullText()){
            return 0;
        }else if(isMobile()){
            var MOBILE_SPACE = 10;
            return MOBILE_SPACE;
        }else if (UADetector.isIE()){
            var IE_SPACE = 30;
            return IE_SPACE;
        }else{
            var NORMAL_SPACE = 20;
            return NORMAL_SPACE;
        }
    };

    function hasMultipleSelection(data){
        if(data.selectedNumber <= 0){
            return false;
        }
        return data.selectedNumber > 1  ||  (data.data && data.data.rangeSelectionStage === "lassoEnd");
    }

    function willHaveSelectionRegion(data){
        return data.data && data.selectedNumber > 0 && hasMultipleSelection(data);
    }

    Tooltip.prototype._getStyleForSelection = function(){
        var style = convertStyle(this._display.selectedText);
        if (this._defaultToolTipColors.footerLabelColor !== "") {
            style += ";color:" + this._defaultToolTipColors.footerLabelColor;
        }
        if (!this._data.data) { // set margin top to zero if no info
            style = style.replace(/margin-top:[0-9]+px/, "margin-top:0px");
        }
        return style;
    };

    Tooltip.prototype._getTextForSelection = function(){
        var singleSelection = this._data.selectedNumber === 1;
        var valuesSelectedText = singleSelection ? langManager.get("IDS_VALUE_SELECTED") :
            langManager.get("IDS_VALUES_SELECTED");
        if (!valuesSelectedText) {
            valuesSelectedText = singleSelection ? DEFAULT_SINGULAR_SELECTED_NOTIFICATION : 
                DEFAULT_SELECTED_NOTIFICATION;
        }

        return this._data.selectedNumber + " " + valuesSelectedText;
    };

    Tooltip.prototype._updateSelection = function(){
        if(this.isActionMode()){
            var data = this._data;
            if (willHaveSelectionRegion(data)) {
                // draw separate line
                var line = this._mainDiv.append("div").attr("class", "v-separationline")
                    .style("margin-top", this._display.horizontalLine.marginTop)
                    .style("border-bottom-width", "1px")
                    .style("border-bottom-style", "solid");
                if (this._defaultToolTipColors.separationLineSingleColor !== "") {
                    line.style("border-bottom-color", this._defaultToolTipColors.separationLineSingleColor);
                }
            }

            if (hasMultipleSelection(data) || !data.data) {
                // draw selected text if selected number > 1
                var style = this._getStyleForSelection();
                var text = this._getTextForSelection();
                this._mainDiv.append("div")
                    .each(function () {
                        CSSUtils.setDOMStyle(this, style);
                    })
                    .attr("class", "v-footer-label tooltipfooterlabel")
                    .text(text);
            }
        }
    };

    Tooltip.prototype._processTimeRange = function (data){
        var len = data.length;
        var i = 0;
        if(len < 2 || !data[i].bTimeRange){
            return ;
        }
        
        if(data[0].value.time && data[0].value.day && data[0].value.day === data[1].value.day){
            data[0].value.day = null;
        }
    };

    Tooltip.prototype._getDimensionTextAndStyle = function(dimTexts, dimStyles, item, bLastDim){
        var nameStyle = ObjectUtils.extend(true, {}, this._display.dimensionName);
        var valueStyle = ObjectUtils.extend(true, {}, this._display.dimensionValue);
        var isTime = item.bTimeRange || item.bValueDate;
        var firstValue = isTime?   (item.value.time|| item.value.day) : item.value;
        if(bLastDim && (!isTime || !item.value.time || !item.value.day)){
            nameStyle.paddingBottom = "0px";
            valueStyle.paddingBottom = "0px";   
        }
        
        if(item.bValueDate){
            valueStyle.paddingLeft = "0px";
        }

        var rowStyle = [];
        var rowText = [];
       
        //Dimension name
        var td, nameText;
        if(!item.bValueDate){
            if (this._defaultToolTipColors.dimensionName !== "") {
                nameStyle.color = this._defaultToolTipColors.dimensionName;
            }

            if(this._isRTL){
                nameStyle._float = "left";
            }

            var dataName;
            var semanticResult = this._semanticResult;
            if(semanticResult && semanticResult.dataName) {
                dataName = semanticResult.dataName[item.id];
            }
            nameText = handleNull(TypeUtils.isExist(dataName) ? dataName : item.name) + ":";

            rowText.push(nameText);
            rowStyle.push(nameStyle);
        }

        var valueText = handleNull(firstValue);
        var dimensionValueStyle = ObjectUtils.extend(true, {}, valueStyle);
        if (this._defaultToolTipColors.dimensionValue !== "") {
            dimensionValueStyle.color = this._defaultToolTipColors.dimensionValue;
        }

        rowText.push(valueText);
        rowStyle.push(dimensionValueStyle);
  
        if(isTime && item.value.day && item.value.time){
            if(bLastDim){
                valueStyle = ObjectUtils.extend(true, {}, this._display.dimensionValue);
                valueStyle.paddingBottom = "0px";
                valueStyle.color = this._defaultToolTipColors.dimensionValue;
                dimensionValueStyle = valueStyle;
            }

            valueText = handleNull(item.value.day);

            rowText.push(valueText);
            rowStyle.push(dimensionValueStyle);  
            //will seperate them into two rows
            item.drawAsTwoRow = true;
        }

        dimStyles.push(rowStyle);
        dimTexts.push(rowText);
    };

    function extendTwoRow(arr, indexes, isItems){
        var result = [];
        for(var ii = 0; ii < arr.length; ii++){
            if(indexes.indexOf(ii) > -1){
                if(isItems){
                    result.push(arr[ii]);
                    result.push(arr[ii]);
                }else{
                    if(arr[ii].length === 2){
                        result.push([arr[ii][0]]);
                        result.push([arr[ii][1]]);
                    }else{
                        result.push(arr[ii].slice(0,2));
                        result.push(arr[ii].slice(2));
                    }
                }
            }else{
                result.push(arr[ii]);
            }
        }
        return result;
    }

    Tooltip.prototype._getTextsAndStyles = function(){
        var data = this._data.data, semanticResult = this._semanticResult;
        if (data && data.length) {
            var nameStyle, valueStyle, style, key, tr, td;
            var dims = [],
                measures = [];
             
            for (var i = -1; ++i < data.length;) {
                if (data[i].type === "Dimension") {
                    var dataItem = data[i];
                    if (FiscalUtil.hasFiscalLevel(this._properties)) {
                        FiscalUtil.tooltipDataToDate(dataItem);
                    }
                    dims.push(dataItem);
                } else if (data[i].type === "Measure") {
                    measures.push(data[i]);
                } 
            }
            
            this._processTimeRange(dims);
            var dimTexts = [], dimStyles = [];
            var twoRowIndexes = [];
            for (i = 0; i < dims.length; ++i) {
                var isLastDimWithoutMsr = i === dims.length - 1 && measures.length === 0;
                if (isLastDimWithoutMsr) {
                    // padding bottom of last dimension or measure is zero
                    nameStyle = ObjectUtils.extend(true, {}, this._display.dimensionName);
                    nameStyle.paddingBottom = "0px";
                    valueStyle = ObjectUtils.extend(true, {}, this._display.dimensionValue);
                    valueStyle.paddingBottom = "0px";
                } else {
                    nameStyle = this._display.dimensionName;
                    valueStyle = this._display.dimensionValue;
                }
                this._getDimensionTextAndStyle(dimTexts, dimStyles, dims[i], isLastDimWithoutMsr);

                if(dims[i].drawAsTwoRow){
                    twoRowIndexes.push(i);
                }
            }

            if(twoRowIndexes.length > 0){
                //need to extend to two for day, time (e.g 00:00:00 2014.09.15)
                dims = extendTwoRow(dims, twoRowIndexes, true);
                dimTexts = extendTwoRow(dimTexts, twoRowIndexes);
                dimStyles = extendTwoRow(dimStyles, twoRowIndexes);
            }

            var msrTexts = [], msrStyles = [];
            for (i = -1; ++i < measures.length;) {
                nameStyle = ObjectUtils.extend(true, {}, this._display.measureName);
                valueStyle = ObjectUtils.extend(true, {}, this._display.measureValue);
                if (i === measures.length - 1) {
                    nameStyle.paddingBottom = "0px";
                    valueStyle.paddingBottom = "0px";
                } 
                //Meansure name
                if (this._defaultToolTipColors.measureName !== "") {
                    nameStyle.color = this._defaultToolTipColors.measureName;
                }
                //RTL
                if(this._isRTL){
                    nameStyle._float = "left";
                }

                var dataName;
                if(semanticResult && semanticResult.dataName) {
                    dataName = semanticResult.dataName[measures[i].id];
                }

                var nameText = handleNull(TypeUtils.isExist(dataName) ? dataName : measures[i].name) + ":";
                var valueText = handleNull(measures[i].value);

                if (this._defaultToolTipColors.measureValue !== "") {
                    valueStyle.color = this._defaultToolTipColors.measureValue;
                }

                msrTexts.push([nameText, valueText]);
                msrStyles.push([nameStyle, valueStyle]);
            }

            return {
                dimTexts: dimTexts,
                dimStyles: dimStyles,
                msrTexts: msrTexts,
                msrStyles:msrStyles,
                dims: dims,
                measures: measures
            };
        }
    };
    
    Tooltip.prototype._drawContent = function(parsedData) {
        var dimTexts = parsedData.dimTexts;
        var dimStyles = parsedData.dimStyles;
        var msrTexts = parsedData.msrTexts;
        var msrStyles = parsedData.msrStyles;
        var dims = parsedData.dims;
        var measures = parsedData.measures; 
        var maxWidth;

        var scrollContainer = this._mainDiv.append("div")
                      .attr("class","v-tooltip-mainDiv-scrollable-container");

        var table = scrollContainer.append("table")
                    .attr("class","v-tooltip-dimension-measure")
                    .style("border-collapse", "collapse");

        if(!this._isTextTooLong){
            this.drawToTable(table, dims, dimTexts, dimStyles, true);
            this.drawToTable(table, measures, msrTexts, msrStyles, false);
        }else{
            maxWidth = this._getMaxWidthForText();
            if (this.isActionMode()) { 
                if(this._isTextTooTall){
                    maxWidth -= this._getReservedSpaceForScrollbar();
                }
                this.drawLongTextToTable(maxWidth, table, dims, dimTexts, dimStyles, true);
                this.drawLongTextToTable(maxWidth, table, measures, msrTexts, msrStyles, false);
            }else{
                //hover mode
                this.drawLongTextToTable(maxWidth, table, dims, dimTexts, dimStyles, true);
                this.drawLongTextToTable(maxWidth, table, measures, msrTexts, msrStyles, false);
            }
        }

        //re-check
        if(this._isTextTooTall){
            var drawHeight = table.node().offsetHeight;
            this._isTextTooTall = drawHeight > this._getMaxHeight();
        }    
        //show scrollbar when height is too much 
        if(this._willHaveScrollbar()){
            var assignHeight = this._getMaxHeightForText();
            scrollContainer.style("height",  assignHeight + "px")
                    .style("overflow-y", "scroll");
        }

        //re-check
        if(this._isTextTooLong){
            var drawWidth = table.node().offsetWidth;
            this._isTextTooLong = drawWidth > maxWidth; 
        }
        if(this._isTextTooLong && !this.shouldShowFullText()){
            scrollContainer.style("width", this._getMaxWidthForText() + "px")
                           .style("overflow-x", "hidden");
        }

    };

    Tooltip.prototype.calculateLineNum = function(totalWidth, width){
        if(this._isRTL){
            return 1;
        }
        //more line wrapping, less truncation
        return this.isActionMode() && width > 0? Math.ceil(totalWidth/width) + 2 : 2;
    };

    Tooltip.prototype.measureWrappedText = function(text, style, maxWidth, isVal){
        var size = this.measure(text, style);
        var height;
        if(size.width < maxWidth ||  isVal){
            return size;
        }

        var lineNum = this.calculateLineNum(size.width, maxWidth);
        var wrapTexts = TextUtils.wrapText(text, [" "], maxWidth, lineNum, convertStyle(style));
        if(wrapTexts.lines.length === 1){
            return size;
        }else{
            var totalHeight = 0;
            var width = 0;
            wrapTexts.lines.forEach(function(e){
                var itemSize = this.measure(e, style);
                totalHeight += itemSize.height;
                width = Math.max(width, itemSize.width);
            }, this);
            height = totalHeight;

            return {
                height: height,
                width: width
            };
        }
    };

    Tooltip.prototype.shouldLayout = function(){
        return true;
    };

    Tooltip.prototype.measure = function(text, style){
        var textSize = TextUtils.fastMeasure(text, style.fontSize, style.fontWeight, style.fontFamily);
        var paddingBottom = style.paddingBottomNum || 0; 
        var paddingLeft = style.paddingLeftNum || 0;
        var DEFAULT_PADDING = 1; 
        textSize.height += paddingBottom + DEFAULT_PADDING;
        textSize.width += paddingLeft + DEFAULT_PADDING;
        return textSize;
    };

    //will measure text size    
    //decide which normal layout or long-text layout
    //decide to show scrollbar or not
    //will set variable this._isTextTooLong, this._isTextTooTall, padding-left
    Tooltip.prototype.layout = function(parsedData){
        var dimTexts = parsedData.dimTexts;
        var dimStyles = parsedData.dimStyles;
        var msrTexts = parsedData.msrTexts;
        var msrStyles = parsedData.msrStyles;
        var dims = parsedData.dims;
        var measures = parsedData.measures;  

        var texts = dimTexts.concat(msrTexts);
        var styles = dimStyles.concat(msrStyles);
        var items = dims.concat(measures);

        var maxWidth = this._getMaxWidthForText();
        var maxHeight = this._getMaxHeightForText();

        var maxNameWidth = 0;
        var maxValueWidth = 0;
        var ii, jj;
        var rowText;
        var rowStyle;
        var item;
        var width;
        var totalHeight = 0;
        var textFloat = this._isRTL? "right" : "left";

        var lastRow = texts.length;
        var lastCol = 0;
        var untruncatedTexts = [];
        var untruncatedStyles = [];

        var allowOmitItem = this.isInfoMode() && !this.shouldShowFullText();

        function checkHeight(tooltip){
            if(totalHeight  > maxHeight){
                tooltip._isTextTooTall = true;
                if(allowOmitItem){
                    //the remaining items will be abandoned, not need to measure
                    lastRow = ii;
                    return true;
                }
            }
            return false;
        }

        //measure and calculate space and assign to name and value texts
        //decide:
        //     this._isTextTooTall
        //     this._isTextTooLong
        //     totalHeight
        for(ii = 0; ii < texts.length; ii++){
            rowText = texts[ii];
            rowStyle = styles[ii];
            item = items[ii];
            if(rowText.length === 2){
                var nameSize = this.measure(rowText[0], rowStyle[0]);
                var valueSize = this.measure(rowText[1], rowStyle[1]);
                totalHeight += Math.max(nameSize.height, valueSize.height);

                if(checkHeight(this)){
                    break;
                }

                width = valueSize.width;
                maxNameWidth = Math.max(maxNameWidth, nameSize.width);
                maxValueWidth = Math.max(maxValueWidth, width);
                if(maxNameWidth + maxValueWidth > maxWidth){
                    this._isTextTooLong = true;
                }
            }else if(rowText.length === 1){
                var tempSize = this.measure(rowText[0], rowStyle[0]);
                totalHeight += tempSize.height;

                if(checkHeight(this)){
                    break;
                }
                
                width = tempSize.width;
                if(width > maxWidth){
                    this._isTextTooLong = true;
                }
            }

            if(isUntruncatableValue(item)){
                untruncatedTexts.push(rowText.length === 2? rowText[1]: rowText[0]);
                untruncatedStyles.push(rowStyle.length === 2? rowStyle[1]: rowStyle[0]);
            }
        }

        //adjust padding for long text
        if(this._isTextTooLong){
            for (ii = 0; ii < styles.length; ii++) {
                var row = styles[ii];
                for(jj = 0; jj < row.length; jj++){
                    var cell = row[jj];
                    cell.paddingLeft = "0px";
                    cell.paddingLeftNum = 0;
                    cell._float = textFloat;

                    if(ii === styles.length - 1 && jj === row.length - 1){
                        cell.paddingBottom = "0px";
                        cell.paddingBottomNum = 0;
                    }else{
                        cell.paddingBottom = DEFAULT_PADDING_BOTTOM;
                        cell.paddingBottomNum = DEFAULT_PADDING_BOTTOM_NUM;
                    }
                }
            }
        }   

        //this._maxUntruncatedTextWidth
        var addScrollbarSpace = false;
        function addScrollbar2UntruncatedWidth(tooltip){
            if(!addScrollbarSpace && tooltip._willHaveScrollbar() && tooltip._maxUntruncatedTextWidth > 0){
                tooltip._maxUntruncatedTextWidth += tooltip._getReservedSpaceForScrollbar();
                addScrollbarSpace = true;
            }
        }

        if(untruncatedTexts.length > 0){
            for(ii = 0; ii < untruncatedTexts.length; ii++){
                width = this.measure(untruncatedTexts[ii], untruncatedStyles[ii]).width;
                this._maxUntruncatedTextWidth = Math.max(this._maxUntruncatedTextWidth, width);
            }
            addScrollbar2UntruncatedWidth(this);
        }

        maxWidth = this._getMaxWidthForText();

        //decide this._isTextTooTall in long text layout
        //lastRow lastCol
        if((!this._isTextTooTall || allowOmitItem || this.shouldShowFullText()) && this._isTextTooLong){
            totalHeight = 0;
            var isOver = false;
            for(ii = 0; ii < lastRow && !isOver; ii++){
                rowText = texts[ii];
                rowStyle = styles[ii];
                item = items[ii];

                //length is 1 or 2
                for(jj = 0; jj < rowText.length; jj++){
                    var isVal = rowText.length === 2 && jj === 0? false :  isUntruncatableValue(item);
                    var rowSize = this.measureWrappedText(rowText[jj], rowStyle[jj], maxWidth, isVal);
                    totalHeight += rowSize.height;
                    if(this.shouldShowFullText()){
                        this._maxUntruncatedTextWidth = Math.max(this._maxUntruncatedTextWidth, rowSize.width);
                    }

                    if(totalHeight  > maxHeight){
                        this._isTextTooTall = true;
                        if(!this.shouldShowFullText()){
                            isOver = true;
                        }
                        if(allowOmitItem){
                            lastRow = ii;
                            lastCol = jj;
                            break;
                        }
                    }
                }
            }
        }  

        //abandon items
        if(this._isTextTooTall && allowOmitItem){
            texts = texts.slice(0, lastRow + 1);
            items = items.slice(0, lastRow + 1);
            styles = styles.slice(0, lastRow + 1);

            if(lastCol === 1){
                texts[lastRow][1] = "...";
                styles[lastRow][1]._float = textFloat;
            }else{
                texts[lastRow] = ["..."];
                styles[lastRow][0]._float = textFloat;
            }
            
            var len = dims.length;
            var totalLen = items.length;

            dimTexts = texts.slice(0, len);
            dimStyles = styles.slice(0, len);
            dims = items.slice(0, len);

            msrTexts = texts.slice(len);
            msrStyles = styles.slice(len);
            measures = items.slice(len);

            parsedData.dimTexts = dimTexts;
            parsedData.dimStyles = dimStyles;
            parsedData.msrTexts = msrTexts;
            parsedData.msrStyles = msrStyles;
            parsedData.dims = dims;
            parsedData.measures = measures;  
        }

        addScrollbar2UntruncatedWidth(this);
        
        return parsedData;
    };

    function renderIntoCell(style, text, tr, cls){
        var td = tr.append("td")
                .each(function () {
                    CSSUtils.setDOMStyle(this, convertStyle(style));
                })
                .text(text)
                .attr("class",  cls); 
        return td;
    }

    Tooltip.prototype.drawToTable = function(table, items, texts, styles, isDimension){
        for(var ii = 0; ii < texts.length; ii++){
            var rowText = texts[ii];
            var rowStyle = styles[ii];
            var tr = table.append("tr");
            var td, cls;
            var item = items[ii];

            if(rowText.length === 2){
                cls = isDimension? "v-body-dimension-label" : "v-body-measure-label";
                td = renderIntoCell(rowStyle[0], rowText[0], tr, cls);
                this._dimensionOrMeasureTitles.push(td);

                cls = isDimension? "v-body-dimension-value" : "v-body-measure-value";
                td = renderIntoCell(rowStyle[1], rowText[1], tr, cls);
            }else if(rowText.length === 1){
                cls = isDimension? "v-body-dimension-value" : "v-body-measure-value";
                td = renderIntoCell(rowStyle[0], rowText[0], tr, cls);

                if(item.bValueDate || item.bTimeRange){
                    td.attr("colspan", "2");
                }
            }

            if(item.bTimeRange){
                td.attr("align", "right");
            }
        }
    };

    function isUntruncatableValue(item){
        return item.type === "Measure" || item.bTimeRange || item.bValueDate;
    }

    Tooltip.prototype.renderLongTextIntoCell = function(text, style, isVal, cls, table, maxWidth){
        var textArray = [text];

        style = convertStyle(style);
        var textSize = this.measure(text, style).width;
        if (textSize > maxWidth && !isVal){
            var lineNum = this.calculateLineNum(textSize, maxWidth);
            var wrapResult = TextUtils.wrapText(text, [" "], maxWidth, lineNum, style);
            textArray = wrapResult.lines;
            //only allow truncation in the last row

            if(!this.shouldShowFullText()){
                var lastIndex = textArray.length - 1;
                textArray[lastIndex] =  TextUtils.ellipsis(textArray[lastIndex], null, maxWidth, style); 
            }
        }

        for(var ii = 0; ii < textArray.length; ii++){
            var tr = table.append("tr");
            var td = tr.append("td")
                .each(function () {
                    CSSUtils.setDOMStyle(this, style);
                })
                .text(textArray[ii])
                .attr("class",  cls);
        }
    };

    Tooltip.prototype.drawLongTextToTable = function(assignedWidth, table, items, texts, styles, isDimension){
        for(var ii = 0; ii < texts.length; ii++){
            var rowText = texts[ii];
            var rowStyle = styles[ii];
            var item = items[ii];
            var td, cls;

            if(rowText.length === 2){
                cls = isDimension? "v-body-dimension-label" : "v-body-measure-label";
                this.renderLongTextIntoCell(rowText[0], rowStyle[0], false, 
                                            cls, table, assignedWidth);
                this._dimensionOrMeasureTitles.push(td);

                cls = isDimension? "v-body-dimension-value" : "v-body-measure-value";
                this.renderLongTextIntoCell(rowText[1], rowStyle[1], isUntruncatableValue(item), 
                                            cls, table, assignedWidth);
                
            }else if(rowText.length === 1){
                cls = isDimension? "v-body-dimension-value" : "v-body-measure-value";
                this.renderLongTextIntoCell(rowText[0], rowStyle[0], isUntruncatableValue(item),
                                            cls, table, assignedWidth);
            }
        }
    };


    function convertStyle(inputStyle) {
        if(TypeUtils.isString(inputStyle)){
            return inputStyle;
        }

        var style = "";
        var table = {
            _float:"float", 
            color: "color",
            fontFamily: "font-family",
            fontSize: "font-size",
            fontWeight: "font-weight",
            whiteSpace: "white-space",
            textOverflow: "text-overflow",
            overflow: "overflow",
            paddingLeft: "padding-left",
            paddingBottom: "padding-bottom",
            marginTop: "margin-top",
        };

        for(var key in table){
            if(table.hasOwnProperty(key) && inputStyle[key]){
                style += table[key] + ":" + inputStyle[key] + ";";
            }
        }

        return style;
    }

    Tooltip.prototype._getStyle = function(inputStyle) {
        return convertStyle(inputStyle);
    };

    Tooltip.prototype.destroy = function() {
        this._extensionDiv = null;
        this._mainDiv = null;
        this._properties = null;
        this._display = null;
        this._defaultToolTipColors = null;
        this._data = null;
        this._semanticResult = null;    
    };

    Tooltip.prototype._updateTooltipColor = function() {
        var props = this._properties.get("tooltip");
        var defaultToolTipColors = this._defaultToolTipColors;
        defaultToolTipColors.backgroundColor = props.background.color;
        defaultToolTipColors.border = props.background.borderColor;
        
        if (props.bodyDimensionLabel && props.bodyDimensionLabel.color) {
            defaultToolTipColors.dimensionName = props.bodyDimensionLabel.color;     
        }
        if (props.bodyDimensionValue && props.bodyDimensionValue.color) {
            defaultToolTipColors.dimensionValue = props.bodyDimensionValue.color; 
        }
        if (props.bodyMeasureLabel && props.bodyMeasureLabel.color) {
            defaultToolTipColors.measureName = props.bodyMeasureLabel.color;
        }
        if (props.bodyMeasureValue && props.bodyMeasureValue.color) {
            defaultToolTipColors.measureValue = props.bodyMeasureValue.color; 
        }
        if (props.separationLine && props.separationLine.color) {
            defaultToolTipColors.separationLineSingleColor = props.separationLine.color;
        }
        if (props.footerLabel && props.footerLabel.color) {
            defaultToolTipColors.footerLabelColor = props.footerLabel.color;
        }
        if (props.closeButton && props.closeButton.backgroundColor) {
            defaultToolTipColors.closeButtonBackground = props.closeButton.backgroundColor;
        }
        if (props.closeButton && props.closeButton.borderColor) {
            defaultToolTipColors.closeButtonBorderColor = props.closeButton.borderColor;
        }
    };

    return Tooltip;
});

define('sap/viz/chart/behavior/config/TooltipClassMap',[
    "sap/viz/chart/behavior/config/tooltip/Tooltip",
], function(Tooltip) {

    var mapping = {"*": Tooltip};
    var mapFunction = {
        
    };
    mapFunction.register = function (chartTypes, handlerClass){
        for(var i = 0; i < chartTypes.length; ++i){
            mapping[chartTypes[i]] = handlerClass;
        }  
    };
    mapFunction.get = function (chartType){
        return mapping[chartType] || mapping["*"];
    };
    return mapFunction;
    
});

define('sap/viz/chart/behavior/config/handler/TooltipBehaviorHandler',[

    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/format/FormatManager',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/behavior/config/handler/TooltipTimerHandler",
    "sap/viz/chart/behavior/config/ContextualDataUtil",
    "sap/viz/chart/behavior/config/TooltipClassMap"
], function(
        DataGraphics, 
        Constants,
        DataUtils, 
        ObjectUtils, 
        TypeUtils, 
        FormatManager, 
        DataPointUtils,
        LangManager,
        DOM,
        TooltipTimerHandler,
        ContextualDataUtil,
        TooltipClassMap) {
    
    var MND_ID = "measureNames";
    var CONTEXT_ROW_NUMBER = "_context_row_number";
    var DIMENSION = "Dimension";
    var RANGE_SELECTION_IN_LASSO = "inLasso";
    var RANGE_SELECTION_IN_LASSOEND = "lassoEnd";

    function constructEventData(tooltipData, plotNodeBBox) {
        var evtData = {
            body: [],
            footer: [],
            point: tooltipData.position,
            selectedValues : tooltipData.selectedNumber
        };
        
        //plot area
        if (plotNodeBBox) {
            evtData.plotArea = plotNodeBBox;
        }
        //data
        var datum = tooltipData.data;
        if (datum && datum.length) {

            for (var i = -1; ++i < datum.length;) {
                var item = datum[i];
                if (item.type === "Measure") {
                    evtData.body.push({
                        name: item.name,
                        val: [{
                            value: item.value
                        }]
                    });
                } else if (item.type === "Dimension") {
                    evtData.footer.push({
                        label: {
                            val: item.name
                        },
                        value: {
                            val: item.value
                        }
                    });
                }
            }
            
        }
        return evtData;
    }
    
    function hideTooltip(tooltipModule, service){
        var hasDecoration = false;
        if (service.getProperties()) {
            var decorations = service.getProperties().get("interaction.decorations");
            if (TypeUtils.isArray(decorations)) {
                decorations.forEach(function(e) {
                    if (e.name === 'hideDetail') {
                        e.fn.call(this, service.getStatus('tooltipMode'));
                        hasDecoration = true;
                    }
                });
            }
        }
        if (!hasDecoration) {
            if(tooltipModule.isShown()){
                tooltipModule.hideTooltip();
                service.setStatus("tooltipMode", null);
                service.fireExternalEvent("hideTooltip", {
                    name: Constants.Event.TooltipHide.name
                });
            }
        }

    }

    //Sync with DataUtils.getDisplayText() if do some change
    function getText(context, key) {
        if (TypeUtils.isExist(context[key + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX])) {
            return context[key + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX];
        } else if (TypeUtils.isExist(context[key])) {
            return context[key];
        }
        return null;
    }

    function getRawText(context, key, hideNoValueLabel) {
        if (TypeUtils.isExist(context[key])) {
            return context[key];
        } else if (hideNoValueLabel === true && context[key] === undefined) {
            return undefined;
        }
        
        return null;
    }

    function getMetaDataByKey(key, bindingMetaData) {
        for (var fieldName in bindingMetaData) {
            if(bindingMetaData.hasOwnProperty(fieldName)){
                for (var j = 0; j < bindingMetaData[fieldName].length; ++j) {
                    var metaData = bindingMetaData[fieldName][j];
                    if (metaData.id === key) {
                        return metaData;
                    }
                }
            }
        }

        return null;
    }

    function getDisplayText(context, key) {
        if (TypeUtils.isExist(context[key + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX])) {
            return context[key + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX];
        }
        return null;
    }

    function getTimeDimensions(service, data){
        var timeAxis, timeDimensions;
        if (data) {
            timeDimensions = data.timeField;
        } else {
            timeAxis = service.getDataModel().timeAxis();
            timeDimensions = timeAxis.metaData.map(function(e) {
                return e.id;
            });
        }
        return timeDimensions;
    }
    

    var formatPercentageValue = d3.format(".2%");

    var TooltipBehaviorHandler = function() {};

    TooltipBehaviorHandler.processDateFormat = function(data, applyTimeAxisFormat, timeAxis){
        if(data.timeDimensions !== undefined){
            var indexes = data.timeDimensions;
            for(var i = 0; i < indexes.length; ++i){
                var item = data[indexes[i]];
                item.bValueDate = true;
                if(applyTimeAxisFormat){
                    item.timeAxis = timeAxis;
                }
            }
        }
    };


    TooltipBehaviorHandler.prototype = {
        
        /**
         * Only invoked in standalone mode.
         */
        standAloneInitialized: function(event, service) {
            service.getProperties().origin.add({
                tooltip : {
                    layinChart : true,
                    visible : true,
                    background : {
                        color : "#ffffff",
                        borderColor : "#cccccc"
                    },
                    bodyDimensionLabel : {
                        color : "#666666"
                    },
                    bodyDimensionValue : {
                        color : "#666666"
                    },
                    bodyMeasureLabel : {
                        color : "#666666"
                    },
                    bodyMeasureValue : { 
                        color : "#000000" 
                    }, 
                    closeButton : { 
                        backgroundColor : "#ffffff", 
                        borderColor : "#cccccc" 
                    }, 
                    footerLabel : { 
                        color : "#000000" 
                    }, 
                    separationLine : { 
                        color : "#a7a9ac" 
                    },
                    preRender : null,
                    postRender : null,
                    formatString : null,
                    unitFormatType : "FinancialUnits"
                }
            });
        },

        createTooltipInstance: function (service) {
            var tooltipClass = TooltipClassMap.get(service._getChartType());
            return new tooltipClass(service.getProperties());
        },
        
        initialized: function(event, service) {
            this._tooltipModule = this.createTooltipInstance(service);
            this._tooltipModule.onClose(function(){
                service.fireExternalEvent("hideTooltip", {
                    name: Constants.Event.TooltipHide.name
                });
            });
            service.setStatus("tooltipMode", null);

            this._createTooltipTimerHandler();
        },
        
        _createTooltipTimerHandler: function() {
            this._tooltipTimerHandler = new TooltipTimerHandler();
        },

        unloadedClear: function(event, service) {
            var tooltipModule = this._tooltipModule;
            if (tooltipModule) {
                hideTooltip.call(this, tooltipModule, service);
                tooltipModule.destroy();
            }
            delete this._tooltipModule;
            service.removeStatus("tooltipMode");
            this._tooltipTimerHandler.reset();
        },
        
        refreshedTooltip: function(event, service) {
            var tooltipModule = this._tooltipModule;
            if (!tooltipModule) {
                return;
            }

            hideTooltip.call(this, tooltipModule, service);
            this._tooltipTimerHandler.reset();
        },

        _getShowTooltipHandler: function(event, service) {
            function showTooltipHander() {
                var tooltipModule = this._tooltipModule;
                if (!tooltipModule) {
                    return;
                }

                var data = this._handleShowDetail(event, service);
                var mode = event.data.mode;
                service.setStatus("tooltipMode", mode);
                service.fireExternalEvent("showTooltip", {
                    name: Constants.Event.TooltipShow.name,
                    data: data.eventtData
                });
            }
            return showTooltipHander.bind(this);
        },

        _getHideTooltipHandler: function(event, service) {
            function hideTooltipHandler() {
                var tooltipModule = this._tooltipModule;
                if (!tooltipModule) {
                    return;
                }
                var mode = service.getStatus("tooltipMode");
                if (!mode || event.data.mode !== mode) {
                    return;
                }
                var decorations = service.getProperties().get("interaction.decorations");
                var hasDecoration = false;
                if (TypeUtils.isArray(decorations)) {
                    decorations.forEach(function(e) {
                        if (e.name === 'hideDetail') {
                            e.fn.call(this, event.data.mode);
                            hasDecoration = true;
                        }
                    });
                }
                hideTooltip.call(this, tooltipModule, service);
            }
            return hideTooltipHandler.bind(this);
        },

        showDetail: function(event, service) {
            var action = event.data.action;
            var showTooltipHander = this._getShowTooltipHandler(event, service);
            var hideTooltipHandler = this._getHideTooltipHandler(event, service);
            if (action) {
                this._tooltipTimerHandler.setShowTooltipHandler(showTooltipHander);
                this._tooltipTimerHandler.setHideTooltipHandler(hideTooltipHandler);
                this._tooltipTimerHandler.setMode(event.data.mode);
                this._tooltipTimerHandler[action](event.data.target);
            } else {
                //keep backward compatiability if necessary
                showTooltipHander();
            }
        },

        _handleShowDetail: function(event, service){
            var data, tooltipModule = this._tooltipModule;

            var applyTimeAxisFormat = service.getProperties().get("tooltip.applyTimeAxisFormat");  
            var formatString =  service.getProperties().get("tooltip.formatString");
            var id;
            var timeAxis = service.getModule("main.timeAxis");
            if(timeAxis){
                var dataModel = service.getDataModel();
                if(dataModel && dataModel._timeAxis){
                    id =  dataModel._timeAxis.metaData[0].id;  
                    applyTimeAxisFormat = applyTimeAxisFormat && 
                        !(TypeUtils.isExist(formatString) && TypeUtils.isExist(formatString[id]));
                }
            }
            
            if (event.data.target && !service.getStatus("rangeSelection")) {
                service.fireEvent("extractTooltipData", {
                    target: event.data.target
                });
                
                data = service.getStatus("tooltipData");
                TooltipBehaviorHandler.processDateFormat(data, applyTimeAxisFormat, timeAxis);
            }else if (service.getStatus("rangeSelection")){
                var range = service.getStatus("rangeDomain");
                var DEFAULT_FROM_WORD = "From";
                var DEFAULT_TO_WORD = "To";
                data = [
                    {id: id, name: LangManager.get("IDS_TIME_FROM") || DEFAULT_FROM_WORD, value: range[0],
                        type : DIMENSION, bTimeRange: true, timeAxis: applyTimeAxisFormat ? timeAxis : null},
                    {id:id,  name: LangManager.get("IDS_TIME_TO") || DEFAULT_TO_WORD, value: range[1],
                        type:  DIMENSION, bTimeRange: true,  timeAxis: applyTimeAxisFormat ? timeAxis : null}
                ];
                
                data.timeDimensions = [0,1];
                data.rangeSelectionStage = RANGE_SELECTION_IN_LASSO;
                if(event.data.bLassoEnd){
                    data.rangeSelectionStage = RANGE_SELECTION_IN_LASSOEND;
                }
            }

            var mode = event.data.mode;
            var tooltipData = {
                "data": data,
                "container": this._getTooltipContainer(service),
                "root": service.getRootContainer(),
                "mode": mode,
                "position": event.data.point,
                "isAnchored": !!event.data.isAnchored,
                "forceStyle": event.data.forceStyle
            };

            //tooltip.showTooltip would change data in tooltipdata when formatting.
            //evtData should be constructed in advance.
            if(!data || data.rangeSelectionStage !== RANGE_SELECTION_IN_LASSO){
                tooltipData["selectedNumber"] = service.getStatus("selectedDataPoints").length;
            }
            var evtData = constructEventData(tooltipData, service.getBBox(service.BoxType.PLOT_NODE));
            var decorations = service.getProperties().get("interaction.decorations");
            var hasDecoration = false;
            if (TypeUtils.isArray(decorations)) {
                decorations.forEach(function(e) {
                    if (e.name === 'showDetail') {
                        e.fn.call(this, ObjectUtils.extend(true, {}, tooltipData));
                        hasDecoration = true;
                    }
                });
            }
            if (!hasDecoration) {
                this._processDecoration(tooltipModule, tooltipData, service, event.data.target);
            }
            return {
                eventtData : evtData,
                tooltipData : tooltipData
            };
        },

        _processDecoration : function(tooltipModule, tooltipData, service, target){
            var semanticMgr = service ? service.getSemanticManager() : null, result;
            try {
                result = semanticMgr ? 
                   semanticMgr.analyzeDataPoint('color,lineColor,lineType,pattern', 
                      DataPointUtils.getContext(target), true, DataPointUtils.getAdditionCtx(target) || {}): null;
            }
            catch(e) {
                result = null;
            }
            var envMgr = service ? service.getEnvManager() : null;
            var isRTL = false;
            if (envMgr) {
                isRTL = envMgr.isRTL();
            }
            tooltipModule.showTooltip(tooltipData, result, isRTL, service);
        },

        _getTooltipContainer : function(service) {
            return service.getTooltipContainer();
        },
        
        hideDetail: function(event, service) {
            var action = event.data.action;
            var hideTooltipHandler = this._getHideTooltipHandler(event, service);
            if (action) {
                this._tooltipTimerHandler.setHideTooltipHandler(hideTooltipHandler);
                this._tooltipTimerHandler[action](event.data.target);
            } else {
                //keep backward compatiability if necessary
                hideTooltipHandler();
            }
        },
        showTooltipHoverOnPlot: function(event, service) {
            service.fireEvent("showDetail", event.data);
        },
        hideTooltipHoverOnPlot: function(event, service) {
            service.fireEvent("hideDetail", event.data);
        },
        showTooltipClickBigData: function(event, service) {
            event.data.action = "select";
            service.fireEvent("showDetail", event.data);
        },
        hideTooltipClickBigData: function(event, service) {
            event.data.action = "deselect";
            service.fireEvent("hideDetail", event.data);
        },
        extractTooltipData: function(event, service) {
            var dataModel = service.getDataModel();
            var bindingMetaData = dataModel.getBindingMetaData();
            var hideNoValueLabel = service.getProperties().get("general.hideNoValueLabel");
            var target = event.data.target,
            data,
            dims = [],
            meas = [],
            dimContexts = [],
            msrContexts = [];
            
            if (target.context) {
                data = target.context;
            } else if (TypeUtils.isString(target) || TypeUtils.isNumber(target)) { // if target is a dp id.
                data = dataModel.getDataPoint(target).context();
            } else { // if target is a node, call DataPointUtils.getContextByDataModel,
                data = DataPointUtils.getContextByDataModel(target, dataModel);
            }
            
            function getMetaDataByKey(key) {
                for (var fieldName in bindingMetaData) {
                    if(bindingMetaData.hasOwnProperty(fieldName)){
                        for (var j = 0; j < bindingMetaData[fieldName].length; ++j) {
                            var metaData = bindingMetaData[fieldName][j];
                            if (metaData.id === key) {
                                return metaData;
                            }
                        }
                    }
                }
    
                return null;
            }
            var dcMetas = dataModel.context() && dataModel.context().metaData;
            function getContextMetaByKey(key){
                for(var i = 0; dcMetas && i < dcMetas.length; ++i){
                    if(dcMetas[i].id === key){
                        return dcMetas[i];
                    }
                }
                return null;
            }

            var units = service._statusMgr.get("data.unit");
            var strValue;
            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    strValue = null;
                    if (key === MND_ID) {
                        continue;
                    }
                    var fieldMeta = getMetaDataByKey(key) || {};
                    var arr = null, type, semanticType = fieldMeta.type, value;
                    type = semanticType;
                    if (semanticType === "Dimension") {
                        arr = dims;
                        // use display name first
                        value = getText(data, key);
                    } else if (semanticType === "Measure" || key === CONTEXT_ROW_NUMBER) {
                        arr = meas;
                        value = (data[key] == null ? data[key] : +data[key]);
                        if (semanticType === "Measure" && typeof(data[key]) === 'string'){
                            strValue = data[key];
                        }
                    }else{
                        fieldMeta = getContextMetaByKey(key) || {};
                        if(!fieldMeta.showInTooltip){
                            continue;
                        }
                        type = fieldMeta.type;
                        if(type === "Dimension" ){
                            arr = dimContexts;
                        }else{
                            arr = msrContexts;
                        }
                        value = getText(data, key);
                    }

                    var nameToShow = this.decorateFieldName((fieldMeta.name || key), key, dataModel, target,
                        service.getProperties());
                    var obj = {
                        "id": key,
                        "name": nameToShow,
                        "value": value,
                        "strValue": strValue,
                        "type": type,
                        "formatString" : fieldMeta.formatString
                    };
                    if (TypeUtils.isExist(getDisplayText(data, key))) {
                        obj["value" + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX] = getDisplayText(data, key);
                        obj["value" + DataUtils.DIMENSION_VALUE_SUFFIX] = getRawText(data, key, hideNoValueLabel);
                    }
                    if (units[obj.id]) {
                        obj.unit = units[obj.id];
                    }
                    if (arr) {
                        arr.push(obj);
                    }
                }
            }
            service.setStatus("tooltipData", dims.concat(dimContexts).concat(meas).concat(msrContexts));
        },

        decorateFieldName: function (name, key, dataModel, target, props) {
            return name;
        },

        extractTooltipDataPie: function(event, service) {
            service.fireEvent(event, true);
            var measureType = service.getProperties().get('tooltip.bodyMeasureValue.type');
            var res = service.getStatus("tooltipData");
            res.forEach(function(e) {
                if (e.type === "Measure" && event.data.target instanceof SVGElement) {
                    var percentage = DataGraphics.getData(event.data.target).percentage;
                    //special handle for trellis_pie and trellis_donut
                    //borrow from PieDataLabels.js
                    if(TypeUtils.isNaN(percentage)){
                        var pathData = d3.select(event.data.target.childNodes[0]).datum();
                        percentage = (pathData.endAngle - pathData.startAngle) / (2 * Math.PI);
                    }
                    
                    e.bothValue = {
                        value: e.strValue ? e.strValue: e.value,
                        percentage: percentage,
                        primaryKey: (measureType === "percentage") ? "percentage" : "value"
                    };
                }
            });
            service.setStatus("tooltipData", res); 
        },
        
        extractTooltipDataPercentage: function(event, service) {
            service.fireEvent(event, true);
            var res = service.getStatus("tooltipData");
            res.forEach(function(e) {
                if (e.type === "Measure" && event.data.target instanceof SVGElement) {
                    e.value = DataGraphics.getData(event.data.target).percentageValue;
                    var context = DataGraphics.getContext(event.data.target);
                    e.bothValue = {
                        value: context[context.measureNames],
                        percentage: e.value,
                        primaryKey: "percentage"
                    };
                }
            });
            service.setStatus("tooltipData", res);
        },
        
        extractTooltipDataTimebubble: function(event, service) {
            service.fireEvent(event, true);
            var res = service.getStatus("tooltipData");
            res.timeMeasure = 0;
            service.setStatus("tooltipData", res);
        },
        extractTooltipDataPercentageMekko: function(event, service) {
            service.fireEvent(event, true);
            var res = service.getStatus("tooltipData");
            var bindingMetaData = service.getDataModel().getBindingMetaData();
            var measureName;
            if(bindingMetaData){
                measureName = bindingMetaData.valueAxis[0]? bindingMetaData.valueAxis[0].id : undefined;
            }

            res.forEach(function(e) {
                if (e.type === "Measure" && e.id===measureName) {
                    e.value = DataGraphics.getData(event.data.target).percentageValue;
                    var context = DataGraphics.getContext(event.data.target);
                    e.bothValue = {
                        value:context[context.measureNames],                      
                        percentage:  e.value,
                        primaryKey: "percentage"
                    };

                    //set the tooltip format of percentage measure always to be "0.00%"
                    e.value = formatPercentageValue(e.value);
                }
            });
            service.setStatus("tooltipData", res);
        },

        extractTooltipDataTimeStackedColumnPercentage: function(event, service) {
            service.fireEvent(event, true);
            var res = service.getStatus("tooltipData");
            var target = event.data.target;
            var data = DataGraphics.getData(target);
            var timeDimensions = getTimeDimensions(service, data);
            var context, indexes = [];
            res.forEach(function(e, i) {
                if (timeDimensions.indexOf(e.id) >= 0) {
                    indexes.push(i);
                }
                if (e.type === "Measure") {
                    e.value = data.percentageValue;
                    context = DataGraphics.getContext(target);
                    e.bothValue = {
                        value: context[context.measureNames],
                        percentage: e.value,
                        primaryKey: "percentage"
                    };
                }
            });
            res.timeDimensions = indexes;

            service.setStatus("tooltipData", res);
        },

        extractTooltipDataTimeWaterfall: function(event, service) {
            service.fireEvent(event, true);
            var dataModel = service.getDataModel();
            var bindingMetaData = dataModel.getBindingMetaData();
            var res = service.getStatus("tooltipData");
            var data = DataGraphics.getData(event.data.target);
            var indexes = [], tooltipData = [], dimensions = [], formatString;
            
            var timeDimensions = getTimeDimensions(service, data);
            var selectByTimeAxisGroup = service.getProperties().get("interaction.selectByTimeAxisGroup");
            for (var i = 0; i < res.length; ++i){
                if (timeDimensions.indexOf(res[i].id) >= 0){
                    indexes.push(i);
                    if(selectByTimeAxisGroup) {
                        tooltipData.push(res[i]);
                    }
                }else if(res[i].type === 'Dimension'){
                    if(selectByTimeAxisGroup) {
                        dimensions.push(res[i].id);
                    }
                }else if(res[i].type === 'Measure') {
                    if(selectByTimeAxisGroup) {
                        formatString = res[i].formatString;
                    }
                }
            }
            res.timeDimensions = indexes;

            var unit = service._statusMgr.get("data.unit"), recapUnit = [];

            if(selectByTimeAxisGroup) {
                var recapTitle = service.getProperties().get("plotArea.dataLabel.recapTitle") ||
                    LangManager.get("IDS_END_OF_PERIOD");
                var dps = ContextualDataUtil.getDataPointsByTimeField(event.data.target, service);
                if(dps){
                    dps.forEach(function(dp){
                        var context = DataGraphics.getContext(dp);
                        var fieldMeta = getMetaDataByKey(context.measureNames, bindingMetaData);
                        var recap = DataGraphics.getData(dp).recap;
                        var name = '', value = context[context.measureNames];
                        dimensions.forEach(function(dim){
                            name += (context[dim + '.d'] || context[dim] || LangManager.get("IDS_ISNOVALUE")) + ' / ';
                        });
                        name += fieldMeta.name || fieldMeta.id;
                        tooltipData.push({
                            formatString: formatString,
                            id: context.measureNames,
                            name: name,
                            type: 'Measure',
                            value: value,
                            color: DataGraphics.getData(dp).color,
                            unit: unit[context.measureNames]
                        });
                        if(recap) {
                            var valueAxisMetaData = service.getDataModel().valueAxis().metaData[0];
                            tooltipData.push({
                                formatString: valueAxisMetaData.formatString,
                                id: valueAxisMetaData.id,
                                name: recapTitle,
                                type: 'Measure',
                                value: recap.value,
                                unit: unit[valueAxisMetaData.id]
                            });
                        }
                    });    
                }

                tooltipData.timeDimensions = indexes;
                res = tooltipData;
            }

            service.setStatus("tooltipData", res);
        },

        extractTooltipDataTimeLine: function(event, service) {
            service.fireEvent(event, true);
            var res = service.getStatus("tooltipData");
            var data = DataGraphics.getData(event.data.target);
            var timeDimensions = getTimeDimensions(service, data);
            var indexes = [];
            for (var i = 0; i < res.length; ++i){
                if (timeDimensions.indexOf(res[i].id) >= 0){
                    indexes.push(i);
                }
            }
            res.timeDimensions = indexes;

            service.setStatus("tooltipData", res);
        },
        
        extractTooltipDataWaterfall: function(event, service) {
            service.fireEvent(event, true);
            var res = service.getStatus("tooltipData");
            res = res.filter(function(e) {
                //The type (subtotal, total, null) can be seen from color.
                //So it is redundant to show "Type" item on tooltip.
                var dataModel = service.getDataModel();
                var metaData = dataModel.waterfallType() ? dataModel.waterfallType().metaData : undefined;
                var wtfTypeDimensionName = metaData && metaData[0] ? metaData[0].id : undefined;
                return e.id !== wtfTypeDimensionName;
            });
            service.setStatus("tooltipData", res);
        },
        
        extractTooltipDataCombination: function(event, service) {
            service.fireEvent(event, true);
            var hideNoValueLabel = service.getProperties().get("general.hideNoValueLabel");
            if (!hideNoValueLabel) {
                return;
            }
            var res = service.getStatus("tooltipData");
            res = res.filter(function(e) {
                if (e.hasOwnProperty("value" + DataUtils.DIMENSION_VALUE_SUFFIX) && 
                    e["value" + DataUtils.DIMENSION_VALUE_SUFFIX] === undefined) {
                    return false;        
                }
                return true;
            });
            service.setStatus("tooltipData", res);
        },
        extractTooltipDataComboEx: function(event, service) {
            this.extractTooltipDataCombination(event, service);
            var res = service.getStatus("tooltipData");

            var dpNode = event.data.target;
            if (!DOM.hasClass(dpNode, "v-datapoint")) {
                dpNode = [].filter.call(service.getNodes(service.NodeType.DATA_POINT, false), function(node) {
                    return node.getAttribute("data-id") === event.data.target.getAttribute("data-id");
                })[0];
            }
            Object.defineProperty(res, "seriesType", {
                enumerable: false,
                value: DataGraphics.getData(dpNode).seriesType
            });
            service.setStatus("tooltipData", res);
        }
    };
    
    return TooltipBehaviorHandler;
});

define('sap/viz/chart/behavior/config/handler/RuntimeSelectionHelperHandler',[ 
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/behavior/config/SelectionUtil",
    'sap/viz/framework/chartmodel/DataSelector',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/Constants", 
    'sap/viz/framework/interaction/Constants',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/behavior/config/tooltip/TooltipUtils',
    'sap/viz/chart/behavior/config/handler/TooltipBehaviorHandler',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/lang/LangManager'
], function( 
    HighlightHelper,
    SelectionUtil, 
    DataSelector,
    DataPointUtils,
    Constants, 
    SDKConstants,
    DataUtils,
    ObjectUtils,
    TypeUtils,
    TooltipUtils,
    TooltipBehaviorHandler,
    DataGraphics,
    LangManager
    ) {

    var SELECTION_MODE = SDKConstants.SELECTION_MODE;
    var DP_LAYER = "datapoint";
    var MND_ID = "measureNames";
    var CONTEXT_ROW_NUMBER = "_context_row_number";
    var DIMENSION = "Dimension";
    var MEASURE = "Measure";
    var TIMEAXIS = "timeAxis";
    var COLOR = "color";
    var WATERFALL_TYPE = "waterfallType";
    var PERCENTAGE = "percentage";

    var syncAllLegendItems = function (service) {
        if (!service.isTrellis() && service.getProperties().get("legend.selectionFeedback")) {
            service.fireEvent("syncSelectedLegendItems");
            service.fireEvent("syncSelectedMBCLegendItems");
        }
    };

    var Handler = function() {

    };

    Handler.prototype.initializedClearSelection = function(event, service) {
        service.setStatus("selectedDataPoints", []);
    };

    Handler.prototype.unloadedClearSelection = function(event, service) {
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        if (selectedDataPoints && selectedDataPoints.length) {
            service.fireEvent("clearPlot", {
                isGray : false
            });
        }
        service.removeStatus("selectedDataPoints");
    };

    Handler.prototype.refreshedKeepSelection = function(event, service) {
        var tempSelectionMode = service.getProperties().get("interaction.selectability.mode");
        // Not every chart support property interaction.selectability.mode, need verify it first.
        var selectionMode = tempSelectionMode ? tempSelectionMode.toUpperCase(): tempSelectionMode;
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        var inRange = service.getStatus("rangeSelection") && service.getStatus("rangeDomain");
        var needClear = false;
        if (!service.getStatusManager().get("interaction.holdSelection") ||
                selectionMode === SELECTION_MODE.NONE ||  
                selectionMode === SELECTION_MODE.SINGLE) {
            // In range selection case, no data point selected, but we need clear plot too
            
            if(selectedDataPoints.length || inRange){
                service.fireEvent("clearPlot", {
                    isGray : false
                });
                if(inRange){
                    service.removeStatus("rangeDomain");
                    service.removeStatus("rangeSelection");
                }
            }

            service.setStatus("selectedDataPoints", []);
            needClear = true;
        } else if (selectedDataPoints.length) {
            service.fireEvent("clearPlot", {
                isGray: !inRange,
                rangeSelection: inRange
            }).fireEvent("selectDataPoint", {
                targets: this._getNodes(selectedDataPoints, service),
                disableAnimation: true
            }).setStatus("selectedDataPoints", selectedDataPoints);
        }
        syncAllLegendItems(service);
        return needClear;
    };
    
    Handler.prototype.reRenderKeepSelection = function(event, service) {
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        var hoveringDataPoint = service.getStatus("hoveringDataPoint");
        
        var inRange = service.getStatus("rangeSelection") && service.getStatus("rangeDomain");
        if (selectedDataPoints.length) {
            var targets = this._getNodes(selectedDataPoints, service);
            service.fireEvent("clearPlot", {
                isGray: !inRange,
                rangeSelection: inRange
            }).fireEvent("selectDataPoint", {
                targets: targets,
                disableAnimation: true
            }).setStatus("selectedDataPoints", selectedDataPoints);
        }
        if (hoveringDataPoint) {
            service.fireEvent("hoverOnDataPoint", {
                targets: hoveringDataPoint
            });
        }
        if(inRange){
            service.fireEvent("rangeRecover");
            
        }
        if (service.getStatus("hoveringOnPlotEvent")){
            service.fireEvent(service.getStatus("hoveringOnPlotEvent"));
        }
        var actionLayer = service._getDecorationLayer();
        actionLayer.clear(DP_LAYER);
    };

    Handler.prototype.deselectAll = function(event, service) {
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        service.fireEvent("clearPlot").fireEvent("deselectDataPoint", {
            targets : this._getNodes(selectedDataPoints, service),
            isAnyOtherSelected : false
        }).fireEvent("hideDetail", {
            mode : "actionMode"
        }).setStatus("selectedDataPoints", []);
        //sync legend items
        syncAllLegendItems(service);

        if (selectedDataPoints && selectedDataPoints.length) {
            service.fireEvent("dispatchDataEvent", {
                targets : selectedDataPoints,
                isSelected : false
            });
        }

        if (service.getProperties().get("interaction.enableInternalEvents")) {
            service.fireExternalEvent("_selectionDetails", {
                'name': '_selectionDetails',
                'data': []   
            });
        }
        
    };

    Handler.prototype.processMultipleSelectionTooltip = function(event, service) {
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        if (selectedDataPoints.length && SelectionUtil.hasDataPoint(selectedDataPoints, event.data.targets[0])) {
            service.fireEvent("showDetail", {
                target : null,
                mode : "actionMode",
                point : event.data.point,
                forceStyle: event.data.forceStyle,
                isAnchored : event.data.isAnchored
            });
        } else {
            service.fireEvent("hideDetail", {
                mode : "actionMode"
            });
        }
    };

    var selectionModes = {};
    selectionModes[SELECTION_MODE.SINGLE] = 1;
    selectionModes[SELECTION_MODE.MULTIPLE] = 1;
    selectionModes[SELECTION_MODE.EXCLUSIVE] = 1;
    selectionModes[SELECTION_MODE.INCLUSIVE] = 1;

    var SELECTION_DETAIL_KEYS = ['id', 'label', 'value', 'type', 'unit', 'unbound'];
    Handler.prototype.processSelection = function(event, service) {
        var lastSelected = service.getStatus("selectedDataPoints");
        if (!lastSelected) {
            return;
        }
        if (!lastSelected.length) {
            // For range selection we should keep range rect, so we add bKeepRange to do this
            service.fireEvent("clearPlot", {
                isGray : !service.getStatus("rangeSelection"),
                rangeSelection: service.getStatus("rangeSelection")
            });
        }

        var config = event.data;
        var mode = String(config.mode).toUpperCase();
        var targets = HighlightHelper.turnToArray(config.targets);
        var pureLastSelection = [];
        var pureNewSelection = [];
        var interSelection = [];
        var dataMap = {};
        var i, len;

        if (!selectionModes[mode]) {
            var tempMode = service.getProperties().get("interaction.selectability.mode");
            mode = tempMode ? String(tempMode).toUpperCase() : tempMode;
        }

        var tempSelectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        var currentSelectionBehavior = tempSelectionBehavior ? tempSelectionBehavior.toUpperCase()
         : tempSelectionBehavior;
        var selectByTimeAxisGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');

        // handle the single mode
        if (!selectByTimeAxisGroup && mode === SELECTION_MODE.SINGLE && 
            currentSelectionBehavior === SDKConstants.SELECTION_BEHAVIOR.DATAPOINT) {
            targets = [targets[0]];
        }

        // prepare pureNew, inter and pureLast selections
        for (i = targets.length; i--;){
            dataMap[targets[i]] = 1;
        }
        for (i = 0, len = lastSelected.length; i < len; ++i) {
            var item = lastSelected[i];
            if (dataMap[item]) {
                interSelection.push(item);
                // mark 2 to indicate this item belongs to inter selection
                dataMap[item] = 2;
            } else {
                pureLastSelection.push(item);
            }
        }
        for (i = 0, len = targets.length; i < len; ++i) {
            if (dataMap[targets[i]] === 1) {
                pureNewSelection.push(targets[i]);
            }
        }

        // calc what to select and what to deselect
        var allSelection = pureNewSelection.concat(lastSelected);
        var ctrlKey = config.ctrlKeyPressed;
        var currentSelected = [];
        var deselectDatas = [];
        var isDeselect = false;

        if(config.deselection === true){
            //For Selection API to do deselection
            currentSelected = pureLastSelection;
            deselectDatas = interSelection;
            isDeselect = true;
        } else {
            if (mode === SELECTION_MODE.SINGLE) {
                if (currentSelectionBehavior === SDKConstants.SELECTION_BEHAVIOR.CATEGORY &&
                    interSelection.length && lastSelected.length !== targets.length) {
                    //For category, support selection between different hierarchical category layer
                    currentSelected = targets;
                    deselectDatas = pureLastSelection;
                } else {
                    if (interSelection.length && lastSelected.length === targets.length) {
                        isDeselect = true;
                    }
                    currentSelected = pureNewSelection;
                    deselectDatas = lastSelected;
                }

            } else if(!ctrlKey && mode === SELECTION_MODE.EXCLUSIVE) {
                currentSelected = targets;
                deselectDatas = pureLastSelection;

            } else if(!ctrlKey && mode === SELECTION_MODE.INCLUSIVE) {
                currentSelected = allSelection;

            } else if(ctrlKey || mode === SELECTION_MODE.MULTIPLE) {

                if (!config.deselectable || pureNewSelection.length) {
                    currentSelected = allSelection;

                } else {
                    currentSelected = pureLastSelection;
                    deselectDatas = interSelection;
                    isDeselect = true;
                }
            }
        }

        this._fireEventForProcessSelection(service, deselectDatas, currentSelected, pureNewSelection,
            config.fireEvents);


        // save selection
        service.setStatus("selectedDataPoints", currentSelected);

        //sync legend items
        syncAllLegendItems(service);

        // fire _selectionDetails
        if (service.getProperties().get("interaction.enableInternalEvents")) {
            this._fireSelectionDetails(service, currentSelected, selectByTimeAxisGroup);
        }

        var ret = {
            isDeselect: isDeselect,
            ctrlKey: ctrlKey
        };

        return ret;
    };

    Handler.prototype.processHighlight = function (event, service) {
        if (!service.isTrellis() && !service.isDisableSyncHightlight()) {
            if (service.isBigDataMode()) {
                //for big data model, we need to use selection-like effect
                //clearplot handling should like selection
                var lastSelected = service.getStatus("selectedDataPoints");
                if (!lastSelected.length) {
                    // For range selection we should keep range rect, so we add bKeepRange to do this
                    service.fireEvent("clearPlot", {
                        isGray: !service.getStatus("rangeSelection"),
                        rangeSelection: service.getStatus("rangeSelection")
                    });
                }
            }
            var highlighted = HighlightHelper.turnToArray(event.data.targets);
            if (highlighted && highlighted.length > 0) {
                service.fireEvent("hoverOnDataPoint", {
                    targets: this._getNodes(highlighted, service)
                });
                service.setStatus("highlightedDataPoints", highlighted);
            }
        }
    };

    Handler.prototype.processUnhighlight = function (event, service) {
        service.fireEvent("cleanAxisHoverEffect");
        service.fireEvent("cleanLegendHoverEffect");
        service.fireEvent("cleanMBCHoverEffect");
        if (!service.isTrellis() && !service.isDisableSyncHightlight()) {
            if (service.isBigDataMode()) {
                var lastSelected = service.getStatus("selectedDataPoints");
                if (!lastSelected.length) {
                    service.fireEvent("clearPlot");
                }
            }
            var lastHighlighted = service.getStatus("highlightedDataPoints");
            if (lastHighlighted && lastHighlighted.length > 0) {
                if (lastHighlighted && lastHighlighted.length) {
                    service.fireEvent("unhoverOnDataPoint", {
                        targets: this._getNodes(lastHighlighted, service)
                    });
                }
                service.setStatus("highlightedDataPoints", []);
            }
        }
    };

    Handler.prototype._fireSelectionDetails = function(service, currentSelected, selectByTimeAxisGroup) {
        var getMetaDataByKey = function (metaData, key){
            for(var i = 0; metaData && i < metaData.length; ++i){
                if(metaData[i].id === key){
                    return metaData[i];
                }
            }
            return null;
        };
        var getMetaDataRoleByKey = function(metaData, key) {
            for (var role in metaData) {
                if (metaData.hasOwnProperty(role)) {
                    var md = getMetaDataByKey(metaData[role], key);
                    if(md) {
                        return {
                            role : role,
                            metaData : md
                        };
                    }
                }
            }
            return null;
        };

        var dataModel = service.getDataModel();
        var bindingMetaData = dataModel && dataModel.getBindingMetaData();
        var ctxMetaData = dataModel && dataModel.context() && dataModel.context().metaData;
        var units = service.getStatusManager().get("data.unit");
        var semanticMgr = service.getSemanticManager();

        var recapTitle;
        if (selectByTimeAxisGroup) {
            recapTitle = service.getProperties().get("plotArea.dataLabel.recapTitle") ||
                LangManager.get("IDS_END_OF_PERIOD");
        }

        var that = this;
        var selectionDetails = currentSelected.map(function(selectedDataPointId) {
            var dp = dataModel && dataModel.getDataPoint(selectedDataPointId);
            if (!dp) {
                return {
                    'data': null,
                    'displayData': []
                };
            }

            var data = ObjectUtils.clone(dp.context());
            var result = semanticMgr.analyzeDataPoint('color,lineColor,lineType,pattern', 
                data, true, dp.additionCtx());
            var dataName = result && result.dataName || {};
            var measureName = data[MND_ID];

            delete data[MND_ID];

            var timeDims = [], colorDims = [], dims = [], measures = [], dimCtxs = [], measureCtxs = [];
            for (var key in data) {
                if (data.hasOwnProperty(key) && key !== CONTEXT_ROW_NUMBER) {
                    var fieldMeta = getMetaDataRoleByKey(bindingMetaData, key) || {'metaData': {}};
                    var arr = null, role = fieldMeta.role, value, valueD, unbound = false, bothVal = null,
                        type = fieldMeta.metaData.type, name = fieldMeta.metaData.name;
                    if (type === DIMENSION) {
                        if (role === WATERFALL_TYPE) {
                            continue;
                        }
                        else if (role === TIMEAXIS) {
                            arr = timeDims;
                            valueD = data[key + DataUtils.DIMENSION_PARSED_VALUE_SUFFIX];
                            value = data[key];
                        } else {
                            if (role === COLOR){
                                arr = colorDims;
                            } else {
                                arr = dims;
                            }
                            value = data[key + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX] || data[key];
                        }
                    } else if (type === MEASURE) {
                        arr = measures;
                        value = data[key];
                        data[key] = (value == null? value : +value);
                        if (key === measureName && data.hasOwnProperty(PERCENTAGE)) {
                            bothVal = {
                                value : value,
                                percentage : data[PERCENTAGE]
                            };
                        }
                    } else {
                        fieldMeta = getMetaDataByKey(ctxMetaData, key) || {};
                        name = fieldMeta.name;
                        if(!fieldMeta.showInTooltip){
                            continue;
                        }
                        unbound = true;
                        type = fieldMeta.type;
                        if(type === DIMENSION){
                            arr = dimCtxs;
                            value = data[key + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX] || data[key];
                        }else{
                            arr = measureCtxs;
                            value = data[key];
                        }
                    }

                    if (arr) {
                        arr.push({
                            "id": key,
                            "label": dataName[key] || name || key,
                            "value": value,
                            "value.d": valueD,
                            "type": type,
                            "formatString": fieldMeta.formatString,
                            'unit': units[key],
                            'unbound': unbound,
                            'bothValue': bothVal
                        });
                    }
                }
            }
    
            var extraData, plot = service.getModule("main.plot");
            if (service.isBigDataMode()) {
                extraData = plot.mappingDataPointInfo(selectedDataPointId).graphic;
            } else {
                //Get data point's extra data infomation
                if (plot) {
                    var seriesIndex = plot.getSeriesIndex(dp);
                    var categoryIndex = dp.address(dp.addressType.CATEGORY);
                    var series = plot.getSeries();
                    if (series && series[seriesIndex]) {
                        var dataPoints = series[seriesIndex].getDataPoints();
                        if (dataPoints && dataPoints[categoryIndex]) {
                            extraData = dataPoints[categoryIndex].getData();
                        }
                        if (!extraData) {
                            var dataPointInfo;
                            for (var i = 0; i < dataPoints.length; i++) {
                                dataPointInfo = dataPoints[i];
                                if (dataPointInfo && dataPointInfo.getData && dataPointInfo.getData()) {
                                    extraData = dataPointInfo.getData();
                                    break;
                                }
                            }
                        }
                    }
                }
                if (!extraData) {
                    //Default
                    var datapoint = that._getNodes([selectedDataPointId], service)[0];
                    if (datapoint) {
                        //visible data point
                        extraData = DataGraphics.getData(datapoint);
                    }
                }
            }

            if (selectByTimeAxisGroup) {
                var recap = extraData.recap;
                if (recap) {
                    var valueAxisMetaData = service.getDataModel().valueAxis().metaData[0];
                    measures.push({
                        "id": valueAxisMetaData.id,
                        "label": recapTitle,
                        "value": recap.value,
                        "value.d": recap.value,
                        "type": MEASURE,
                        "formatString": valueAxisMetaData.formatString,
                        'unit': units[valueAxisMetaData.id],
                        'unbound': false
                    });
                }
            }

            var allData = timeDims.concat(colorDims).concat(dims).concat(dimCtxs)
                .concat(measureCtxs).concat(measures);

            var props = service.getProperties();
            if (timeDims.length > 0) {
                var timeDimensions = timeDims.map(function(dim, i) {
                    return i;
                });
                allData.timeDimensions = timeDimensions;
                var applyTimeAxisFormat = props.get("tooltip.applyTimeAxisFormat");
                var formatString = props.get("tooltip.formatString");
                var timeAxis = service.getModule("main.timeAxis");
                var id = dataModel.timeAxis().metaData[0].id;
                applyTimeAxisFormat = applyTimeAxisFormat &&
                    !(TypeUtils.isExist(formatString) && TypeUtils.isExist(formatString[id]));
                TooltipBehaviorHandler.processDateFormat.call(null, allData, applyTimeAxisFormat, timeAxis);
            }

            var trim = function(tData) {
                return Object.keys(tData).reduce(function(data, key) {
                    if (SELECTION_DETAIL_KEYS.indexOf(key) !== -1) {
                        data[key] = tData[key];
                    }
                    return data;
                }, {});
            };

            allData = TooltipUtils.format({
                data: allData
            }, props, service, true).data.map(function(tData) {
                var trimed, fiscalLabels = (tData.timeAxis && tData.timeAxis.getFiscalUnitLabels &&
                    tData.timeAxis.getFiscalUnitLabels());
                if (fiscalLabels && fiscalLabels.length > 0) {
                    trimed = fiscalLabels.map(function(fiscalLabel, idx) {
                        var ret = trim(tData);
                        ret.label = fiscalLabel;
                        ret.value = idx === 0 ? tData.value.fiscalyear : tData.value.fiscalperiod;
                        return ret;
                    });
                } else {
                    trimed = trim(tData);
                }
                return trimed;
            });

            var displayData = [];
            allData.forEach(function(data) {
                if (TypeUtils.isArray(data)) {
                    displayData = displayData.concat(data);
                } else {
                    displayData.push(data);
                }
            });            

            return {
                'data': data,
                'displayData': displayData,
                'graphicInfo' : TooltipUtils.buildEventGraphicInfo(service, extraData, result)
            };
        });

        service.fireExternalEvent("_selectionDetails", {
            'name': '_selectionDetails',
            'data': selectionDetails
        });
    };

    Handler.prototype._fireEventForProcessSelection = function (service,
        deselectDatas, currentSelected, pureNewSelection, fireEvents) {
        if (deselectDatas.length) {
            service.fireEvent("deselectDataPoint", {
                targets: this._getNodes(deselectDatas, service),
                isAnyOtherSelected: currentSelected.length > 0
            });
        }
        if (currentSelected.length) {
            service.fireEvent("selectDataPoint", {
                targets: this._getNodes(currentSelected, service)
            });
        } else {
            service.fireEvent("clearPlot", {
                isGray: false
            });
        }

        if (fireEvents !== false) {
            if (pureNewSelection.length) {
                service.fireEvent("dispatchDataEvent", {
                    targets: pureNewSelection,
                    isSelected: true
                });
            }
            if (deselectDatas.length) {
                service.fireEvent("dispatchDataEvent", {
                    targets: deselectDatas,
                    isSelected: false
                });
            }
        }
    };

    function dispatchEvent(service, isSelected, data, type){
        var eventName, eventIdentifier;
        if (isSelected) {
            eventName = Constants.Event.SelectData.name;
            eventIdentifier = "selectData";
           
        } else {
            eventName = Constants.Event.DeSelectData.name;
            eventIdentifier = "deselectData";
        }
        var event =  {
            name : eventName,
            data : data,
            type : type
        };
        if(isSelected && service.getStatus("rangeSelection")){
            var domains = service.getStatus("rangeDomain");
            var dataModel = service.getDataModel();
            var id =  dataModel._timeAxis.metaData[0].id;
            var start = {}, end = {};
            start[id] = domains[0];
            end[id] = domains[1];
            event.dateTimeRange = {start:start, end:end};
            
        }
       
        service.fireExternalEvent(eventIdentifier,event);
    }

    Handler.prototype.dispatchDataEvent = function(event, service) {
        var targets = event.data.targets;
        var data = this._buildEventData(targets, service);
        var isSelected = event.data.isSelected;
        dispatchEvent(service, isSelected, data, "dataPoint");
    };
    
    Handler.prototype.dispatchRangeDataEvent = function(event, service) {
        var targets = event.data.targets;
        var data, type;
        if (service.isBigDataMode()) {
            data = buildLineBigDataRange(targets, service);
            type = "range";
        } else {
            data = this._buildEventData(targets, service);
            type = "dataPoint";
        }

        var isSelected = event.data.isSelected;
        dispatchEvent(service, isSelected, data, type);
    };

    Handler.prototype._buildEventData = function(dpIds, service) {
        var dataModel = service.getDataModel();
        var dataPointNodes = service.getNodes(service.NodeType.DATA_POINT, false);
        var nodeHash = {};
        for(var i = dataPointNodes.length; i--;){
            var id = DataPointUtils.getDataPointId(dataPointNodes[i]);
            nodeHash[id] = dataPointNodes[i];
        }
        return dpIds.map(function(dpId) {
            var dp = dataModel.getDataPoint(dpId);
            return {
                target: nodeHash[dpId] || null,
                data: dp.context()
            };
        });
    };

    Handler.prototype._getNodes = function(dataPoints, service){
        return DataPointUtils.getNodes(dataPoints, service);
    };
    
    Handler.prototype._hasDataPoint = function(dataPoints, dataPoint) {
        return SelectionUtil.hasDataPoint(dataPoints, dataPoint);
    };

    
    function bindingMapping(axisBinding, bindingDef) {
        
        var axisDef = [], series = [];
        
        var def, i;
        
        for (var prop in bindingDef) {
            if (bindingDef.hasOwnProperty(prop)) {
                
                if (axisBinding.horizontal.indexOf(prop) !== -1 ||
                    axisBinding.vertical.indexOf(prop) !== -1) {
                    def = bindingDef[prop];
                    for (i = 0; i < def.length; i++) {
                        axisDef.push(def[i].id);
                    }
                    continue;
                }
                def = bindingDef[prop];
                for (i = 0; i < def.length; i++) {
                    if (def[i].id === "measureNames") {
                        continue;
                    }
                    series.push(def[i].id);
                }
                
            }
        }
        
        return {
            axisDef: axisDef,
            seriesDef: series
        };
    }
    
    function buildLineBigDataRange(targetData, service) {
        
        var plotModule = service.getModule("main.plot");
        if (!plotModule){
            return;
        }
        var axisBinding = plotModule.getAxisBinding();
        var dataModel = service.getDataModel();
        
        var bindingDef = bindingMapping(axisBinding, dataModel.getBindingMetaData());
        
        var ranges = [], range = null, i;
        
        var previousSeriesIndex = null;
        var previousSeqId = null;
        
        var axisDef = bindingDef.axisDef;
        var seriesDef = bindingDef.seriesDef;
        
        // Because building data point instance by series, the id is the same as seqId.
        targetData = targetData.slice().sort(function(a, b) {
            return a - b;
        });
        var dpInfos = [];
        
        // obtain data point info by dataId
        for (i = 0 ; i < targetData.length; i++) {
            dpInfos.push(dataModel.getDataPoint(targetData[i]));
        }

        for (i = 0 ; i < dpInfos.length; i++) {
            var dpInfo = dpInfos[i];
            var seriesIndex = dpInfo.address(dpInfo.addressType.SERIES);
            if (i !== 0 &&
                (previousSeqId !== dpInfo.id - 1 || previousSeriesIndex !== seriesIndex)) {
                ranges.push(range);
                range = null;
            }
            
            var context = dpInfo.context();
            
            if (range == null) {
                range = {};
                seriesDef.forEach(function(name) {
                    range[name] = DataUtils.getContextValue(context, name);
                });
                axisDef.forEach(function(name) {
                    var value = DataUtils.getContextValue(context, name);
                    range[name] = {
                        min: value,
                        max: value
                    };
                });
            } else {
                axisDef.forEach(function(name) {
                    var value = DataUtils.getContextValue(context, name);
                    range[name].min = Math.min(value, range[name].min);
                    range[name].max = Math.max(value, range[name].max);
                });
            }
            
            previousSeriesIndex = seriesIndex;
            previousSeqId = dpInfo.id;
        }
        
        if (range != null) {
            ranges.push(range);
        }

        return ranges;
    }

    return Handler;
});

define('sap/viz/chart/behavior/config/RuntimeSelectionHelperConfig',[
    "sap/viz/chart/behavior/config/handler/RuntimeSelectionHelperHandler",
    "sap/viz/chart/behavior/config/HighlightHelper"
], function(
    RuntimeSelectionHelperHandler,
    HighlightHelper
) {

    return [
        {
            "id" : "runtimeSelectionHelperDefinition",
            "handler" : RuntimeSelectionHelperHandler,
            "handlerType" : "class",
            "triggerEvent" : [
                {
                    "name" : "afterBehaviorLoaded",
                    "method" : "initializedClearSelection"
                },
                {
                    "name" : "beforeBehaviorUnloaded",
                    "method" : "unloadedClearSelection"
                },
                {
                    "name" : "afterChartRendered",
                    "method" : "refreshedKeepSelection"
                },
                {
                    "name" : "reRenderComplete",
                    "method" : "reRenderKeepSelection"
                },
                {
                    "name" : "click",
                    "excludeTargets" : HighlightHelper.getDeselAllExTargets(),
                    "method" : "deselectAll"
                }, {
                    "name" : "processMultipleSelectionTooltip",
                    "method" : "processMultipleSelectionTooltip"
                }, {
                    "name": "processSelection",
                    "method": "processSelection"
                }, {
                    "name": "processHighlight",
                    "method": "processHighlight"
                }, {
                    "name": "processUnhighlight",
                    "method": "processUnhighlight"
                }, {
                    "name" : "dispatchDataEvent",
                    "declaredEvents" : [
                        "selectData", "deselectData"
                    ],
                    "method" : "dispatchDataEvent"
                }, {
                    "name" : "dispatchDataEvent",
                    "declaredEvents" : [
                        "selectData", "deselectData"
                    ],
                    "supportedChartTypes": ["info/timeseries_line",
                    "info/timeseries_column", "info/timeseries_stacked_column",
                    "info/timeseries_100_stacked_column", "info/timeseries_watefall"],
                    "method" : "dispatchRangeDataEvent"
                }
            ]
        }
    ];
});

define('sap/viz/chart/behavior/config/SelectionTreeUtil',[
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/framework/interaction/Constants'
], function(
    ObjectUtils,
    ArrayUtils,
    TypeUtils,
    Constants
){
    var MND = "measureNames";
    var ANY = "*";

    var generalSeriesBinding = {
        bindings: ["color", "color2"],
        selectionTree: "seriesSelectionTree",
        metaInfo: "seriesMetaInfo"
    };

    var bubbleSeriesBinding = {
        bindings: ["color", "shape"],
        maxDimension: [1, 1],
        selectionTree: "seriesSelectionTree",
        metaInfo: "seriesMetaInfo"
    };

    var heatMapSeriesBinding = null;

    var bindingConfig = {
        categoryAxis: {
            bindings: ["categoryAxis"],
            selectionTree: "categorySelectionTree",
            metaInfo: "categoryMetaInfo"
        },
        categoryAxis2: {
            bindings: ["categoryAxis2"],
            selectionTree: "category2SelectionTree",
            metaInfo: "category2MetaInfo"
        },
        series: generalSeriesBinding
    };

    function applyDimensionalSelection(service, treeName, selectionTree, ctx, isDeselect, metaInfo) {
        var selectability = service.getProperties().get("interaction.selectability");
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        var selectionBehavior = selectability.behavior ? selectability.behavior.toUpperCase() : selectability.behavior;
        var tempItemData;
        if (selectionBehavior === Constants.SELECTION_BEHAVIOR.CATEGORY) {
            tempItemData = handleMND(ctx, metaInfo);
            if (!isDeselect) {
                setSelectionTree(selectionTree, tempItemData, metaInfo, 0);
            } else {
                removeSelectionTree(selectionTree, tempItemData, metaInfo, 0);
            }
            service.setStatus(treeName, selectionTree);
        } else if (selectionBehavior === Constants.SELECTION_BEHAVIOR.SERIES) {
            tempItemData = handleMND(ctx, metaInfo);
            if (!isDeselect) {
                setSelectionTree(selectionTree, tempItemData, metaInfo, 0);
            } else {
                removeSelectionTree(selectionTree, tempItemData, metaInfo, 0);
            }
            service.setStatus(treeName, selectionTree);
        }

    }

    function getSelectionTree(service, option, treeName) {
        var selectability = service.getProperties().get("interaction.selectability");
        var selectionMode = option.mode || (selectability.mode ? selectability.mode.toUpperCase() : selectability.mode);
        var selectionBehavior = selectability.behavior ? selectability.behavior.toUpperCase() : selectability.behavior;
        var selectionTree;
        if (option.isDeselect) {
            selectionTree = service.getStatus(treeName);
        } else {
            selectionTree = (
                ((selectionMode === Constants.SELECTION_MODE.EXCLUSIVE) && !option.ctrlKey) ||
                selectionMode === Constants.SELECTION_MODE.SINGLE && !option.isDeselect
                ) ? {}
            : service.getStatus(treeName);
        }
        return selectionTree;
    }

    function setSelectionTree(tree, item, metaInfo, layer) {
        if (!metaInfo[layer]) {
            return;
        }
        var id = metaInfo[layer].id;
        var values;
        if (item.hasOwnProperty(id)) {
            values = (item[id] && item[id]["in"]) ? item[id]["in"] : [item[id]];
        } else {
            values = (metaInfo[layer].values);
        }
        if (!tree.children) {
            tree.children = [];
        }

        for (var j = 0; j < values.length; ++j) {
            var val = values[j];
            for (var k = 0; k < tree.children.length; ++k) {
                if (tree.children[k].value === val) {
                    break;
                }
            }
            var node;
            if (k < tree.children.length) {
                // value already exists for current layer's dimension
                setSelectionTree(tree.children[k], item, metaInfo, layer + 1);
                node = tree.children[k];
            } else {
                // value is new to current layer's dimension
                node = {
                    dimension: id,
                    maxChildren: metaInfo[layer + 1] ? metaInfo[layer + 1].values.length: 0,
                    value: val,
                    children: []
                };
                tree.children.push(node);
                setSelectionTree(node, item, metaInfo, layer + 1);
            }
        }
    }

    function removeSelectionTree(tree, item, metaInfo, layer) {
        if (!metaInfo[layer]) {
            return true;
        }
        var id = metaInfo[layer].id;
        var values;
        if (item.hasOwnProperty(id)) {
            values = (item[id]["in"]) ? item[id]["in"] : [item[id]];
        } else {
            values = (metaInfo[layer].values);
        }
        for (var j = 0; j < values.length; ++j) {
            var val = values[j];
            if (!tree.children) {
                return;
            }
            for (var k = 0; k < tree.children.length; ++k) {
                if (tree.children[k].value === val) {
                    if (removeSelectionTree(tree.children[k], item, metaInfo, layer + 1)) {
                        tree.children.splice(k, 1);
                    }
                    break;
                }
            }
            if (tree.children.length === 0) {
                return true;
            }
        }
    }

    function getSelectionResult(tree, result, path) {
        for (var i = 0; i < tree.children.length; ++i) {
            var node = tree.children[i];
            var currentPath = ObjectUtils.clone(path);
            currentPath[node.dimension] = node.value;
            if (node.children.length === 0) {
                result.push({data: currentPath});
            } else {
                getSelectionResult(node, result, currentPath);
            }
        }
    }

    function getDuplicatedMetaInfo(metaData, values){
        var result = [];
        for (var i = 0; i < metaData.length; ++i) {
            var item = {}, hasNoValue = false;
            item.id = metaData[i].id;
            item.type = metaData[i].type;
            if (values[i].some(function (e) {
                return e === null;
            })) {
                hasNoValue = true;
            }
            item.values = values[i] ? ArrayUtils.unique(values[i], function(a) {
                return a ? a.toString() : false;
            }) : [];
            if (hasNoValue) {
                item.values.push(null);
            }
            if (metaData[i].hidden) {
                item.hidden = true;
            }
            // remove unused MND
            if(item.id === MND && item.values.length < 2 && metaData.length > 1){
                continue;
            }
            result.push(item);
        }
        return result;
    }

    function handleMND(ctx, metaInfo) {
        var measureNames = metaInfo.filter(function(e) {return e.id === "measureNames";})[0];
        if (measureNames) {
            var measureNamesValues = [];
            var tempCtx = ObjectUtils.clone(ctx);
            for (var prop in tempCtx) {
                if (tempCtx.hasOwnProperty(prop)) {
                    if (measureNames.values.indexOf(prop) > -1) {
                        delete tempCtx[prop];
                        measureNamesValues.push(prop);
                    }
                }
            }
            if (measureNamesValues.length) {
                tempCtx[MND] = {"in": measureNamesValues};
            }
            return tempCtx;
        } else {
            return ctx;
        }
    }

    function applyFilterDimension(input, service, behavior, needComplete) {
        var metaInfo, binding;
        var result = {};
        if (behavior === Constants.SELECTION_BEHAVIOR.CATEGORY) {
            binding = "categoryAxis";
            metaInfo = service.getStatus(bindingConfig[binding].metaInfo);
            result[binding] = filterDimension(input, metaInfo);
            result[binding] = filterHidden(result[binding], metaInfo);
            binding = "categoryAxis2";
            metaInfo = service.getStatus(bindingConfig[binding].metaInfo);
            result[binding] = filterDimension(input, metaInfo);
            result[binding] = filterHidden(result[binding], metaInfo);
        } else if (behavior === Constants.SELECTION_BEHAVIOR.SERIES) {
            binding = "series";
            metaInfo = service.getStatus(bindingConfig[binding].metaInfo);
            result[binding] = filterDimension(input, metaInfo);
        } else {
            return input;
        }
        if (result[binding] && needComplete) {
            completeDimension(result[binding], metaInfo);
        }
        return result;
    }


    function filterDimension(input, metaInfo) {
        var ret = null;
        if (metaInfo) {
            var measureNames = metaInfo.filter(function(e) {return e.id === "measureNames";})[0];
            var item = ObjectUtils.clone(input);
            for (var prop in item) {
                if (item.hasOwnProperty(prop)) {
                    var find = metaInfo.filter(function(e){
                        return e.id === prop;
                    });
                    if(find.length === 0) {
                        if (!measureNames || measureNames.values.indexOf(prop) < 0) {
                            delete item[prop];
                        } else {
                            item[prop] = "*";
                        }
                    }
                }
            }
            if (!TypeUtils.isEmptyObject(item)) {
                ret = item;
            }
        }
        return ret;
    }

    function filterHidden(input, metaInfo) {
        var result = ObjectUtils.clone(input);
        if (!metaInfo || !result) {
            return null;
        }
        metaInfo.forEach(function(meta) {
            if (meta.hidden) {
                delete result[meta.id];
            }
        });
        return TypeUtils.isEmptyObject(result) ? null : result;
    }

    function completeDimension(input, metaInfo) {
        for (var i = 0; i < metaInfo.length; ++i) {
            var item = metaInfo[i];
            if (!input[item.id]) {
                input[item.id] = item.values[0];
            }
        }
    }

    function handleChartType(service) {
        var type = (service.getDataModel() && service.getDataModel().chartType) ?
         service.getDataModel().chartType() : null;
        switch (type) {
            case "info/bubble":
            case "info/scatter":
            case "info/timeseries_bubble":
            case "info/timeseries_scatter":
                bindingConfig.series = bubbleSeriesBinding;
                break;
            case "info/heatmap":
            case "info/treemap":
                bindingConfig.series = heatMapSeriesBinding;
                break;
            default:
                bindingConfig.series = generalSeriesBinding;
        }
    }

    function initSelectionTree(service) {
        if (service._dataModelMgr && service.getDataModel()) {
            var dataModel = service.getDataModel();
            handleChartType(service);
            for (var item in bindingConfig) {
                if (bindingConfig.hasOwnProperty(item) && bindingConfig[item]) {
                    var bindings = bindingConfig[item].bindings;
                    var allMetaDatas = [], allValues = [];
                    for (var i = 0; i < bindings.length; ++i) {
                        var bindingFunc = dataModel[bindings[i]];
                        if (bindingFunc && !TypeUtils.isEmptyObject(bindingFunc())) {
                            var bindingItem = bindingFunc();
                            var metaDatas = bindingItem.metaData;
                            var values = bindingItem.values;
                            if (metaDatas && values) {
                                var maxDim = bindingConfig[item].maxDimension;
                                var len = maxDim ? (maxDim[i] || metaDatas.length) :  metaDatas.length;
                                var val;
                                for (var j = 0; j < len; ++j) {
                                    for (var k = 0; k < allMetaDatas.length; ++k) {
                                        if (allMetaDatas[k].id === metaDatas[j].id) {
                                            if (values[j]) {
                                                if (values[j][0] && values[j][0].v) {
                                                    // only get v when values has d and v
                                                    val = values[j].map(function(e) {return (e && e.v);});
                                                } else {
                                                    val = values[j];
                                                }
                                                allValues[k] = allValues[k].concat(val);
                                            }
                                            break;
                                        }
                                    }
                                    if (k === allMetaDatas.length) {
                                        allMetaDatas.push(metaDatas[j]);
                                        if (values[j]) {
                                            if (values[j][0] && values[j][0].v) {
                                                // only get v when values has d and v
                                                val = values[j].map(function(e) {return (e && e.v);});
                                            } else {
                                                val = values[j];
                                            }
                                            allValues.push(val);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (allMetaDatas.length && allValues.length) {
                        var metaInfo = getDuplicatedMetaInfo(allMetaDatas, allValues);
                        service.setStatus(bindingConfig[item].selectionTree, {});
                        service.setStatus(bindingConfig[item].metaInfo, metaInfo);
                    }
                }
            }
        }
    }

    function isSelectable(service, callfrom){
        var behavior = service.getProperties().get("interaction.selectability.behavior");
        behavior = behavior ? behavior.toUpperCase() : behavior;
        var chartType = service.getDataModel().chartType();
        var result = false;

        if (callfrom === "DATAPOINT") {
            if (behavior === Constants.SELECTION_BEHAVIOR.SERIES) {
                if (service.getStatus("seriesMetaInfo") &&
                    chartType.indexOf("bullet") <= -1 && 
                    chartType.indexOf("timeseries_waterfall") <= -1 &&
                    chartType !== "info/heatmap") {
                    result = true;
                }
            } else if (behavior === Constants.SELECTION_BEHAVIOR.CATEGORY) {
                if (service.getStatus("categoryMetaInfo") ||
                    (chartType === "info/heatmap" && service.getStatus("categoryMetaInfo") &&
                     service.getStatus("category2MetaInfo"))
                    ) {
                    result =  true;
                }
            } else {
                result = true;
            }
        } else if (behavior === Constants.SELECTION_BEHAVIOR.DATAPOINT) {
            result = true;
        } else if (behavior === callfrom) {
            if (!(behavior === Constants.SELECTION_BEHAVIOR.SERIES &&
                chartType.indexOf('waterfall') > -1)) {
                //disable waterfall series selection
                result = true;
            }
        }

        return result;
    }

    function emptySelectionTree(service, behavior) {
        var treeName;
        if (behavior === Constants.SELECTION_BEHAVIOR.CATEGORY) { 
            treeName = bindingConfig.categoryAxis.selectionTree;
            service.setStatus(treeName, {});
            treeName = bindingConfig.categoryAxis2.selectionTree;
            service.setStatus(treeName, {});
        } else if (behavior === Constants.SELECTION_BEHAVIOR.SERIES) {
            treeName = bindingConfig.series.selectionTree;
            service.setStatus(treeName, {});
        }
    }

    return {
        getSelectionResult: getSelectionResult,
        filterDimension: filterDimension,
        applyDimensionalSelection: applyDimensionalSelection,
        initSelectionTree: initSelectionTree,
        removeSelectionTree: removeSelectionTree,
        getSelectionTree: getSelectionTree,
        applyFilterDimension: applyFilterDimension,
        bindingConfig: bindingConfig,
        isSelectable: isSelectable,
        emptySelectionTree: emptySelectionTree
    };
});

define('sap/viz/chart/behavior/config/handler/SelectionAPIHandler',[
    'sap/viz/framework/interaction/Constants', 
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/ObjectUtils", 
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/SelectionUtil", 
    "sap/viz/chart/behavior/config/SelectionTreeUtil", 
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/behavior/config/ContextualDataUtil"
], function(
    Constants, 
    DataPointUtils, 
    ObjectUtils, 
    TypeUtils, 
    SelectionUtil, 
    SelectionTreeUtil,
    DataUtils,
    commonConstants,
    ArrayUtils,
    DataGraphics,
    ContextualDataUtil
) {

    function setSelection(config, service) {
        service.fireEvent("hideDetail", {
            mode : "infoMode"
        });
        service.fireEvent("hideDetail", {
            mode : "actionMode"
        });

        var tempSelectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        var tempSelectionMode = service.getProperties().get("interaction.selectability.mode");
        var currentSelectionMode = tempSelectionMode ? tempSelectionMode.toUpperCase() : tempSelectionMode;
        var currentSelectionBehavior = tempSelectionBehavior ? tempSelectionBehavior.toUpperCase()
         : tempSelectionBehavior;

        var options = config.options || {};
        var selectionMode;
        if (options.selectionMode) {
            selectionMode = String(options.selectionMode).toUpperCase();
        }

        var valid = false;
        for ( var validMode in Constants.SELECTION_MODE) {
            if (Constants.SELECTION_MODE.hasOwnProperty(validMode) && validMode === selectionMode) {
                valid = true;
                break;
            }
        }

        if (!valid) {
            if (options.hasOwnProperty('clearSelection') && currentSelectionMode !== Constants.SELECTION_MODE.NONE) {
                selectionMode = options.clearSelection ? Constants.SELECTION_MODE.EXCLUSIVE
                    : Constants.SELECTION_MODE.INCLUSIVE;
                if (currentSelectionBehavior !== Constants.SELECTION_BEHAVIOR.DATAPOINT) {
                    SelectionTreeUtil.emptySelectionTree(service, currentSelectionBehavior);
                }
            } else {
                selectionMode = currentSelectionMode;
            }
        }

        selectionMode = selectionMode ? selectionMode.toUpperCase() : selectionMode;
        if (selectionMode === Constants.SELECTION_MODE.NONE) {
            config.success = false;
            return;
        }

        var items = config.items;
        var targets = [];
        var isSuccessful = true;
        var start, end;
        var filteredCtx = {};
        var firstTargets = [], firstCtx = [];
        if(selectionMode === Constants.SELECTION_MODE.RANGE) {
            var plotLassoMode = service.getProperties().get("interaction.selectability.plotLassoMode");
            plotLassoMode = plotLassoMode ? plotLassoMode.toUpperCase() : plotLassoMode;
            var plotLassoSelection = service.getProperties().get("interaction.selectability.plotLassoSelection");
            if(plotLassoSelection && plotLassoMode === Constants.SELECTION_MODE.RANGE &&
                    TypeUtils.isArray(items) && items.length === 2) {
                // Range selection mode must only have two items as min and max
                var dataModel = service.getDataModel(), dimensions = dataModel.dimensions(), 
                    dateField = dataModel._timeAxis.metaData[0].id;
                start = items[0].data ? new Date(items[0].data[dateField]).getTime() : null;
                end = items[1].data ? new Date(items[1].data[dateField]).getTime() : null;
                if(TypeUtils.isNaN(start) || TypeUtils.isNaN(end)) {
                    config.success = false;
                    return;
                }
                var range = [{data:{}}];
                if(start > end) {
                    var tmp = start;
                    start = end;
                    end = tmp;
                }

                var domain = service.getExtendTimeRange();
                if(start > domain[1] || end < domain[0]) {
                    config.success = false;
                    return;
                }
                
                start = Math.max(start, domain[0]);
                end = Math.min(end, domain[1]);                 
                range[0].data[dateField] = {min:start, max:end};                
                targets = this._getTargets(range, service);
            }
            else {
                config.success = false;
                return;
            }
        }        
        else if (TypeUtils.isArray(items) && items.length) {
            if (service.getProperties().get("interaction.behaviorType") ===
                Constants.BEHAVIOR.NOHOVER_BEHAVIOR_ID && currentSelectionBehavior !==
                Constants.SELECTION_BEHAVIOR.DATAPOINT) {
                //enable series/category selection behavior only when noHoverBehavior
                isSuccessful = false;
                if (SelectionTreeUtil.isSelectable(service, "DATAPOINT")) {
                    var needComplete = false;
                    if (currentSelectionMode === Constants.SELECTION_MODE.SINGLE &&
                        currentSelectionBehavior === Constants.SELECTION_BEHAVIOR.SERIES) {
                        // complete series dimensions when single mode to get only 1 series
                        needComplete = true;
                    }
                    for (var i = 0; i < items.length; ++i) {
                        var item = SelectionTreeUtil.applyFilterDimension(items[i].data, service, 
                            currentSelectionBehavior, needComplete);
                        var currentTargets;
                        var isItemSuccessful;
                        if (item) {
                            for (var cond in item) {
                                if (item.hasOwnProperty(cond) && item[cond]) {
                                    currentTargets = this._getTargets([{data: item[cond]}], service);
                                    if (currentTargets.length > 0) {
                                        if (targets.length === 0) {
                                            firstTargets = currentTargets;
                                            firstCtx[cond] = [];
                                            firstCtx[cond].push(item[cond]);
                                        }
                                        targets = targets.concat(currentTargets);
                                        isSuccessful = true;
                                        filteredCtx[cond] = filteredCtx[cond] || [];
                                        filteredCtx[cond].push(item[cond]);
                                    }
                                }
                            }
                        }
                    }
                    targets = ArrayUtils.unique(targets);
                }
            } else {
                targets = this._getTargets(items, service);
                isSuccessful = targets.length > 0;
            }
        }
        config.success = isSuccessful;

        if (isSuccessful) {
            var selectByTimeAxisGroup = service.getProperties().get("interaction.selectByTimeAxisGroup");
            if(selectByTimeAxisGroup) {
                var groupTargets = [];
                targets.forEach(function(target) {
                    if(groupTargets.indexOf(target) === -1) {
                        var node = service.getNodes(service.NodeType.DATA_POINT_GROUP, false)[0];
                        var dataPoint = DataPointUtils.findByDataPointId(node, target);
                        var dps = ContextualDataUtil.getDataPointsByTimeField(dataPoint, service)
                            .map(function(n){
                                return DataPointUtils.getDataPointId(n);
                            });
                        groupTargets = groupTargets.concat(dps);
                    }
                });
                if(groupTargets.length > 0) {
                    targets = ArrayUtils.unique(groupTargets);
                }
            }

            if(service.getStatus("rangeSelection") || selectionMode === Constants.SELECTION_MODE.RANGE) {
                service._actionLayer.clear();
                service.setStatus("rangeSelection", false);
                var selectedDataPoints =  service.getStatus("selectedDataPoints");
                if(selectedDataPoints && selectedDataPoints.length > 0) {
                    service.setStatus("selectedDataPoints", []).fireEvent("clearPlot");
                    if(options.deselection === true){
                        service.fireEvent("dispatchDataEvent", {
                            targets : selectedDataPoints,
                            isSelected : false
                        }).fireEvent("deselectDataPoint", {
                            targets : DataPointUtils.getNodes(selectedDataPoints, service),
                            isAnyOtherSelected : false
                        });
                        return;
                    } else {
                        service.fireEvent("deselectDataPoint", {
                            targets : DataPointUtils.getNodes(selectedDataPoints, service),
                            isAnyOtherSelected : targets.length > 0
                        });
                    }
                }

            }
            if(selectionMode === Constants.SELECTION_MODE.RANGE) {
                service.setStatus('rangeDomain', [start, end]);
                service.fireEvent('rangeRecover');
                if(targets.length > 0) {
                    service.fireEvent("processSelection", {
                        targets : targets,
                        mode : Constants.SELECTION_MODE.EXCLUSIVE
                    });
                }
            }
            else {
                service.setStatus('rangeDomain', null);
                if (currentSelectionMode === Constants.SELECTION_MODE.SINGLE &&
                    currentSelectionBehavior !== Constants.SELECTION_BEHAVIOR.DATAPOINT) {
                    filteredCtx = firstCtx;
                    targets = firstTargets;
                }
                service.fireEvent("processSelection", {
                    ctx : filteredCtx,  // sFinBehavior will check ctx to trigger category/series selection
                    targets : targets,
                    deselection : options.deselection,
                    mode : selectionMode,
                    fireEvents: options.fireEvents
                });
            }
        }
    }

    function getSelection(service) {
        var selected = service.getStatus("selectedDataPoints");
        var ret = TypeUtils.isArray(selected) && selected.length ?
            this._buildGetSelectionResult(selected, service) : [];
        var plotLassoMode = service.getProperties().get("interaction.selectability.plotLassoMode");
        if (plotLassoMode && plotLassoMode.toUpperCase() === Constants.SELECTION_MODE.RANGE) {
            var selectabilityMode = service.getProperties().get("interaction.selectability.mode");
            selectabilityMode = selectabilityMode ? selectabilityMode.toUpperCase() : selectabilityMode;
            if (selectabilityMode !== Constants.SELECTION_SINGLE &&
                selectabilityMode !== Constants.SELECTION_NONE) {
                var rangeDomain = service.getStatus("rangeDomain");
                var dataModel = service.getDataModel(),
                    dimensions = dataModel.dimensions(),
                    dateField = dataModel._timeAxis.metaData[0].id;
                ret.dateTimeRange = rangeDomain && rangeDomain.length === 2 && dateField ? {
                    start: {},
                    end: {}
                } : null;
                if (ret.dateTimeRange) {
                    ret.dateTimeRange.start[dateField] = rangeDomain[0];
                    ret.dateTimeRange.end[dateField] = rangeDomain[1];
                }
            }
        }

        var tempSelectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        var currentSelectionBehavior = tempSelectionBehavior ? tempSelectionBehavior.toUpperCase()
         : tempSelectionBehavior;
        if (service.getProperties().get("interaction.behaviorType") ===
            Constants.BEHAVIOR.NOHOVER_BEHAVIOR_ID && currentSelectionBehavior !==
            Constants.SELECTION_BEHAVIOR.DATAPOINT) {
            //enable series/category selection behavior only when noHoverBehavior
            var selectionTree;
            var dimensionSelection = [];
            if (currentSelectionBehavior === Constants.SELECTION_BEHAVIOR.CATEGORY) {
                selectionTree = service.getStatus("categorySelectionTree");
                if (!TypeUtils.isEmptyObject(selectionTree) && selectionTree) {
                    SelectionTreeUtil.getSelectionResult(selectionTree, dimensionSelection, {});
                }
                selectionTree = service.getStatus("category2SelectionTree");
                if (!TypeUtils.isEmptyObject(selectionTree) && selectionTree) {
                    var dimensionSelection2 = [];
                    SelectionTreeUtil.getSelectionResult(selectionTree, dimensionSelection2, {});
                    ret.category = dimensionSelection.concat(dimensionSelection2);
                } else {
                    ret.category = dimensionSelection;
                }
            } else if (currentSelectionBehavior === Constants.SELECTION_BEHAVIOR.SERIES) {
                selectionTree = service.getStatus("seriesSelectionTree");
                if (!TypeUtils.isEmptyObject(selectionTree) && selectionTree) {
                    SelectionTreeUtil.getSelectionResult(selectionTree, dimensionSelection, {});
                }
                ret.series = dimensionSelection;
            }
        }
        return ret;
    }

    var Handler = function() {

    };

    Handler.prototype.initialize = function(event, service) {
        if (service.getProperties().get("interaction.behaviorType") ===
            Constants.BEHAVIOR.NOHOVER_BEHAVIOR_ID) {
            SelectionTreeUtil.initSelectionTree(service);
        }
        var that = this;
        service.getStatusManager().add("interaction.selectedDataPoints", {
            serializable : false,
            set : function(config) {
                setSelection.call(that, config || {}, service);
            },
            get : function() {
                return getSelection.call(that, service);
            }
        });
    };

    Handler.prototype._getTargets = function(items, service) {
        return SelectionUtil.getTargets(items, service);
    };

    Handler.prototype._buildGetSelectionResult = function(selectedDataPoints, service) {
        var timeField, measureFields = [], dimensionFields = [], 
            dataModel = service.getDataModel(),
            semanticMgr = service.getSemanticManager();
        if (dataModel && dataModel.timeAxis && dataModel.timeAxis()) {
            timeField = dataModel.timeAxis().metaData.map(function(e) {
                return e.id;
            });
        }
        if(dataModel && dataModel._rawData && dataModel._rawData.data()) {
            var metadata = dataModel._rawData.data().metadata;
            if(metadata && metadata.fields) {
                measureFields = metadata.fields.filter(function(item) {
                    return item.semanticType === "Measure";
                });
                dimensionFields = metadata.fields.filter(function(item) {
                    return item.semanticType === "Dimension";
                });
            }
        }
        return selectedDataPoints.map(function(selectedDataPointId) {
            
            var dp = dataModel.getDataPoint(selectedDataPointId);
            //Clone the context to return, 
            //in case user change the return object so that context will be modified.
            var data = ObjectUtils.clone(dp.context());
            delete data["measureNames"];
            delete data["_id"];
            delete data[timeField + DataUtils.DIMENSION_PARSED_VALUE_SUFFIX];
            var ret = {
                data : data
            };
            //Add unit & dataName information
            var result = semanticMgr.analyzeDataPoint('color,lineColor,lineType,pattern', 
                dp.context(), true, dp.additionCtx());
            var dataName = result && result.dataName || {};
            measureFields.forEach(function(measure) {
                var id = measure.id;
                if(data.hasOwnProperty(id) && measure.hasOwnProperty('unit')) {
                    ret.unit = ret.unit || {};
                    ret.unit[id] = measure.unit;
                }
                if(ret.data[id] != null){
                    ret.data[id] = +ret.data[id];
                }
                if(dataName.hasOwnProperty(id)) {
                    ret.dataName = ret.dataName || {};
                    ret.dataName[id] = dataName[id];
                }
            });
            dimensionFields.forEach(function(dimension) {
                var id = dimension.id;
                if(dataName.hasOwnProperty(id)) {
                    ret.dataName = ret.dataName || {};
                    ret.dataName[id] = dataName[id];
                }
            });
            return ret;
        });
    };

    return Handler;
});

define('sap/viz/chart/behavior/config/SelectionAPIConfig',[ "sap/viz/chart/behavior/config/handler/SelectionAPIHandler" ], function(SelectionAPIHandler) {
    return [ {
        "id" : "selectionAPIDefinition",
        "handler" : SelectionAPIHandler,
        "handlerType" : "class",
        "triggerEvent" : [ {
            "name" : "afterBehaviorLoaded",
            "method" : "initialize"
        } ]
    } ];
});

define('sap/viz/chart/behavior/config/PinchBehaviorConfig',[
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/components/util/ScrollbarUtil",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/chart/components/plots/PlotGeometryKeeper",
    'sap/viz/framework/interaction/Constants'
], function(
    DataPointUtils,
    ScrollbarUtil,
    UADetector,
    PlotGeometryKeeper,
    Constants
) {
    var csvChartTypes = [
            "info/bar",
            "info/column",
            "info/dual_bar",
            "info/dual_column",
            "info/stacked_bar",
            "info/stacked_column",
            "info/dual_stacked_bar",
            "info/dual_stacked_column",
            "info/100_stacked_bar",
            "info/100_stacked_column",
            "info/100_dual_stacked_bar",
            "info/100_dual_stacked_column",
            "info/line",
            "info/horizontal_line",
            "info/dual_line",
            "info/dual_horizontal_line",
            "info/combination",
            "info/combinationEx",
            "info/horizontal_combination",
            "info/stacked_combination",
            "info/horizontal_stacked_combination",
            "info/dual_stacked_combination",
            "info/dual_horizontal_stacked_combination",
            "info/bullet",
            "info/vertical_bullet",
            "info/mekko",
            "info/100_mekko",
            "info/horizontal_mekko",
            "info/100_horizontal_mekko",
            "info/dual_combination",
            "info/dual_horizontal_combination",
            "info/area",
            "info/horizontal_area",
            "info/100_area",
            "info/100_horizontal_area",
            "info/waterfall",
            "info/stacked_waterfall",
            "info/horizontal_waterfall",
            "info/horizontal_stacked_waterfall"
        ],
        bubbleChartTypes = [
            "info/bubble",
            "info/scatter",
            "info/time_bubble",
            "info/timeseries_bubble",
            "info/timeseries_scatter"
        ],
        timeChartTypes = [
            "info/timeseries_waterfall",
            "info/timeseries_line",
            "info/timeseries_column",
            "info/timeseries_stacked_column",
            "info/timeseries_100_stacked_column",
            "info/timeseries_combination",
            "info/dual_timeseries_combination",
            "info/timeseries_stacked_combination",
            "info/timeseries_bullet"
        ];

    var chartTypes = csvChartTypes.concat(bubbleChartTypes, timeChartTypes);

    function scrollDirection(service) {
        var pla = service.getModule("main"),
            hsb = pla.getHScrollbar(),
            vsb = pla.getVScrollbar(),
            dir = '';
        if (hsb && hsb.isExist) {
            dir += "x";
        }
        if (vsb && vsb.isExist) {
            dir += "y";
        }
        return dir;
    }

    function zoomerPinch(event, service) {
        if (!UADetector.isMobile()) {
            return null;
        }
        var plotArea = service.getModule("main"),
            s = event.data.scale,
            r = service.getStatus("ratioBeforePinch");

        return plotArea.getZoomer().zoom({
            x: r.x * s,
            y: r.y * s
        }, event.data.point);
    }

    function initialize(event, service) {
        var plot = service.getModule("main.plot");
        service.setStatus("canvasBBox", plot.getSize());
        service.fireEvent(event, true);
    }

    var THRESHOLD = 2;
    var DRAGOFFSET = Constants.RANGE_SELECTION.OFFSET;
    function pageScrollAllowed(xOff, yOff, service, direction) {
        var chartCannotScroll = false,
            hScroll = service.getModule("main").getHScrollbar(),
            vScroll = service.getModule("main").getVScrollbar(),
            //FIXME: delete underscore before the function name to expose to public
            hThumbFull = hScroll ? hScroll._isFull() : true,
            vThumbFull = vScroll ? vScroll._isFull() : true,
            xOver = hScroll ? hScroll.isThumbOverTrack(-xOff) : true,
            yOver = vScroll ? vScroll.isThumbOverTrack(-yOff) : true,
            notPanning = false;

        switch (direction) {
            case "x":
                notPanning = (Math.abs(xOff) < THRESHOLD && yOff !== 0);
                chartCannotScroll = hThumbFull || xOver;
                break;
            case "y":
                notPanning = (Math.abs(yOff) < THRESHOLD && xOff !== 0);
                chartCannotScroll = vThumbFull || yOver;
                break;
            case "xy":
                //if one bar is full, and the other is over, it is also "cannotscroll"
                chartCannotScroll = ((hThumbFull && vThumbFull) || (xOver && yOver) || 
                    (hThumbFull && yOver) || (xOver && vThumbFull));
                break;
        }
        return notPanning || chartCannotScroll;
    }

    function pan(event, service) {
        if (!UADetector.isMobile()){
            return;
        }
        if(service.getStatus("dragAsLasso")){
            service.fireEvent({name: "lassomove", data: event.data});
            return;
        }

        var startPoint = service.getStatus("panLastPoint");
        if (!startPoint) {
            return;
        }

        var currentPoint = event.data.point,
            dir = scrollDirection(service),
            xOff = currentPoint.x - startPoint.x,
            yOff = currentPoint.y - startPoint.y,
            offset = service.getStatusManager().get("plot.transform.translate"),
            translate = {
                x: offset.x + xOff,
                y: offset.y + yOff
            },
            allowPageScroll = pageScrollAllowed(xOff, yOff, service, dir);

        service.setStatus("panLastPoint", currentPoint);
        service.getStatusManager().set("plot.transform.translate", translate);

        if (!allowPageScroll && event.data.originalEvent.cancelable) {
            //some move event cannot be prevented. It is not a bug and
            //the check is just to prevent error messages.
            event.data.originalEvent.preventDefault();
        } else if (UADetector.isWindowsSurface() || UADetector.isWindowsPhone()) {
            window.scrollBy(-xOff, -yOff);
        }
        ScrollbarUtil.showScrollbar(service);
        service.setStatus("needToPreventDefault", !allowPageScroll);
    }

    return [{
        "id": "initialized_pinch",
        "triggerEvent": {
            "name": "afterChartRendered",
            "supportedChartTypes": chartTypes
        },
        "handler": initialize
    }, {
        "id": "pinchstart_on_eventLayer",
        "triggerEvent": {
            "name": "pinchstart",
            "targets": "v-m-root",
            "supportedChartTypes": chartTypes
        },
        "handler": function(event, service) {
            if (UADetector.isMobile()) {
                service.setStatus("ratioBeforePinch", service.getStatusManager().get("plot.transform.scale"));
                return zoomerPinch(event, service);
            } else {
                return null;
            }
        }
    }, {
        "id": "pinchmove_on_eventLayer",
        "triggerEvent": {
            "name": "pinchmove",
            "targets": "v-m-root",
            "supportedChartTypes": chartTypes
        },
        "handler": zoomerPinch
    }, {
        "id": "pinchend_on_eventLayer",
        "triggerEvent": {
            "name": "pinchend",
            "targets": "v-m-root",
            "supportedChartTypes": chartTypes
        },
        "handler": zoomerPinch
    }, {
        "id": "2Xfingertouch_show_indicator",
        "triggerEvent": {
            "name": "touchchange",
            "targets": "v-m-root",
            "supportedChartTypes": chartTypes
        },
        "handler": function(event, service) {
            if (!UADetector.isMobile() || event.data.totalTouchesNumber !== 2) {
                return;
            }
            service.fireEvent("hideDetail", {
                mode: "actionMode"
            });
            ScrollbarUtil.showScrollbar(service, true);
        }
    }, {
        "id": "pan_start_on_plot_pinch",
        "triggerEvent": {
            "name": "dragstart",
            "targets": ["v-m-plot", "v-m-action-layerrange-content", "v-m-datapoints"], 
            "supportedChartTypes": chartTypes
        },
        "handler": function(event, service) {
            if (!UADetector.isMobile()) {
                return;
            }
            if (service.getStatus("rangeSelection") )
            {
                var rangeRect = service.getBBox(service.BoxType.RANGE_SELECTION);
                if(rangeRect){
                    var point = event.data.point;
                    if(point.x >= rangeRect.left - DRAGOFFSET && point.x <= rangeRect.right + DRAGOFFSET &&
                            point.y >= rangeRect.top && point.y <= rangeRect.bottom ){
                        service.setStatus("dragAsLasso", true);
                        service.fireEvent({name: "lassostart", data: event.data});
                        return;
                    }

                }

            }
            service.fireEvent("hideDetail", {
                mode: "actionMode"
            });
            service.setStatus("panLastPoint", event.data.point);
            if (service.getStatus("needToPreventDefault") && event.data.originalEvent.cancelable) {
                //some move event cannot be prevented. It is not a bug and
                //the check is just to prevent error messages.
                event.data.originalEvent.preventDefault();
            }
            ScrollbarUtil.showScrollbar(service);
        }
    }, {
        "id": "pan_move_on_plot_pinch",
        "triggerEvent": {
            "name": "dragmove",
            "targets": ["v-m-plot", "v-m-action-layerrange-content", "v-m-datapoints"],
            "supportedChartTypes": chartTypes
        },
        "handler": pan
    }, {
        "id": "pan_end_on_plot_pinch",
        "triggerEvent": {
            "name": "dragend",
            "targets": ["v-m-plot", "v-m-action-layerrange-content", "v-m-datapoints"],
            "supportedChartTypes": chartTypes
        },
        "handler": function(event, service) {
            if (!UADetector.isMobile()) {
                return;
            }

            if(service.getStatus("dragAsLasso")){
                service.fireEvent({name: "lassoend", data: event.data});
                service.removeStatus("dragAsLasso");
                return;
            }
            if (service.getStatus("needToPreventDefault") && 
                event.data.originalEvent.cancelable) {
                //some move event cannot be prevented. It is not a bug and
                //the check is just to prevent error messages.
                event.data.originalEvent.preventDefault();
            }
            service.removeStatus("panLastPoint");
            PlotGeometryKeeper.scroll.save(service);
        }
    }];
});

define('sap/viz/chart/behavior/config/TooltipBehaviorConfig',[
    "sap/viz/chart/behavior/config/handler/TooltipBehaviorHandler"
], function(TooltipBehaviorHandler) {

    return [{
        "id": "tooltipBehaviorDefinition",
        "handler": TooltipBehaviorHandler,
        "handlerType": "class",
        "triggerEvent": [{
            "name": "standAloneInitialized",
            "method": "standAloneInitialized"
        }, {
            "name": "afterBehaviorLoaded",
            "method": "initialized"
        },{
            "name": "beforeBehaviorUnloaded",
            "method": "unloadedClear"
        }, {
            "name": "afterChartRendered",
            "method": "refreshedTooltip"
        }, {
            "name": "showDetail",
            "method": "showDetail"
        }, {
            "name": "hideDetail",
            "method": "hideDetail"
        }, {
            "name": "showTooltipHoverOnPlot",
            "method": "showTooltipHoverOnPlot"
        }, {
            "name": "hideTooltipHoverOnPlot",
            "method": "hideTooltipHoverOnPlot"
        }, {
            "name": "showTooltipClickBigData",
            "method": "showTooltipClickBigData"
        }, {
            "name": "hideTooltipClickBigData",
            "method": "hideTooltipClickBigData"
        }, {
            "name": "extractTooltipData",
            "method": "extractTooltipData"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": [
                "info/100_stacked_bar", "info/100_stacked_column",
                "info/100_dual_stacked_bar", "info/100_dual_stacked_column",
                "info/trellis_100_stacked_bar", "info/trellis_100_stacked_column",
                "info/trellis_100_dual_stacked_bar", "info/trellis_100_dual_stacked_column",
                "info/100_area", "info/100_horizontal_area", "info/trellis_100_area",
                "info/trellis_100_horizontal_area"
            ],
            "method": "extractTooltipDataPercentage"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": [
                "info/pie", "info/donut", 'info/trellis_pie', 'info/trellis_donut'
            ],
            "method": "extractTooltipDataPie"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": ["info/time_bubble"],
            "method": "extractTooltipDataTimebubble"
        },{
            "name": "extractTooltipData",
            "supportedChartTypes": ["info/100_mekko", "info/100_horizontal_mekko"],
            "method": "extractTooltipDataPercentageMekko"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes":  [
                "info/timeseries_line",
                "info/timeseries_column",
                "info/timeseries_stacked_column",
                "info/timeseries_scatter",
                "info/timeseries_bubble",
                "info/timeseries_combination",
                "info/dual_timeseries_combination",
                "info/timeseries_stacked_combination",
                "info/timeseries_bullet"
            ],
            "method": "extractTooltipDataTimeLine"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": [
                "info/waterfall", "info/stacked_waterfall",
                "info/horizontal_waterfall", "info/horizontal_stacked_waterfall"
            ],
            "method": "extractTooltipDataWaterfall"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": [
                "info/combination", "info/horizontal_combination",
                "info/stacked_combination", "info/horizontal_stacked_combination",
                "info/dual_combination", "info/dual_horizontal_combination",
                "info/dual_stacked_combination", "info/dual_horizontal_stacked_combination"
            ],
            "method": "extractTooltipDataCombination"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": ["info/combinationEx", "info/trellis_combinationEx"],
            "method": "extractTooltipDataComboEx"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": ["info/timeseries_100_stacked_column"],
            "method": "extractTooltipDataTimeStackedColumnPercentage"
        }, {
            "name": "extractTooltipData",
            "supportedChartTypes": ["info/timeseries_waterfall"],
            "method": "extractTooltipDataTimeWaterfall"
        }]
    }];

});

define('sap/viz/chart/behavior/config/ZoomBehaviorConfig',[
    "sap/viz/framework/interaction/utils/PlotZoomUtils",
    "sap/viz/chart/components/plots/PlotGeometryKeeper",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/Constants"
], function(
    PlotZoomUtils,
    PlotGeometryKeeper,
    DataGraphics,
    Constants
) {
    var CHARTTYPE = [
        "info/100_dual_stacked_bar",
        "info/100_dual_stacked_column",
        "info/100_stacked_bar",
        "info/100_stacked_column",
        "info/bar",
        "info/bullet",
        "info/vertical_bullet",
        "info/column",
        "info/combination",
        "info/combinationEx",
        "info/dual_combination",
        "info/dual_bar",
        "info/dual_column",
        "info/dual_stacked_bar",
        "info/dual_stacked_column",
        "info/horizontal_combination",
        "info/dual_horizontal_combination",
        "info/stacked_bar",
        "info/stacked_column",
        "info/stacked_combination",
        "info/horizontal_stacked_combination",
        "info/dual_stacked_combination",
        "info/dual_horizontal_stacked_combination",
        "info/dual_horizontal_line",
        "info/dual_line",
        "info/horizontal_line",
        "info/line",
        "info/scatter",
        "info/bubble",
        "info/time_bubble",
        "info/timeseries_line",
        "info/timeseries_column",
        "info/timeseries_stacked_column",
        "info/timeseries_100_stacked_column",
        "info/timeseries_bubble",
        "info/timeseries_scatter",
        "info/timeseries_combination",
        "info/timeseries_bullet",
        "info/dual_timeseries_combination",
        "info/timeseries_stacked_combination",
        "info/timeseries_waterfall",
        "info/waterfall",
        "info/stacked_waterfall",
        "info/horizontal_stacked_waterfall",
        "info/horizontal_waterfall",
        "info/area"
    ];

    var AREA_ATTR_TOKEEP = ["stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"];

    return [{
        id: "restore_size_and_position_on_render",
        triggerEvent: {
            name: "afterChartRendered"
        },
        handler: function(e, service) {
            var properties = service.getProperties();
            if (properties.get("plotArea.scrollbar.visible") === false){
                service.setStatus("plotArea.window", []);
                return;
            }
            // When change chart's "interaction.behaviorType" from
            // "DesignTimeBehavior" to default and match the following 4
            // conditions, it should not restore the previous zoom and scroll status.
            // TODO: distinguish which action(plotArea.isFixedDataPointSize or
            // zoomInOut) causes the change of zoom status
            if((properties.get("plotArea.isFixedDataPointSize") === false) &&
                (properties.get("interaction.zoom.enablement") !==
                    "enabled") &&
                !properties.get("plotArea.window.start") &&
                !properties.get("plotArea.window.end")
                ) {
                return;
            }
            if (PlotGeometryKeeper.hasRangeChange(service)) {
                service.setStatus("plotArea.window", service.getStatusManager().get("plotArea.window"));
                PlotGeometryKeeper.size.save(service);
                PlotGeometryKeeper.scroll.save(service);
            } else {
                PlotGeometryKeeper.size.load(service);
                PlotGeometryKeeper.scroll.load(service);
            }
        }
    }, {
        id: "discard_saved_zoom_onscalechange",
        triggerEvent: {
            name: "scalesUpdated"
        },
        handler: function(e, service) {
            if (e.data instanceof Array && e.data.some(function(s) {
                return s.feed !== "color" && s.feed !== "shape";
            })) {
                PlotGeometryKeeper.size.clear(service);
                PlotGeometryKeeper.scroll.clear(service);
            }
        }
    }, {
        id: "discard_saved_zoom_ondatachange",
        triggerEvent: {
            name: "dataUpdated"
        },
        handler: function(e, service) {
            PlotGeometryKeeper.size.clear(service);
            PlotGeometryKeeper.scroll.clear(service);
        }
    }, {
        id: "discard_saved_zoom",
        triggerEvent: {
            name: "discardSavedZoom"
        },
        handler: function(e, service) {
            PlotGeometryKeeper.size.clear(service);
            PlotGeometryKeeper.scroll.clear(service);
        }
    }, {
        id: "save_zoom",
        triggerEvent: {
            name: "saveZoom",
            "supportedChartTypes": CHARTTYPE
        },
        handler: function(e, service) {
            PlotGeometryKeeper.size.save(service);
            PlotGeometryKeeper.scroll.save(service);
        }
    }, {
        "id": "zoom_on_mousewheel_area_prezoom",
        "triggerEvent": {
            "name": "wheelmove",
            "targets": ["v-m-plot", "v-m-action-layerrange"],
            "supportedChartTypes": ["info/combinationEx"]
        },
        "handler": function(event, service) {
            if (!event.data.originalEvent.ctrlKey) {
                return;
            }

            var allDataPoints = [].slice.call(service.getNodes(service.NodeType.DATA_POINT, false)),
                areaDataPoints = allDataPoints.filter(function(node) {
                    return DataGraphics.getData(node).seriesType === "area";
                });
            service.setStatus("areaDpStyles", areaDataPoints.filter(function(node) {
                return node.getAttribute("opacity") !== "0";
            }).map(function(node) {
                var pathNode = node.querySelector("path");
                return {
                    dataId: node.getAttribute("data-id"),
                    opacity: node.getAttribute("opacity"),
                    pathAttrs: AREA_ATTR_TOKEEP.map(function(attr) {
                        return pathNode.getAttribute(attr);
                    })
                };
            }));
        }
    }, {
        "id": "zoom_on_mousewheel",
        "triggerEvent": {
            "name": "wheelmove",
            "targets": ["v-m-plot", "v-m-action-layerrange", "v-m-datapoints"],
            "supportedChartTypes": CHARTTYPE
        },
        "handler": function(event, service) {
            if (event.data.originalEvent.ctrlKey) {
                service.getNodes(service.NodeType.LEGEND_GROUP).select(".v-m-highlight").remove();
                service.getNodes(service.NodeType.MAIN_NODE).select(".v-m-highlight").remove();

                var dir = event.data.wheelDelta > 0 ? "in" : "out";
                var isBigDataBeforeZoom =service.isBigDataMode();

                service.getModule("main").getZoomer().zoomInOut(dir, event.data.point,
                    Constants.ZOOM.DEFAULT_ZOOM_LEVEL_STEPS_MOSUSEWHEEL);
                event.data.originalEvent.preventDefault();

                var isBigDataAfterZoom =service.isBigDataMode();
                if(isBigDataBeforeZoom && !isBigDataAfterZoom){
                    var actionLayer = service._getDecorationLayer();
                    actionLayer.clear();
                }
            }
        }
    }, {
        "id": "zoom_on_mousewheel_area_rehighlight",
        "triggerEvent": {
            "name": "wheelmove",
            "targets": ["v-m-plot", "v-m-action-layerrange"],
            "supportedChartTypes": ["info/combinationEx"]
        },
        "handler": function(event, service) {
            var areaDpStyles = service.getStatus("areaDpStyles");
            if (!event.data.originalEvent.ctrlKey || !areaDpStyles || !areaDpStyles.length) {
                return;
            }

            var dpNodes = service.getNodes(service.NodeType.DATA_POINT, false),
                dpNodesByDataId = [].reduce.call(dpNodes, function(dps, node) {
                    dps[node.getAttribute("data-id")] = node;
                    return dps;
                }, {});

            areaDpStyles.forEach(function(style) {
                var g = dpNodesByDataId[style.dataId], path;
                if (g) {
                    g.setAttribute("opacity", style.opacity);
                    path = g.querySelector("path");
                    AREA_ATTR_TOKEEP.forEach(function(attr, i) {
                        path.setAttribute(attr, style.pathAttrs[i]);
                    });
                }
            });

            var hoveringDp = service.getStatus("hoveringDataPoint");
            if (hoveringDp) {
                service.setStatus("hoveringDataPoint", dpNodesByDataId[hoveringDp.getAttribute("data-id")]);
            }
            service.removeStatus("areaDpStyles");
        }
    }];
});

define('sap/viz/chart/behavior/config/ScreenReaderUtil',[
    "jquery",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/chart/behavior/config/ContextualDataUtil',
    "sap/viz/chart/behavior/config/SelectionUtil",
    'sap/viz/framework/interaction/Constants'
], function( 
    jQuery,
    DataPointUtils,
    LangManager,
    DataGraphics,
    Constants,
    TypeUtils,
    ContextualDataUtil,
    SelectionUtil,
    SDKConstants
) {

    var HOURS = "hours";
    var MINUTES = "minutes";
    var SENCONDS = "senconds";
    
    var setNonInteractiveScreenReaderDesc = function(chartArguments, service) {
        
        var rootContainer = chartArguments.rootContainer;
        if (rootContainer.attr("markARIAforNonInteractive") === "true") {
            return;
        }
        rootContainer.attr("markARIAforNonInteractive", "true");

        var chartType = service._getRenderType();
        var rootNode = chartArguments.rootElement;
        var rootNode$ = rootNode.node();
        var chartAppId = chartArguments.chartAppId;
        var nonInteractiveAriaNode = rootNode.append('g').attr('class',Constants.CSS.CLASS.NONINTERACTIVEARIA);
        var ariaLabelId = rootContainer.attr('aria-labelledby');
        
        // set dataPoints Aria lable
        var dataPoints = rootNode$.querySelectorAll('.v-datapoint');
        ariaLabelId += setNonInteractiveAriaLabel(dataPoints, nonInteractiveAriaNode, service, 1, 
            'DataPoint', chartAppId);
        
        // set axis Aria lable
        var axises;
        if (isTimeseries(service)) {
            axises = rootNode$.querySelectorAll('.v-timeaxis-item');
        } else {
            var categoryAxisRootNode = rootNode$.querySelector('.v-m-categoryAxis');
            axises = categoryAxisRootNode ? categoryAxisRootNode.querySelectorAll('.v-axis-item') : [];
        }
        ariaLabelId += setNonInteractiveAriaLabel(axises, nonInteractiveAriaNode, service, 2, 
            'Axis', chartAppId);
        
        // set legend Aria lable
        var legendGroup = isTreeMap(service) || isHeatMap(service) ? 
            rootNode$.querySelectorAll('.v-mbc-legend-item') : 
            rootNode$.querySelectorAll('.v-legend-item');
        ariaLabelId += setNonInteractiveAriaLabel(legendGroup, nonInteractiveAriaNode, service, 3, 
            'Legend', chartAppId);

        // set categoryAxis2 aria label
        var categoryAxis2RootNode = rootNode$.querySelector('.v-m-categoryAxis2');
        if (categoryAxis2RootNode) {
            axises = categoryAxis2RootNode.querySelectorAll('.v-axis-item');
            ariaLabelId += setNonInteractiveAriaLabel(axises, nonInteractiveAriaNode, service, 4, 
                'Axis2', chartAppId);
        }

        rootContainer.attr('aria-labelledby', ariaLabelId);
    };

    var setNonInteractiveAriaLabel = function(targetNodes, nonInteractiveAriaNode, service, order, 
        type, chartAppId) {

        if (targetNodes.length === 0) {
            return "";
        } else {
            var currentId, description = '';
            var isTimeseriesChart = isTimeseries(service);
            for(var t = 0; t < targetNodes.length; t++) {
                description += ' ' + setDescription(service, targetNodes[t], isTimeseriesChart, order, true);
            }
            currentId = chartAppId + '-Aria' + type;
            nonInteractiveAriaNode.append('g').attr('aria-label', description).attr('id', currentId);
            return ' ' + currentId;
        }
    };

    var clearNonInteractiveAria = function(service, chartArguments) {
        
        var rootContainer = chartArguments.rootContainer;
        var rootContainer$ = rootContainer.node();
        if (rootContainer$.getAttribute("markARIAforNonInteractive")) {
            var chartAppId = chartArguments.chartAppId;
            rootContainer$.removeAttribute("markARIAforNonInteractive");
            rootContainer$.setAttribute('aria-labelledby', chartAppId + "-title");

            var ariaNode = chartArguments.rootElement.node()
                .querySelector('.' + Constants.CSS.CLASS.NONINTERACTIVEARIA);
            if (ariaNode) {
                ariaNode.parentNode.removeChild(ariaNode);
            }
        }
    };

    var setInteractiveScreenReaderDesc = function(service, target, isTimeseries) {
        setDescription(service, target, isTimeseries, null, false);
    };

    var setDescription = function(service, target, isTimeseries, tabOrder, isNonInteractive) {
        tabOrder = tabOrder || service.getStatus("tabOrder");
        if(!isNonInteractive && !isFocusable(service, tabOrder)){
            return;
        }
        var targetId = target.getAttribute("data-datapoint-id");
        var text = "";
        var valuesArray;
        var ctx;
        var units = service.getStatusManager().get("data.unit");
        switch (tabOrder) {
            case 1:
                if (isTreeMap(service) && !targetId){
                    text = ' Category Axis Item ' + text;
                    text += target.nextSibling.value;
                    if (!isNonInteractive) {
                        d3.select(target).attr("role", "option");
                    }
                    
                    break;
                }
                //Data Point
                text = ' Data Value ' + text;
                if (service && targetId) {
                    ctx = DataPointUtils.getContextByDataModel(target, service.getDataModel());
                }
                if (ctx) {
                    if(isTreeMap(service)){
                        delete ctx.level;
                        delete ctx.levelNum;
                        delete ctx.realLabelWidth;
                    }
                    
                    valuesArray = Object.keys(ctx);

                    if (isTimeseries) {
                        var measures = service.getDataModel().measures();
                        var bindings = service._dataModelMgr._bindings;
                        var tmpMeasure = [], removeMeasure = [];
                        for (var b in bindings) {
                            if (measures.indexOf(bindings[b].feed) !== -1) {
                                tmpMeasure = tmpMeasure.concat(bindings[b].source);
                            }
                        }
                        
                        var tmpValuesArray = valuesArray.filter(function(item) {
                            if (tmpMeasure.indexOf(item) === -1) {
                                return item;
                            } else {
                                removeMeasure.push(item);
                            }
                        });
                        valuesArray = tmpValuesArray.concat(removeMeasure);
                    }
                    
                    //The following code handle {v, d} case.
                    //Use .d ending string as key in ctx object is a bad idea,
                    //because user also can use .d as ending string in dataset.
                    var tmpCtx = {};
                    var dEndingList = [];
                    var nonDEndingList = [];
                    var displayKeys = [];
                    var pos;
                    valuesArray.forEach(function(elem) {
                        if (/(\.d)$/.test(elem)) {
                            dEndingList.push(elem);
                        } else {
                            nonDEndingList.push(elem);
                        }
                    });

                    if (dEndingList.length > 0) {
                        nonDEndingList.forEach(function(elem) {
                            pos = dEndingList.indexOf(elem + ".d");
                            if (pos > -1) {
                                dEndingList.splice(pos, 1);
                            }
                        });

                        dEndingList.forEach(function(elem) {
                            pos = dEndingList.indexOf(elem + ".d");
                            if (pos > -1) {
                                dEndingList.splice(pos, 1);
                            }
                        });
                    }

                    displayKeys = nonDEndingList.concat(dEndingList);

                    if (displayKeys.length !== valuesArray.length) {
                        valuesArray.forEach(function(key) {
                            if (displayKeys.indexOf(key) > -1 && valuesArray.indexOf(key + ".d") > -1) {
                                tmpCtx[key] = ctx[key + ".d"];
                            } else if (displayKeys.indexOf(key) > -1) {
                                tmpCtx[key] = ctx[key];
                            }
                        });
                        ctx = tmpCtx;
                        valuesArray = displayKeys;
                    }
                }
                //.attr('aria-posinset', DataPointUtils.getDataId(target) + 1)
                // .attr('aria-setsize', service.getDataModel().getDataPointCount())
                if (!isNonInteractive) {
                    d3.select(target).attr("role", "listitem");
                }
                break;
            case 2:
            case 4:
                //Category Axis
                text = (isTimeseries ? ' Time Axis Item ' : ' Category Axis Item ') + text;
                text += DataGraphics.getContext(target).text;
                if (!isNonInteractive) {
                    d3.select(target).attr("role", "option");
                }
                break;
            case 3:
                //Legend
                if(target.getAttribute('aria-posinset') === '1'){
                    //While tab to legend, its title should be read.
                    var propertyManager = service.getProperties();
                    if(propertyManager.get('legend.title.visible')){
                        text = " Legend title is " + service.getModule("legendGroup.legend").getLegendTitleText() +". ";
                    }
                }
                text = text + ' Legend Item ';
                valuesArray = DataGraphics.getContext(target).val;
                //The following code handle semantic color case.
                //The val is not array when legend text is customized by semantic color.
                if (!TypeUtils.isArray(valuesArray)) {
                    if (valuesArray === 'N/A') {
                        valuesArray = LangManager.get("IDS_ISNOVALUE");
                        text += valuesArray;
                    }
                    else {
                        var tempCtx = DataGraphics.getContext(target).ctx;
                        var measureName = tempCtx.measureName;
                        if (measureName) {
                            var min = tempCtx[measureName].min;
                            var max = tempCtx[measureName].openmax;
                            if (min === -Number.MAX_VALUE) {
                                text += " below " + max;
                            }
                            else if (max === Number.MAX_VALUE) {
                                text += " above " + min;
                            }
                            else {
                                text += min + " to " + max;
                            }
                        }
                        else {
                            text += valuesArray;
                        }

                    }
                    valuesArray = null;
                } else {
                    //The following code handle {v, d} case.
                    var tmpArray = [];
                    valuesArray.forEach(function(elem) {
                        if (!TypeUtils.isString(elem) && TypeUtils.isPlainObject(elem)) {
                            tmpArray.push(elem.d);
                        }
                    });
                    valuesArray = tmpArray.length > 0 ? tmpArray : valuesArray;
                }
                if (!isNonInteractive) {
                    d3.select(target).attr("role", "option").attr("tabindex", "0");
                }
                break;
        }

        var selectByTimeAxisGroup = service.getProperties().get("interaction.selectByTimeAxisGroup");
        if (valuesArray) {
            valuesArray.forEach(function(key) {
                if (tabOrder !== 3 && ctx) {
                    var val = ctx[key];
                    if (!TypeUtils.isExist(val)) {
                        val = LangManager.get("IDS_ISNOVALUE");
                    }
                    if (key !== Constants.BINDING.MEASURE_NAMES &&
                        key !== Constants.BINDING.CONTEXT_ID_NAME &&
                        !(/(\.parsedValue)$/.test(key))) {
                        //check the chart type is timeSeries
                        var dateVal = service.getModule("main.timeAxis");
                        if (key.toLowerCase() === Constants.DATA_TYPE.DATE  && dateVal) {
                            //check whether tooltip's applyTimeAxisFormat
                            var isApplyTimeAxisFormat = false;
                            //check chart is timeSeries
                            var dateObject = dateVal.getFormatTimeValue(ctx.Date);
                            //check whether tooltip's visible
                            if (service.getProperties().get("interaction.behaviorType") === "noHoverBehavior") {
                                var date = new Date(val);
                                text = dateObject.day + " " + date.getHours() + " " + HOURS + " " + date.getMinutes() +
                                    " " + MINUTES + " " + date.getSeconds() + " " + SENCONDS + " ";
                            } else {
                                if (service.getProperties().get("tooltip")) {
                                    isApplyTimeAxisFormat = service.getProperties().get("tooltip").applyTimeAxisFormat;
                                }
                                if (isApplyTimeAxisFormat) {
                                    text = (dateObject.time === null) ?
                                        dateObject.day + " " :
                                        dateObject.time + " " + dateObject.day + " ";
                                } else {
                                    var time = new Date(val);
                                    text = dateObject.day + " " + time.getHours() + " " + HOURS + " " +
                                        time.getMinutes() + " " + MINUTES + " " + time.getSeconds() +
                                        " " + SENCONDS + " ";
                                }
                            }
                        } else {
                            if(!selectByTimeAxisGroup) {
                                if(units && units[key]){
                                    text += key + " " + val + units[key] + " ";
                                } else{
                                    text += key + " " + val + " ";
                                }
                            }
                        }
                    }
                } else {
                    if (!TypeUtils.isExist(key)) {
                        key = LangManager.get("IDS_ISNOVALUE");
                    }
                    text += key + " ";
                }
            });
            if(selectByTimeAxisGroup && tabOrder === 1) {
                var metaData = service.getDataModel().color().metaData;
                var dims = metaData ? metaData.map(function(dim) {return dim.id;}) : [];
                metaData = service.getDataModel().context().metaData;
                var inResultDims = metaData ? metaData.filter(function(item){
                    return item.showInTooltip && item.type === 'Dimension';
                }).map(function(dim) {return dim.id;}) : [];
                dims = dims.concat(inResultDims);
                var recapTitle = service.getProperties().get("plotArea.dataLabel.recapTitle") ||
                    LangManager.get("IDS_END_OF_PERIOD");
                var dps = ContextualDataUtil.getDataPointsByTimeField(target, service);
                dps.forEach(function(dp){
                    var context = DataGraphics.getContext(dp);
                    var dimText = "", measrueText = "";
                    for(var key in context) {
                        if(context.hasOwnProperty(key)) {
                            if (key !== Constants.BINDING.MEASURE_NAMES &&
                                key.toLowerCase() !== Constants.DATA_TYPE.DATE &&
                                !(/(\.parsedValue)$/.test(key))) {
                                if(dims.indexOf(key) === -1) {
                                    measrueText += key + " " + context[key] + " ";
                                } else {
                                    dimText += context[key] + " ";
                                }
                            }
                        }
                    }
                    text += dimText + measrueText;
                    var recap = DataGraphics.getData(dp).recap;
                    if(recap) {
                        text += recapTitle + " " + recap.value;
                    }
                });
            }
        }
        if(!isNonInteractive && tabOrder === 1 && 
            SelectionUtil.hasDataPoint(service.getStatus("selectedDataPoints"), targetId)){
            text = text + ' is selected';
        }
        text += ". ";
        if(!isNonInteractive) {
            d3.select(target).attr('aria-label', text).attr("focusable", true)
                .style('outline', 'none');

            if (typeof target.focus === "function") {
                target.focus();
            } else {
                HTMLElement.prototype.focus.call(target);
            }
        } else if (tabOrder === 3) {
            text += target.getAttribute('aria-posinset') + " of " +
                target.getAttribute('aria-setsize') + ". ";
        }
        return text;
    };

    var isFocusable = function(service, tabOrder){
        var focusable = true;
        var selectability = service.getProperties().get("interaction.selectability");
        if (!selectability) {
            focusable = false;
        } else {
            var selectionMode = (selectability.mode || "").toUpperCase();
            var currentSelectionBehavior = (selectability.behavior || "").toUpperCase();
            if (selectionMode === SDKConstants.SELECTION_MODE.NONE) {
                focusable = false;
            } else {
                switch(tabOrder){
                    case 1:
                        //Data Point
                        focusable = selectability.plotStdSelection;
                        break;
                    case 3:
                        //Legend
                        if(!selectability.legendSelection ||
                            (selectionMode === SDKConstants.SELECTION_MODE.SINGLE &&
                            currentSelectionBehavior !== SDKConstants.SELECTION_BEHAVIOR.SERIES)){
                            focusable = false;
                        }
                        break;
                    case 2:
                    case 4:
                        if(!selectability.axisLabelSelection ||
                            (selectionMode === SDKConstants.SELECTION_MODE.SINGLE &&
                            currentSelectionBehavior !== SDKConstants.SELECTION_BEHAVIOR.CATEGORY)){
                            focusable = false;
                        }
                        break;
                }
            }
        }
        return focusable;
    };


    var isTreeMap = function (service) {
        var chartType = service._getRenderType();
        return (chartType.indexOf("treemap") > -1);
    };

    var isHeatMap = function (service) {
        var chartType = service._getRenderType();
        return (chartType.indexOf("heatmap") > -1);
    };

    var isTimeseries = function(service) {
        var chartType = service._getRenderType();
        return (chartType.indexOf("timeseries") > -1);
    };

    return {
        clearNonInteractiveAria: clearNonInteractiveAria,
        setInteractiveScreenReaderDesc: setInteractiveScreenReaderDesc,
        setNonInteractiveScreenReaderDesc: setNonInteractiveScreenReaderDesc
    };
});
define('sap/viz/chart/behavior/config/ScreenReaderConfig',[
    "sap/viz/chart/behavior/config/ScreenReaderUtil"
], function(
    ScreenReaderUtil
) {
    var chartFocusAction = [{
        "id": "focus_chart_on_non_interactive_mode",
        "triggerEvent": {
            "name": "focusOnChart"
        },
        "handler": function (event, service) {
            ScreenReaderUtil.clearNonInteractiveAria(service, event.data);
            var chartDom = event.data.rootContainer.node();
            var isNonInteractive = service._propertyMgr.get('interaction.noninteractiveMode');

            if (isNonInteractive) {
                chartDom.onfocusin = function() {
                    ScreenReaderUtil.setNonInteractiveScreenReaderDesc(event.data, service);
                };
            } else if (chartDom.onfocusin) {
                chartDom.onfocusin = null;
            }
        }
    }];

    return chartFocusAction;
});
define('sap/viz/chart/behavior/config/handler/KeyboardBehaviorHandler',[
    'sap/viz/framework/common/util/SVG',
    "sap/viz/framework/common/util/UADetector",
    'sap/viz/framework/common/util/Constants',
    "sap/viz/chart/components/util/ScrollbarUtil",
    "sap/viz/chart/components/util/ChartConstants",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/framework/interaction/utils/PlotZoomUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/chart/components/plots/PlotGeometryKeeper",
    'sap/viz/framework/interaction/Constants',
    'sap/viz/chart/behavior/config/ContextualDataUtil',
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/chart/behavior/config/ScreenReaderUtil",
    "sap/viz/chart/components/util/BoundingBoxUtils",
    "sap/viz/chart/components/util/ChartTypeUtils"
], function(
    SVG,
    UADetector,
    Constants,
    ScrollbarUtil,
    ChartConstants,
    ChartComponentNavigatorFactory,
    DataPointUtils,
    SelectionUtil,
    PlotZoomUtils,
    DataGraphics,
    TypeUtils,
    LangManager,
    PlotGeometryKeeper,
    SDKConstants,
    ContextualDataUtil,
    ObjectUtils,
    ScreenReaderUtil,
    BoundingBox,
    ChartTypeUtils
) {

    var THRESHOLD = 0.05;
    var ADJUST_RATIO = 0.95;
    var TABORDER = "tabOrder";
    var DATAPOINT_NAVIGATOR = ChartConstants.DATAPOINT_NAVIGATOR;
    var CATEGORYAXIS_NAVIGATOR = ChartConstants.CATEGORYAXIS_NAVIGATOR;
    var CATEGORYAXIS2_NAVIGATOR = ChartConstants.CATEGORYAXIS2_NAVIGATOR;
    var TIMEAXIS_NAVIGATOR = ChartConstants.TIMEAXIS_NAVIGATOR;
    var LEGEND_NAVIGATOR = ChartConstants.LEGEND_NAVIGATOR;
    var COLORLEGEND_NAVIGATOR = ChartConstants.COLORLEGEND_NAVIGATOR;
    var MBCLEGEND_NAVIGATOR = ChartConstants.MBCLEGEND_NAVIGATOR;
    var DIMENSION_PARSED_VALUE = 'parsedValue';
    var MAIN_NODE = "mainNode";
    var LEGEND_GROUP = "legendGroup";
    var PLOT_NODE = "plotNode";
    var CATEGORYAXIS_NODE_BOUND = Constants.CSS.CLASS.CATEGORY_BOUND_SELECTION;
    var CATEGORYAXIS2_NODE_BOUND = Constants.CSS.CLASS.CATEGORY2_BOUND_SELECTION;
    var TIMEAXIS_NODE_BOUND = Constants.CSS.CLASS.TIME_BOUND_SELECTION;
    var LEGEND_NODE_BOUND = Constants.CSS.CLASS.LEGEND_BOUND_SELECTION;
    var PLOT_NODE_BOUND = Constants.CSS.CLASS.PLOT_BOUND_SELECTION;
    var LEGEND_ITEM_BOUND = Constants.CSS.CLASS.LEGEND_ITEM_BOUND_SELECTION;
    var AXIS_ITEM_NODE_BOUND = Constants.CSS.CLASS.AXIS_ITEM_BOUND_SELECTION;
    var DATAPOINTHOVER = Constants.CSS.CLASS.DATAPOINTHOVER;
    var ZEROVALUEHOVER = Constants.CSS.CLASS.ZEROVALUEHOVER;
    var ZERO_LINE_GROUP = Constants.CSS.CLASS.ZERO_LINE_GROUP;
    var STACK = Constants.CSS.CLASS.STACK;
    var FOCUS_INSIDE_CLASS = "v-focusInside";
    var ZERO_FOCUS = {
        RECT: 2,
        LINE: 1
    };

    var getLegendScrollbar = function(service) {
        return service.getModule("legendGroup.legend").getScrollbar();
    };

    var getSingleScrollbar = function(service) {
        var xyContainer = service.getModule("main");
        if (!xyContainer) {
            return null;
        }

        var isHorizontal = service.isHorizontal();
        if (isHorizontal === undefined) {
            return null;
        }
        if (isHorizontal) {
            return xyContainer.getVScrollbar();
        } else {
            return xyContainer.getHScrollbar();
        }
    };

    var getNextTarget = function(_navigator, event, nodeId, service) {
        var target = null;
        var eventName = event.name;
        var altKey = event.data.originalEvent.altKey;
        if (altKey) {
            switch (eventName) {
                case "uparrow":
                    target = _navigator.upSeries(nodeId);
                    break;
                case "downarrow":
                    target = _navigator.downSeries(nodeId);
                    break;
                case "leftarrow":
                    target = _navigator.leftSeries(nodeId);
                    break;
                case "rightarrow":
                    target = _navigator.rightSeries(nodeId);
                    break;
            }
        } else {
            switch (eventName) {
                case "uparrow":
                    var offset = 0;
                    if(service) {
                        offset = getPlot(service).getOffset();
                    }
                    target = _navigator.up(nodeId, offset);
                    break;
                case "downarrow":
                    target = _navigator.down(nodeId);
                    break;
                case "leftarrow":
                    target = _navigator.left(nodeId);
                    break;
                case "rightarrow":
                    target = _navigator.right(nodeId);
                    break;
            }
        }
        return target;
    };

    function getPlot(service){
        return service.getModule('main.plot') || service.getModule('plot');
    }

    function getPlotArea(service){
        return service.getModule('main') || service.getModule('plot');
    }

    function adjustVerticalOffset(realSize, plotSize, offsetXY, position, offset, isNegative) {
        // if having vertical scroll bar, move viewport to contain data point as possible as we can
        if (realSize.height !== plotSize.height) {
            // if need adjusting x and no adjustment for y, keep offset.x firstly
            offsetXY = offsetXY || {x: offset.x};
            // because there is max offset check in xycontainer, we can send offset directly
            offsetXY.y = null;

            if (isNegative) {
                if (position.y + position.height + offset.y > plotSize.height) {
                    // negative column bottom exceeds plot, adjust bottom space to fixed ratio
                    offsetXY.y = -(position.y + position.height - plotSize.height * ADJUST_RATIO);
                } else if (position.y + position.height + offset.y < plotSize.height * THRESHOLD) {
                    // negative column bottom does not reach threshold
                    if (position.height >= plotSize.height * (1 - THRESHOLD) ) {
                        // column height exceeds plot height, adjust bottom space to fixed ratio
                        offsetXY.y = -(position.y + position.height - plotSize.height * ADJUST_RATIO);
                    } else {
                        // else adjust top space to fixed ratio
                        offsetXY.y = -(position.y - plotSize.height * (1 - ADJUST_RATIO));
                    }
                }
            } else {
                if (position.y + offset.y > plotSize.height * (1 - THRESHOLD)) {
                    // positive column top does not reach threshold
                    if (position.height >= plotSize.height * (1 - THRESHOLD) ) {
                        // column height exceeds plot height, adjust top space to fixed ratio
                        offsetXY.y = -(position.y - plotSize.height * (1 - ADJUST_RATIO) );
                    } else {
                        // else adjust bottom space to fixed ratio
                        offsetXY.y = -(position.y + position.height - plotSize.height * ADJUST_RATIO);
                    }
                } else if (position.y + offset.y < 0) {
                    // positive column top exceeds plot, adjust top space to fixed ratio
                    offsetXY.y = -(position.y - plotSize.height * (1 - ADJUST_RATIO));
                }
            }
        }

        return offsetXY;
    }

    function adjustHorizontalOffset(realSize, plotSize, offsetXY, position, offset, isNegative) {
        // if having horizontal scroll bar, move viewport to contain data point as possible as we can
        if (realSize.width !== plotSize.width) {
            // if need adjusting y and no adjustment for x, keep offset.y firstly
            offsetXY = offsetXY || {y: offset.y};
            // because there is max offset check in xycontainer, we can send offset directly
            offsetXY.x = null;

            if (isNegative) {
                if (position.x + offset.x < 0) {
                    // negative bar left exceeds plot, adjust left space to fixed ratio
                    offsetXY.x = -(position.x - plotSize.width * (1 - ADJUST_RATIO) );
                } else if (position.x + offset.x > plotSize.width * (1 - THRESHOLD) ){
                    // negative bar left does not reach threshold
                    if (position.width > plotSize.width * (1 - THRESHOLD) ) {
                        // bar width exceeds plot width, adjust left space to fixed ratio
                        offsetXY.x = -(position.x - plotSize.width * (1 - ADJUST_RATIO) );
                    } else {
                        // else adjust right space to fixed ratio
                        offsetXY.x = -(position.x + position.width - plotSize.width * ADJUST_RATIO);
                    }
                }
            } else {
                if (position.x + position.width + offset.x < plotSize.width * THRESHOLD) {
                    // positive bar right does not reach threshold
                    if (position.width > plotSize.width * (1 - THRESHOLD) ) {
                        // bar width exceeds plot width, adjust right space to fixed ratio
                        offsetXY.x = -(position.x + position.width - plotSize.width * ADJUST_RATIO);
                    } else {
                        // else, adjust left space to fixed ratio
                        offsetXY.x = -(position.x - plotSize.width * (1 - ADJUST_RATIO) );
                    }
                } else if (position.x + position.width + offset.x > plotSize.width) {
                    // positive bar right exceeds plot, adjust right space to fixed ratio
                    offsetXY.x = -(position.x + position.width - plotSize.width * ADJUST_RATIO);
                }
            }
        }

        return offsetXY;
    }

    function scrollPlot(eventName, service, position, isHorizontal, adjustOptions){
        var plot = getPlot(service);
        var plotArea = getPlotArea(service);
        var offset = plot.getOffset();
        var plotSize = plot.getSize();
        var realSize = plot.getRealSize();

        var offsetXY = null;

        var isBubbleChart = service._getRenderType().indexOf("bubble") > - 1;
        var isScatterChart = service._getRenderType().indexOf("scatter") > -1;

        var originalPosition = {
            // For zero hover effect, the below if clause will make both width and height zero.
            // This will make zero hover effect invisible when scrolling.
            // Use a new object to record the original status.
            x: position.x,
            y: position.y,
            width: position.width,
            height: position.height
        };

        if (position.width === 0 || position.height === 0) {
            // remove line's width and height
            position.width = 0;
            position.height = 0;
        }

        if (isBubbleChart || isScatterChart) {
            // For scatter chart, position.height === 0 is always true
            // caused by getDataPointPosition() in ScatterPlot.js
            originalPosition = position;
        }

        // if yy chart
        if (isHorizontal == null && position.r != null) {

            // if circle center is in view port, the reference location is not adjusted
            if (position.x < -offset.x || position.x + position.r > -offset.x + plotSize.width ||
                position.y < -offset.y || position.y + position.r > -offset.y + plotSize.height) {

                if (eventName === "leftarrow") {
                    offsetXY = {x: -position.x, y: null};
                } else if (eventName === "rightarrow") {
                    offsetXY = {x: plotSize.width - position.x - position.width, y: null};
                } else if (eventName === "downarrow") {
                    offsetXY = {x: null, y: plotSize.height - position.y - position.height};
                } else {
                    offsetXY = {x: null, y: -position.y};
                }
            }
            if (adjustOptions.needAdjust) {
                if (["rightarrow", "leftarrow"].indexOf(eventName) !== -1) {
                    offsetXY = adjustVerticalOffset(realSize, plotSize, offsetXY, position, offset, true);
                } else {
                    offsetXY = adjustHorizontalOffset(realSize, plotSize, offsetXY, position, offset, true);
                }
            }

        } else if (isHorizontal === true) {
            // if not in current visible range, move scroll bar
            if (originalPosition.y < -offset.y || 
                originalPosition.y + originalPosition.height > plotSize.height - offset.y) {
                if ("downarrow" === eventName) {
                    var verticalOffset = originalPosition.y + originalPosition.height - plotSize.height;
                    offsetXY = {x: null, y: -verticalOffset};
                } else {
                    offsetXY = {x: null, y: -originalPosition.y};
                }
            }
            if (adjustOptions.needAdjust) {
                offsetXY = adjustHorizontalOffset(realSize, plotSize, offsetXY, position, offset,
                    adjustOptions.isNegative);
            }
        } else {
            // if not in current visible range, move scroll bar
            if (originalPosition.x < -offset.x || 
                originalPosition.x + originalPosition.width > plotSize.width - offset.x) {
                if ("rightarrow" === eventName) {
                    var horizontalOffset = originalPosition.x + originalPosition.width - plotSize.width;
                    offsetXY = {x: -horizontalOffset, y: null};
                } else {
                    offsetXY = {x: -originalPosition.x, y: null};
                }
            }
            if (adjustOptions.needAdjust) {
                offsetXY = adjustVerticalOffset(realSize, plotSize, offsetXY, position, offset,
                    adjustOptions.isNegative);
            }
        }

        if(offsetXY){
            // if scroll bar has no enough space to scroll, use max offset
            plotArea.scroll(offsetXY);
            if(this._isTimeseries) {
                var gator = this[TIMEAXIS_NAVIGATOR];
                var layers = service.getModule("main.timeAxis.axisBody").getActiveLabels();
                gator.updateCells(layers);
            }
            return true;
        }
        return false;
    }

    var scrollLegend = function(event, service, hoveredTarget){
        if (!hoveredTarget) {
            return;
        }
        var bodyBound = service.getNodes(service.NodeType.LEGEND_BODY_BOUND_SELECTION, false)[0];
        if (!bodyBound){
            return;
        }
        var visualBound = bodyBound.getBoundingClientRect();
        if (!visualBound) {
            return;
        }
        var hoveringBound = hoveredTarget.getBoundingClientRect();
        var boundingBoxOffset = 0;
        if (UADetector.isIE() || UADetector.isFirefox()) {
            boundingBoxOffset = 2;
        }
        var offset;
        if (hoveringBound.right > visualBound.right + boundingBoxOffset) {
            offset = (hoveringBound.right - visualBound.right);
        } else if (hoveringBound.left < visualBound.left - boundingBoxOffset) {
            offset = (hoveringBound.left - visualBound.left);
        } else if (hoveringBound.top < visualBound.top - boundingBoxOffset) {
            offset = (hoveringBound.top - visualBound.top);
        } else if (hoveringBound.bottom > visualBound.bottom + boundingBoxOffset) {
            offset = (hoveringBound.bottom - visualBound.bottom);
        }

        if (offset != null) {
            var module = service.getModule("legendGroup.legend");
            var scrollbarInst = module.getScrollbar();
            if(scrollbarInst && scrollbarInst.isExist()) {
                var ratio = scrollbarInst.getThumbRatio();
                offset /= ratio ? ratio : 1;
                module.scroll(offset);
            }
            event.data.originalEvent.preventDefault();
        }
    };

    function decorate(event, service, type, target, isTimeseries, byKeyboard) {

        if (!target) {
            if (isTimeseries) {
                /*
                 * When tab to continuous look timeaxis the axis item cannot be hovered,
                 * the target will be null, and we need to clear the plot hover status
                 */
                var hoveredTarget = service.getStatus("keyArrowHoveredDataPoint");
                if (hoveredTarget) {
                    service.fireEvent("unhoverOnDataPoint", {
                        targets: hoveredTarget
                    });
                }
            }
            return;
        }
        // Set screen reader text and focus target
        if(type === 'hover'){
            ScreenReaderUtil.setInteractiveScreenReaderDesc(service, target, isTimeseries);
        }

        var tabOrder = service.getStatus("tabOrder");
        if (tabOrder === 1 && event.name === "tab" &&
            service.getProperties().get("interaction.selectability.plotStdSelection")) {
            blurNode(d3.select(target), true);
        }
        var box = target.getBoundingClientRect();
        var plotBound = service.getBBox(service.BoxType.PLOT_BOUND_NODE);
        var visibleLeft, visibleRight, visibleTop, visibleBottom, renderType;
        var x, y;
        if (tabOrder === 1) {
            visibleLeft = Math.max(box.left, plotBound.left);
            visibleRight = Math.min(box.right, plotBound.right);
            visibleTop = Math.max(box.top, plotBound.top);
            visibleBottom = null;
            renderType = service._getRenderType();
            if (renderType.indexOf("pie") > -1 ||
                renderType.indexOf("donut") > -1 ||
                renderType.indexOf("bubble") > -1 ||
                renderType.indexOf("scatter") > -1 ||
                renderType.indexOf("heatmap") > -1 ||
                renderType.indexOf("treemap") > -1) {
                visibleBottom = Math.min(box.bottom, plotBound.bottom);
            }
            x = (visibleLeft + visibleRight) / 2;
            y = visibleBottom ? (visibleTop + visibleBottom) / 2 : visibleTop;
        } else {
            x = (box.left + box.right) / 2;
            y = (box.top + box.bottom) / 2;
        }

        service.fireEvent(type, {
            target: target,
            ctrlKey: event.data.originalEvent.ctrlKey,
            point: {
                x: x,
                y: y
            },
            byKeyboard: !!byKeyboard
        });
    }

    var highlightNodeHandler = function(mainBoundNode, hoveredTargetNode, boundNode,
        service, tabOrder, isTreeMapHeader) {
        if (boundNode) {
            var highlightProps = service.getProperties().get("interaction.keyboard");
            highlightProps.color = service.getEffectManager().register({
                fillColor: highlightProps.color
            });
            highlightProps.angle = service.getProperties().get('categoryAxis.label.angle');
            var selectByTimeAxisGroup =
                service.getProperties().get('interaction.selectByTimeAxisGroup');
            var data = DataGraphics.getData(hoveredTargetNode);
            if (TypeUtils.isExist(data)) {
                for (var prop in data) {
                    if (data.hasOwnProperty(prop) && !highlightProps.hasOwnProperty(prop)) {
                        highlightProps[prop] = data[prop];
                    }
                }
            }
            var renderType = service._getRenderType();
            highlightProps.renderType = renderType;
            highlightProps.isVerticalRender = ChartTypeUtils.getChartTypeProperty(renderType).isVerticalRender;
            if (tabOrder === 1 && selectByTimeAxisGroup) {
                var dps = ContextualDataUtil.getDataPointsByTimeField(
                    hoveredTargetNode, service);
                if (dps) {
                    dps.forEach(function(target) {
                        highlightNode(mainBoundNode,
                            d3.select(target), boundNode, highlightProps);
                    });
                }
            } else {
                highlightNode(mainBoundNode, isTreeMapHeader ?
                    d3.select(hoveredTargetNode.parentNode) :
                    d3.select(hoveredTargetNode), boundNode, highlightProps);
            }
        }
    };

    var isPercentageStackedChart = function(renderType) {
        return renderType.indexOf(ChartConstants.PERCENT_STACKED_COLUMN) > -1 || 
            renderType.indexOf(ChartConstants.PERCENT_STACKED_BAR) > -1;
    };

    var isTimeseriesWaterFall = function(renderType) {
        return renderType.indexOf(ChartConstants.TIMEWATERFALL) > -1;
    };

    var reShapeHorizontalHelper = function(transform, properties) {
        transform.a = !properties.isAllZero && properties.isAllValueNegative &&
            !isPercentageStackedChart(properties.renderType) && !properties.isNegative ? -1 : 1;
        return transform;
    };

    var reShapeVerticalHelper = function(transform, properties) {
        transform.d = !properties.isAllZero && properties.isAllValueNegative && 
            !isPercentageStackedChart(properties.renderType) && !properties.isNegative ? 1 : -1;
        return transform;
    };

    var reShapeTransform = function(transform, properties) {
        if (properties.isZeroValue) {
            var fn = properties.isVerticalRender ? reShapeVerticalHelper : reShapeHorizontalHelper;
            transform = fn(transform, properties);
        }
        return transform;
    };

    var reShapeSizeInfo = function(sizeInfo, properties) {
        if (properties.isZeroValue) {
            for (var key in sizeInfo) {
                if (sizeInfo[key] === 0) {
                    sizeInfo[key] = ZERO_FOCUS.RECT;
                }
            }
        }
        return sizeInfo;
    };

    var isOverLapInStack = function(hoverPos, stackPos, properties, delta) {
        if (properties.renderType.indexOf('stacked') > -1 && properties.isZeroValue) {
            if (!properties.isVerticalRender) {
                return hoverPos.left >= stackPos.left && hoverPos.right <= stackPos.right;
            } else {
                return hoverPos.top + delta >= stackPos.top && hoverPos.bottom - delta <= stackPos.bottom;
            }
        }
        return false;
    };

    var reShapeXY = function(pos, properties) {
        var XY = {
            deltaX: 0,
            deltaY: 0
        };
        if (properties.isZeroValue) {
            if (!properties.isVerticalRender) {
                if (pos.hoverPos.left < pos.axisPos.right) {
                    XY.deltaX = Math.abs(pos.hoverPos.left - pos.axisPos.right);
                }
                if (pos.hoverPos.top < pos.plotPos.top) {
                    XY.deltaY = Math.abs(pos.hoverPos.top - pos.plotPos.top);
                }
                if (pos.hoverPos.left < pos.wtfLinePos.right) {
                    XY.deltaX = Math.abs(pos.hoverPos.left - pos.wtfLinePos.right);
                }
            } else {
                if (pos.hoverPos.left < pos.plotPos.left) {
                    XY.deltaX = Math.abs(pos.hoverPos.left - pos.plotPos.left);
                } 
                if (pos.hoverPos.bottom > pos.axisPos.top) {
                    XY.deltaY = Math.abs(pos.hoverPos.bottom - pos.axisPos.top);
                }
                if (pos.hoverPos.bottom > pos.wtfLinePos.top) {
                    XY.deltaY = Math.abs(pos.hoverPos.bottom - pos.wtfLinePos.top);
                }
            }
        }
        return XY;
    };

    var getWTFLineNode = function(wtfLineNode, hoverPos, isHorizontal) {
        var closestNode = wtfLineNode[0];
        for (var i = 1; i < wtfLineNode.length; ++i) {
            if (isHorizontal) {
                if (Math.abs(wtfLineNode[i].getBoundingClientRect().left - hoverPos.left) < 
                    Math.abs(closestNode.getBoundingClientRect().left - hoverPos.left)) {
                    closestNode = wtfLineNode[i];
                }
            } else {
                if (Math.abs(wtfLineNode[i].getBoundingClientRect().top - hoverPos.top) < 
                    Math.abs(closestNode.getBoundingClientRect().top - hoverPos.top)) {
                    closestNode = wtfLineNode[i];
                }
            }
        }
        return closestNode;
    };

    var highlightNode = function(mainBoundNode, hoverNode, selectBound, properties) {
        blurNode(hoverNode);
        var d3Node = hoverNode.select(selectBound),
            currentNode = d3Node.node();
        if (!currentNode) {
            return;
        }
        var stackNode = d3.select(hoverNode.node().parentNode).node();
        var stackPos = TypeUtils.isExist(stackNode) ? 
            stackNode.getBoundingClientRect() : {};
        var data = DataGraphics.getData(currentNode);
        if (TypeUtils.isExist(data)) {
            properties.bTinyValue = data.bTinyValue;
        }
        var svgRect = currentNode.getBoundingClientRect(),
            digitalWidth = parseFloat(properties.width) || 1,
            dasharray = digitalWidth + ', ' + digitalWidth;
        var boundNode = hoverNode.append("g").attr("class", "v-m-highlight");
        var bound = {
            rect: null,
            line: null
        };

        var isStackedChart;
        if (properties.renderType) {
            isStackedChart = properties.renderType.indexOf('stacked') > -1;
        }

        var angle = properties.angle;

        if (isStackedChart && properties.isZeroValueInStack && properties.isZeroOnFirstTab) {
            bound.line = boundNode.append('line').attr('class', 'v-highlight-bound')
                .attr("stroke", properties.color)
                .attr("stroke-width", properties.width).attr("stroke-dasharray", dasharray)
                .style("pointer-events", "none" );
        } else {
            bound.rect =  boundNode.append("rect").attr("class", "v-highlight-bound")
                .attr("transform", d3Node.attr("transform"))
                .attr("width", d3Node.attr("width")).attr("height", d3Node.attr("height"))
                .attr("x", d3Node.attr("x")).attr("y", d3Node.attr("y"))
                .attr("fill", "transparent").attr("fill-opacity", 0)
                .attr("stroke", properties.color)
                .attr("stroke-width", properties.width).attr("stroke-dasharray", dasharray)
                .attr("shape-rendering", "crispEdges").style("pointer-events", "none");
        }

        if (selectBound === "rect" || selectBound === "path") {
            var transform = SVG.getTransformToElement(currentNode, hoverNode.node());
            var axisNode = d3.select(CATEGORYAXIS_NODE_BOUND).node() || 
                d3.select(CATEGORYAXIS2_NODE_BOUND).node() || d3.select(TIMEAXIS_NODE_BOUND).node();
            var axisPos = TypeUtils.isExist(axisNode) ? 
                axisNode.getBoundingClientRect() : {};
            var plotNode = d3.select(PLOT_NODE_BOUND).node();
            var plotPos = TypeUtils.isExist(plotNode) ? 
                plotNode.getBoundingClientRect() : {};
            var zeroLineNode = d3.select('.' + ZERO_LINE_GROUP).node();
            var zeroLinePos = TypeUtils.isExist(zeroLineNode) ? 
                zeroLineNode.getBoundingClientRect() : {};
            var wtfLineNode = [];
            if (properties.isZeroValue) {
                var wtf = d3.selectAll('.v-wtf-linkline');
                for (var i = 0; i < wtf[0].length; ++i) {
                    wtfLineNode.push(wtf[0][i]);
                }
            }
            var hoverPos = boundNode.node().getBoundingClientRect();
            var wtfLinePos = wtfLineNode.length > 0 ? 
                getWTFLineNode(wtfLineNode, hoverPos, !properties.isVerticalRender).getBoundingClientRect() : {};
            if (properties.isZeroValue && properties.isZeroOnFirstTab) {
                if (properties.isVerticalRender) {
                    properties.bCloseCategory = (axisPos.top <= hoverPos.top) || 
                        (plotPos.top <= hoverPos.top);
                } else {
                    properties.bCloseCategory = (axisPos.right <= hoverPos.left) || 
                        (plotPos.right <= hoverPos.left);
                }
            }
            if (!properties.isZeroValueInStack) {
                if (TypeUtils.isExist(hoverNode.select(".negative-datapoint").node())) {
                    properties.isNegative = true;
                }
                transform = reShapeTransform(transform, properties);
                boundNode.attr("transform", "translate(" + transform.e + "," + transform.f + ") " +
                "scale(" + transform.a + "," + transform.d + ") ");
            } else {
                var posTransformLine, negTransformLine;
                negTransformLine = {
                    a: properties.isVerticalRender ? 0 : 
                        isPercentageStackedChart(properties.renderType) ? 
                        (-1) * 0.5 * ZERO_FOCUS.LINE : 0.5 * ZERO_FOCUS.LINE,
                    b: properties.isVerticalRender ? isPercentageStackedChart(properties.renderType) ? 
                        0.5 * ZERO_FOCUS.LINE : (-1) * 0.5 * ZERO_FOCUS.LINE : 0
                };
                posTransformLine = negTransformLine;
                if (!properties.isAllValueNegative && !isPercentageStackedChart(properties.renderType)) {
                    posTransformLine = {
                        a: properties.isVerticalRender ? 0 : (-1) * 0.5 * ZERO_FOCUS.LINE,
                        b: properties.isVerticalRender ? 0.5 * ZERO_FOCUS.LINE : 0
                    };
                }
                transform = properties.isAllValueNegative ? negTransformLine : posTransformLine;
                if (properties.bCloseCategory) {
                    if (properties.isVerticalRender) {
                        transform.b *= -1;
                    } else {
                        transform.a *= -1;
                    }
                }
            }
            var x = d3Node.attr("x"), y = d3Node.attr("y");
            var width = selectBound === "rect" ? parseFloat(d3Node.attr("width")) : svgRect.width,
                height = selectBound === "rect" ? parseFloat(d3Node.attr("height")) : svgRect.height;
            var strokeWidth = parseFloat(d3Node.attr("stroke-width")) || 0;

            if (!properties.isZeroValue) {
                if (selectBound === "path") {
                    x -= 0.5 * width;
                    y -= 0.5 * height;
                }
                x -= strokeWidth;
                y -= strokeWidth;
                width = width ? width + 2 * strokeWidth : 0;
                height = height? height + 2 * strokeWidth : 0;
            }
            if (TypeUtils.isExist(bound.line) || TypeUtils.isExist(bound.rect)) {
                var pos = {
                    plotPos: plotPos, 
                    axisPos: axisPos,
                    zeroLine: {
                        zeroLinePos: zeroLinePos,
                        strokeWidth: TypeUtils.isExist(zeroLineNode) ? 
                            parseFloat(zeroLineNode.getAttribute('stroke-width')) : 0
                    },
                    hoverPos: hoverPos,
                    wtfLinePos: wtfLinePos
                };
                x += reShapeXY(pos, properties).deltaX;
                y += reShapeXY(pos, properties).deltaY;
            }
            var sizeInfo = {
                width: width,
                height: height
            };
            sizeInfo = reShapeSizeInfo(sizeInfo, properties);
            var zeroValueHoverNode, originalHoverNode, highlightNode, originalTransform;
            if (TypeUtils.isExist(bound.rect)) {
                bound.rect.attr("width", sizeInfo.width).attr("height", sizeInfo.height)
                    .attr("x", x).attr("y", y);
                if (properties.bTinyValue || isOverLapInStack(hoverPos, stackPos, properties, ZERO_FOCUS.RECT)) {
                    d3.select(stackNode).selectAll('.' + ZEROVALUEHOVER).remove();
                    zeroValueHoverNode = SVG.create('g');
                    originalHoverNode = d3.select('.' + DATAPOINTHOVER);
                    highlightNode = d3.select('.v-m-highlight');
                    zeroValueHoverNode.setAttribute('class', ZEROVALUEHOVER);
                    originalTransform = originalHoverNode.attr('transform');
                    zeroValueHoverNode.setAttribute('transform', originalTransform);
                    zeroValueHoverNode.appendChild(highlightNode.node());
                    stackNode.appendChild(zeroValueHoverNode);
                }
            } else {
                if (properties.isVerticalRender) {
                    bound.line.attr("x1", x).attr("y1", y).attr("x2", x + sizeInfo.width)
                        .attr("y2", y);
                } else {
                    bound.line.attr("x1", x).attr("y1", y).attr("x2", x)
                        .attr("y2",y + sizeInfo.height);
                }
                bound.line.attr("transform", "translate(" + transform.a + "," + transform.b + ")");
                if (properties.bCloseCategory || isOverLapInStack(hoverPos, stackPos, properties, ZERO_FOCUS.LINE)) {
                    if (properties.bCloseCategory) {
                        var defaultWidth = Math.max(parseFloat(properties.width), 2);
                        bound.line.attr("stroke-width", defaultWidth + '');
                    }
                    d3.select(stackNode).selectAll('.' + ZEROVALUEHOVER).remove();
                    zeroValueHoverNode = SVG.create('g');
                    originalHoverNode = d3.select('.' + DATAPOINTHOVER);
                    highlightNode = d3.select('.v-m-highlight');
                    zeroValueHoverNode.setAttribute('class', ZEROVALUEHOVER);
                    originalTransform = originalHoverNode.attr('transform');
                    zeroValueHoverNode.setAttribute('transform', originalTransform);
                    zeroValueHoverNode.appendChild(highlightNode.node());
                    stackNode.appendChild(zeroValueHoverNode);
                }
            }
            if (isTimeseriesWaterFall(properties.renderType)) {
                var prop = properties.isVerticalRender ? "height" : "width";
                var highlightNodes = d3.selectAll(".v-m-highlight")[0];
                if (highlightNodes) {
                    for (var p = 0; p < highlightNodes.length; ++p) {
                        if (parseFloat(d3.select(highlightNodes[p]).select(".v-highlight-bound").attr(prop)) === 0) {
                            d3.select(highlightNodes[p]).select(".v-highlight-bound").attr(prop, ZERO_FOCUS.RECT);
                        }
                    }
                }
            }
        } else if (!angle || angle % 90 === 0) {
            var parentRect = mainBoundNode.getBoundingClientRect();
            var intersectionBoundRect = BoundingBox.intersection(parentRect, svgRect);
            if (intersectionBoundRect) {
                bound.rect.attr("width", intersectionBoundRect.width)
                    .attr("height", intersectionBoundRect.height);
                /*
                * When there's scrollbar on the legend, set x = 0 or y = 0 instead of
                * keeping x/y as null, will make the Chrome render differently
                */
                if (intersectionBoundRect.left !== svgRect.left) {
                    bound.rect.attr("x", (parseFloat(d3Node.attr("x")) || 0) +
                        intersectionBoundRect.left - svgRect.left);
                }
                if (intersectionBoundRect.top !== svgRect.top) {
                    bound.rect.attr("y", (parseFloat(d3Node.attr("y")) || 0) +
                        intersectionBoundRect.top - svgRect.top);
                }
            }
        }
    };

    var blurNode = function(mainNode, bForced) {
        var highlightNodes = mainNode.selectAll(".v-m-highlight")[0];
        if (highlightNodes) {
            for (var i = 0; i < highlightNodes.length; ++i) {
                var data = DataGraphics.getData(highlightNodes[i].parentNode) || {};
                if (!data.isZeroValue || bForced) {
                    d3.select(highlightNodes[i]).remove();
                }
            }
        }
    };

    var isTreeMap = function (service) {
        var chartType = service._getRenderType();
        return (chartType.indexOf("treemap") > -1);
    };

    var getDataPointsCenterPoint = function(datapoints) {
        var i;
        var left, right, top, bottom;
        var centerX, centerY;
        if (datapoints.length === 0) {
            return null;
        }
        var dataPointBox = datapoints[0].getBoundingClientRect();
        left = dataPointBox.left;
        right = dataPointBox.right;
        top = dataPointBox.top;
        bottom = dataPointBox.bottom;

        for (i = 1; i < datapoints.length; ++i) {
            dataPointBox = datapoints[i].getBoundingClientRect();
            left = (dataPointBox.left < left) ? dataPointBox.left : left;
            right = (dataPointBox.right > right) ? dataPointBox.right : right;
            top = (dataPointBox.top < top) ? dataPointBox.top : top;
            bottom = (dataPointBox.bottom > bottom) ? dataPointBox.bottom : bottom;
        }

        centerX = (left + right) / 2;
        centerY = (top + bottom) / 2;

        if (centerX && centerY) {
            return {x: centerX, y: centerY};
        } else {
            return null;
        }
    };

    var clearAllHoveredEffectAndStatus = function(service) {
        var hoveredTarget = service.getStatus("keyArrowHoveredDataPoint");
        if (isTreeMap(service) && hoveredTarget) {
            var hoveredTargetId = service.getStatus("hoveredDataPointId");
            var groupNode = service.getNodes(service.NodeType.DATA_POINT_GROUP);
            var hoveredTargetNode =
                groupNode.selectAll("g.v-datapoint[data-datapoint-id='" + hoveredTargetId + "']").node();
            // whether it's datapoint or label
            if (hoveredTargetNode) {
                service.fireEvent("unhoverOnDataPoint", {
                    targets: hoveredTarget
                });
            }
        }
        else if (hoveredTarget) {
            service.fireEvent("unhoverOnDataPoint", {
                targets: hoveredTarget
            });
        }

        service.fireEvent("processUnhighlight");

        service.setStatus("keyArrowHoveredDataPoint", null);
        service.setStatus("hoveredDataPointId", null);
        service.setStatus("keyArrowHoveredCategoryLabel", null);
        service.setStatus("keyArrowHoveredCategory2Label", null);
        service.setStatus("keyArrowHoveredTimeLabel", null);
        service.setStatus("hoveredCategoryLabelId", null);
        service.setStatus("hoveredCategory2LabelId", null);
        service.setStatus("hoveredTimeLabelId", null);
        service.setStatus("orgHoveredTimeLabelId", null);
        service.setStatus("keyArrowHoveredLegendLabel", null);
        service.setStatus("hoveredLegendLabelId", null);
        service.setStatus("hoveredRadarLabelId", null);

        service._rootNode.selectAll('g[focusable="true"]').attr('focusable', false);
    };

    // make sure the direct handle functions only 2 parameters
    var arrowKeyHandler = function(event, service) {
        _arrowKeyHandler.call(this, event, service, undefined);
    };

    var getTargetsForTime = function (axisItem, service) {
        var axisCtx = DataPointUtils.getContext(axisItem);
        if (!axisCtx.hasOwnProperty('rectX')) {
            return;
        }
        SelectionUtil.cleanRangeSelection(service);
        var ctx = {}, dateField = service.getDataModel()._timeAxis.metaData[0].id;
        ctx[dateField + '.' + DIMENSION_PARSED_VALUE] = axisCtx.range;
        return SelectionUtil.getDataPointIds(ctx, service);
    };

    var _arrowKeyHandler = function (event, service, isFocusAgain, mainNode, mainBoundNode) {
        var tabOrder = service.getStatus("tabOrder");
        if (tabOrder === -1) {
            return;
        }

        event.data.originalEvent.preventDefault();

        var componentNavigator = null;
        var hoveredTargetNode = null;
        var hoveredTargetId = null;
        var hoveredTarget = null;
        var groupNode = null;
        var oldHovredTargetId = null;
        var isHorizontal = service.isHorizontal();
        var position;
        var adjustOptions = {};
        var boundNode = null;
        var renderType = service._getRenderType();
        var isTreeMapHeader = false;
        var isRadarChart = service._getRenderType().indexOf('radar') > -1;

        switch (tabOrder) {
            case 1:
                componentNavigator = this[DATAPOINT_NAVIGATOR];
                if (!componentNavigator){
                    return;
                }
                if (/line|bullet|pie|donut/.test(renderType)) {
                    boundNode = null;
                } else if (/scatter|bubble/.test(renderType)) {
                    boundNode = "path";
                }
                else {
                    boundNode = "rect";
                }
                hoveredTargetNode = service.getStatus("keyArrowHoveredDataPoint");
                oldHovredTargetId = service.getStatus("hoveredDataPointId");
                if (!hoveredTargetNode) {
                    hoveredTarget = componentNavigator.getFirstStartPoint();
                } else if(isFocusAgain){
                    hoveredTarget = componentNavigator.getDataPoint(oldHovredTargetId);
                }else{
                    hoveredTarget = getNextTarget(componentNavigator, event, oldHovredTargetId, service);
                }

                // if the first or last point, there are no next point in plot.
                if (!hoveredTarget) {
                    return;
                }

                if (this.plotScrollable) {
                    var address = hoveredTarget.address();
                    var plot = getPlot(service);
                    // Obtain position of current point.
                    position = plot.getDataPointPosition(address[1], address[0], true);
                    // some data points are not drawn at all, so they don't have position
                    if (!position) {
                        return;
                    }

                    adjustOptions.needAdjust = true;
                    adjustOptions.isNegative = false;
                    if (hoveredTarget._data) {
                        if (service._getRenderType().indexOf("bullet") > -1){
                            var item = plot.getData().series[address[1]][address[0]];
                            adjustOptions.isNegative = true;
                            ["actualValues", "additionalValues", "forecastValues"]
                            .forEach(function(key){
                                if(TypeUtils.isNumber(item[key]) && item[key] > 0){
                                    adjustOptions.isNegative = false;
                                }
                            });
                        } else {
                            adjustOptions.isNegative =
                                hoveredTarget._data[hoveredTarget._data.measureNames] < 0 ? true : false;
                        }
                        adjustOptions.isZeroValue = hoveredTarget._data[hoveredTarget._data.measureNames] === 0;
                    }
                    scrollPlot.call(this, event.name, service, position, isHorizontal, adjustOptions);
                }

                hoveredTargetId = hoveredTarget.id;
                groupNode = service.getNodes(service.NodeType.DATA_POINT_GROUP);
                hoveredTargetNode =
                    groupNode.selectAll("g.v-datapoint[data-datapoint-id='" + hoveredTargetId + "']").node();
                var prop = isHorizontal ? "width" : "height";
                var hoveredRect = d3.select(hoveredTargetNode).select("rect");
                var isZeroValueInStack;
                if (hoveredRect.node()) {
                    isZeroValueInStack = parseInt(hoveredRect.attr(prop)) === 0;
                }
                if (isZeroValueInStack) {
                    var prevHoveredNode = 
                        groupNode.selectAll("g.v-datapoint[data-datapoint-id='" + oldHovredTargetId + "']").node();
                    var nextTarget = getNextTarget(componentNavigator, event, hoveredTargetId, service) || {};
                    var nextHoveredNode = 
                        groupNode.selectAll("g.v-datapoint[data-datapoint-id='" + nextTarget.id + "']").node();
                    var node, trans;
                    var prev = isHorizontal ? "leftarrow" : "uparrow";
                    var next = isHorizontal ? "rightarrow" : "downarrow";
                    if (prevHoveredNode && nextHoveredNode) {
                        if (renderType === ChartConstants.STACKED_COMBINATION) {
                            switch (event.name) {
                                case prev: 
                                    node = (!this.isAllValueNegative) ? prevHoveredNode : nextHoveredNode;
                                    break;
                                case next:
                                    node = (!this.isAllValueNegative) ? nextHoveredNode : prevHoveredNode;
                                    break;
                            }
                        }
                        if (node) {
                            trans = node.getAttribute("transform");
                            hoveredTargetNode.setAttribute("transform", trans);
                        }
                    }
                }
                if (hoveredTargetNode == null && isTreeMap(service)){
                    hoveredTargetNode =
                        groupNode.selectAll("g [data-datapoint-id='" + hoveredTargetId + "'] .v-labelarea").node();
                    isTreeMapHeader = true;
                    boundNode = "rect.v-labelarea";
                }

                if (hoveredTargetId && hoveredTargetNode) {
                    service.setStatus("keyArrowHoveredDataPoint", hoveredTargetNode);
                    service.setStatus("hoveredDataPointId", hoveredTargetId);
                }
                service.fireEvent("saveZoom", {scroll: true});
                if (event && event.data && event.data.rootHandler) {
                    d3.select(event.data.rootHandler).classed(FOCUS_INSIDE_CLASS, true);
                }
                
                if (hoveredTarget && hoveredTarget._data && hoveredTargetNode) {
                    var hoveredTargetData = DataGraphics.getData(hoveredTargetNode);
                    var values, v;
                    if (this._isBulletChart) {
                        if (hoveredTarget && hoveredTarget._data) {
                            hoveredTargetData.isZeroValue = true;
                            var model = hoveredTarget._model;
                            if (model.hasOwnProperty("forecastValues")) {
                                values = model.forecastValues.values;
                                if (values) {
                                    v = values[hoveredTarget.address()[0]][hoveredTarget.address()[1]];
                                    if (TypeUtils.isArray(v)) {
                                        v = v[0];
                                    }
                                }
                                hoveredTargetData.isZeroValue = v === 0 || !TypeUtils.isExist(v);
                            }
                        }
                    } else if (this._isPieChart || this._isDonutChart) {
                        hoveredTargetData.isZeroValue = hoveredTargetData.startAngle === hoveredTargetData.endAngle;
                    } else if (this._isTimeseriesWaterFall) {
                        hoveredTargetData.isZeroValue = false;
                    } else {
                        hoveredTargetData.isZeroValue = hoveredTarget._data[hoveredTarget._data.measureNames] === 0;
                        if (hoveredTargetData.isZeroValue && TypeUtils.isExist(this.zeroValueInStackIndex)) {
                            var index = hoveredTarget.address()[0];
                            hoveredTargetData.isZeroValueInStack = this.zeroValueInStackIndex.indexOf(index) > -1;
                        }
                    }
                    hoveredTargetData.isAllValueNegative = this.isAllValueNegative;
                    hoveredTargetData.isAllZero = this.isAllZero;
                    DataGraphics.setData(hoveredTargetNode, hoveredTargetData);
                }
                break;
            case 2:
            case 4:
                if (isRadarChart) {
                    var axis = service.getNodes(service.NodeType.RADAR_AXIS).node();
                    var startIndex = 0;
                    var endIndex = axis.childElementCount - 1;
                    var data = DataGraphics.getData(axis);
                    if (TypeUtils.isUndefined(data)) {
                        DataGraphics.setData(axis, {
                            focusPos: 0
                        });
                    }
                    var hoveredIndex = DataGraphics.getData(axis).focusPos;
                    switch (event.name) {
                        case 'leftarrow':
                            if (hoveredIndex !== startIndex) {
                                hoveredIndex = (hoveredIndex === endIndex) ? startIndex : (hoveredIndex + 1);
                            }
                            break;
                        case 'rightarrow':
                            if (hoveredIndex !== startIndex + 1) {
                                hoveredIndex = (hoveredIndex === startIndex) ? endIndex : (hoveredIndex - 1);
                            }
                            break;
                    }
                    data = DataGraphics.getData(axis);
                    data.focusPos = hoveredIndex;
                    DataGraphics.setData(axis, data);
                    hoveredTargetNode = service.getNodes(service.NodeType.AXIS_ITEM)[0][hoveredIndex];
                    boundNode = AXIS_ITEM_NODE_BOUND;
                    service.setStatus("hoveredRadarLabelId", hoveredIndex);
                } else {
                    var axisBody = this._isTimeseries ? service.getModule('main.timeAxis.axisBody') :
                        (((tabOrder == 2) ? service.getModule('main.categoryAxis.axisBody') :
                            service.getModule('main.categoryAxis2.axisBody')));

                    if(axisBody.isOnlyShowingFirstAndLastLabel && axisBody.isOnlyShowingFirstAndLastLabel()){
                        return;
                    }

                    boundNode = AXIS_ITEM_NODE_BOUND;
                    componentNavigator = this._isTimeseries ? this[TIMEAXIS_NAVIGATOR] :
                        ((tabOrder == 2) ? this[CATEGORYAXIS_NAVIGATOR] : this[CATEGORYAXIS2_NAVIGATOR]);
                    hoveredTargetNode = this._isTimeseries ? service.getStatus("keyArrowHoveredTimeLabel") :
                        ((tabOrder == 2) ? service.getStatus("keyArrowHoveredCategoryLabel") :
                            service.getStatus("keyArrowHoveredCategory2Label"));
                    oldHovredTargetId = this._isTimeseries ? service.getStatus("hoveredTimeLabelId") :
                        ((tabOrder == 2) ? service.getStatus("hoveredCategoryLabelId") :
                            service.getStatus("hoveredCategory2LabelId"));
                    if (!hoveredTargetNode) {
                        if(this._isTimeseries) {
                            componentNavigator.updateCells(
                                service.getModule("main.timeAxis.axisBody").getActiveLabels());
                        }
                        hoveredTargetId = componentNavigator.getFirstStartPoint().id;
                    } else if(isFocusAgain){
                        hoveredTarget = componentNavigator.getCell(oldHovredTargetId);
                        hoveredTargetId = hoveredTarget && hoveredTarget.id ||
                            componentNavigator.getFirstStartPoint().id;
                    }else{
                        hoveredTarget = getNextTarget(componentNavigator, event, oldHovredTargetId, service);
                        hoveredTargetId = hoveredTarget && hoveredTarget.id;
                    }
                    // For the special case, when shift left or right, but the timeAxis doesn't buffer the label
                    var forceSrcoll = false;
                    if(!hoveredTargetId && oldHovredTargetId &&
                        this._isTimeseries && ["rightarrow", "leftarrow"].indexOf(event.name) > -1) {
                        var range = service.getModule("main.timeAxis.axisBody").getRange(),
                            targetValue = oldHovredTargetId.split('-')[1];
                        if(("leftarrow" === event.name && targetValue > range[0]) ||
                            ("rightarrow" === event.name && targetValue < range[1])) {
                            hoveredTargetId = oldHovredTargetId;
                            forceSrcoll = true;
                        }
                    }
                    if(hoveredTargetId != null){
                        position = axisBody.getCellPosition(hoveredTargetId);
                        if(forceSrcoll && position) {
                            if("rightarrow" === event.name) {
                                position.x = position.x + position.width;
                            }
                            else if("leftarrow" === event.name) {
                                position.x = position.x - position.width;
                            }
                        }
                        adjustOptions.needAdjust = false;
                        var scrolled;
                        if(this._isTimeseries && ["rightarrow", "leftarrow"].indexOf(event.name) === -1) {
                            scrolled = false;
                        }
                        else if (position) {
                            scrolled = scrollPlot.call(this, event.name, service, position, 
                                isHorizontal, adjustOptions);
                        }

                        if(this._isTimeseries) {
                            if(scrolled) {
                                // When scrolled, the navigator may be re-calculated
                                hoveredTarget = getNextTarget(componentNavigator, event, oldHovredTargetId, service);
                                hoveredTargetId = hoveredTarget && hoveredTarget.id;
                            }
                            if(!hoveredTargetId && forceSrcoll) {
                                hoveredTargetId = oldHovredTargetId;
                            }
                            groupNode = service.getNodes(service.NodeType.TIME_LABEL_GROUP);
                            hoveredTargetNode = groupNode.node().querySelector(
                                    "g.v-label-interaction .v-timeaxis-item[timelabel-id='" + hoveredTargetId + "']") ||
                                groupNode.node().querySelector(
                                    "g.v-label-interaction .v-timeaxis-item-upperLevel[timelabel-id='" +
                                    hoveredTargetId + "']");
                        }
                        else {
                            groupNode = (tabOrder == 2)?
                                service.getNodes(service.NodeType.CATEGORY_LABEL_GROUP) :
                                service.getNodes(service.NodeType.CATEGORY2_LABEL_GROUP);
                            hoveredTargetNode = groupNode.node()
                                .querySelector("g.v-label[categorylabel-id='" + hoveredTargetId + "']");
                        }

                        if (hoveredTargetNode) {
                            if(this._isTimeseries) {
                                service.setStatus("keyArrowHoveredTimeLabel", hoveredTargetNode);
                                service.setStatus("hoveredTimeLabelId", hoveredTargetId);
                                service.setStatus("orgHoveredTimeLabelId", hoveredTargetId);
                            } else {
                                if (tabOrder === 2) {
                                    service.setStatus("keyArrowHoveredCategoryLabel", hoveredTargetNode);
                                    service.setStatus("hoveredCategoryLabelId", hoveredTargetId);
                                } else {
                                    service.setStatus("keyArrowHoveredCategory2Label", hoveredTargetNode);
                                    service.setStatus("hoveredCategory2LabelId", hoveredTargetId);
                                }
                            }
                        }
                    }
                }
                break;
            case 3:
                if (/bullet|timeseries_waterfall/.test(renderType)) {
                    service.fireEvent("processUnhighlight");
                    return;
                }

                boundNode = LEGEND_ITEM_BOUND;
                componentNavigator = this[LEGEND_NAVIGATOR];
                hoveredTargetNode = service.getStatus("keyArrowHoveredLegendLabel");
                oldHovredTargetId = service.getStatus("hoveredLegendLabelId");
                if (!hoveredTargetNode) {
                    hoveredTargetId = componentNavigator.getFirstStartPoint().id;
                } else if(isFocusAgain){
                    hoveredTarget = componentNavigator.getCell(oldHovredTargetId);
                    hoveredTargetId = hoveredTarget && hoveredTarget.id;
                }else{
                    hoveredTarget = getNextTarget(componentNavigator, event, oldHovredTargetId, service);
                    hoveredTargetId = hoveredTarget && hoveredTarget.id;
                }

                var semanticMgr = service.getSemanticManager();
                var legendNodeType = service.NodeType.LEGEND_ITEM;
                if ((renderType.indexOf("heatmap") > -1 ||
                    renderType.indexOf("treemap") > -1) &&
                    (!(semanticMgr.hasDataPointColorStyle() && semanticMgr.isOverrideMode()))){
                    legendNodeType = service.NodeType.MBC_LEGEND_ITEM;
                }
                var legendItems = service.getNodes(legendNodeType, false);

                function getLegendItemById(items, id) {
                    if (id == null){
                        return null;
                    }
                    for (var i = 0; i < items.length; ++i){
                        if (items[i].getAttribute("legendlabel-id") === id.toString()){
                            return items[i];
                        }
                    }
                    return null;
                }
                hoveredTargetNode = getLegendItemById(legendItems, hoveredTargetId);

                if (hoveredTargetId !== null && !hoveredTargetNode) {
                    if (!componentNavigator.isLastCellID(hoveredTargetId)) {
                        var legendMod = service.getModule("legendGroup.legend");
                        if (legendMod && legendMod.loadMore) {
                            legendMod.loadMore();
                            legendItems = service.getNodes(service.NodeType.LEGEND_ITEM, false);
                        }
                        hoveredTargetNode = getLegendItemById(legendItems, hoveredTargetId);
                    }
                }
                if (hoveredTargetId != null && hoveredTargetNode) {
                    scrollLegend(event, service, hoveredTargetNode);
                    service.setStatus("keyArrowHoveredLegendLabel", hoveredTargetNode);
                    service.setStatus("hoveredLegendLabelId", hoveredTargetId);
                }
                break;
        }

        var elements;
        if (this._isTimeseries) {
            if (tabOrder !== 1) {
                var dataPoints = getTargetsForTime(hoveredTargetNode, service);
                elements = DataPointUtils.getNodes(dataPoints, service);
                elements.forEach(function(e) {
                    extraData = DataGraphics.getData(e);
                    if (extraData.isZeroValue) {
                        extraData.isZeroOnFirstTab = false;
                    }
                    DataGraphics.setData(e, extraData);
                });
            }
        }
        if (hoveredTargetNode) {
            var extraData = DataGraphics.getData(hoveredTargetNode);
            if (!TypeUtils.isExist(extraData)) { 
                var condition = ObjectUtils.extendByRepalceArray({}, DataPointUtils.getContext(hoveredTargetNode).ctx);
                elements = SelectionUtil.getDataPointNodes(condition, service);
                elements.forEach(function(e) {
                    extraData = DataGraphics.getData(e);
                    if (extraData.isZeroValue) {
                        extraData.isZeroOnFirstTab = tabOrder === 1;
                    }
                    DataGraphics.setData(e, extraData);
                });
            } else {
                if (extraData.isZeroValue) {
                    extraData.isZeroOnFirstTab = tabOrder === 1;
                }
                DataGraphics.setData(hoveredTargetNode, extraData);
            }
        }

        decorate(event, service, 'hover', hoveredTargetNode, this._isTimeseries, true);

        if (mainNode) {
            this._mainNode = mainNode;
        }
        if (mainBoundNode) {
            this._mainBoundNode = this._mainNode.select(mainBoundNode).node();
        }

        if (hoveredTargetNode) {
            if (this._mainNode) {
                blurNode(this._mainNode);
            }
            highlightNodeHandler(this._mainBoundNode,
                hoveredTargetNode, boundNode, service, tabOrder, isTreeMapHeader);
        }
    };

    var clickHandler = function (event, service) {
        var hoveredTimeLabelId;
        var hoveredCategoryId;
        var hoveredDataPointId;
        var hoveredRadarLabelId;
        var tabOrder = service.getStatus("tabOrder");
        var hoveredTarget = null;
        var isRadarChart = service._getRenderType().indexOf('radar') > -1;
        switch (tabOrder) {
            case 1:
                hoveredDataPointId = service.getStatus("hoveredDataPointId");
                var dpGroupNode = service.getNodes(service.NodeType.DATA_POINT_GROUP);
                hoveredTarget = dpGroupNode.node()
                    .querySelector("g.v-datapoint[data-datapoint-id='" + hoveredDataPointId + "']");

                if (hoveredTarget == null && isTreeMap(service)){
                    hoveredTarget = dpGroupNode.node()
                        .querySelector("g [data-datapoint-id='" + hoveredDataPointId + "'] .v-labelarea");
                }
                break;
            case 2:
                if(this._isTimeseries) {
                    hoveredTimeLabelId = service.getStatus("hoveredTimeLabelId");
                    var timeLabelGroupNode = service.getNodes(service.NodeType.TIME_LABEL_GROUP);
                    hoveredTarget = timeLabelGroupNode.node().querySelector(
                            "g.v-label-interaction .v-timeaxis-item[timelabel-id='" + hoveredTimeLabelId + "']") ||
                        timeLabelGroupNode.node().querySelector(
                            "g.v-label-interaction .v-timeaxis-item-upperLevel[timelabel-id='" +
                            hoveredTimeLabelId + "']");
                } else if (isRadarChart) {
                    hoveredRadarLabelId = service.getStatus("hoveredRadarLabelId");
                    var radarLabelGroupNode = service.getNodes(service.NodeType.AXIS_ITEM);
                    hoveredTarget = radarLabelGroupNode[0][hoveredRadarLabelId];
                }
                else {
                    hoveredCategoryId = service.getStatus("hoveredCategoryLabelId");
                    var categoryGroupNode = service.getNodes(service.NodeType.CATEGORY_LABEL_GROUP);
                    hoveredTarget = categoryGroupNode.node()
                        .querySelector("g.v-label[categorylabel-id='" + hoveredCategoryId + "']");
                }
                break;
            case 3:
                hoveredTarget = service.getStatus("keyArrowHoveredLegendLabel");
                break;
            case 4:
                hoveredTarget = service.getStatus("keyArrowHoveredCategory2Label");
                break;
        }
        if (hoveredTarget) {
            if (tabOrder === 1 &&
                service.getProperties().get("interaction.selectability.plotStdSelection")) {
                // When type "Enter" on datapoint, remove the dashed line at first
                blurNode(this[MAIN_NODE]);
            }
            decorate(event, service, "click", hoveredTarget);
            decorate(event, service, "down", hoveredTarget);
            setTimeout(function() {
                decorate(event, service, "up", hoveredTarget);
            }, 100);
            event.data.originalEvent.preventDefault();
        }
    };

    var zoomKeyHandler = function(event, service) {
        if (!service.getStatusManager().get("plot.zoom")) {
            return;
        }

        if (event.data.originalEvent.altKey || event.data.originalEvent.ctrlKey) {
            return;
        }
        var tabOrder = service.getStatus("tabOrder");
        if (tabOrder != 1 && tabOrder != 2) {
            return;
        }
        event.data.originalEvent.preventDefault();

        var dir = null;
        var hoveredTarget, targets = [];
        if (event.name === "plus") {
            dir = "in";
        } else if (event.name === "minus") {
            dir = "out";
        }

        var hoveredDataPointId, dpGroupNode;
        var hoveredCategoryId, categoryGroupNode, timeGroupNode;
        var orgHoverdTargetId;
        var boundNode = null;
        var isTreeMapHeader = false;

        switch (tabOrder) {
            case 1:
                var renderType = service._getRenderType();
                if (/line|bullet|pie|donut/.test(renderType)) {
                    boundNode = null;
                } else if (/scatter|bubble/.test(renderType)) {
                    boundNode = "path";
                } else {
                    boundNode = "rect";
                }
                hoveredDataPointId = service.getStatus("hoveredDataPointId");
                dpGroupNode = service.getNodes(service.NodeType.DATA_POINT_GROUP);
                hoveredTarget = dpGroupNode.node()
                    .querySelector("g.v-datapoint[data-datapoint-id='" + hoveredDataPointId + "']");
                if (hoveredTarget) {
                    targets = TypeUtils.isArray(hoveredTarget) ? hoveredTarget : [hoveredTarget];
                }
                break;
            case 2:
                boundNode = AXIS_ITEM_NODE_BOUND;
                if(this._isTimeseries) {
                    hoveredCategoryId = service.getStatus("hoveredTimeLabelId");
                    timeGroupNode = service.getNodes(service.NodeType.TIME_LABEL_GROUP);
                    hoveredTarget = timeGroupNode.node().querySelector(
                            "g.v-label-interaction .v-timeaxis-item[timelabel-id='" + hoveredCategoryId + "']") ||
                        timeGroupNode.node().querySelector(
                            "g.v-label-interaction .v-timeaxis-item-upperLevel[timelabel-id='" +
                            hoveredCategoryId + "']");
                    service.setStatus("keyArrowHoveredTimeLabel", hoveredTarget);
                } else {
                    //Here use categoryLabel-id to query label because lazy rendering will mis-delete previous dom
                    hoveredCategoryId = service.getStatus("hoveredCategoryLabelId");
                    categoryGroupNode = service.getNodes(service.NodeType.CATEGORY_LABEL_GROUP);
                    hoveredTarget = categoryGroupNode.node()
                        .querySelector("g.v-label[categorylabel-id='" + hoveredCategoryId + "']");
                    service.setStatus("keyArrowHoveredCategoryLabel", hoveredTarget);
                }
                if (hoveredTarget) {
                    var ctx;
                    if(this._isTimeseries) {
                        ctx = DataPointUtils.getContext(hoveredTarget);
                        var dpCtx = {}, dateField = service.getDataModel()._timeAxis.metaData[0].id;
                        dpCtx[dateField + '.' + DIMENSION_PARSED_VALUE] = ctx.range;
                        targets = SelectionUtil.getDataPointNodes(dpCtx, service);
                    }
                    else {
                        ctx = DataPointUtils.getContext(hoveredTarget).ctx;
                        targets = SelectionUtil.getDataPointNodes(ctx, service);
                    }
                }
                break;
        }

        if (service._getRenderType().indexOf("bullet") > -1) {
            var hasVisiblePriAddFor = false;
            var hasTarget = false;
            var bulletTargets = [];
            for (var i = 0; i < targets.length; ++i) {
                var filteredItem = Array.prototype.slice.call(
                    targets[i].querySelectorAll(".v-primary, .v-additional, .v-forecast"));
                bulletTargets = bulletTargets.concat(filteredItem);

                if (!hasTarget && targets[i].querySelectorAll(".v-target").length > 0) {
                    hasTarget = true;
                }

                if (!hasVisiblePriAddFor) {
                    for (var j = 0; j < filteredItem.length; ++j) {
                        var box = filteredItem[j].getBoundingClientRect();
                        if (box.width && box.height) {
                            hasVisiblePriAddFor = true;
                            break;
                        }
                    }
                }
            }

            if (hasVisiblePriAddFor || !hasTarget) {
                targets = bulletTargets;
            }
        }

        var centerPoint = getDataPointsCenterPoint(targets);

        if (!centerPoint && tabOrder == 2 && hoveredTarget) {
            var categorylabelBox = hoveredTarget.getBoundingClientRect();
            var clx, cly;
            if (service.isHorizontal()) {
                clx = categorylabelBox.right;
                cly = (categorylabelBox.top + categorylabelBox.bottom) / 2;
            } else {
                clx = (categorylabelBox.left + categorylabelBox.right) / 2;
                cly = categorylabelBox.top;
            }

            centerPoint = {
                x: clx,
                y: cly
            };
        }

        var len0;
        if (tabOrder === 2) {
            len0 = this._isTimeseries ? service.getModule("main.timeAxis.axisBody").getActiveLabels().length :
                service.getModule("main.categoryAxis.axisBody").getActiveLevels().length;
        }

        service.getModule("main").getZoomer().zoomInOut(dir, centerPoint, 14);

        if (tabOrder === 2) {
            var node = this._isTimeseries ? timeGroupNode.node() : categoryGroupNode.node(),
                gator = this._isTimeseries ? this[TIMEAXIS_NAVIGATOR] : this[CATEGORYAXIS_NAVIGATOR],
                layers = this._isTimeseries ? service.getModule("main.timeAxis.axisBody").getActiveLabels() :
                    service.getModule("main.categoryAxis.axisBody").getActiveLevels(),
                len1 = layers.length;

            var cId = hoveredCategoryId, toKeep;
            if (len0 !== len1 && !this._isTimeseries && TypeUtils.isExist(cId)) {
                var hoveredDom = node.querySelector("g.v-label[categorylabel-id='" + cId + "']"),
                    parentCell = gator.getParentCell(cId);
                while (!hoveredDom && parentCell) {
                    cId = parentCell.id;
                    hoveredDom = node.querySelector("g.v-label[categorylabel-id='" + cId + "']");
                    parentCell = gator.getParentCell(cId);
                }
                toKeep = gator.getCell(cId).ctx;
                gator.updateCells(layers);
                hoveredCategoryId = (gator.findCell(toKeep) || gator.getFirstStartPoint()).id;
                service.setStatus("hoveredCategoryLabelId", hoveredCategoryId);
            }
            else if(this._isTimeseries) {
                gator.updateCells(layers);
                orgHoverdTargetId = service.getStatus("orgHoveredTimeLabelId");
                toKeep = orgHoverdTargetId ? (gator.getCell(orgHoverdTargetId) || {id : orgHoverdTargetId}) :
                    (gator.getCell(cId) || {id : cId});
                hoveredCategoryId = (gator.findCell(toKeep) || gator.getFirstStartPoint()).id;
                service.setStatus("hoveredTimeLabelId", hoveredCategoryId);
                if(!orgHoverdTargetId) {
                    service.setStatus("orgHoveredTimeLabelId", hoveredCategoryId);
                }
            }
            hoveredTarget = this._isTimeseries ? (node.querySelector(
                "g.v-label-interaction .v-timeaxis-item[timelabel-id='" + hoveredCategoryId + "']") ||
            node.querySelector(
                "g.v-label-interaction .v-timeaxis-item-upperLevel[timelabel-id='" + hoveredCategoryId + "']")) :
                node.querySelector("g.v-label[categorylabel-id='" + hoveredCategoryId + "']");
            if(this._isTimeseries) {
                service.setStatus("keyArrowHoveredTimeLabel", hoveredTarget);
            }
        } else if (tabOrder === 1) {
            hoveredTarget = dpGroupNode.node()
                .querySelector("g.v-datapoint[data-datapoint-id='" + hoveredDataPointId + "']");
        }

        decorate(event, service, "hover", hoveredTarget, this._isTimeseries, true);

        if (hoveredTarget) {
            highlightNodeHandler(this._mainBoundNode,
                hoveredTarget, boundNode, service, tabOrder, isTreeMapHeader);
        }

        return;
    };

    var KeyboardBehaviorHandler = function() {};

    KeyboardBehaviorHandler.prototype = {
        initialized: function(event, service) {
            service.setStatus("tabOrder", -1);
            this[MAIN_NODE] = service.getNodes(service.NodeType.MAIN_NODE);
            this[LEGEND_GROUP] = service.getNodes(service.NodeType.LEGEND_GROUP);
            this[PLOT_NODE] = service.getNodes(service.NodeType.PLOT_NODE);
            this._mainNode = null;
            this._mainBoundNode = null;

            var renderType = service._getRenderType();
            this._isTimeseries = renderType.indexOf('timeseries') > -1;
            var options = {
                "renderType": renderType,
                "dataModel": service.getDataModel(),
                "propertyManager": service.getProperties(),
                "treeRect": service.getStatusManager().get('treeRect'),
                "borderWidth": service.getProperties().get("plotArea.border.visible") ? 1 : 0,
                "isTimeseries": this._isTimeseries
            };

            this._isBulletChart = renderType.indexOf('bullet') > -1;
            this._isStackedChart = renderType.indexOf('stacked') > -1;
            this._isWaterFallChart = renderType.indexOf('waterfall') > -1;
            this._isPieChart = renderType.indexOf('pie') > -1;
            this._isTimeseriesWaterFall = renderType.indexOf('timeseries_waterfall') > -1;
            this._isDonutChart = renderType.indexOf('donut') > -1;
            this._isDualChart = service._getChartType().indexOf("dual") > -1; 
            this.isAllValueNegative = true;
            var series = getPlot(service).getData().series;
            var msr, i, j;
            if (this._isBulletChart) {
                msr = ["actualValues", "additionalValues", "forecastValues", "targetValues"];
                for (i = 0; i < series[0].length; ++i) {
                    for (var m = 0; m < msr.length; ++m) {
                        var value = series[0][i][msr[m]];
                        if (TypeUtils.isNumber(value) && value > 0) {
                            this.isAllValueNegative = false;
                            break;
                        }
                    }
                }
            } else if (this._isWaterFallChart) {
                this.isAllValueNegative = !(series[0].some(function(elem) {
                    return elem.base > 0 || elem.total > 0;
                }));
                this.isAllZero = !(series[0].some(function(elem) {
                    return elem.valueAxis !== 0;
                }));
            } else if (this._isPieChart || this._isDonutChart) {
                this.isAllValueNegative = !(series.some(function(elem) {
                    return elem[0].size > 0;
                }));
                this.isAllZero = !(series.some(function(elem) {
                    return elem[0].size !== 0;
                }));
            } else {
                this.isAllZero = true;
                for (i = 0; i < series.length; ++i) {
                    for (j = 0; j < series[i].length; ++j) {
                        if (series[i][j] && series[i][j].dp && series[i][j].dp._data) {
                            msr = series[i][j].dp._data[series[i][j].dp._data.measureNames];
                            if (msr !== 0) {
                                this.isAllZero = false;
                                break;    
                            }
                        }
                    }
                }
                for (i = 0; i < series.length; ++i) {
                    var findPosValue = false;
                    for (j = 0; j < series[i].length; ++j) {
                        if (series[i][j] && series[i][j].dp && series[i][j].dp._data) {
                            msr = series[i][j].dp._data[series[i][j].dp._data.measureNames];
                            if (msr > 0) {
                                findPosValue = true;
                                break;
                            }
                        }
                    }
                    if (findPosValue) {
                        this.isAllValueNegative = false;
                        break;
                    }
                }
                if (this._isStackedChart) {
                    this.zeroValueInStackIndex = [];
                    for (j = 0; j < series[0].length; ++j) {
                        var stack = [];
                        for (i = 0; i < series.length; ++i) {
                            if (TypeUtils.isExist(series[i][j]) && (TypeUtils.isExist(series[i][j].valueAxis) || 
                                TypeUtils.isExist(series[i][j].valueAxis2))) {
                                msr = TypeUtils.isExist(series[i][j].valueAxis) ? 
                                    series[i][j].valueAxis : series[i][j].valueAxis2;
                                stack.push(msr);
                            }
                        }
                        if (stack.indexOf(0) > -1) {
                            stack = stack.filter(function(item) {
                                return item !== 0;
                            });
                            if (stack.length > 0) {
                                this.zeroValueInStackIndex.push(j);
                            }
                        }
                    }
                }
            }
            var navigatorFactory = ChartComponentNavigatorFactory;
            var _navigator = !service.isBigDataMode() ?
                navigatorFactory.createNavigator(options, DATAPOINT_NAVIGATOR) : null;
            if (_navigator) {
                _navigator.init();
                this[DATAPOINT_NAVIGATOR] = _navigator;
                service.setStatus("keyArrowHoveredDataPoint", null);
            }

            options = {
                "renderType": renderType,
            };
            if (service.getModule("main.categoryAxis")){
                var axisBody = service.getModule("main.categoryAxis.axisBody");

                if(service._propertyMgr.get("categoryAxis.label.overlapBehavior") !== "auto"){
                    options.cells = axisBody.getActiveLevels.bind(axisBody);
                }else{
                    options.cells = axisBody.getActiveLevels();
                }

                if (options.cells) {
                    options.isVerticalRender = true;
                    _navigator = navigatorFactory.createNavigator(options, CATEGORYAXIS_NAVIGATOR);
                }

                if (_navigator) {
                    _navigator.init();
                    this[CATEGORYAXIS_NAVIGATOR] = _navigator;
                    service.setStatus("keyArrowHoveredCategoryLabel", null);
                }
            }

            if (service.getModule("main.categoryAxis2")){
                options.cells = service.getModule("main.categoryAxis2.axisBody").getActiveLevels();
                if (options.cells) {
                    options.isVerticalRender = false;
                    _navigator = navigatorFactory.createNavigator(options, CATEGORYAXIS_NAVIGATOR);
                }

                if (_navigator) {
                    _navigator.init();
                    this[CATEGORYAXIS2_NAVIGATOR] = _navigator;
                    service.setStatus("keyArrowHoveredCategory2Label", null);
                }
            }

            if (service.getModule("main.timeAxis")){
                options.cells = service.getModule("main.timeAxis.axisBody").getActiveLabels();
                if (options.cells) {
                    options.isVerticalRender = false;
                    _navigator = navigatorFactory.createNavigator(options, TIMEAXIS_NAVIGATOR);
                }

                if (_navigator) {
                    _navigator.init();
                    this[TIMEAXIS_NAVIGATOR] = _navigator;
                    service.setStatus("keyArrowHoveredTimeLabel", null);
                }
            }

            var legendModule = service.getModule("legendGroup.legend");
            if (legendModule && legendModule.isVisible()) {
                var legendType = legendModule.getType();
                if (legendType.search(/(ColorLegend|MBCLegend)/) != -1) {
                    var legendCells = legendModule.getActiveLevels();
                    if (legendCells) {
                        options = {
                            "renderType": service._getRenderType(),
                            "cells": legendCells
                        };
                        var navigatorType;
                        switch (legendType) {
                            case "ColorLegend":
                                navigatorType = COLORLEGEND_NAVIGATOR;
                                break;
                            case "MBCLegend":
                                navigatorType = MBCLEGEND_NAVIGATOR;
                                break;
                        }
                        _navigator = navigatorFactory.createNavigator(options, navigatorType);
                    }

                    if (_navigator) {
                        _navigator.init();
                        this[LEGEND_NAVIGATOR] = _navigator;
                        service.setStatus("keyArrowHoveredLegendLabel", null);
                    }
                }
            }

            var scrollbarInst = getSingleScrollbar(service);
            if (scrollbarInst && scrollbarInst.isExist()) {
                this.plotScrollable = true;
            }
            service.fireEvent(event, true);
        },

        unloaded: function(event, service) {
            service.fireEvent(event, true);
            if (this[DATAPOINT_NAVIGATOR]) {
                this[DATAPOINT_NAVIGATOR].destroy();
                this[DATAPOINT_NAVIGATOR] = null;
            }

            if (this[CATEGORYAXIS_NAVIGATOR]) {
                this[CATEGORYAXIS_NAVIGATOR].destroy();
                this[CATEGORYAXIS_NAVIGATOR] = null;
            }

            if (this[CATEGORYAXIS2_NAVIGATOR]) {
                this[CATEGORYAXIS2_NAVIGATOR].destroy();
                this[CATEGORYAXIS2_NAVIGATOR] = null;
            }

            if (this[TIMEAXIS_NAVIGATOR]) {
                this[TIMEAXIS_NAVIGATOR].destroy();
                this[TIMEAXIS_NAVIGATOR] = null;
            }

            if (this[LEGEND_NAVIGATOR]) {
                this[LEGEND_NAVIGATOR].destroy();
                this[LEGEND_NAVIGATOR] = null;
            }

            this[MAIN_NODE] = null;
            this[LEGEND_GROUP] = null;

            service.removeStatus("keyArrowHoveredDataPoint");
            service.removeStatus("keyArrowHoveredCategoryLabel");
            service.removeStatus("keyArrowHoveredCategory2Label");
            service.removeStatus("keyArrowHoveredTimeLabel");
            service.removeStatus("keyArrowHoveredLegendLabel");
            service.removeStatus("tabOrder");
            service.removeStatus("hoveredTimeLabelId");
            service.removeStatus("orgHoveredTimeLabelId");
        },

        uparrowHandler: function(event, service) {
            arrowKeyHandler.call(this, event, service);
        },

        downarrowHandler: function(event, service) {
            arrowKeyHandler.call(this, event, service);
        },

        leftarrowHandler: function(event, service) {
            arrowKeyHandler.call(this, event, service);
        },

        rightarrowHandler: function(event, service) {
            arrowKeyHandler.call(this, event, service);
        },

        tabKeyHandler: function(event, service) {
            //The main node of pie chart is plot node.
            var boundNode = PLOT_NODE_BOUND,
                mainNode = this[MAIN_NODE].empty() ? this[PLOT_NODE] : this[MAIN_NODE];
            var currentIdx = service.getStatus("tabOrder");
            var releaseTab = false;
            var shiftKey = event.data.originalEvent.shiftKey;
            var categoryAxisModule = service.getModule("main.categoryAxis");
            var categoryAxis2Module = service.getModule("main.categoryAxis2");
            var timeAxisModule = service.getModule("main.timeAxis");
            var legendModule = service.getModule("legendGroup.legend");
            var hoveredTarget = null;
            var axisBody = this._isTimeseries ? service.getModule('main.timeAxis.axisBody') :
                    (service.getModule('main.categoryAxis.axisBody') ||
                        service.getModule('main.categoryAxis2.axisBody'));
            var isOnlyShowingFirstAndLastLabel = axisBody &&
                axisBody.isOnlyShowingFirstAndLastLabel && axisBody.isOnlyShowingFirstAndLastLabel();

            var highlightAxis = function() {
                if (isOnlyShowingFirstAndLastLabel &&
                    (boundNode === CATEGORYAXIS_NODE_BOUND ||
                    boundNode === CATEGORYAXIS2_NODE_BOUND ||
                    boundNode === TIMEAXIS_NODE_BOUND)) {
                    var highlightProps = service.getProperties().get("interaction.keyboard");
                    highlightProps.color = service.getEffectManager().register({
                        fillColor: highlightProps.color
                    });
                    var mainBoundNode = mainNode.select(boundNode).node();
                    highlightNode(mainBoundNode, d3.select(mainBoundNode.parentNode),
                        ".v-bound", highlightProps);
                }
            };
            
            if (currentIdx === -1) {
                if (!shiftKey){
                    event.data.originalEvent.preventDefault();
                    currentIdx = 1;
                    highlightAxis();
                } else {
                    currentIdx = -1;
                    releaseTab = true;
                }
                service.setStatus("tabOrder", currentIdx);
            } else {
                switch (currentIdx) {
                    case 1:
                        blurNode(mainNode);
                        if (!shiftKey) {
                            if (service._getChartType().indexOf('radar') > -1) {
                                currentIdx++;
                            } else if (categoryAxisModule && categoryAxisModule.isVisible()) {
                                boundNode = CATEGORYAXIS_NODE_BOUND;
                                currentIdx++;
                            } else if(timeAxisModule && timeAxisModule.isVisible()) {
                                boundNode = TIMEAXIS_NODE_BOUND;
                                currentIdx++;
                            }
                            else if (legendModule && legendModule.isVisible()) {
                                mainNode = this[LEGEND_GROUP];
                                boundNode = LEGEND_NODE_BOUND;
                                currentIdx += 2;
                            }
                            else if (categoryAxis2Module && categoryAxis2Module.isVisible()) {
                                boundNode = CATEGORYAXIS2_NODE_BOUND;
                                currentIdx += 3;
                            }else {
                                currentIdx = -1;
                                releaseTab = true;
                            }
                        } else {
                            currentIdx = -1;
                            releaseTab = true;
                        }
                        break;
                    case 2:
                        blurNode(mainNode);
                        if (!shiftKey) {
                            if (!this._isBulletChart && legendModule && legendModule.isVisible()) {
                                mainNode = this[LEGEND_GROUP];
                                boundNode = LEGEND_NODE_BOUND;
                                currentIdx++;
                            }
                            else if (categoryAxis2Module && categoryAxis2Module.isVisible()) {
                                boundNode = CATEGORYAXIS2_NODE_BOUND;
                                currentIdx += 2;
                            }
                            else {
                                currentIdx = -1;
                                releaseTab = true;
                            }
                        } else {
                            boundNode = PLOT_NODE_BOUND;
                            currentIdx--;
                        }
                        break;
                    case 3:
                        blurNode(this[LEGEND_GROUP]);
                        if (!shiftKey) {
                            if (categoryAxis2Module && categoryAxis2Module.isVisible()) {
                                boundNode = CATEGORYAXIS2_NODE_BOUND;
                                currentIdx++;
                            } else {
                                currentIdx = -1;
                                releaseTab = true;
                            }
                        } else {
                            if (service._getRenderType().indexOf('radar') > -1) {
                                boundNode = AXIS_ITEM_NODE_BOUND;    
                                currentIdx--;
                            } else if (categoryAxisModule && categoryAxisModule.isVisible()) {
                                boundNode = CATEGORYAXIS_NODE_BOUND;
                                currentIdx--;
                            } else if(timeAxisModule && timeAxisModule.isVisible()) {
                                boundNode = TIMEAXIS_NODE_BOUND;
                                currentIdx--;
                            }
                            else {
                                service.fireEvent("processUnhighlight");
                                currentIdx = 1;
                            }
                        }
                        break;
                    case 4:
                        blurNode(mainNode);
                        if (!shiftKey) {
                            currentIdx = -1;
                            releaseTab = true;
                        } else if (legendModule && legendModule.isVisible()) {
                            mainNode = this[LEGEND_GROUP];
                            boundNode = LEGEND_NODE_BOUND;
                            currentIdx = 3;
                        } else if (categoryAxisModule && categoryAxisModule.isVisible()) {
                            boundNode = CATEGORYAXIS_NODE_BOUND;
                            currentIdx = 2;
                        } else {
                            boundNode = PLOT_NODE_BOUND;
                            currentIdx = 1;
                        }
                        break;
                }
                service.fireEvent("hideDetail", {
                    mode: "infoMode",
                    action: "interrupt"
                });
                service.setStatus("tabOrder", currentIdx);

                if (releaseTab) {
                    clearAllHoveredEffectAndStatus(service);
                    if (event && event.data && event.data.rootHandler) {
                        d3.select(event.data.rootHandler).classed(FOCUS_INSIDE_CLASS, false);
                    }
                    return;
                } else {
                    event.data.originalEvent.preventDefault();
                    highlightAxis();
                }

            }

            switch (currentIdx) {
                case 1:
                    hoveredTarget = service.getStatus("keyArrowHoveredDataPoint");
                    break;
                case 2:
                    hoveredTarget = this._isTimeseries ? service.getStatus("keyArrowHoveredTimeLabel") :
                        service.getStatus("keyArrowHoveredCategoryLabel");
                    break;
                case 3:
                    hoveredTarget = service.getStatus("keyArrowHoveredLegendLabel");
                    break;
                case 4:
                    hoveredTarget = this._isTimeseries ? service.getStatus("keyArrowHoveredTimeLabel") :
                        service.getStatus("keyArrowHoveredCategory2Label");
                    break;
            }

            _arrowKeyHandler.call(this, event, service, !!hoveredTarget, mainNode, boundNode);
        },

        spaceKeyHandler: function(event, service) {
            clickHandler.call(this, event, service);
        },

        enterKeyHandler: function(event, service) {
            clickHandler.call(this, event, service);
        },

        plusKeyHandler: function(event, service) {
            zoomKeyHandler.call(this, event, service);
        },

        minusKeyHandler: function(event, service) {
            zoomKeyHandler.call(this, event, service);
        },

        clearHighlightBorder: function(event, service) {
            if(service.getStatus("tabOrder") === -1){
                blurNode(this[MAIN_NODE]);
                blurNode(this[LEGEND_GROUP]);
            }
        }
    };

    return KeyboardBehaviorHandler;
});

define('sap/viz/chart/behavior/config/KeyboardBehaviorConfig',[
    "sap/viz/chart/behavior/config/handler/KeyboardBehaviorHandler"
], function(KeyboardBehaviorHandler) {

    var supportedChartTypes = [
        "info/bar", "info/dual_bar",
        "info/stacked_bar", "info/dual_stacked_bar",
        "info/100_stacked_bar", "info/100_dual_stacked_bar",
        "info/column", "info/dual_column",
        "info/stacked_column", "info/dual_stacked_column",
        "info/100_stacked_column", "info/100_dual_stacked_column",
        "info/line", "info/horizontal_line",
        "info/combination", "info/horizontal_combination",
        "info/stacked_combination", "info/horizontal_stacked_combination",
        "info/dual_stacked_combination", "info/dual_horizontal_stacked_combination",
        "info/bullet", "info/vertical_bullet",
        "info/pie", "info/donut",
        "info/scatter", "info/bubble", "info/time_bubble",
        "info/timeseries_scatter", "info/timeseries_bubble",
        "info/dual_line", "info/dual_horizontal_line",
        "info/timeseries_line", "info/timeseries_column", "info/timeseries_bullet",
        "info/timeseries_stacked_column", "info/timeseries_100_stacked_column",
        "info/timeseries_combination","info/dual_timeseries_combination","info/timeseries_stacked_combination",
        "info/dual_combination", "info/dual_horizontal_combination",
        "info/heatmap", "info/waterfall", "info/horizontal_waterfall",
        "info/timeseries_waterfall","info/treemap",
        "info/area","info/radar"
    ];

    return [{
        "id": "keyboardBehaviorDefinition",
        "handler": KeyboardBehaviorHandler,
        "handlerType": "class",
        "triggerEvent": [{
            "name": "afterChartRendered",
            "supportedChartTypes": supportedChartTypes,
            "method": "initialized"
        }, {
            "name": "beforeBehaviorUnloaded",
            "supportedChartTypes": supportedChartTypes,
            "method": "unloaded"
        }, {
            "name": "uparrow",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "uparrowHandler"
        }, {
            "name": "downarrow",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "downarrowHandler"
        }, {
            "name": "leftarrow",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "leftarrowHandler"
        }, {
            "name": "rightarrow",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "rightarrowHandler"
        }, {
            "name": "tab",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "tabKeyHandler"
        }, {
            "name": "space",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "spaceKeyHandler"
        }, {
            "name": "enter",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "enterKeyHandler"
        }, {
            "name": "blur",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "clearHighlightBorder"
        }, {
            "name": "plus",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "plusKeyHandler"
        }, {
            "name": "minus",
            "targets": "*",
            "supportedChartTypes": supportedChartTypes,
            "method": "minusKeyHandler"
        }]
    }];
});

define('sap/viz/chart/behavior/DefaultBehavior',[
    "sap/viz/framework/interaction/Constants",
    "sap/viz/framework/interaction/BehaviorFactory",
    "sap/viz/framework/interaction/BehaviorManager",
    "sap/viz/chart/behavior/config/PlotScrollBehaviorConfig",
    "sap/viz/chart/behavior/config/AxisBehaviorConfig",
    "sap/viz/chart/behavior/config/ContextualDataConfig",
    "sap/viz/chart/behavior/config/LegendBehaviorConfig",
    "sap/viz/chart/behavior/config/LassoBehaviorConfig",
    "sap/viz/chart/behavior/config/DataPointBehaviorConfig",
    "sap/viz/chart/behavior/config/RuntimeSelectionHelperConfig",
    "sap/viz/chart/behavior/config/SelectionAPIConfig",
    "sap/viz/chart/behavior/config/PinchBehaviorConfig",
    "sap/viz/chart/behavior/config/TooltipBehaviorConfig",
    "sap/viz/chart/behavior/config/ZoomBehaviorConfig",
    "sap/viz/chart/behavior/config/ScreenReaderConfig",
    "sap/viz/chart/behavior/config/KeyboardBehaviorConfig"
], function(Constants, BehaviorFactory, BehaviorManager) {
    return BehaviorManager.register(Constants.BEHAVIOR.DEFAULT_BEHAVIOR_ID,
        BehaviorFactory.buildBehavior([].slice.call(arguments, 3)));
});

define('sap/viz/chart/behavior/SFinBehavior',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/interaction/Constants',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/BoundingBoxUtils",
    "sap/viz/framework/interaction/BehaviorManager",
    "sap/viz/chart/behavior/DefaultBehavior",
    "sap/viz/chart/behavior/config/handler/RuntimeSelectionHelperHandler",
    "sap/viz/chart/behavior/config/handler/TooltipBehaviorHandler",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler",
    "sap/viz/chart/behavior/config/SelectionTreeUtil",
    "sap/viz/chart/behavior/config/handler/AxisBehaviorHandler",
    "sap/viz/chart/behavior/config/handler/LegendBehaviorHandler",
    "sap/viz/chart/behavior/config/handler/LassoBehaviorHandler",
    "sap/viz/framework/common/util/ArrayUtils",
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/behavior/config/tooltip/TooltipUtils",
    "sap/viz/chart/behavior/config/handler/TooltipTimerHandler",
    'sap/viz/framework/common/util/DOM',
    'sap/viz/chart/behavior/config/ContextualDataUtil',
    'sap/viz/framework/common/util/DataUtils',

], function(
    oo,
    Constants,
    SDKConstants,
    DataPointUtils,
    DataGraphics,
    BoundingBox,
    BehaviorManager,
    RuntimeBehaviorRegistry,
    RuntimeSelectionHelperHandler,
    TooltipBehaviorHandler,
    SelectionUtil,
    DataPointBehaviorHandler,
    SelectionTreeUtil,
    AxisBehaviorHandler,
    LegendBehaviorHandler,
    LassoBehaviorHandler,
    ArrayUtils,
    TypeUtils,
    ObjectUtils,
    TooltipUtils,
    TooltipTimerHandler,
    DOM,
    ContextualDataUtil,
    DataUtils
) {

    var POP_LAYER = "pop";

    function getCoveredTarget(dpIds, service) {
        var plotBoundNode = service.getNodes(service.NodeType.PLOT_BOUND_SELECTION).node();
        if (!plotBoundNode) {
            return null;
        }

        var allDpNodes = service.getNodes(service.NodeType.DATA_POINT, false),
            dpNodes = DataPointUtils.findByDataPointIds(allDpNodes, dpIds);

        var dpOrder = dpIds.reduce(function(order, id, i) {
            order[id] = i;
            return order;
        }, {});
        dpNodes.sort(function(a, b) {
            return dpOrder[DataPointUtils.getDataPointId(a)] - dpOrder[DataPointUtils.getDataPointId(b)];
        });

        for (var i = 0, len = dpNodes.length; i < len; i++) {
            if (isInPlot(dpNodes[i], plotBoundNode)) {
                return dpNodes[i];
            }
        }

        return null;
    }

    function isInPlot(node, boundNode) {
        var boundRect = boundNode ? boundNode.getBoundingClientRect() : null;
        return node && boundRect && BoundingBox.intersects(boundRect,
            node.getBoundingClientRect());
    }

    function applyDimensionalSelection(service, ctx, option) {
        var selectionTree, metaInfo;
        var config = SelectionTreeUtil.bindingConfig;
        for (var item in ctx) {
            if (ctx.hasOwnProperty(item) && ctx[item]) {
                var treeName = config[item].selectionTree;
                selectionTree =  SelectionTreeUtil.getSelectionTree(service, option, treeName);
                metaInfo = service.getStatus(config[item].metaInfo);
                var obj = ctx[item];
                if (obj.or || obj instanceof Array) {
                    // call from click on axis(hierarchical) and selection api
                    var arr = obj.or || obj;
                    for (var i = 0; i < arr.length; ++i) {
                        SelectionTreeUtil.applyDimensionalSelection(service, treeName, selectionTree,
                            arr[i], option.isDeselect, metaInfo);
                    }
                } else {
                    // call from click on axis(non-hierarchical), legend and datapoint
                    SelectionTreeUtil.applyDimensionalSelection(service, treeName, selectionTree,
                        obj, option.isDeselect, metaInfo);
                }
            }
        }
    }


    var sFinBehavior = BehaviorManager.get("default").clone();

    var SFinRuntimeSelectionHelperHandler = function() {};

    oo.extend(SFinRuntimeSelectionHelperHandler, RuntimeSelectionHelperHandler);

    SFinRuntimeSelectionHelperHandler.prototype.processMultipleSelectionTooltip = function(event, service) {
        if (service.getStatus("selectedDataPoints").length) {
            service.fireEvent("showDetail");
        } else {
            service.fireEvent("hideDetail");
        }
    };

    SFinRuntimeSelectionHelperHandler.prototype.deselectAll = function(event, service) {
        SFinRuntimeSelectionHelperHandler.superclass.deselectAll.apply(this, arguments);
        service.setStatus("categorySelectionTree", {});
        service.setStatus("category2SelectionTree", {});
        service.setStatus("seriesSelectionTree", {});
    };

    SFinRuntimeSelectionHelperHandler.prototype.processSelection = function(event, service) {
        var option = SFinRuntimeSelectionHelperHandler.superclass.processSelection.apply(this, arguments);
        var selectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        selectionBehavior = selectionBehavior ? selectionBehavior.toUpperCase() : selectionBehavior;
        if (event.data.ctx && selectionBehavior !== SDKConstants.SELECTION_BEHAVIOR.DATAPOINT) {
            option.mode = event.data.mode;
            applyDimensionalSelection(service, event.data.ctx, option);
        }
    };

    SFinRuntimeSelectionHelperHandler.prototype.refreshedKeepSelection = function(event, service) {
        var needClear = SFinRuntimeSelectionHelperHandler.superclass.refreshedKeepSelection.apply(this, arguments);
        var selectionBehavior = service.getProperties().get("interaction.selectability.behavior");
        selectionBehavior = selectionBehavior ? selectionBehavior.toUpperCase() : selectionBehavior;
        if (needClear && selectionBehavior !== SDKConstants.SELECTION_BEHAVIOR.DATAPOINT) {
            SelectionTreeUtil.initSelectionTree(service);
        }
    };

    var EVENT_DATA_KEYS = ["id", "name", "type", "value"];
    SFinRuntimeSelectionHelperHandler.prototype._buildEventData = function(dpIDs, service) {
        var eventData = RuntimeSelectionHelperHandler.prototype._buildEventData.call(this, dpIDs, service);
        function trimTooltipData(ttData) {
            var trimed = Object.keys(ttData).reduce(function(data, key) {
                if (EVENT_DATA_KEYS.indexOf(key) !== -1) {
                    data[key] = ttData[key];
                }
                return data;
            }, {});
            return trimed;
        }

        var props = service.getProperties();

        var applyTimeAxisFormat = service.getProperties().get("tooltip.applyTimeAxisFormat");
        var formatString = service.getProperties().get("tooltip.formatString");
        var id;
        var timeAxis = service.getModule("main.timeAxis");
        if (timeAxis) {
            var dataModel = service.getDataModel();
            if (dataModel && dataModel._timeAxis) {
                id = dataModel._timeAxis.metaData[0].id;
                applyTimeAxisFormat = applyTimeAxisFormat &&
                    !(TypeUtils.isExist(formatString) && TypeUtils.isExist(formatString[id]));
            }
        }

        if (props.get("interaction.extraEventInfo")) {
            eventData.forEach(function(d, i) {
                service.fireEvent("extractTooltipData", {
                    target: d.target || {
                        context: d.data
                    }
                });

                var data = service.getStatus("tooltipData");
                // add .timeAxis to data for TooltipUtils.format to consume
                TooltipBehaviorHandler.processDateFormat.call(null, data, applyTimeAxisFormat, timeAxis);
                d.tooltipText = TooltipUtils.format({
                    data: data
                }, props).data.map(trimTooltipData);
            }.bind(this));
        }
        return eventData;
    };

    sFinBehavior.getActionById("runtimeSelectionHelperDefinition").setHandler(SFinRuntimeSelectionHelperHandler);

    var SFinDataPointBehaviorHandler = function() {};
    oo.extend(SFinDataPointBehaviorHandler, DataPointBehaviorHandler);

    function sFinClickOnDataPointHandler(event, service, target) {
        if (!SelectionTreeUtil.isSelectable(service, "DATAPOINT")) {
            return;
        }
        var selectability = service.getProperties().get("interaction.selectability");
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        if (!selectability.plotStdSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE || !target) {
            return;
        }
        var selectByTimeAxisGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');
        var config = event.data;
        var dp = [], series, i, ctx, id, pos;
        if(selectByTimeAxisGroup) {
            ctx = DataGraphics.getContext(target);
            var dps = ContextualDataUtil.getDataPointsByTimeField(target, service);
            var that = this;
            dps.forEach(function(g) {
                dp.push(that._getDataPoint(g, service));
            });
        }else {
            switch(selectability.behavior){
                case SDKConstants.SELECTION_BEHAVIOR.SERIES:
                    ctx = DataGraphics.getContext(target);
                    if (!ctx) {
                        //timeseries chart does not have ctx on dom
                        id = target.getAttribute("data-datapoint-id");
                        ctx = service.getDataModel().getDataPoint(id).context();
                    }
                    ctx = SelectionTreeUtil.applyFilterDimension(ctx, service, selectability.behavior);
                    dp = SelectionUtil.getTargets([{data: ctx.series}], service);
                    break;
                case SDKConstants.SELECTION_BEHAVIOR.CATEGORY:
                    ctx = DataGraphics.getContext(target);
                    ctx = SelectionTreeUtil.applyFilterDimension(ctx, service, selectability.behavior);
                    dp = SelectionUtil.getTargets([{data: ctx.categoryAxis}], service);
                    if (ctx.categoryAxis2) {
                        var dp2 = SelectionUtil.getTargets([{data: ctx.categoryAxis2}], service);
                        dp = dp.concat(dp2);
                        dp = ArrayUtils.unique(dp);
                    }
                    break;
                default:
                    dp = this._getDataPoint(target);
            }
        }

        var selectedBefore = this._hasDataPoint(service.getStatus("selectedDataPoints"),
            id || this._getDataPoint(target));
        service.fireEvent("processSelection", {
            ctx: ctx,  // sFinBehavior will check ctx to trigger category/series selection
            targets: dp,
            deselectable: true,
            ctrlKeyPressed: config.ctrlKey
        });
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        if (this._hasDataPoint(service.getStatus("selectedDataPoints"),
            id || this._getDataPoint(target))) {
            service.fireEvent("showDetail", {
                target: target
            });
        } else {
            if (selectedBefore) {
                target = getCoveredTarget(selectedDataPoints, service);
                if (target) {
                    service.fireEvent("showDetail", {
                        target: target
                    });
                }
            } else {
                service.fireEvent("hideDetail");
            }
            service.setStatus("isHoveringDeselectedDataPoint", selectedBefore);
        }
        service.fireEvent("hideDetail", {
            target: target,
            action: "select",
            type: "instantTooltip"
        });
    }

    function sFinHoverOnDataPointHandler(event, service, target) {
        //var target = event.data.currentTarget;
        if(!target) {
            // When hover on total label or recap label, the datapoint will be null
            return;
        }
        var point = event.data.point;
        var hoveringDataPoint = service.getStatus("hoveringDataPoint");
        var dp = this._getDataPoint(target);
        var selected = this._hasDataPoint(service.getStatus("selectedDataPoints"), dp);
        if (hoveringDataPoint) {
            if (hoveringDataPoint === target) {
                if (!service.getStatus("isHoveringDeselectedDataPoint")) {
                    service.fireEvent("showDetail", {
                        target : target,
                        point : point,
                        action: "hover",
                        originalEvent: event.data.originalEvent,
                        type: "instantTooltip"
                    });
                }
                return;
            }
            service.fireEvent("unhoverOnDataPoint", {
                targets: hoveringDataPoint
            });
        }
        if (hoveringDataPoint !== target) {
            service.setStatus("isHoveringDeselectedDataPoint", false);
        }
        hoveringDataPoint = target;
        service.fireEvent("hoverOnDataPoint", {
            targets: hoveringDataPoint,
            byKeyboard : !!event.data.byKeyboard
        }).setStatus("hoveringDataPoint", hoveringDataPoint).fireEvent("showDetail", {
            target : target,
            point : point,
            action: "hover",
            originalEvent: event.data.originalEvent,
            type: "instantTooltip"
        });
    }

    SFinDataPointBehaviorHandler.prototype.clickOnDataPoint = function(event, service) {
        sFinClickOnDataPointHandler.call(this, event, service, event.data.currentTarget);
    };

    SFinDataPointBehaviorHandler.prototype.clickOnDataLabel = function(event, service) {
        sFinClickOnDataPointHandler.call(this, event, service,
            DataPointUtils.getDataPointByDataLabel(event.data.currentTarget, service));
    };

    SFinDataPointBehaviorHandler.prototype.hoverOnDataPoint = function(event, service) {
        sFinHoverOnDataPointHandler.call(this, event, service, event.data.currentTarget);
    };

    SFinDataPointBehaviorHandler.prototype.hoverOnDataLabel = function(event, service) {
        sFinHoverOnDataPointHandler.call(this, event, service,
            DataPointUtils.getDataPointByDataLabel(event.data.currentTarget, service));
    };

    SFinDataPointBehaviorHandler.prototype.hoverOnNonDataPoint = function (event, service) {
        service.setStatus("isHoveringDeselectedDataPoint", false);
        var hoveringDataPoint = service.getStatus("hoveringDataPoint");
        if (hoveringDataPoint && !this.isHoveringDataPointHighlighted(service)) {
            service.fireEvent("unhoverOnDataPoint", {
                targets: hoveringDataPoint
            });
        }
        service.setStatus("hoveringDataPoint", null);
        service.fireEvent("hideDetail", {
            mode: "infoMode",
            target: "nonDataPoint",
            action: "interrupt",
            type: "instantTooltip"
        });
    };

    var dataPointBehaviorDefinitionAction = sFinBehavior.getActionById("dataPointBehaviorDefinition");

    dataPointBehaviorDefinitionAction.setHandler(SFinDataPointBehaviorHandler);

    var SFinTooltipBehaviorHandler = function() {};

    oo.extend(SFinTooltipBehaviorHandler, TooltipBehaviorHandler);

    function isInPlotBigData(offset, size, position) {
        size.left = -offset.x;
        size.top = -offset.y;
        position.left = position.x;
        position.top = position.y;
        return BoundingBox.intersects(size, position);
    }

    function drawSimulateTarget(position, service) {
        var actionLayer = service._getActionLayer();
        actionLayer.clear(POP_LAYER);
        var layer = actionLayer.createLayer(POP_LAYER);
        var matrix = service.getOffsetMatrix(service.OffsetType.PLOT_NODE, true);
        var plot = service.getModule("main.plot");
        var offset = plot.getOffset();
        offset.x += matrix.e;
        offset.y += matrix.f;
        layer.addRect({
            x: position.x + offset.x,
            y: position.y + offset.y,
            width: position.width,
            height: position.height,
            pointerEvent: "none",
            fill: "transparent",
            opacity: 0
        });

        return actionLayer.drawLayer(layer);
    }

    function getEventData(event, service) {
        var data, extraData, result, i, len,
            semanticMgr = service.getSemanticManager();
        var target = event.data.target;
        if (target) {
            service.fireEvent("extractTooltipData", {
                target: target
            });
            data = service.getStatus("tooltipData");

            result = semanticMgr.analyzeDataPoint('color,lineColor,lineType,pattern',
                    DataPointUtils.getContext(target), true, DataPointUtils.getAdditionCtx(target));
            if(result && result.dataName) {
                for(var k = 0; k < data.length; k++) {
                    var dataName = result.dataName[data[k].id];
                    data[k].dataName = TypeUtils.isNonEmptyString(dataName) ? dataName : data[k].name;
                }
            }
        }
        var selectedDataPoints = service.getStatus("selectedDataPoints");
        var evtData = {
            data: {
                val: data
            },
            selectedValues: selectedDataPoints.length
        };
        if (event.data.type === "instantTooltip") {
            evtData.point = event.data.point;
        }

        if (service.getProperties().get("interaction.selectByTimeAxisGroup")) {
            var selectedPeriods = SelectionUtil.getSelectedPeriods(service, selectedDataPoints);
            evtData.selectedValues = selectedPeriods.length;
        }

        var isDom = target && target.className && target.className.baseVal;
        //timeseries_stacked_combination's stacks are still doms even during big data
        if (service.isBigDataMode() && !isDom) {
            var plot = service.getModule("main.plot");
            var size = plot.getSize();
            var offset = plot.getOffset();
            var info;
            if (target) {
                info = plot.mappingDataPointInfo(target);
                if (info && info.position && isInPlotBigData(offset, size, info.position)) {
                    extraData = info.graphic;
                    evtData.target = drawSimulateTarget(info.position, service);
                }
            } else {
                for (i = 0, len = selectedDataPoints.length; i < len; i++) {
                    info = plot.mappingDataPointInfo(selectedDataPoints[i]);
                    if (info && info.position && isInPlotBigData(offset, size, info.position)) {
                        extraData = info.graphic;
                        evtData.target = drawSimulateTarget(info.position, service);
                        break;
                    }
                }
            }
        } else {
            if (target) {
                var plotBoundNode = service.getNodes(service.NodeType.PLOT_BOUND_SELECTION).node();
                evtData.target = isInPlot(target, plotBoundNode) ? target : null;
                extraData = DataGraphics.getData(target);

            } else {
                //No target means legend / axis label / lasso selection.
                //Set targe with the last selected datapoint.
                evtData.target = getCoveredTarget(selectedDataPoints, service);
                if (evtData.target) {
                    extraData = DataGraphics.getData(evtData.target);
                }
            }
        }
        evtData.data = ObjectUtils.extend(true, evtData.data,
            TooltipUtils.buildEventGraphicInfo(service, extraData, result));

        return evtData;
    }

    var SFinTooltipTimerHandler = function() {
        SFinTooltipTimerHandler.superclass.constructor.apply(this, arguments);
    };

    oo.extend(SFinTooltipTimerHandler, TooltipTimerHandler);

    SFinTooltipBehaviorHandler.prototype._createTooltipTimerHandler = function(event, service) {
        this._tooltipTimerHandler = new SFinTooltipTimerHandler();
    };

    SFinTooltipTimerHandler.prototype._selectedHandler = function() {
        if (this._showTimeOut) {
            clearTimeout(this._showTimeOut);
            this._showTimeOut = null;
        }
        if (this._hideTimeOut) {
            clearTimeout(this._hideTimeOut);
            this._hideTimeOut = null;
        }
        this._hideHandler();
    };

    SFinTooltipBehaviorHandler.prototype._getShowTooltipHandler = function(event, service) {
        function showTooltipHandler() {
            var data = getEventData(event, service);
            var renderType = service._getRenderType();
            var selectByTimeAxisGroup = service.getProperties().get("interaction.selectByTimeAxisGroup");
            if (renderType.indexOf('timeseries') > -1) {
                //Time chart
                var timeTooltipData = this._handleShowDetail(event, service),
                    tooltipData;
                if (timeTooltipData && timeTooltipData.tooltipData && timeTooltipData.tooltipData.data) {
                    tooltipData = timeTooltipData.tooltipData.data;
                }
                data = ObjectUtils.extend(true, data, {
                    'timeTooltipData' : tooltipData,
                    data : {
                        'selectByTimeAxisGroup' : selectByTimeAxisGroup
                    }
                });
            }
            var eventName = "showTooltip";
            if (event.data.type === "instantTooltip") {
                eventName = "showInstantTooltip";
            }
            service.fireExternalEvent(eventName, {
                name: Constants.Event.TooltipShow.name,
                data: data
            });
        }
        return showTooltipHandler.bind(this);
    };

    SFinTooltipBehaviorHandler.prototype._getHideTooltipHandler = function(event, service) {
        function hideTooltipHandler() {
            var eventName = "hideTooltip";
            if (event.data.type === "instantTooltip") {
                eventName = "hideInstantTooltip";
            }
            service.fireExternalEvent(eventName, {
                name: Constants.Event.TooltipHide.name
            });
        }
        return hideTooltipHandler.bind(this);
    };

    SFinTooltipBehaviorHandler.prototype._processDecoration = function(tooltipModule, tooltipData){
        if (TypeUtils.isArray(tooltipData.data)) {
            //Here we only need to format time dimension for UI5 time chart
            var props = tooltipModule._properties,
                formatString = props.get("tooltip.formatString"),
                isUTC = props.get('general.showAsUTC');
            tooltipData.data.forEach(function(rowItem, i){
                if (rowItem.type === "Dimension" && tooltipData.data.timeDimensions !== undefined &&
                    tooltipData.data.timeDimensions.indexOf(i) >= 0){
                    TooltipUtils.formatTimeDimension(rowItem, formatString, isUTC);
                }
            });
        }
    };

    SFinTooltipBehaviorHandler.prototype.refreshedTooltip = function(event, service) {
        this.hideDetail.apply(this, arguments);
        this._tooltipTimerHandler.reset();
    };


    //override hover/click handler for big data case
    SFinTooltipBehaviorHandler.prototype.showTooltipHoverOnPlot = function(event, service) {
        event.data.type = "instantTooltip";
        service.fireEvent("showDetail", event.data);
    };

    //override hover/click handler for big data case
    SFinTooltipBehaviorHandler.prototype.hideTooltipHoverOnPlot = function(event, service) {
        event.data.type = "instantTooltip";
        service.fireEvent("hideDetail", event.data);
    };

    //override hover/click handler for big data case
    SFinTooltipBehaviorHandler.prototype.showTooltipClickBigData = function(event, service) {
        service.fireEvent("showDetail", event.data);
        service.fireEvent("hideDetail", {
            target: event.data.target,
            action: "select",
            type: "instantTooltip"
        });
    };

    //override hover/click handler for big data case
    SFinTooltipBehaviorHandler.prototype.hideTooltipClickBigData = function(event, service) {
        service.fireEvent("hideDetail", event.data);
        service.fireEvent("hideDetail", {
            target: event.data.target,
            action: "deselect",
            type: "instantTooltip"
        });
    };

    var tooltipDefinitionAction = sFinBehavior.getActionById("tooltipBehaviorDefinition");

    tooltipDefinitionAction.setHandler(SFinTooltipBehaviorHandler);


    //override some default axis behaviors

    var SFinAxisBehaviorHandler = function() {};
    oo.extend(SFinAxisBehaviorHandler, AxisBehaviorHandler);

    SFinAxisBehaviorHandler.prototype.clickOnAxisLabel = function(event, service) {
        if (SelectionTreeUtil.isSelectable(service, "CATEGORY")) {
            SFinAxisBehaviorHandler.superclass.clickOnAxisLabel.apply(this, arguments);
        }
    };

    SFinAxisBehaviorHandler.prototype.filterCtx = function(ctx, rootCtx) {
        var filteredCtx = {};
        if (rootCtx && rootCtx.name === "categoryAxis2") {
            filteredCtx["categoryAxis2"] = ctx;
        } else {
            filteredCtx["categoryAxis"] =  ctx;
        }
        return filteredCtx;
    };

    var axisBehaviorDefinitionAction = sFinBehavior.getActionById("axisBehaviorDefinition");

    axisBehaviorDefinitionAction.setHandler(SFinAxisBehaviorHandler);

    //override some default legend behaviors

    var SFinLegendBehaviorHandler = function() {};
    oo.extend(SFinLegendBehaviorHandler, LegendBehaviorHandler);

    SFinLegendBehaviorHandler.prototype.click = function(event, service) {
        var behavior = service.getProperties().get("interaction.selectability.behavior");
        behavior = behavior ? behavior.toUpperCase() : behavior;
        var isSemantic = DataPointUtils.getContext(event.data.currentTarget).isSemantic;
        if (behavior === SDKConstants.SELECTION_BEHAVIOR.SERIES && isSemantic) {
            return;
        }
        if(SelectionTreeUtil.isSelectable(service, "SERIES")){
            SFinLegendBehaviorHandler.superclass.click.apply(this, arguments);
        }
    };

    var legendBehaviorDefinitionAction = sFinBehavior.getActionById("legendBehaviorDefinition");

    legendBehaviorDefinitionAction.setHandler(SFinLegendBehaviorHandler);

    //Override lasso behavior

    var SFinLassoBehaviorHandler = function() {};
    oo.extend(SFinLassoBehaviorHandler, LassoBehaviorHandler);

    SFinLassoBehaviorHandler.prototype.lassoStart = function(event, service) {
        var behavior = service.getProperties().get("interaction.selectability.behavior");
        if(behavior === SDKConstants.SELECTION_BEHAVIOR.DATAPOINT){
            SFinLassoBehaviorHandler.superclass.lassoStart.apply(this, arguments);
        }
    };

    SFinLassoBehaviorHandler.prototype._fireShowDetail = function(service, dpTarget, point) {
        service.fireEvent("showDetail", {
            target: dpTarget,
            mode: "actionMode",
            point: point,
            bLassoEnd: true
        });
        service.fireEvent("hideDetail", {
            action: "select",
            type: "instantTooltip"
        });
    };

    SFinLassoBehaviorHandler.prototype._fireHideDetail = function(service) {
        service.fireEvent("hideDetail", {
            mode: "actionMode"
        });
        service.fireEvent("hideDetail", {
            action: "select",
            type: "instantTooltip"
        });
    };

    var lassoBehaviorDefinitionAction = sFinBehavior.getActionById("lassoBehaviorDefinition");

    lassoBehaviorDefinitionAction.setHandler(SFinLassoBehaviorHandler);

    //override some default MBC legend behaviors

    BehaviorManager.register("noHoverBehavior", sFinBehavior);
});

define('sap/viz/chart/behavior/AllBehaviors',['sap/viz/chart/behavior/DefaultBehavior','sap/viz/chart/behavior/SFinBehavior','require'], function(){ return Array.prototype.slice.apply(arguments); });
define('sap/viz/chart/scales/ColorScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/BaseScale',

    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/scales/ScaleUtil',
    'sap/viz/framework/common/util/ArrayUtils'
], function (oo, 
        BaseScale,
        ObjectUtils,
        DataUtils,
        ChartScaleUtil,
        ArrayUtils) {

    /*
     * Used for color scale
     */
    var ColorScale = function (domain, range, opt) {
        ColorScale.superclass.constructor.apply(this, arguments);
        this.__className = "sap.viz.scale.ColorScale";
        this._name = null;
        this._type = "color";
        opt = opt || {};
        this._needRuntimeColorScales = opt.needRuntimeColorScales !== false;
        this._sharedRuntimeColorScale = opt.sharedRuntimeColorScale;
        this._metaData = (opt.metaData || []).map(function(md) {
            var metadata = ObjectUtils.extend(true, {}, md);
            if (!opt.respectHidden) {
                delete metadata.hidden;
            }
            return metadata;
        });
        this._runtimeColorScale = null;
        this._mergedRuntimeColorScale = null;
        this._colorId = opt.colorId;
        this._initScale(opt);
    };

    oo.extend(ColorScale, BaseScale);
  
    ColorScale.prototype._initScale = function (opt) {
        if (this._scale === undefined) {
            this._scale = d3.scale.ordinal();

            var domain = [];
            for (var i = 0, len = this._domain.length; i < len; i++) {
                domain.push(DataUtils.valuesToString(this._domain[i]));
            }

            var shrinkedDomainArray = ChartScaleUtil.shrinkedDomain(this._domain, this.getMetaData());
            var colorId = opt.colorId || 'color';
            if (this._needRuntimeColorScales && this._sharedRuntimeColorScale && shrinkedDomainArray.length !== 0){
                this._handleRuntimeScale(domain, shrinkedDomainArray, colorId);
            } else {
                var range = [].concat(this._range);
                this._range = range.splice(0, domain.length > 0 ? domain.length : 1);
                this._scale.domain(domain).range(this._range);
                if (this._needRuntimeColorScales){
                    this._constructRuntimeColorScale(colorId);
                }
            }
        }
    };
  

    ColorScale.prototype._constructRuntimeColorScale = function(colorId){
        var runtimeScaleResults = [];
        var shrinkedDomainArray = ChartScaleUtil.shrinkedDomain(this._domain, this.getMetaData());
        var ids = this.getMetaData().map(function(item){
            return item.id;
        });
        for (var i = 0; i < shrinkedDomainArray.length; i++){
            runtimeScaleResults.push({
                dataContext: shrinkedDomainArray[i],
                scaleResult: {
                    index: i,
                    value: this._range[i % this._range.length]
                }
            });
        }
        this._runtimeColorScale = {
            feed : colorId,
            fields: ids,
            results : runtimeScaleResults
        };
        this._mergedRuntimeColorScale = ObjectUtils.clone(this._runtimeColorScale);
    };
   
    ColorScale.findMatchRuntimeScale = function(sharedRuntimeScale, metaIds){
        var mappings = sharedRuntimeScale && sharedRuntimeScale.mappings;
        if(!mappings ){
            return sharedRuntimeScale;
        }
        for( var i = 0; i < mappings.length; ++i){
            var curRuntime = mappings[i];
            var fields = curRuntime.fields;
            if(ArrayUtils.equal(fields, metaIds)){
                return curRuntime;
            }
        }
        return null;
    };
    
    ColorScale.prototype._handleRuntimeScale = function(domain, shrinkedDomainArray, colorId){
        var range = [], i;
        var runtimeScaleResults = [];
        var mergedRuntimeScaleResults = [];
        var sharedRuntimeScale = this._sharedRuntimeColorScale;
        var currentResultIndexes = [];
        var metaIds = this.getMetaData().map(function(item){
            return item.id;
        });
        var curRuntimeScale = ColorScale.findMatchRuntimeScale(sharedRuntimeScale, metaIds);
    

        var rangeLength = this._range.length;
        // Array which indicate current color existing sharedRumetimeScale or not, 0 means color not sharedRuntimescale
        // 1 means in sharedRuntimeScale but the context is not used in current chart,
        // 2 means in sharedRuntimescale and used in current chart;
        var rangeMaps = [];
        if(curRuntimeScale){
            var results = curRuntimeScale.results;
            for (i = 0; i < results.length; i++){
                rangeMaps[results[i].scaleResult.index % rangeLength] = 1;
            }
        }
        
        var  domainArray, rIndex;
        // process shared runtime scale first, remove unused color index.
        for (i = 0; i < shrinkedDomainArray.length; i++){
            domainArray = shrinkedDomainArray[i];
            var result = ChartScaleUtil.findScaleResult(curRuntimeScale,
                    domainArray, ChartScaleUtil.domainArrayCompare);
            if (result){
                //Use share runtime scale result
                result = ObjectUtils.clone(result);
                rIndex = result.scaleResult.index % this._range.length;
                rangeMaps[rIndex] = 2;
                result.scaleResult.value = this._range[rIndex];
                range[i] = result.scaleResult.value;
                mergedRuntimeScaleResults.push(result);
                
            } 
        }
        
        var unusedIndexs = [];
        var secondIndexs = [];
        for(i = 0; i < rangeLength; ++i){
            if(rangeMaps[i] === 1){
                secondIndexs.push(i); 
            }else if(rangeMaps[i] !== 2){
                unusedIndexs.push(i);
            }
        }
        // One map to put all color index that can be gotten in order
        unusedIndexs = unusedIndexs.concat(secondIndexs);
        var unusedLen = unusedIndexs.length;
        var nextRange = rangeLength;
        var curIndex = 0;
        for (i = 0; i < shrinkedDomainArray.length; i++){
            //Use own runtime scale result
            domainArray = shrinkedDomainArray[i]; 
            if(range[i] == null){
                rIndex = (curIndex < unusedLen ? unusedIndexs[curIndex] : nextRange++);
                ++curIndex;
                //Handle overflow
                var colorIndex = rIndex % rangeLength;
                var colorValue = this._range[colorIndex];
                range[i] = colorValue;
    
                var newResult = {
                    dataContext: domainArray,
                    scaleResult: {
                        index: rIndex,
                        value: colorValue
                    }
                };
                //Record runtime scale result
                runtimeScaleResults.push(newResult);
                mergedRuntimeScaleResults.push(newResult);
            }
            
        }

        this._range = range;
        this._scale.domain(domain).range(this._range);

        this._runtimeColorScale = {
            feed : colorId,
            fields:metaIds,
            results : runtimeScaleResults
        };
        this._mergedRuntimeColorScale = {
            feed : colorId,
            fields:metaIds,
            results : mergedRuntimeScaleResults
        };
    };

    ColorScale.prototype.runtimeColorScale = function(){
        return this._runtimeColorScale;
    };
    ColorScale.prototype.mergedRuntimeColorScale = function(){
        return this._mergedRuntimeColorScale;
    };
    
    ColorScale.prototype.hasDomain = function(domain){
        var result = false;
        if(this._domain && this._domain.length && domain && domain.length){
            for( var i = this._domain.length; !result && i >= 0; --i){
                result = ArrayUtils.equal(this._domain[i], domain);
            }
        }
        return result;
        
    };
    
    ColorScale.prototype.scale = function (value) {
        if (value) {
            var hiddenFields = this._metaData.map(function(md) {
                return !!md.hidden;
            });
            if (value instanceof Array) {
                value = value.filter(function(v, i) {
                    return !hiddenFields[i];
                });
            }
            return this._scale(DataUtils.valuesToString(value));
        } else {
            return this._scale(value);
        }
    };
    ColorScale.prototype.destroy = function(){
        ColorScale.superclass.destroy.apply(this, arguments);
        this._sharedRuntimeColorScale = null;
        this._runtimeColorScale = null;
        this._mergedRuntimeColorScale = null;
    };

    return ColorScale;
});

define('sap/viz/chart/util/PropertyUtils',[
    "sap/viz/framework/common/util/NumberUtils",
],
function( NumberUtils)
{
    var utils = {};
    var ALL_LEVEL = "all";
    utils.getBubbleDepth = function(properties, name, array){
        if(!array || !array.length){
            return 0;
        }
        var depth = properties.get(name);
        var maxLen = array.length;
        if(depth === ALL_LEVEL){
            depth = array.length;
        }else{
            depth = parseInt(depth);
            
            if (NumberUtils.isNoValue(depth) || depth <= 0) {
                depth = properties.getDefault(name);
            }
        }
        
        return Math.min(depth, maxLen);
        
    };
    return utils;
});

define('sap/viz/chart/scales/ColorScaleProcessor',[ 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/scale/ScaleUtil',
    'sap/viz/framework/scale/ScaleRepository',
    'sap/viz/chart/scales/ColorScale',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/util/PropertyUtils',
    'sap/viz/chart/scales/ScalesFactory',
    'sap/viz/framework/scale/ScaleRoleTypeMapFactory',
    'sap/viz/chart/scales/ScaleUtil'
],function(
    TypeUtils,
    ScaleUtil,
    ScaleRepository,
    ColorScale,
    Constants,
    ArrayUtils,
    ObjectUtils,
    DataUtils,
    PropertyUtils,
    ScalesFactory,
    ScaleRoleTypeMapFactory,
    ChartScaleUtils)
    {
        var rotateArray = ArrayUtils.transpose;
        var generateUniqueDomain = ChartScaleUtils.generateUniqueDomain;

        var colorScale = function(data, name, scaleMgr, propMgr, option, dataModel) {
            option = option || {};
            var seriesType = option.seriesType;
            var paletteNum = option.colorPaletteNum;
            var customerColorPalette = option.customerColorPalette;
            var props = scaleMgr.get(name);
            var templateProps = scaleMgr.get(name, "templateValue");
            var dual = option.isDual;
            var sharedRuntimeScales = scaleMgr.get('sharedRuntime');
            var colorRuntimeScale = ScaleUtil.getScaleOfType(
                    sharedRuntimeScales, option.colorId || 'color');
            var needRuntimeColorScales = option.isPaging || !(option.isGhost);
            var colorPalette = props ? props.palette: (customerColorPalette ? customerColorPalette : null);
            if (ArrayUtils.equal(colorPalette,Constants.COLOR.SAPColorSingleAxis) && customerColorPalette) {
                colorPalette = customerColorPalette;
            }
            var options = {
                sharedRuntimeColorScale : colorRuntimeScale,
                needRuntimeColorScales : needRuntimeColorScales,
                metaData : data.metaData,
                colorId : option.colorId
            };
            if (!TypeUtils.isExist(data)) {
                return new ColorScale([], colorPalette, options);
            }
            var domain = [];
            var dualColorPalette = [(templateProps && templateProps.palette && templateProps.palette[0]) || 
                                    Constants.COLOR.SAPColorDualAxis1, 
                                    (templateProps&& templateProps.palette && templateProps.palette[1]) || 
                                    Constants.COLOR.SAPColorDualAxis2];
            if (data.values) {
                if (seriesType === 'yy') { // for bubble and scatter, only
                    // set first binding to domain
                    var depth = PropertyUtils.getBubbleDepth(propMgr.origin, "plotArea.colorDepth", data.values);
                    var ignoreNoValue = propMgr.get("legend.ignoreNoValue");
                    domain = generateUniqueDomain(data.values, depth,data.metaData,
                            data.rowArray, dataModel, ignoreNoValue, "color");
                    options.respectHidden = true;
                } else if(seriesType !== 'bullet') {
                    domain = rotateArray(data.values);
                    var noValueIndex = option.noValueIndex;
                    if (TypeUtils.isArray(noValueIndex) && noValueIndex.length > 0) {
                        noValueIndex.forEach(function(index) {
                            domain.splice(index, 1);
                            data.rowArray[index].isNoValue = true;
                        });
                    }
                }
            }
            var isColorPalette0ArrayArray = false;
            if (colorPalette && TypeUtils.isArray(colorPalette[0]) &&
                    (TypeUtils.isArray(colorPalette[0][0]) || TypeUtils.isArray(colorPalette[0][1]))) {
                // we support Array of Array for colorPalette[0] in
                // combinationEx
                isColorPalette0ArrayArray = true;
            }
            if (option.seriesType === "bullet" || options.seriesType === "timeseries_bullet") {
                options.mnds = option.mnds;
                options.isTime = option.isTime;
                options.noValueIndex = option.noValueIndex;
                return new (ScalesFactory.getScale("bullet", "color"))(data, propMgr, options, scaleMgr);

            } else {
                var defaultPalette;
                if (!dual) {
                    if (isColorPalette0ArrayArray) {
                        colorPalette = colorPalette[0][0] || Constants.COLOR.SAPColorSingleAxis;
                    } else if (!colorPalette) {
                        colorPalette = (templateProps && templateProps.palette) || 
                                        Constants.COLOR.SAPColorSingleAxis;
                    } else if ((TypeUtils.isArray(colorPalette) && TypeUtils.isArray(colorPalette[0]))) {
                        if (option.chartFamily === "combex") {
                            colorPalette = colorPalette[0];
                        } else {
                            colorPalette = Constants.COLOR.SAPColorSingleAxis;
                        }
                    }

                    defaultPalette = Constants.COLOR.SAPColorSingleAxis;
                    if (propMgr.origin.has("plotArea.colorPalette")) {
                        // only rewrite colorPalette property when it is an
                        // orginal property
                        propMgr.origin.add(
                            'plotArea.colorPalette',
                            {
                                defaultValue : Constants.COLOR.SAPColorSingleAxis,
                                serializable : false,
                                get : function() {
                                    var returnValue = props ? props.palette : null;
                                    if (!returnValue || returnValue === Constants.COLOR.SAPColorSingleAxis) {
                                        returnValue = this.value || colorPalette;
                                    }
                                    return returnValue;
                                }
                            });
                    }
                } else {
                    if (isColorPalette0ArrayArray) {
                        if (paletteNum === 0) {
                            colorPalette = colorPalette[paletteNum][1] || dualColorPalette[paletteNum];
                        } else {
                            colorPalette = colorPalette[paletteNum] || dualColorPalette[paletteNum];
                        }
                    } else if (TypeUtils.isArray(colorPalette) && TypeUtils.isArray(colorPalette[paletteNum])) {
                        colorPalette = colorPalette[paletteNum];
                    } else {
                        colorPalette = dualColorPalette[paletteNum];
                    }

                    defaultPalette = dualColorPalette;
                    if (paletteNum === 0) {
                        if (propMgr.origin.has("plotArea.primaryValuesColorPalette")) {
                            // only rewrite colorPalette property when it is
                            // an orginal property
                            propMgr.origin.add(
                                'plotArea.primaryValuesColorPalette',
                                {
                                    defaultValue : dualColorPalette[0],
                                    serializable : false,
                                    get : function() {
                                        return colorPalette;
                                    }
                                });
                        }
                    }
                    if (paletteNum === 1) {
                        if (propMgr.origin.has("plotArea.secondaryValuesColorPalette")) {
                            // only rewrite colorPalette property when it is
                            // an orginal property
                            propMgr.origin.add(
                                'plotArea.secondaryValuesColorPalette',
                                {
                                    defaultValue : dualColorPalette[1],
                                    serializable : false,
                                    get : function() {
                                        return colorPalette;
                                    }
                                });
                        }
                    }
                }

                if (!TypeUtils.isExist(scaleMgr.getDefault(name))) {
                    if (option.chartFamily === "combex") {
                        defaultPalette = [
                            [ Constants.COLOR.SAPColorSingleAxis, dualColorPalette[0] ],
                            dualColorPalette[1] 
                        ];
                    }
                    scaleMgr.add(name, {
                        serializable : true,
                        defaultValue : {
                            "feed" : name,
                            "type" : "color",
                            "palette" : ObjectUtils.clone(defaultPalette, true)
                        }
                    });
                }
                return new ColorScale(domain, colorPalette, options);
            }

        };
        
     
        ScaleRepository["colorScale"] = colorScale;
        
        ScaleRoleTypeMapFactory.register(null, null, function(ScaleMapping, scaleRoles, dataModel, i) {
            return {
                role : ScaleMapping.TO_OLD_SCALEROLE[scaleRoles[i].role],
                type : ScaleMapping.TO_OLD_SCALETYPE[scaleRoles[i].role],
                name : i
            };
        });
        ScaleRoleTypeMapFactory.register(null, "color", function(ScaleMapping, scaleRoles) {
            return {
                colorPaletteNum : 0,
                role : ScaleMapping.TO_OLD_SCALEROLE[scaleRoles['color'].role],
                type : ScaleMapping.TO_OLD_SCALETYPE[scaleRoles['color'].role],
                name : 'color'
            };
        });
        ScaleRoleTypeMapFactory.register(null , "color2",  function(ScaleMapping, scaleRoles) {
            return {
                colorPaletteNum : 1,
                role : ScaleMapping.TO_OLD_SCALEROLE[scaleRoles['color2'].role],
                type : ScaleMapping.TO_OLD_SCALETYPE[scaleRoles['color2'].role],
                name : 'color'
            };
        });
       
    });
define('sap/viz/chart/scales/PercentageValueScale',['sap/viz/framework/common/util/oo', 'sap/viz/chart/scales/ValueScale',
        'sap/viz/framework/common/util/TypeUtils'
    ],
    function(oo, ValueScale, TypeUtils) {

        var PercentageValueScale = function(domain, range, domainFixed) {
            this.__className = "sap.viz.scale.PercentageValueScale";
            PercentageValueScale.superclass.constructor.apply(this, arguments);
        };

        oo.extend(PercentageValueScale, ValueScale);

        PercentageValueScale.prototype.scale = function(value) {
            if (this._scale === undefined || this._isReset === true) {
                this._initScale();
            }
            var result = this._scale(+value);
            return result < 0 ? 0 : result;
        };



        return PercentageValueScale;
    });
define('sap/viz/chart/scales/ScaleTypeHandler',[ 'sap/viz/framework/common/util/TypeUtils',
         'sap/viz/chart/scales/ValueScale',
         'sap/viz/chart/scales/ValueScaleUtil',
         'sap/viz/framework/common/util/NumberUtils',
         'sap/viz/chart/scales/PercentageValueScale'
        ],
    function( 
        TypeUtils, 
        ValueScale, 
        ValueScaleUtil, 
        NumberUtils, 
        PercentageValueScale
        ) 
{
    var ROLE_LAYOUT = 'layout';
    var hasMinMaxInMeta = function(metaData) {
        var i;
        var hasMinMax = true;
        for(i = 0; i < metaData.length; i++) {
            if(!(metaData[i].hasOwnProperty("min") && metaData[i].hasOwnProperty("max")) ) {
                hasMinMax = false;
                break;
            }
        }
        return hasMinMax;
    };
    var hasValues = function(array) {
        if (TypeUtils.isArray(array)){
            for (var i in array){
                if (array.hasOwnProperty(i)){
                    if (!TypeUtils.isArray(array[i])){
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
        return false;
    };

    var checkValue = function(data, max, min, result) {
        if (TypeUtils.isArray(data)){
            for (var k = 0, kLen = data.length; k < kLen; ++k){
                if (!data.hasOwnProperty(k)){
                    continue;
                }
                var value = data[k];
                checkValue(value, max, min, result);
                if (result.withNoValue && !result.allNoValue &&
                    result.withMiddleValue && result.withZeroValue) {
                    break;
                }
            }
        } else {
            if (TypeUtils.isExist(data)){
                result.allNoValue = false;
                if (data !== max && data !== min){
                    result.withMiddleValue = true;
                }
                if (data === 0){
                    result.withZeroValue = true;
                }
            } else {
                result.withNoValue = true;
            }
            if (result.withNoValue && !result.allNoValue &&
                result.withMiddleValue && result.withZeroValue) {
                return;
            }
        }
    };
    var isBlankSetting = function(setting) {

        if (setting == null) {
            return true;
        }

        for (var prop in setting) {

            if (setting[prop] != null) {
                for (var subProp in setting[prop]) {
                    if (setting[prop][subProp] != null) {
                        return false;
                    }
                }
            } else if (TypeUtils.isArray(setting[prop])) {
                if (setting[prop].length !== 0) {
                    return false;
                }
            }

        }
        return true;
    };
    var flattenValuesArray = function(values, flattenedValues) {
        if (!hasValues(values)){
            for (var i in values){
                if (values.hasOwnProperty(i)){
                    flattenValuesArray(values[i], flattenedValues);
                }
            }
        } else {
            flattenedValues.push(values);
        }
    };
    var isValuesHierarchical = function(values){
        for (var i in values){
            if (values.hasOwnProperty(i)){
                for (var j in values[i]){
                    if (values[i].hasOwnProperty(j)){
                        if(TypeUtils.isArray(values[i][j])) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                }
            }
        }
    };
    
    var getMinMax = function(data) {
        if (!TypeUtils.isArray(data)) {
            data = [data];
        }
        var dataMin;
        var dataMax;

        data.forEach(function(d) {
            var minMax = {};
            if (TypeUtils.isArray(d)) {
                minMax = getMinMax(d);
            } else {
                if (NumberUtils.isNoValue(d)) {
                    return;
                }
                minMax = {
                    min: d,
                    max: d
                };
            }
            if (dataMin === undefined) {
                dataMin = minMax.min;
                dataMax = minMax.max;
                
            }
            if(!NumberUtils.isNoValue(minMax.min)){
                dataMin = dataMin > minMax.min ? minMax.min : dataMin;
                dataMax = dataMax > minMax.max ? dataMax : minMax.max;
            }
        });
        return {
            min: dataMin,
            max: dataMax
        };
    };
    var prepareValueScaleData = ValueScaleUtil.prepareValueScaleData;

    


    var getStackedArrayValues = ValueScaleUtil.getStackedArrayValues;
 

    var getAreaArrayValues = function(data, range) {
        if (data) {
            if (TypeUtils.isArray(data)) {
                var tmpRange = [0, 0, 0];
                for (var i = data.length - 1; i >= 0 ; i--) {
                    getAreaArrayValues(data[i], tmpRange);
                }
                if (tmpRange[0] < range[0]) {
                    range[0] = tmpRange[0];
                }
                if (tmpRange[1] > range[1]) {
                    range[1] = tmpRange[1];
                }
            } else {
                var v = +data;
                if (range.length > 2) {
                    range[2] = range[2] + v;
                    range[0] = range[2] < range[0] ? range[2] : range[0];
                    range[1] = range[2] > range[1] ? range[2] : range[1];
                } else if (v < 0) {
                    range[0] += v;
                } else {
                    range[1] += v;
                }
            }
        }
    };

    var getPercentageArrayValues = function(data, range) {
        if (TypeUtils.isArray(data)) {
            for (var i in data) {
                if (data.hasOwnProperty(i)) {
                    getPercentageArrayValues(data[i], range);
                }
            }
        } else {
            range[1] += Math.abs(data);
        }
    };

    var scaleTypesHandler = {
            stacked_combination: function(data, scaleOption, generateValueScale, role, dataShape, color) {
                var flattenedValues = [];
                var origValues = data.values;
                data.lineRawRange = data.lineRawRange || data.range;
                if (TypeUtils.isArray(data.values) && isValuesHierarchical(data.values)){
                    /*if data.values is hierarchical(when playField is binded,
                    as "(country, year) * values"), we need to flatten the array
                     to "category * values"*/
                    flattenValuesArray(data.values, flattenedValues);
                    data.values = flattenedValues;
                }
                if (role === ROLE_LAYOUT) {
                    var stackedRange = [];
                    var lineRange = [];

                    for (var i in data.values) {
                        if (data.values.hasOwnProperty(i)) {
                            var values = data.values[i];
                            var stackedData = [];
                            var lineData = [];
                            for (var j in values){
                                if (values[j] && values.hasOwnProperty(j)) {
                                    if (color && color[j] && dataShape){
                                        var shape = dataShape[color[j].mndIndex || 0];
                                        if (shape === "bar"){
                                            stackedData.push(data.values[i][j]);
                                        } else/* use line as default value when input is invalid*/{
                                            lineData.push(data.values[i][j]);
                                        }
                                    }
                                }
                            }
                            //stacked range
                            if (stackedData.length) {
                                stackedRange[i] = [];
                                stackedRange[i][0] = 0;
                                stackedRange[i][1] = 0;
                                getStackedArrayValues(stackedData, stackedRange[i]);
                            }

                            //line range
                            if (lineData.length) {
                                lineRange[i] = [];
                                var minMax = getMinMax(lineData);
                                lineRange[i][0] = minMax.min;
                                lineRange[i][1] = minMax.max;
                            }
                        }
                    }
                    //mix stacked scale and line scale
                    data.range = stackedRange.concat(lineRange);
                    data.stackedRange = stackedRange;
                    data.lineRange = lineRange;
                }
                //calc final scale result
                scaleOption.minMax = getMinMax(data.range);
                var scaleResult = generateValueScale(data, scaleOption);
                data.values = origValues;
                return scaleResult;
            },
            stacked: function(data, scaleOption, generateValueScale, role) {
                prepareValueScaleData(data, role, scaleOption && scaleOption.rangeIndex);
                scaleOption = scaleOption || {};
                scaleOption.minMax = getMinMax(data.range);
                var sValueScale = generateValueScale(data, scaleOption);
                if(!sValueScale.isFixed()) {
                    var maximizedDataRange;
                    if (hasMinMaxInMeta(data.metaData)) {
                        var i;
                        var rg = [0, 0];
                        for(i = 0; i < data.metaData.length; i++) {
                            rg[0] = Math.min(rg[0], data.metaData[i].min, rg[0] + data.metaData[i].min);
                            rg[1] = Math.max(rg[1], data.metaData[i].max, rg[1] + data.metaData[i].max);
                        }
                        var multiplier = 1;
                        if (data.values.length) {
                            multiplier = data.values[0].length / data.metaData.length;
                        }
                        maximizedDataRange = [rg[0] * multiplier, rg[1] * multiplier];
                    }
                    if(maximizedDataRange) {
                        sValueScale.maximizedDomain = maximizedDataRange;
                    }
                }
                return sValueScale;
            },
            waterfall: function(data, scaleOption, generateValueScale, role) {
                scaleOption.minMax = getMinMax(data.range);
                return generateValueScale(data, scaleOption);
            },
            area: function(data, scaleOption, generateValueScale, role) {
                if (role === ROLE_LAYOUT) {
                    var range = [];
                    for (var i in data.values) {
                        if (data.values.hasOwnProperty(i)) {
                            range[i] = [];
                            range[i][0] = 0;
                            range[i][1] = 0;
                            getAreaArrayValues(data.values[i], range[i]);
                        }
                    }
                    data.range = range;
                }
                scaleOption.minMax = getMinMax(data.range);
                return generateValueScale(data, scaleOption);
            },
            spread: function(data, scaleOption, generateValueScale) {
                data.lineRawRange = data.lineRawRange || data.range;
                scaleOption = scaleOption || {};
                scaleOption.minMax = getMinMax(data.range);
                return generateValueScale(data, scaleOption);
            },
            bullet: function(data, scaleOption, generateValueScale) {
                var range = [data.minValue, data.maxValue];
                data.range = range;
                scaleOption = scaleOption || {};
                scaleOption.minMax = getMinMax(data.range);
                return generateValueScale(data, scaleOption);
            },
            percentage: function(data, scaleOption, generateValueScale, role) {
                if (role === ROLE_LAYOUT) {
                    var range = [];
                    for (var i in data.values) {
                        if (data.values.hasOwnProperty(i)) {
                            range[i] = [];
                            range[i][0] = 0;
                            range[i][1] = 0;
                            getPercentageArrayValues(data.values[i], range[i]);
                        }
                    }
                    data.range = range;
                    return new PercentageValueScale(range, [0, 1]);
                } else {
                    scaleOption.minMax = getMinMax(data.range);
                    return generateValueScale(data, scaleOption);
                }
            },
            yy: function(data, scaleOption, generateValueScale) {
                var option = scaleOption || {};
                option.allowZeroMinMax = true;
                option.minMax = getMinMax(data.range);
                var scale = generateValueScale(data, option);
                var max = scale._domain[0],
                    min = scale._domain[1];
                var values = data.values;
                var result = {
                    "withNoValue": false,
                    "allNoValue": true,
                    "withMiddleValue": false,
                    "withZeroValue": false
                };
                for (var i = 0, iLen = values.length; i < iLen; ++i){
                    checkValue(values[i], max, min, result);
                    if (result.withNoValue && !result.allNoValue &&
                        result.withMiddleValue && result.withZeroValue) {
                        break;
                    }
                }

                var withNoValue = result.withNoValue,
                    allNoValue = result.allNoValue,
                    withMiddleValue = result.withMiddleValue,
                    withZeroValue = result.withZeroValue;

                if (withNoValue) {
                    scale._domain.withNoValue = true;
                }
                if (allNoValue) {
                    scale._domain = [];
                }
                if (withMiddleValue) {
                    scale._domain.withMiddleValue = true;
                }
                if (withZeroValue) {
                    scale._domain.withZeroValue = true;
                }
                return scale;
            }
        };
    return scaleTypesHandler;
});
define('sap/viz/chart/scales/ValueScaleProcessor',[ 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/scale/ScaleRepository',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/scales/ScaleTypeHandler',
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/framework/scale/ScaleDataParseFactory',
    'sap/viz/chart/scales/ScalesFactory',
    
],function(
    TypeUtils,
    ScaleRepository,
    ObjectUtils,
    ScaleTypeHandler,
    ValueScale,
    ValueScaleUtil,
    ScaleDataParseFactory,
    ScalesFactory)
    {
        var valueScale = function(data, name, scaleMgr, propertyMgr, option) {
            option = option || {};
            var seriesType = option.seriesType, role = option.role, series = option.series;
            var propKey;
            if (name == "valueAxis") {
                propKey = "plotArea.dataShape.primaryAxis";
            } else if (name == "valueAxis2") {
                propKey = "plotArea.dataShape.secondaryAxis";
            }
            var dataShape;
            if (propKey) {
                dataShape = propertyMgr.get(propKey);
                if (!( dataShape instanceof Array)) {
                    dataShape = propertyMgr.get(propKey, 'defaultValue');
                }
            }

            var scaleOption = scaleMgr.get(name) || {};
            scaleOption = ObjectUtils.extend({}, scaleOption);
            if (name === "valueAxis" && option &&
                option.chartFamily === "ty" && seriesType === "stacked") {
                scaleOption.rangeIndex = option.rangeIndex;
            }

            var propKeys = [name, "valueAxis", "plotArea.valueAxis"];
            for(var ii = 0; ii <= propKeys.length; ii++){
                if(ii === propKeys.length){
                    scaleOption.allowDecimals = true;
                }else if(propertyMgr.has(propKeys[ii] + ".label.allowDecimals")){
                    scaleOption.allowDecimals = 
                                propertyMgr.get(propKeys[ii] + ".label.allowDecimals");
                    break;
                }

            }

            var scale = ScaleTypeHandler[seriesType].
                call(this, data, scaleOption, ValueScaleUtil.generateValueScale, role, dataShape, option.color);
            //ValueScaleUtil.perfectTicks(scale);
            if (!TypeUtils.isExist(scaleMgr.getDefault(name)) && 
                    (name.indexOf('valueAxis') > -1 || name.indexOf('actualValues') > -1)) {
                scaleMgr.add(name, {
                    serializable: true,
                    defaultValue: {
                        "feed": name,
                        "type": "linear",
                        "min": "auto",
                        "max": "auto"
                    }
                });
            }
            scale.setOption(scaleMgr.get(name));
           
            if (option.comboexStackSeries || option.isFlexibleStack) {
                calculateComboEx(scale, series, option.isTrellis, name);
            }
            return scale; //return row Scale without perfect.
        };
    
        
        
        function calculateComboEx(scale, series, isTrellis, name){
            var fixedDomain = scale.getDomainFixed();
            var seriesDomain;
            if(isTrellis){
                for(var ii = 0; ii < series.length; ii++){
                    for(var jj = 0; jj < series[ii].length; jj++){
                        var tempSerisDomain = getComboxSeriesDomain(name, series[ii][jj]);
                        if(!tempSerisDomain){
                            continue;
                        }

                        seriesDomain = seriesDomain || tempSerisDomain;

                        if (seriesDomain[0] > tempSerisDomain[0]) {
                            seriesDomain[0] = tempSerisDomain[0];
                        }
                        if (seriesDomain[1] < tempSerisDomain[1]) {
                            seriesDomain[1] = tempSerisDomain[1];
                        }
                    } 
                }
            }else{
                seriesDomain = getComboxSeriesDomain(name, series);
            }
            
            if (seriesDomain) {
                var mergedDomain = scale.getDomain();
                if (!fixedDomain[0]) {
                    mergedDomain[0] = Math.min(mergedDomain[0], seriesDomain[0]);
                }
                if (!fixedDomain[1]) {
                    mergedDomain[1] = Math.max(mergedDomain[1], seriesDomain[1]);
                }
                scale.setDomain(mergedDomain);
                var autoDomain = [];
                autoDomain[0] = Math.min(scale.getAutoDomain()[0], seriesDomain[0]);
                autoDomain[1] = Math.max(scale.getAutoDomain()[1], seriesDomain[1]);
                scale.setAutoDomain(autoDomain);
            }
        }

        function getComboxSeriesDomain(name, series) {
            var posStack = {};
            var negStack = {};

            //settings.group is the internal id of each flexible stack
            if (series.every(function(sr) {
                return !sr.settings.group;
            })) {
                return null;
            }

            series.forEach(function(sr, seriesIdx) {
                if (sr.spec.mndKey !== name || !sr.settings.group) {
                    return;
                }
                var key = sr.settings.group;
                var posSum = posStack[key] = posStack[key] || [];
                var negSum = negStack[key] = negStack[key] || [];

                sr.forEach(function(data, cateIdx) {
                    posSum[cateIdx] = posSum[cateIdx] || 0;
                    negSum[cateIdx] = negSum[cateIdx] || 0;
                    var value = data[name] || 0;
                    if(value > 0){
                        posSum[cateIdx] = posSum[cateIdx] + value;
                    }else{
                        negSum[cateIdx] = negSum[cateIdx] + value;
                    }
                });
            });

            function getMinMax(stack){
                return  Object.keys(stack).map(function(stackId) {
                            var sums = stack[stackId],
                                min = sums[0],
                                max = sums[0];
                            for(var i = 1; i < sums.length; i++) {
                                if (min > sums[i] || (!TypeUtils.isExist(min) && TypeUtils.isExist(sums[i]))) {
                                    min = sums[i];
                                }
                                if (max < sums[i] || (!TypeUtils.isExist(max) && TypeUtils.isExist(sums[i]))) {
                                    max = sums[i];
                                }
                            }
                            return [min, max];
                        }).reduce(function(overall, minMax) {
                            if (overall[0] > minMax[0]) {
                                overall[0] = minMax[0];
                            }
                            if (overall[1] < minMax[1]) {
                                overall[1] = minMax[1];
                            }
                            return overall;
                        }, [0, 0]);
            }

            var posMinMax = getMinMax(posStack);
            var negMinMax = getMinMax(negStack);


            
            return [negMinMax[0] ,posMinMax[1]];
        }
        ScaleRepository["valueScale"] = valueScale; 
        ScalesFactory.register(null, "value", ValueScale);
        ScaleDataParseFactory.register(null, "valueAxis",  function(dataModel, chartType) {
            var valueAxis = dataModel['valueAxis']();
            if(valueAxis.values)
            {
                var calcArrayDepth = function(value)
                {
                    var depth = 0;
                    var _calcArrayDepth = function(v){
                        if(TypeUtils.isArray(v)) {
                            depth++;
                            _calcArrayDepth(v[0]);
                        }
                    };
                    _calcArrayDepth(value);
                    return depth;
                };
                if(chartType.indexOf('trellis') > -1){
                    while(calcArrayDepth(valueAxis.values) < 4) {
                        var wrapValueInArray = function(value){
                            var index;
                            if(TypeUtils.isArray(value) && TypeUtils.isArray(value[0]))
                            {
                                for(index = 0; index < value.length; index++)
                                {
                                    if(value[index] !== undefined) {
                                        wrapValueInArray(value[index]);
                                    }
                                }
                            } else {
                                if(value.length){
                                    for(index = 0; index < value.length; index++)
                                    {
                                        value[index] = [value[index]];
                                    }
                                }else{
                                    value[0] = [];
                                }
                            }
                        };
                        wrapValueInArray(valueAxis.values);
                    }
                }
            }
            return dataModel;
        });
    });
define('sap/viz/chart/scales/CategoryScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/BaseScale',
    'sap/viz/framework/common/util/DataUtils'
], function(oo, BaseScale, DataUtils) {

    var CategoryScale = function(domain, range) {
        CategoryScale.superclass.constructor.apply(this, arguments);
        this.__className = "sap.viz.scale.CategoryScale";
        this._type = "categorical";
        this._initScale();
    };

    oo.extend(CategoryScale, BaseScale);

    CategoryScale.prototype.getDomain = function() {
        this._ensureScaled();
        return this._domain;
    };

    CategoryScale.prototype.getRange = function() {
        this._ensureScaled();
        return this._range;
    };

    CategoryScale.prototype.scale = function(value) {
        this._ensureScaled();
        return this._scale(DataUtils.valuesToString(value));
    };

    CategoryScale.prototype.getRangeInterval = function() {
        this._ensureScaled();
        return this._scale.range();
    };

    CategoryScale.prototype.getRangeBand = function() {
        this._ensureScaled();
        return this._rangeBand;
    };

    CategoryScale.prototype._ensureScaled = function() {
        if (this._scale === undefined || this._isReset === true) {
            this._initScale();
        }
    };
    
    CategoryScale.prototype._initScale = function() {
        var _domain = this._domain;
        var _range = this._range;
        var len = _domain.length;
        var offset = Math.abs(_range[0] - _range[1]) / len;
        this._rangeBand = offset;
        var range = Array(len);
        var domain = _domain.map(function(d, i){
            var s = i * offset;
            range[i] = [s, s+offset];
            return DataUtils.valuesToString(d);
        });
        this._scale = d3.scale.ordinal().domain(domain).range(range);
        this._isReset = false;
    };

    CategoryScale.prototype.destroy = function() {
        CategoryScale.superclass.destroy.call(this);
        this._rangeBand = null;
        this._isReset = null;
    };
    
    return CategoryScale;
});
define('sap/viz/chart/scales/CategoryScaleProcessor',[ 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/scale/ScaleRepository',
    'sap/viz/chart/scales/CategoryScale',
    'sap/viz/framework/common/util/ArrayUtils',
],function(
    TypeUtils,
    ScaleRepository,
    CategoryScale,
    ArrayUtils
    )
    {
        var rotateArray = ArrayUtils.transpose;
        var categoryScale = function(data, name, scaleMgr, propertyManager) {
            if (TypeUtils.isArray(data.values)) {
                var dimensions = rotateArray(data.values);
                var scale = new CategoryScale(dimensions, [0, 1]);
                return scale;
            }
    
        };
    
        ScaleRepository["categoryScale"] = categoryScale; 
    });
define('sap/viz/chart/scales/ScaleOptionsProcessor',[ 
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/scale/ScaleOptionFactory"  
],function(
        TypeUtils,
        ScaleOptionFactory)
    {
    // return index array of series index that series are all null values
    // startIndex: for dual chart "color2" because series put "color" first
    // number: for timeseries_combination, if datapoint === "connect", only first series need process
    function getNoValueIndexes(color, series, startIndex, number){
        var indexArr = [];
        if(!color.rowArray){
            return indexArr;
        }
        var cLen = number || color.rowArray.length;
        startIndex = startIndex || 0;
         
        for(var i = cLen - 1; i >= 0; --i){
            var isEmpty = series[i + startIndex].every(function(e){
                return e.valueAxis == null && e.valueAxis2 == null;
            });
            series[i + startIndex].isEmpty = isEmpty;
            if(isEmpty){
                indexArr.push(i);
            }
        }
        return indexArr;
    }
    
    ScaleOptionFactory.register("timeseries.*column|timeseries_bullet", null,
        function(option, dataModel,runtime, propertyMgr ){
        option.allowEqual = true;
        option.dataTimeLevel = runtime.statusManager().get("timeLevels")[0];
        option.showAsUTC = propertyMgr.get("general.showAsUTC");
    });
    
    ScaleOptionFactory.register("stacked_", "waterfallType", 
        function(option, dataModel,runtime, propertyMgr ){
        option.isStacked = true;
    });
    
    ScaleOptionFactory.register("timeseries.*stacked_column", "valueAxis", 
        function(option, dataModel,runtime, propertyMgr ){
        option.isStacked = true;
        option.rangeIndex = dataModel._rangeIndex;
    });
    
    ScaleOptionFactory.register("dual_.*", null,
         function(option, dataModel,runtime, propertyMgr ){
        option.isDual = true;
    });
    ScaleOptionFactory.register(null, "valueAxis", 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
            option.color = dataModel.color ? dataModel.color().rowArray : null;
        }
    );
   
    ScaleOptionFactory.register(null, "valueAxis2", 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
            option.color = dataModel.color2 ? dataModel.color2().rowArray : null;
        }
    );
    ScaleOptionFactory.register("^((?!(pie|donut|bullet|heatmap|treemap|tagcloud|timeseries)).)*$", 
        "color", function(option, dataModel,runtime, propertyMgr, valueAxes ){
            var ignoreNoValue = propertyMgr.get("legend.ignoreNoValue");
            if(ignoreNoValue && !/bubble|scatter/.test(dataModel.chartType())){
               
                option.noValueIndex = getNoValueIndexes( dataModel.color(), dataModel.getInitSeries());
            }
            // bubble and scatter need process "plotArea.colorDepth", "plotArea.shapeDepth", 
            // don't need noValueIndex here, process in ColorScaleProcessor and Shape
            option.colorId = "color";
        }
    );
    ScaleOptionFactory.register("timeseries_((?!(bubble|scatter|combination|bullet)).)*$","color", 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
            // For TimeSeriesLine, "plotArea.dataPoint.invalidity" is true, all data point will be displayed
            var ignoreNoValue = propertyMgr.get("legend.ignoreNoValue") && 
                propertyMgr.get("plotArea.dataPoint.invalidity") !== "connect";
            if(ignoreNoValue){
                option.noValueIndex = getNoValueIndexes(dataModel.color(), dataModel.getInitSeries());
            }
            option.colorId = "color";
        }
    );
    ScaleOptionFactory.register("timeseries_.*combination$","color", 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
            var ignoreNoValue = propertyMgr.get("legend.ignoreNoValue");
            if(ignoreNoValue){
                // only first series is "BAR", when "plotArea.dataPoint.invalidity" is true, process first series only

                option.noValueIndex = getNoValueIndexes(dataModel.color(), dataModel.getInitSeries(), 0,
                        propertyMgr.get("plotArea.dataPoint.invalidity") === "connect" ? 1 : 0);
               
            }
          
            option.colorId = "color";
        }
    );
    ScaleOptionFactory.register("pie|donut", "color", 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
        var ignoreNoValue = propertyMgr.get('legend.ignoreNoValue');
        
        if(ignoreNoValue){
            var valueAxis =  dataModel.size && dataModel.size();
            for(var i = valueAxis.values.length - 1; i >= 0;  --i){
                if(!TypeUtils.isExist(valueAxis.values[i])){
                    option.noValueIndex = option.noValueIndex || [];
                    option.noValueIndex.push(i);
                }
            }
        }
        option.colorId = "color";
    });
    var BULLETVALUES = ["actualValues", "additionalValues", "forecastValues", "targetValues"];
    var MLEN = BULLETVALUES.length;
    ScaleOptionFactory.register("bullet", "color", 
            function(option, dataModel,runtime, propertyMgr, valueAxes){
            var ignoreNoValue = propertyMgr.get('legend.ignoreNoValue');

            if(ignoreNoValue){
                option.noValueIndex = [];
                var series = dataModel.getInitSeries();
                for(var i = 0; i < series.length; ++i){
                    var curSeries = series[i];
                    var hasValues = [false, false, false, false];
                    var hasValue = false;
                    for(var j = 0; j < curSeries.length; ++j){
                        var curCat = curSeries[j];
                        BULLETVALUES.forEach(function(e, j){
                            if(curCat[e] != null){
                                hasValue = hasValues[j] = true;
                            }
                        });
                    }
                    
                    curSeries.isEmpty = !hasValue;
                    hasValues.forEach(function(e, t){
                        if(!e){
                            option.noValueIndex.push(i * MLEN + t);
                        } 
                    });
                    
                    
                }
            }
            option.colorId = "color";
        });
    ScaleOptionFactory.register("^((?!(dual_timeseries_combination|timeseries_combination)).)*$", "color2", 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
        var ignoreNoValue = propertyMgr.get('legend.ignoreNoValue');
        if( ignoreNoValue){
            var color = dataModel.color();
            var len = color.rowArray ? color.rowArray.length : 0;
            option.noValueIndex = getNoValueIndexes(
                    dataModel.color2(), dataModel.getInitSeries(), len);
        }
        option.colorId = "color2";
    });
    
    ScaleOptionFactory.register("timeseries_.*combination$", "color2", 
            function(option, dataModel,runtime, propertyMgr, valueAxes ){
            var ignoreNoValue = propertyMgr.get('legend.ignoreNoValue') &&
                propertyMgr.get("plotArea.dataPoint.invalidity") !== "connect";
            if( ignoreNoValue){
                // valueAxis2 are all "LINE"
                var color = dataModel.color();
                var len = color.rowArray ? color.rowArray.length : 0;
                option.noValueIndex = getNoValueIndexes( dataModel.color2(), dataModel.getInitSeries(), len);
            }
            option.colorId = "color2";
        });
    
    ScaleOptionFactory.register("combinationEx", null, 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
        option.isDual = valueAxes.length > 1;
        option.comboexStackSeries = true;
    });
    
    ScaleOptionFactory.register("trellis", null, 
        function(option, dataModel,runtime, propertyMgr, valueAxes ){
        option.isTrellis = true;
    });

    ScaleOptionFactory.register("stacked_column", null,
        function (option, dataModel, runtime, propertyMgr) {
            if (propertyMgr.origin.get("plotArea.series")) {
                option.isFlexibleStack = true;
            }
        }
    );
});
define('sap/viz/chart/dynamicScales/BaseDyScaleProcessor',[ 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ArrayUtils',
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/format/UnitFormat",
    'sap/viz/framework/scale/DynamicScaleRepository',
],function(
    TypeUtils,
    ArrayUtils,
    NumberUtils,
    UnitFormat,
    DynamicScaleRepository
){

    function BaseDyScaleProcessor(type, propertyMgr, dataModel, runtime){
        this._type = type;
        this._propertyMgr = propertyMgr;
        this._dataModel = dataModel.dataModel;
        this._scales = dataModel.scales;
        this._runtime = runtime;
        this._units =  this._runtime.statusManager().get("data.unit") || {};
        this._mainValue = "valueAxis";
    }

    var K = 3, M = 6, B = 9, T = 12, Q = 15;
    var TRY_LEVELS = [Q, T, B, M, K];
    function getScaleFactorForSingleNum(num){
        var numStr = num.toString();
        var len = numStr.length-1;
        var scale = 0;
        for(var ii = 0; ii < TRY_LEVELS.length; ii++){
            if(len >= TRY_LEVELS[ii]){
                scale = TRY_LEVELS[ii];
                break;
            }
        }
        return scale;
    }

    BaseDyScaleProcessor.prototype.getValue = function(dp){
        return dp.valueAxis || dp.valueAxis2;
    };

    BaseDyScaleProcessor.prototype.calculatedynamicScale = function(minTable, maxTable, metaKey) {
        if(!minTable || !maxTable || minTable.length === 0 || maxTable.length === 0){
            return null;
        }

        var data = this._dataModel[metaKey]();
        var temp = this.getUnit(data, this._units);
        var unit = temp[0];
        var isDifferentUnit = temp[1];
        var metaKeys = data.metaData.map(function(e){
            return e.id||e.name;
        });
        //define the scale
        var scaleSet = [];
        var scale = 0;

        maxTable.forEach(function(max, index){
            if(max === undefined){
                return;
            }
            var maxScale = getScaleFactorForSingleNum(max);
            var minScale = getScaleFactorForSingleNum(minTable[index]);
            scale = 0;

            if(minScale === maxScale){
                scale = minScale;
            }else if(minScale + 3 === maxScale && maxScale <= T){
                scale = maxScale;
            }else if(minScale + 6 === maxScale && maxScale <= T){
                scale = minScale + 3; 
            }
            scaleSet.push(scale);
        });

        var result = null;
        if(ArrayUtils.unique(scaleSet).length !== 1){
            scale = 0;
        } else {
            scale = scaleSet[0];
        }

        var symbolTable = {
            3: "K",
            6: "M",
            9: "B",
            12: "T",
            15: "Q",
        };

        if((scale && symbolTable[scale]) || (scale === 0 && unit) ){
            var postfix = " in";
            if(symbolTable[scale]){
                postfix += " " + symbolTable[scale];
            }
            if(unit){
                postfix += " " + unit;
            }

            var factor = Math.pow(10, scale);
            var format = function(value, formatString, unitFormatType, options){
                if(factor === 0){
                    value = UnitFormat.format(value,formatString, unitFormatType, options);
                }else if(TypeUtils.isNumber(value)){
                    value /= factor;
                    value = +value.toFixed(2); 
                    //ignore 'u' format when dynamic scale
                    if(formatString && formatString.indexOf("u") === formatString.length -1){
                        value = value.toString();
                    }else{
                        value = UnitFormat.format(value,formatString, unitFormatType, options);
                    }
                }else{
                    value = value.toString();
                }
                return value;
            };

            result = { factor: factor, 
                       symbol: symbolTable[scale]||"",
                       unit: unit || "",
                       isDifferentUnit: isDifferentUnit,
                       postfix:postfix,
                       format: format,
                       metaKeys: metaKeys };
        }
        return result;
    };

    function cleanValue(value){
        return Math.abs(parseInt(value));
    }

    BaseDyScaleProcessor.prototype.cleanValue = cleanValue;

    function cleanRange(range){
        var result = range.map(cleanValue).sort(function(a, b){return a - b;});
        return result;
    }

    BaseDyScaleProcessor.prototype.cleanRange = cleanRange;

    BaseDyScaleProcessor.prototype.getUnit = function(valueAxis, units){
        var isDifferentUnit = false;
        var result = "";
        if(valueAxis && valueAxis.metaData && valueAxis.metaData.length > 0){
            result = units[valueAxis.metaData[0].id] || "";
            for(var ii = 1; ii < valueAxis.metaData.length; ii++){
                var unit = units[valueAxis.metaData[ii].id] || "";
                if(unit !== result){
                    isDifferentUnit = true;
                    result = "";
                    break;
                }
            }
        }
        return [result, isDifferentUnit];
    };

    BaseDyScaleProcessor.prototype.generateResult = function(autoScale, autoScale2){
        var result = null;
        var data = this._dataModel;
        //generate result
        if (this._type.indexOf("dual") > -1 && (autoScale || autoScale2)){
            result = {
                valueAxis: autoScale,
                valueAxis2: autoScale2,
                onlyChartTitle: false
            };

            if(autoScale && autoScale2){
                var isSameUnit = autoScale.unit === autoScale2.unit;
                var isSameFactor = autoScale.factor === autoScale2.factor;

                if(isSameFactor && isSameUnit){
                    result.onlyChartTitle = true;
                    result.postfix = autoScale.postfix;
                }else{
                    //show unit and factor as long as there is any difference, according to PO
                    result.showUnitOnDataLabel =  !isSameUnit || !isSameFactor;   
                    result.showSymbolOnDatalabel = !isSameUnit || !isSameFactor;
                }
            }else{
                //only existing one scale
                result.showUnitOnDataLabel =  true;
                result.showSymbolOnDatalabel = true; 
            }
        } else if(autoScale){
            result = {
                valueAxis: autoScale,
                postfix: autoScale.postfix,
                onlyChartTitle: true
            };   
        }

        if(result){
            if((autoScale && autoScale.isDifferentUnit)  || (autoScale2 && autoScale2.isDifferentUnit)){
                result.showUnitOnDataLabel =  true;
            }

            result.getScaleFactor = function(id){
                var trylist = [];
                for(var factor in result){
                    if(result.hasOwnProperty(factor) && result[factor] && result[factor].format){
                        trylist.push(result[factor]);
                    }
                }

                for (var i = 0; i < trylist.length; i++) {
                    if(trylist[i] && trylist[i].metaKeys.indexOf(id) > -1){
                        return trylist[i];
                    }
                }
            };
        }
        return result;
    };


    //the key algo function, will be implemented by subclasses
    BaseDyScaleProcessor.prototype.getMinMax = function(){
        return {};
    };

    BaseDyScaleProcessor.prototype.getdynamicScale = function(){
        var minMaxResult = this.getMinMax();
        var data = this._dataModel;
        var autoScale = this.calculatedynamicScale(minMaxResult.minTable,
                        minMaxResult.maxTable, this._mainValue);
        var autoScale2 = data._valueAxis2 && 
            this.calculatedynamicScale(minMaxResult.minTable2, minMaxResult.maxTable2, "valueAxis2");
        return this.generateResult(autoScale, autoScale2);
    };

    return BaseDyScaleProcessor;  
});
define('sap/viz/chart/dynamicScales/BaseColumnDyScaleProcessor',[ 
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/scale/DynamicScaleRepository',
    "sap/viz/chart/dynamicScales/BaseDyScaleProcessor"

],function(
    oo,
    DynamicScaleRepository,
    BaseDyScaleProcessor
){

    function BaseColumnDyScaleProcessor(type, propertyMgr, dataModel, runtime){
        BaseColumnDyScaleProcessor.superclass.constructor.apply(this, arguments);
    }
    oo.extend(BaseColumnDyScaleProcessor, BaseDyScaleProcessor);

    ["column", "dual_column", "bar", "dual_bar", 
    "line", "horizontal_line", "dual_line", "dual_horizontal_line", "timeseries_line",
    "combination", "horizontal_combination", "dual_combination","dual_horizontal_combination", 
    "timeseries_column", "timeseries_combination", "dual_timeseries_combination"]
    .forEach(function(type){
        DynamicScaleRepository[type] = BaseColumnDyScaleProcessor;
    });

    BaseColumnDyScaleProcessor.prototype.chooseMinMaxFromRanges = function(ranges){
        var minTable = [], maxTable = [];
        if(ranges){
            ranges.forEach(function(range){
                if(range){
                    range = this.cleanRange(range);
                    minTable.push(range[0]);
                    maxTable.push(range[1]);  
                }
            }, this);
        } 
        return [minTable, maxTable];
    };

    //by meansure
    BaseColumnDyScaleProcessor.prototype.getMinMax = function(){
        var result = {};
        var mainData = this._dataModel[this._mainValue]();
        var temp = this.chooseMinMaxFromRanges(mainData.range);
        result.minTable = temp[0];
        result.maxTable = temp[1];

        if(this._dataModel._valueAxis2){
            temp = this.chooseMinMaxFromRanges(this._dataModel._valueAxis2.range);
            result.minTable2 = temp[0];
            result.maxTable2 = temp[1]; 
        }
        
        return result;
    };

    return BaseColumnDyScaleProcessor;  
});
define('sap/viz/chart/views/ChartView',[
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/chart/layout/GridLayout",
    'sap/viz/chart/components/title/Title',
    'sap/viz/chart/components/Background',
    'sap/viz/chart/components/scrollbar/PaginationScrollbar',
    'sap/viz/chart/components/legend/ColorLegend',
    'sap/viz/chart/components/legend/LegendGroup',
    'sap/viz/chart/components/container/UIContainer',
    'sap/viz/chart/metadata/properties/PropertyLoader',
    "sap/viz/chart/behavior/AllBehaviors",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/chart/scales/ColorScaleProcessor",
    "sap/viz/chart/scales/ValueScaleProcessor",
    "sap/viz/chart/scales/CategoryScaleProcessor",
    "sap/viz/chart/scales/ScaleOptionsProcessor",

    "sap/viz/chart/dynamicScales/BaseColumnDyScaleProcessor"
], function(
    Constants,
    DomUtil,
    oo,
    TypeUtils,
    GridLayout,
    Title,
    Background,
    PaginationScrollbar,
    ColorLegend,
    LegendGroup,
    UIContainer,
    PropertyLoader,
    AllBehaviors,
    TextUtils
) {

    var ChartView = function (runtime, option) {
        ChartView.superclass.constructor.apply(this, arguments);
        var props = PropertyLoader.getProperties(option.chartType, this._isTrellis());
        this._properties.add(props);

        this._exposeMoreEvents("ready");
        this._exposeMoreEvents("renderComplete");
        this._exposeMoreEvents("reRenderComplete");
        this._exposeMoreEvents("initialized");
        this._exposeMoreEvents("plotScroll");

        this.runtime().statusManager().add('ChartPaddingInfo');
        this.runtime().statusManager().add('sizeChanged');

        var LayoutClazz = this._getLayoutDefinition();
        this._supportLazyRender = false;

        this.setLayoutAlgorithm(new LayoutClazz());
        this._outline = {
            visible: false
        };
        this._background = null;
        this._backgroundNode = null;

        this._rootContainer = null;
        
        this._paginationScrollbar = null;
        this._paginationScrollbarNode = null;
        
        this._initialized = false;
        this._legendIsAUTO = false;

        this._createChildren();
        this._plotAreaLayout = null;

        this._semanticMgr = this.runtime().semanticManager();
    };

    oo.extend(ChartView, UIContainer);

    /**
     * Create child components: title, legend, plot...
     */
    ChartView.prototype._createChildren = function () {
        this._createBackground();
        this._createTitle();
        this._createLegendGroup();
        this._createPaginationScrollbar();
    };
    
    ChartView.prototype._createPaginationScrollbar = function () {
        var moduleKey = this._getPaginationScrollbarKey();
        //we do not add paginationScrollbar as child, because paginationScrollbar is desgined 
        //to replace scroll bar in category axis. 
        //We do not need to layout paginationScrollbar in Chart Container.
        this._paginationScrollbar = new PaginationScrollbar(this.runtime(), {
            name: moduleKey
        });
    };

    ChartView.prototype._createTitle = function (position) {
        var moduleKey = this._getTitleModuleKey();
        var ModuleClazz = this._getTitleDefinition();
        var moduleInstance = new ModuleClazz(this.runtime(), {
            name: moduleKey
        });

        if (TypeUtils.isFunction(moduleInstance.setPosition)) {
            moduleInstance.setPosition(position);
        }
        this.setChild(moduleKey, moduleInstance, {
            priority: 1,
            spacing: {
                spacingWithMainToRough : Constants.TITLE.SPACING_WITH_MAIN_TO_ROUGH,
                spacingMaxInPX : Constants.TITLE.SPACING_MAX_IN_PX
            }
        });
    };

    ChartView.prototype._createLegendGroup = function (position) {

        var legendGroupModuleKey = this._getLegendGroupModuleKey();
        var LegendGroupClazz = this._getLegendGroupDefinition();
        var legendGroup = new LegendGroupClazz(this.runtime(), {
            name: legendGroupModuleKey
        });
        if (TypeUtils.isFunction(legendGroup.setPosition)) {
            legendGroup.setPosition(position);
        }

        var legendDefinitions = this._getLegendDefinition();
        var legendInitOpts = this._getLegendInitOptions();
        var legendModuleKey = this._getLegendModuleKey();

        // multi-legend
        var legendInstance;
        if (TypeUtils.isArray(legendDefinitions)) {
            for (var index = 0; index < legendDefinitions.length; index++) {
                var LegendClazz = legendDefinitions[index];
                var key = legendModuleKey[index];
                legendInstance = new LegendClazz(this.runtime(), {
                    name: key,
                    options: legendInitOpts[index]
                });
                legendGroup.setChild(key, legendInstance);
            }
        } else {
            legendInstance = new legendDefinitions(this.runtime(), {
                name: legendModuleKey,
                options: legendInitOpts
            });
            legendGroup.setChild(legendModuleKey, legendInstance);
        }

        this.setChild(legendGroupModuleKey, legendGroup, {
            priority: 2,
            spacing: {
                spacingWithMainToRough : Constants.LEGEND_GROUP.SPACING_WITH_MAIN_TO_ROUGH,
                spacingMaxInPX : Constants.LEGEND_GROUP.SPACING_MAX_IN_PX
            }
        });
    };

    ChartView.prototype._createBackground = function () {
        this._background = new Background(this.runtime(), {
            name: 'general.background'
        });
    };
    
    /*
     * Clear the background, paginationScrollbar, title and legend when set empty dataset, 
     * the plotarea will be reset by _resetPlotContainer() when reset data
     */
    ChartView.prototype.clear = function () {
        if(this._rootContainer) {
            this._rootContainer.removeAttribute('tabIndex');
        }

        if(this._backgroundNode) {
            this._backgroundNode.select('.v-background-body').remove();
            this._backgroundNode.select('.v-background-border').remove();
        }
        
        if(this._paginationScrollbarNode) {
            this._paginationScrollbarNode.select('.v-background-body').remove();
        }
        
        var title;
        if (this.getChild(this._getTitleModuleKey())) {
            title = this.getChild(this._getTitleModuleKey()).module;
        }
        if(title) {
            title.clear();
        }
        var legendGroup;
        if (this.getChild(this._getLegendGroupModuleKey())) {
            legendGroup = this.getChild(this._getLegendGroupModuleKey()).module;
        }
        if(legendGroup) {
            legendGroup.clear();
        }
    };
    
    ChartView.prototype.paginationOptions = function() {
        //paginationOptions is set into chart metadata,
        //the object is like
        //"metadata" : {
        //    options : {
        //        pagination : {
        //            mode : "update",//reset, update
        //            ratio : 0.1
        //        }
        //    },
        //update mode means keeping layout and just update plot,
        //reset mode means redraw pagination scrollbar.
        //ratio means scroll bar thumb ratio. 
        var paginationOptions;
        var data = this.getData();
        if (data && data.dataModel && data.dataModel.getPaginationOptions) {
            paginationOptions = data.dataModel.getPaginationOptions();
        }
        return paginationOptions;
    };
    
    ChartView.prototype.savePlotAreaLayout = function(plotAreaLayout) {
        var plotAreaChildren = this._plotArea._children;
        for (var key in plotAreaChildren) {
            if (plotAreaChildren.hasOwnProperty(key)) {
                var module = plotAreaChildren[key].module;
                if(module._size) {
                    plotAreaLayout[key] = {};
                    plotAreaLayout[key].module = {};
                    plotAreaLayout[key].module._size = {};
                    plotAreaLayout[key].module._size.width = module._size.width;
                    plotAreaLayout[key].module._size.height = module._size.height;
                }
            }
        }
    };
    
    ChartView.prototype._getDataRange = function(start, end){
        return this._plotArea && this._plotArea._getDataRange(start, end);
    };

    ChartView.prototype._resetPlotContainer = function () {
        if (this._plotArea) {
            if (this._selections && this._selections[this._plotArea.alias]){
                var paginationOptions = this.paginationOptions();
                if(paginationOptions) {
                    //we must keep v-m-main, because Pagination scrollbar DOM is supposed to 
                    //drawn after (to cover) v-m-main.
                    this._selections[this._plotArea.alias].selectAll("*").remove();
                    if(!this._plotAreaLayout) {
                        //we have to save all _plotArea children layout, and these layout 
                        //may be used in data updating   
                        this._plotAreaLayout = {};
                        this.savePlotAreaLayout(this._plotAreaLayout);
                    }
                    
                    if(paginationOptions.mode !== Constants.PAGINATION_MODE.UPDATE) {
                        this._plotAreaLayout = null;
                    }
                }
                else {
                    this._plotAreaLayout = null;
                    this._selections[this._plotArea.alias].remove();
                    this._selections[this._plotArea.alias] = null;                    
                }
            }

            this._plotArea.destroy();
            this._plotArea = null;
        }
    };

    ChartView.prototype._createPlotContainer = function (isTrellis) {};
    
    ChartView.prototype._getPaginationScrollbarKey = function () {
        return "paginationScrollbar";
    };

    ChartView.prototype._getLegendGroupDefinition = function () {
        return LegendGroup;
    };

    ChartView.prototype._getLegendGroupModuleKey = function () {
        return Constants.LEGEND_GROUP.KEY;
    };

    ChartView.prototype._getTitleDefinition = function () {
        return Title;
    };

    ChartView.prototype._getTitleModuleKey = function () {
        return "title";
    };

    ChartView.prototype._getLegendDefinition = function () {
        return [ColorLegend];
    };

    ChartView.prototype._getLegendInitOptions = function() {
        return [null];
    };

    ChartView.prototype._getLegendModuleKey = function () {
        return ["legend"];
    };

    ChartView.prototype._getLayoutDefinition = function () {
        return GridLayout;
    };
    
    ChartView.prototype.layoutPaginationScrollbar = function(node) {
        var position = this._plotArea._categoryAxis._position;
        var mainLocation = this._layoutResult.main;
        
        var plotLocation = this._plotArea._layoutResult.plot;
        var axisLocation = this._plotArea._layoutResult.categoryAxis;
        var axisTitleLocation = this._plotArea._categoryAxis._layoutResult.axisTitle;
        var axisScrollbarLocation = this._plotArea._categoryAxis._layoutResult.axisScrollbar;

        var paginationOptions = this.paginationOptions();
        var contentRatio = 1;
        if(paginationOptions) {
            contentRatio = paginationOptions.ratio;
        }
        //we use category axis position as the position of 
        //pagination scrollbar, because we just need to know
        //_isVertical. 
        this._paginationScrollbar.setPosition(position);
        
        var x;
        var y;
        var trackSize;
        if(this._paginationScrollbar._isVertical()) {
            var topOffset = 0;
            if(this._plotArea._valueAxis && 
               this._plotArea._valueAxis._position === "top") {
                topOffset = this._plotArea._layoutResult.valueAxis.height;
            }
            x = mainLocation.x + plotLocation.x + plotLocation.width;
            y = mainLocation.y + topOffset;
            trackSize = this._plotArea.getVScrollbar()._trackSize;
        }
        else {
            //we have to record the init _axisScrollbarOffset
            if(this._paginationScrollbarOffset === undefined || 
               this._paginationScrollbarOffset === null) {
                if(axisTitleLocation.y > 0 && axisScrollbarLocation.height > 0) {
                    this._paginationScrollbarOffset = axisTitleLocation.y - 
                        axisScrollbarLocation.y - axisScrollbarLocation.height;
                }
                else {
                    this._paginationScrollbarOffset = 0;
                }
            }
            x = mainLocation.x + plotLocation.x;
            y = mainLocation.y + plotLocation.height + axisLocation.height - axisTitleLocation.height -
                    axisScrollbarLocation.height - this._paginationScrollbarOffset;
            trackSize = this._plotArea.getHScrollbar()._trackSize;
        }
        node.attr("transform","translate(" + x + "," + y + ")");
        if(contentRatio !== null && contentRatio !== undefined) {
            this._paginationScrollbar.setContentSize(trackSize / contentRatio);
        }
        else {
            //No contentRatio. We use original contentRatio.
            var originalContentRatio = this._paginationScrollbar.getTrackSize() / 
                                    this._paginationScrollbar.getContentSize();
            if(originalContentRatio) {
                this._paginationScrollbar.setContentSize(trackSize / originalContentRatio);                
            }
        }
        this._paginationScrollbar.setTrackSize(trackSize);
    };

    ChartView.prototype._updateBackgroundColor = function (semanticDisplayStyleRules) {
        if (semanticDisplayStyleRules && semanticDisplayStyleRules.background && 
                semanticDisplayStyleRules.background.color) {
            this._background.setData({
                'color': semanticDisplayStyleRules.background.color
            });
        } else {
            this._background.setData(null);
        }
    };

    /**
     * To render element.
     *
     * @param rootElement {D3Selection} the parent D3 selection for rendering
     */
    ChartView.prototype.render = function (rootElement, options) {
        if (!this._size.width || !this._size.height) {
            return;
        }

        this._rootContainer = rootElement.node().parentNode;
        if (this._rootContainer) {
            this._rootContainer.setAttribute("tabIndex", this._properties.get('general.tabIndex'));
            if (this._outline.visible || this._properties.get("interaction.enableKeyboard")) {
                this._rootContainer.style.outline = null;
            } else {
                this._rootContainer.style.outline = "none";
            }
        }

        if (this._background) {
            this._background.setSize(this._size);
            var tagName = rootElement.node().tagName;
            if(tagName.toLowerCase() === "div"){
                this._backgroundNode = this._backgroundNode || rootElement.append('svg')
                .style('position',"absolute")
                .style('height',"100%")
                .style('width',"100%;")
                .append('g').attr('class', 'v-m-background');
            }else{
                this._backgroundNode = this._backgroundNode || rootElement.append('g').attr('class', 'v-m-background');
            }
            this._updateBackgroundColor(this._semanticDisplayStyleRules);
            this._background.render(this._backgroundNode);
        }
        this._initRenderBase(rootElement);
                
        this.clearSize(true);
        
        options = options || {};

        var paginationOptions = this.paginationOptions();
        if(paginationOptions) {
            options.pagination = paginationOptions;

            if((options.dataChanged && paginationOptions && 
                paginationOptions.mode === Constants.PAGINATION_MODE.UPDATE) ||
                //fixed layout when switching page
                (!options.isSizeChanged && !options.propertiesChanged)) {
                //reuse layout result
                options.plotAreaLayout = this._plotAreaLayout;
            }else {
                //Resized. Saved layout is invalid.
                this._plotAreaLayout = null;
                this._paginationScrollbarOffset = null;
            }
            //we have to make sure _paginationScrollbar is created, or 
            //XYContainer cannot get the ref of _paginationScrollbar.
            options._paginationScrollbar = this._paginationScrollbar;
        }

        options._semanticDisplayStyleRules = this._semanticDisplayStyleRules;

        this.layout(options);

        //Set chart paddinginfo to statusmanager for valueaxis layout BITSDC2-2591
        var config = this._layoutAlgorithm.config;
        this._runtime.statusManager().set('ChartPaddingInfo', {
            padding: config.get('padding'),
            paddingLeft: config.get('paddingLeft'),
            paddingRight: config.get('paddingRight'),
            paddingTop: config.get('paddingTop'),
            paddingBottom: config.get('paddingBottom')
        });

        // execute module drawing logics
        for (var key in this._children) {
            if(key !== 'plot'){
                if (this._children.hasOwnProperty(key)) {
                    this.getChild(key).module.render(this._selections[key], this._semanticDisplayStyleRules);
                }                
            }
        }
        //always render plot last.
        if(this.getChild('plot')){
            this.getChild('plot').module.render(this._selections['plot'], null, this._semanticDisplayStyleRules);
        }
        
        this._renderForPagination(rootElement, paginationOptions, options);
        this._runtime.statusManager().set("sizeChanged", options.isSizeChanged);
        this._dispatchInitialized();
    };

    ChartView.prototype._renderForPagination = function(rootElement, paginationOptions, options){
        if(paginationOptions && this._plotArea && this._plotArea._categoryAxis) {
            var axisScrollbar = this._plotArea._categoryAxis.getChild("axisScrollbar");
            var plotAreaScrollbar = this._plotArea.getChild("scrollbar");
            //we create _paginationScrollbar when categoryaxis scrollbar is visible, or 
            //plot scrollbar is visible.
            if( (axisScrollbar && axisScrollbar.module && 
                 axisScrollbar.module.isVisible() && axisScrollbar.module.isExist()) ||
                (plotAreaScrollbar && plotAreaScrollbar.module && 
                 plotAreaScrollbar.module.isVisible() && plotAreaScrollbar.module.isExist()) ){

                if(!this._paginationScrollbar) {
                    this._createPaginationScrollbar();
                }

                if(!this._paginationScrollbarNode) {
                    this._paginationScrollbarNode = rootElement.append('g')
                    .attr('class', 'v-m-paginationScrollbar');
                }
                if(paginationOptions.mode === Constants.PAGINATION_MODE.RESET) {
                    this._paginationScrollbarOffset = null;
                }
                
                if(options.isSizeChanged || options.propertiesChanged ||
                    paginationOptions.mode === Constants.PAGINATION_MODE.RESET ||
                    paginationOptions.mode === Constants.PAGINATION_MODE.UPDATE) {
                    this.layoutPaginationScrollbar(this._paginationScrollbarNode);
                    this._paginationScrollbar.render(this._paginationScrollbarNode);
                }
                
                if(!options.isSizeChanged && options.dataChanged &&
                     paginationOptions.mode === Constants.PAGINATION_MODE.RESET) {
                    //reset position to 0
                    this._paginationScrollbar.setThumbPosition(0);
                    this._paginationScrollbar._thumbRatio = 0;
                }
                else {
                    if(this._paginationScrollbar._thumbRatio) {
                        this._paginationScrollbar.setThumbPosition(this._paginationScrollbar._thumbRatio *
                            this._paginationScrollbar._maxThumbPosition);
                    }
                }
            }
        }
        else {
            //destory _paginationScrollbarNode and _paginationScrollbar
            if (this._paginationScrollbarNode) {
                this._paginationScrollbarNode.remove();
            }
            this._paginationScrollbarNode = null;

            if (this._paginationScrollbar && TypeUtils.isFunction(this._paginationScrollbar.destroy)) {
                this._paginationScrollbar.destroy();
            }
            this._paginationScrollbar = null;
        }
    };
    
    ChartView.prototype._dispatchInitialized = function() {
        if (this._eventDispatch) {
            this._eventDispatch.ready(); //an inner event used only by modules inside like interaction.
        }
        TextUtils.destroy();
        // to support chart.on("initialized")
        window.setTimeout((function () {
            if (this._eventDispatch) {
                this._initialized = true;
                this._eventDispatch.initialized();
                if(this._customerDispatch && this._customerDispatch.initialized) {
                    this._customerDispatch.initialized();
                }
                // Incase the chart is destroyed in the "initialized" event
                if (this._eventDispatch) {
                    this._eventDispatch.renderComplete();
                }
                if(this._customerDispatch && this._customerDispatch.renderComplete) {
                    this._customerDispatch.renderComplete();
                }
            }

            // notify the external handler if any
            window.setTimeout(function() {
                if (window._sap_viz_notify_load_complete) {
                    window._sap_viz_notify_load_complete();
                }
            }, 0);
        }).bind(this), 0);
    };

    /**
     * To layout children elements
     *
     */
    ChartView.prototype._configLayout = function() {
        // execute layout
        var components = this._getLayoutComponents();
        var paddingInfo = this.calculatePaddingInPX(this._properties.origin, this._size.width, this._size.height);

        var padding = paddingInfo.propertyPaddingInPX;
        var paddingTop = paddingInfo.propertyPaddingTopInPX;
        var paddingRight = paddingInfo.propertyPaddingRightInPX;
        var paddingBottom = paddingInfo.propertyPaddingBottomInPX;
        var paddingLeft = paddingInfo.propertyPaddingLeftInPX;

        var config = this._layoutAlgorithm.config;
        config.set('totalWidth', this._size.width);
        config.set('totalHeight', this._size.height);
        config.set('padding', padding);
        config.set('paddingTop', paddingTop);
        config.set('paddingRight', paddingRight);
        config.set('paddingBottom', paddingBottom);
        config.set('paddingLeft', paddingLeft);
        config.set('isTrellis', this._isTrellis());
        config.set('legendGroup.layout.respectPlotPosition',
                this._properties.origin.get("legendGroup.layout.respectPlotPosition"));
        config.set('legendGroup.layout.alignment',
                this._properties.origin.get("legendGroup.layout.alignment"));
        config.set('title.layout.respectPlotPosition',
                this._properties.origin.get("title.layout.respectPlotPosition"));

        return components;
    };


    ChartView.prototype._postLayout = function () {
        var results = this._layoutResult;

        for (var key in results) {
            if (results.hasOwnProperty(key)) {
                var selection = this._selections[key];
                if (selection.node().tagName === 'DIV') {
                    selection.style({
                        position: 'absolute',
                        left: results[key].x + 'px',
                        top: results[key].y + 'px',
                        height : results[key].height + "px",
                        width : results[key].width + "px"
                    });
                } else {
                    selection.attr('transform', 'translate(' + results[key].x + ', ' + results[key].y + ')');
                }

            }
        }
    };

    ChartView.prototype._getLayoutComponents = function () {
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var child = this.getChild(key);
                var option = child.option;

                var layoutProps = this._properties.proxy(key + ".layout");
                var positionProp = layoutProps.get('position');
                var maxWidth = layoutProps.get("maxWidth");
                var maxHeight = layoutProps.get("maxHeight");
                var width = layoutProps.get("width");
                var height = layoutProps.get("height");

                var position = null;
                var defaultPosition = null;

                if(key === Constants.LEGEND_GROUP.KEY) {
                    if(positionProp === "auto") {
                        position = "right";
                        if(this._size.width < Constants.LEGEND_GROUP.AUTO_THRESHOLD) {
                            position = "bottom";
                        }
                    } else {
                        position = positionProp;
                    }
                    //we have to set current position to legendGroup.
                    child.module.setPosition(position); 

                    if(this._properties.origin.get("legendGroup.forceToShow") && !this._isTrellis()) {
                        //if the legend group is forceToShow, it means legend will take max width and height
                        maxWidth = 1;
                        maxHeight = 1;
                    }
                    //to get rid of invalid value
                    position = child.module.getPosition();
                }else{
                    // for title only because no property of position of title is defined in metadata so far
                    position = child.module.getPosition ? child.module.getPosition() : positionProp;
                }

                if (position) {
                    option.position = position;
                }

                if (!child.module.getPosition) {
                    option.defaultPosition = layoutProps.getDefault("position");
                }

                if (maxWidth) {
                    option.maxWidth = maxWidth;
                }

                if (maxHeight) {
                    option.maxHeight = maxHeight;
                }

                if (width) {
                    option.width = width; /**still keep the unit*/
                    option.maxWidth = width;
                }else{
                    option.width = null;
                }

                if (height) {
                    option.height = height;
                    option.maxHeight = height;
                }else{
                    option.height = null;
                }
            }
        }
        return this._children;
    };

    /**
     * To set size
     * @param size {width: Number, height: Number}
     */
    ChartView.prototype.setSize = function () {
        ChartView.superclass.setSize.apply(this, arguments);
        if (this._rawData) {
            this._updateData();
        }
    };

    ChartView.prototype.getData = function () {
        return this._rawData;
    };

    /**
     * Set DataModel and Scales
     * @param {dataModel: framework/chartmodel/DataModel, scales: {key, chart/scales/BaseScale}} data
     */
    ChartView.prototype.setData = function (data) {
        this._rawData = data;
        this._updateData();
    };

    ChartView.prototype._updateData = function () {
        var data = this._rawData;
        var items = this._getDataItems();
        this._data = {};
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (!data.dataModel[item]) {
                continue;
            }
            this._data[item] = data.dataModel[item]();
            if (data.scales.hasOwnProperty(item)) {
                this._data[item].scale = data.scales[item];
            }
        }
        if (TypeUtils.isFunction(data.dataModel.context)) {
            var context = data.dataModel.context();
            this._data['context'] = context;
        }
        this._data._dataPoints = data.dataModel._dataPoints;
        this._data._seriesType = data.dataModel._seriesType;
        this._extendData();
        this._dataChanged();
    };

    //extend here to let all chart views to get raw data model
    ChartView.prototype._extendData = function(){
        this._data.rawData = this._rawData;
    };

    ChartView.prototype.getBindingMetaData = function () {
        var bindingMetaData = {},
            items = this._getDataItems();

        for (var i = 0; i < items.length; ++i) {
            var item = this._data[items[i]];
            if (item == null) {
                continue;
            }
            var metaData = item.metaData;
            if (metaData == null) {
                continue;
            }
            bindingMetaData[items[i]] = metaData;
        }

        return bindingMetaData;
    };

    /**
     * @return {Array[String]}
     */
    ChartView.prototype._getDataItems = function () {
        return [];
    };

    ChartView.prototype._isTrellis = function () {
        return !!(this._data && (this._data.trellisRow || this._data.trellisColumn));
    };

    ChartView.prototype._dataChanged = function () {
        this._resetPlotContainer();
        this._createPlotContainer(this._isTrellis());
        if(this._supportLazyRender){
            this._plotArea.getDispatch().on("reRenderComplete.chartview", this._reRenderComplete.bind(this));
        }

        if (this._data) {
            for (var key in this._children) {
                if (this._children.hasOwnProperty(key)) {
                    this.getChild(key).module.setData(this._data);
                }
            }
        }
    };

    ChartView.prototype._reRenderComplete = function(){
        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };

    /**
     * @return {JSON}
     */
    ChartView.prototype.properties = function (properties) {
        if (!arguments.length) {
            return this._properties.get();
        }

        this._properties.set(properties);

        return this;
    };

    /**
     * @return {String}
     */
    ChartView.prototype.chartType = function (chartType) {
        if (!arguments.length) {
            return this._chartType;
        }
        this._chartType = chartType;
        return this;
    };

    /**
     * To destroy children elements and its own memebers
     *
     */
    ChartView.prototype.destroy = function () {
        // release all properties which hold dom instances
        ChartView.superclass.destroy.call(this);

        if (this._backgroundNode) {
            this._backgroundNode.remove();
        }
        this._backgroundNode = null;
        
        if (this._background && TypeUtils.isFunction(this._background.destroy)) {
            this._background.destroy();
        }

        this._background = null;
        
        //destory _paginationScrollbarNode and _paginationScrollbar
        if (this._paginationScrollbarNode) {
            this._paginationScrollbarNode.remove();
        }
        this._paginationScrollbarNode = null;

        if (this._paginationScrollbar && TypeUtils.isFunction(this._paginationScrollbar.destroy)) {
            this._paginationScrollbar.destroy();
        }

        this._paginationScrollbar = null;

        this._chartType = null;
        this._properties = null;
        this._plotArea = null;
        this._plotAreaLayout = null;
        this._data = null;

        if (this._rawData) {

            if (this._rawData.dataModel) {
                var dataModel = this._rawData.dataModel;
                if(TypeUtils.isFunction(dataModel.destroy)){
                    dataModel.destroy();
                }
                
            }

            if (this._rawData.scales) {

                var scales = this._rawData.scales;
                for (var key in scales) {
                    if (scales.hasOwnProperty(key) && scales[key] && TypeUtils.isFunction(scales[key].destroy)) {
                        scales[key].destroy();
                        scales[key] = null;
                    }
                }

            }
        }

        this._rawData = null;

        this._outline = null;

        if (this._semanticMgr) {
            this._semanticMgr.destroy();
        }
        this._semanticMgr = null;
    };

    ChartView.prototype.changes = function(changes) {
        if (changes.dataChanged) {
            this.runtime().fireInteractionEvent("dataUpdated");
        }
        if (changes.scalesChanged) {
            this.runtime().fireInteractionEvent("scalesUpdated", changes.scalesChanged);
        }
    };

    ChartView.prototype.changePaddingTop = function(prop, paddings){
        var propStyle = prop.get("valueAxis.label.style");
        var valueLabelTextHeight = TextUtils.canvasMeasure('', propStyle['fontSize'], 
            propStyle['fontWeight'], propStyle['fontFamily']).height;
        if(TypeUtils.isExist(paddings.propertyPaddingInPX) && 
            paddings.propertyPaddingInPX < valueLabelTextHeight / 2) {
            paddings.propertyPaddingTopInPX = valueLabelTextHeight / 2;
        }
        if(TypeUtils.isExist(paddings.propertyPaddingTopInPX) && 
            paddings.propertyPaddingTopInPX < valueLabelTextHeight / 2) {
            paddings.propertyPaddingTopInPX = valueLabelTextHeight / 2;
        }
    };
    return ChartView;
});

define('sap/viz/chart/components/callout/CalloutContainer',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/UIComponent',
    'sap/viz/framework/chartmodel/DataSelector',
    'sap/viz/chart/components/util/TextUtils',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/framework/common/util/ObjectUtils'
], function(
    oo,
    UIComponent,
    DataSelector,
    TextUtils,
    DataPointUtils,
    UnitFormat,
    LangManager,
    ObjectUtils
) {
    var MAX_CALLOUT_NUMBER = 2,
        CONFIG = {
            top: {
                labelGap: 12,
                labelMargin: 2,
                lineExt: 8,
                occupy: "width",
                prefer: "height",
                alignKey: "y",
                positionKey: "left",
                positionKey2: "top",
                offsetKey: "x"
            },
            left: {
                labelGap: 0,
                labelMargin: 2,
                lineExt: 8,
                occupy: "height",
                prefer: "width",
                alignKey: "x",
                positionKey: "top",
                positionKey2: "left",
                offsetKey: "y"
            }
        },
        CALLOUT_CLASSNAME = "v-callout",
        LINE_DASH = "2,3";

    var EMPTY_CHAR = " ";
    var CalloutContainer = function(runtime, options) {
        CalloutContainer.superclass.constructor.apply(this, arguments);
        this._callouts = [];
        this._plotOffset = {
            x: 0,
            y: 0
        };
        this._plotRealSize = null;
    };

    oo.extend(CalloutContainer, UIComponent);

    function getConfig(pos) {
        return CONFIG[pos || this._options.position];
    }

    CalloutContainer.prototype.getPreferredSize = function(bound) {
        var pos = this._options.position,
            rules = this.properties(pos),
            result = {
                width: 0,
                height: 0
            };

        var rulesLen = rules && rules.length;
        if (rulesLen) {
            var fontFamily = this.properties("label.style.fontFamily"),
                fontSize = this.properties("label.style.fontSize"),
                fontWeight = this.properties("label.style.fontWeight"),
                fontStyle = this.properties("label.style.fontStyle"),
                formatString = this.properties("label.formatString"),
                unitFormatType = this.properties("label.unitFormatType");
            var i, config = getConfig.call(this, pos),
                occupy = config.occupy,
                prefer = config.prefer,
                availableSize = bound[occupy] - config.lineExt,
                labelGap = config.labelGap,
                index = 0,
                callouts = this._callouts,
                maxPreferSize = 0,
                done = false,
                data = this.getData();

            var unitObj = this.runtime().statusManager().get("data.unit");
            for (i = 0; i < rulesLen; i++) {
                var rule = rules[i];
                new DataSelector(rule.dataContext, data).iterateDataPoints(function(dp) {
                    var options = {
                        decimalFormatString: 
                        UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.DATALABEL)
                    };
                    var ctx = dp.context(),
                        text = UnitFormat.format(ctx[ctx.measureNames], formatString, unitFormatType, options);
                    if(text === null || text === undefined) {
                        text = LangManager.get('IDS_ISNOVALUE');
                    }
                    else if(ctx.measureNames && unitObj[ctx.measureNames]) {
                        //to add unit string
                        text += (EMPTY_CHAR + unitObj[ctx.measureNames]);
                    }
                    var textMeasure = TextUtils.fastMeasure(text, fontSize, fontWeight,
                        fontFamily, fontStyle);
                    var preferSize = textMeasure[prefer];
                    if (preferSize <= (bound[prefer] - config.lineExt)) {
                        var occupySize = textMeasure[occupy];
                        if (occupySize <= availableSize) {
                            if(!callouts[index]) {
                                callouts[index] = {};
                            }
                            callouts[index].dpId = dp.id;
                            callouts[index].text = text;
                            callouts[index].textMeasure = textMeasure;
                            callouts[index].offset = 0;
                            index++;
                            maxPreferSize = Math.max(maxPreferSize, preferSize);
                            if (index === MAX_CALLOUT_NUMBER || (availableSize -= occupySize + labelGap) <= 0) {
                                done = true;
                                return false;
                            }
                        }
                    }
                });

                if (done) {
                    break;
                }
            }

            if (callouts.length) {
                result[occupy] = bound[occupy];
                result[prefer] = maxPreferSize + config.labelMargin + config.lineExt;
            }
        }
        return result;
    };

    CalloutContainer.prototype.render = function(selection) {
        var calloutPositon = this._options.position;
        
        var callouts = this._callouts;
        if (!callouts.length) {
            return;
        }

        this._selection = selection;
	
        selection.selectAll('*').remove();
        var rootSelection = this._rootSelection = selection.append("g");
        var mainSelection = this._mainSelection = rootSelection.append("g");

        var config = getConfig.call(this),
            prefer = config.prefer,
            alignKey = config.alignKey,
            alignSize = this._size[config.prefer] - config.labelMargin - config.lineExt;

        var calloutsSelection = this._calloutsSelection = mainSelection.selectAll("." + CALLOUT_CLASSNAME)
            .data(callouts).enter()
            .append("g").attr("class", CALLOUT_CLASSNAME);

        var textAnchor = null;
        var envManager = this.runtime().envManager();
        if (envManager) {
            textAnchor = envManager.textAnchor();
        }

        this._labelSelection = calloutsSelection.append("text")
            .text(function(d) {
                return d.text;
            })
            .attr("font-family", this.properties("label.style.fontFamily"))
            .attr("font-size", this.properties("label.style.fontSize"))
            .attr("font-style", this.properties("label.style.fontStyle"))
            .attr("font-weight", this.properties("label.style.fontWeight"))
            .attr("fill", this.properties("label.style.color"))
            .attr("text-anchor", textAnchor)
            .attr(alignKey, function(d) {
                var textMeasure = d.textMeasure;
                var offsetSize = alignSize;
                if(calloutPositon === "left") {
                    offsetSize = alignSize - textMeasure[prefer] - textMeasure[alignKey];
                }
                return offsetSize;
            });

        var lineColor = this._properties.get("line.color");
        if(!lineColor) {
            lineColor = this._properties.getDefault('line.color');
        }
        this._lineSelection = calloutsSelection.append("polyline")
            .attr("stroke", lineColor)
            .attr("fill", "none")
            .attr("stroke-dasharray", LINE_DASH);
    };

    CalloutContainer.prototype.postRender = function(plotNode, plotSize, 
        plotRealSize, dpPlotNode) {
        var callouts = this._callouts;
        if (!callouts.length) {
            return;
        }
        this._plotNode = plotNode;
        
        var plotRect = {};
        plotRect.width = plotNode.getBoundingClientRect().width;
        plotRect.height = plotNode.getBoundingClientRect().height;

        this._plotBoundRect = plotRect;

        var size = this._size;

        var clipSize = {
            width: size.width,
            height: size.height
        };
        var config = getConfig.call(this),
            prefer = config.prefer;
        clipSize[prefer] += plotSize[prefer];

        var clipPathId = "callout_clipPath" + ObjectUtils.guid();
        this._selection.append("clipPath").attr("id", clipPathId)
            .append("rect").attr("width", clipSize.width).attr("height", clipSize.height);

        this._rootSelection.attr("clip-path", "url(#" + clipPathId + ")");
        
        this._plotRealSize = plotRealSize;
        this.update(dpPlotNode);
    };

    CalloutContainer.prototype.update = function(dpPlotNode) {
        var calloutsSelection = this._calloutsSelection;
        if (!calloutsSelection) {
            return;
        }
        //reset label location, because we update label location based on 
        //original location.
        this._selection.selectAll('text').attr("visibility", "hidden");
        if (this._options.position === "top") {
            this._selection.selectAll('text').attr("x", 0);
        }
        else {
            this._selection.selectAll('text').attr("y", 0);
        }

        var config = getConfig.call(this),
            positionKey = config.positionKey,
            positionKey2 = config.positionKey2,
            occupy = config.occupy,
            prefer = config.prefer;

        var plotBoundRect = this._plotBoundRect;
        var plotBoundNode = d3.select(this._plotNode)
            .select(".v-plot-bound").node();
        if (plotBoundNode) {
            plotBoundRect = plotBoundNode.getBoundingClientRect();
        }

        var rectSelection = this._mainSelection.append("rect");
        var origin = rectSelection.node().getBoundingClientRect();
        rectSelection.remove();

        plotBoundRect = {
            left: plotBoundRect.left - origin.left,
            top: plotBoundRect.top - origin.top,
            width: plotBoundRect.width,
            height: plotBoundRect.height
        };

        var callouts = this._callouts;
        callouts.forEach(function(d) {
            d.visible = false;
            var dpRect = d.dpRect;
            var dp = DataPointUtils.findByDataPointId(dpPlotNode, d.dpId);

            if(dp) {
                dpRect = dp.getBoundingClientRect();
                dpRect = d.dpRect = {
                    left: dpRect.left - origin.left,
                    top: dpRect.top - origin.top,
                    width: dpRect.width,
                    height: dpRect.height
                };
    
                //to add width check
                d.visible = (dpRect[positionKey2] + dpRect[prefer] > plotBoundRect[positionKey2] ) &&
                            (dpRect[positionKey2] < plotBoundRect[positionKey2] + plotBoundRect[prefer]) &&
                            (dpRect[positionKey] + dpRect[occupy] > plotBoundRect[positionKey] ) &&
                            (dpRect[positionKey] < plotBoundRect[positionKey] + plotBoundRect[occupy]);
            }
            
            //we have to calculate line start and joint even the label is invisble,
            //becasue "end[positionKey]" need these values
            var lineStart = d.lineStart = {};
            var joint = d.lineJoint = {};
            if(dpRect && dpRect[positionKey] && dpRect[occupy]) {
                var dpRectMiddle = dpRect[positionKey] + dpRect[occupy] / 2;
                lineStart[positionKey] = joint[positionKey] = dpRectMiddle;
                lineStart[positionKey2] = Math.max(dpRect[positionKey2], plotBoundRect[positionKey2]);
                joint[positionKey2] = plotBoundRect[positionKey2];
            }
        });

        //adjustLayout        
        //we have to change all labels, include all invisble labels.
        //because if we scroll the plot area, invisible label may be visible again.
        var labelSelection = calloutsSelection.select("text");
        labelSelection.each(function(d) {
            var labelRect = d.labelRect = this.getBoundingClientRect();
            labelRect = d.labelRect = {
                left: labelRect.left - origin.left,
                top: labelRect.top - origin.top,
                width: labelRect.width,
                height: labelRect.height
            };
            if(d.visible) {
                d.offset = d.lineStart[positionKey] - labelRect[positionKey] - labelRect[occupy] / 2;
            }
        });

        var shownCallouts = callouts.filter(function(d) {
            return d.visible;
        });

        shownCallouts.sort(function(a, b) {
            return a.lineStart[positionKey] - b.lineStart[positionKey];
        });

        var offsetKey = config.offsetKey;
        var firstFixed = false;
        var prevGap;
        if(shownCallouts.length > 0) {
            var first = shownCallouts[0];
            prevGap = first.labelRect[positionKey] + first.offset;
            if (prevGap < 0) {
                first.offset -= prevGap;
                firstFixed = true;
            }
        }

        var len;
        var i;
        var labelGap;
        len = shownCallouts.length;
        labelGap = config.labelGap;
        //the layout function is used to define the offset of each callout item. 
        this.layoutCallouts(shownCallouts, positionKey, occupy, labelGap);


        var lineExt = config.lineExt;
        var calloutPositon = this._options.position;

        labelSelection.attr(offsetKey, function (d) {
            return d.offset;
        }).each(function(d) {
            var labelRect = this.getBoundingClientRect();
            var joint = d.lineJoint;
            var jointPosition = joint[positionKey];
            var labelStart = labelRect[positionKey] - origin[positionKey],
                endPosition;
            if (jointPosition < labelStart) {
                endPosition = labelStart;
            } else {
                var labelEnd = labelStart + labelRect[occupy];
                if (jointPosition > labelEnd) {
                    endPosition = labelEnd;
                } else {
                    endPosition = jointPosition;
                }
            }

            var end = d.lineEnd = {};
            end[positionKey2] = joint[positionKey2] - lineExt;
            end[positionKey] = endPosition;
        });
        
        var allVisibleLabels = calloutsSelection.attr("visibility", function(d) {
            return d.visible ? null : "hidden";
        }).filter(function(d) {
            return d.visible;
        });

        allVisibleLabels.select("polyline").attr("points", function(d) {
            return [d.lineStart, d.lineJoint, d.lineEnd].map(function(p) {
                return p.left + "," + p.top;
            }).join(" ");
        });

        //make text visible again
        this._selection.selectAll('text').attr("visibility", null);
    };
    
    CalloutContainer.prototype.normalizeItem = function (calloutItem, positionKey, occupy) {
        //to simplify layout logical, plus labelRect[positionKey], and then reduce it. 
        //There is no labelRect[positionKey].
        if(calloutItem.offset < 0) {
            calloutItem.offset = 0;
        }
        else if ((calloutItem.offset + calloutItem.labelRect[occupy]) >
                this._plotRealSize[occupy]) {
            calloutItem.offset = this._plotRealSize[occupy] - calloutItem.labelRect[occupy];
        }
    };

    CalloutContainer.prototype.layoutCallouts = function(shownCallouts, positionKey, occupy, labelGap) {
        //the function is used to define the offsets. The function just layout 1 or 2 callout items,
        //because we will have at most 2 callout in one direction.
        var allSpace = this._plotRealSize[occupy];
        //to simplify layout logical, plus labelRect[positionKey], and then reduce it
        if (shownCallouts.length > 0) {
            shownCallouts[0].offset += shownCallouts[0].labelRect[positionKey];
            if (shownCallouts[1]) {
                shownCallouts[1].offset += shownCallouts[1].labelRect[positionKey];
            }
        }

        if(shownCallouts.length === 1) {
            var calloutItem = shownCallouts[0];
            this.normalizeItem(calloutItem, positionKey, occupy);
        }
        else if(shownCallouts.length === 2){
            var firstItem = shownCallouts[0];
            var lastItem = shownCallouts[1];
            
            this.normalizeItem(firstItem, positionKey, occupy);
            this.normalizeItem(lastItem, positionKey, occupy);
            
            var itemsOverlapped = false;
            if ((firstItem.offset + firstItem.labelRect[occupy] + labelGap) >
                lastItem.offset) {
                itemsOverlapped = true;
            }
            
            //preferred size algorithm 
            if(itemsOverlapped) {
                var tryOffset;
                //move one or move two items
                tryOffset = (firstItem.offset + firstItem.labelRect[occupy] + labelGap);
                if((tryOffset + lastItem.labelRect[occupy]) <= allSpace) {
                    lastItem.offset = tryOffset;
                }
                else {
                    tryOffset = (lastItem.offset - labelGap - 
                            firstItem.labelRect[occupy]);
                    if((tryOffset) > 0) {
                        firstItem.offset = tryOffset;
                    }
                    else {
                        //we have to move 2 labels. 
                        if(firstItem.offset < (allSpace - lastItem.offset)) {
                            //put them from left
                            firstItem.offset = 0;
                            lastItem.offset = firstItem.labelRect[occupy] + labelGap;
                        }
                        else {
                            //put them from right
                            lastItem.offset = allSpace - lastItem.labelRect[occupy];
                            firstItem.offset = allSpace - lastItem.labelRect[occupy] - labelGap - 
                                firstItem.labelRect[occupy];
                        }
                    }
                }
            }
        }

        if (shownCallouts.length > 0) {
            shownCallouts[0].offset -= shownCallouts[0].labelRect[positionKey];
            if (shownCallouts[1]) {
                shownCallouts[1].offset -= shownCallouts[1].labelRect[positionKey];
            }
        }
    };
    
    CalloutContainer.prototype.afterPlotZoom = function(dpPlotNode) {
        this.update(dpPlotNode);
    };

    CalloutContainer.prototype.setPlotRealSize = function(plotSize) {
        this._plotRealSize = plotSize;
    };

    CalloutContainer.prototype.scroll = function(offset) {
        var mainSelection = this._mainSelection;
        if (mainSelection) {
            this._mainSelection.attr("transform", "translate(" + offset.x + "," + offset.y + ")");
        }
    };

    CalloutContainer.prototype.afterPlotScroll = function(offset, dpPlotNode) {
        var current = this._plotOffset;
        if (offset.x != null) {
            current.x = offset.x;
        }
        if (offset.y != null) {
            current.y = offset.y;
        }

        this.update(dpPlotNode);
    };

    CalloutContainer.prototype.destroy = function() {
        CalloutContainer.superclass.destroy.apply(this, arguments);
        this._selection = null;
        this._rootSelection = null;
        this._mainSelection = null;
        this._calloutsSelection = null;
        this._plotNode = null;
        this._plotRealSize = null;
    };

    return CalloutContainer;
});

define('sap/viz/chart/layout/XYLayout',[
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/layout/BaseLayout"
], function Setup(NumberUtils, TypeUtils, oo, BaseLayout) {

    // var VERTICALSEQUENCELAYOUTMODULE = ['left', 'right', 'bottom', 'top'];
    // var HORIZONTALSEQUENCELAYOUTMODULE = ['bottom', 'top', 'left', 'right'];
    // var VERTICALSEQUENCE = ['width', 'width', 'height', 'height'];
    // var HORIZONTALSEQUENCE = ['height', 'height', 'width', 'width'];
    var layoutNameMapping = {
        'height': { max: 'maxHeight',
                    fix: 'height'},
        'width': {  max: 'maxWidth',
                    fix: 'width'}
    };
    var position2SizeField = {
        left: "width",
        right: "width",
        top: "height",
        bottom: "height"
    };
    var position2RefSizeField = {
        left: "height",
        right: "height",
        top: "width",
        bottom: "width"
    };

    var TOPPADDINGINDEX = 0;
    var LEFTPADDINGINDEX = 1;
    var BOTTOMPADDINGINDEX = 2;
    var RIGHTPADDINGINDEX = 3;

    var DEFAULT_MAX_WIDTH = 1 / 3;
    var DEFAULT_MAX_HEIGHT = 1 / 3;


    function XYLayout(){
        XYLayout.superclass.constructor.apply(this, arguments);
        this.config.add({
            padding: [0, 0, 0, 0],
            rootWidth: 0,
            rootHeight: 0,
            layoutSequence: []
        });
    }

    oo.extend(XYLayout, BaseLayout);

    /*
     * items:
     * [{
     *      maxHeight: 1,
     *      maxWidth: 1,
     *      module: null,
     *      padding: [],
     *      position: ''
     * }]
     */
    XYLayout.prototype.layout = function(components, options){
        var results = {};
        var preferredSizeTable = {};
        var config = this.config;
        var i = 0;
        var width = config.get('totalWidth');
        var height = config.get('totalHeight');
        var rootWidth = config.get('rootWidth');
        var rootHeight = config.get('rootHeight');
        var rootSize = {
            width: config.get("rootWidth"),
            height: config.get("rootHeight")
        };
        var padding = config.get('padding');
        var layoutSequence = config.get('layoutSequence');

        var totalWidth = width - (padding[LEFTPADDINGINDEX] + padding[RIGHTPADDINGINDEX]);
        var totalHeight = height - (padding[TOPPADDINGINDEX] + padding[BOTTOMPADDINGINDEX]);
        totalWidth = totalWidth > 0 ? totalWidth : 0;
        totalHeight = totalHeight > 0 ? totalHeight : 0;

        var component;
        var item, o;
        var option;
        var pos;
        var componentsByPosition = {};
        for (var key in components) {
            if (components.hasOwnProperty(key)) {
                component = components[key];
                option = component.option;
                pos = option.position;

                if (!componentsByPosition.hasOwnProperty(pos)){
                    componentsByPosition[pos] = [];
                }

                var priority = option.priority;
                if (priority == null){
                    priority = -1;
                }

                var componentsByPositionArray = componentsByPosition[pos];
                var len = componentsByPositionArray.length;
                for (i = 0; i < len; i++) {
                    if (priority >= componentsByPositionArray[i].option.priority) {
                        break;
                    }
                }

                componentsByPositionArray.splice(i, 0, {
                    module: component.module,
                    option: {
                        unique: option.unique,
                        priority: priority,
                        position: pos,
                        padding: {
                            paddingTop: getFloatValueOrZero(option.paddingTop),
                            paddingBottom: getFloatValueOrZero(option.paddingBottom),
                            paddingLeft: getFloatValueOrZero(option.paddingLeft),
                            paddingRight: getFloatValueOrZero(option.paddingRight)
                        },
                        maxWidth: isValidSize(option.maxWidth) ? option.maxWidth : DEFAULT_MAX_WIDTH,
                        maxHeight: isValidSize(option.maxHeight) ? option.maxHeight : DEFAULT_MAX_HEIGHT,
                        width: isValidSize(option.width) ? option.width : null,
                        height: isValidSize(option.height) ? option.height : null
                    }
                });
            }
        }

        var items = [];
        for(i = 0; i < layoutSequence.length; ++i){
            pos = layoutSequence[i];
            if (TypeUtils.isFunction(pos)) {
                items.push(pos);
                continue;
            }
            var array = componentsByPosition[pos];
            if (array){
                Array.prototype.push.apply(items, array);
            }
        }
        items.push(componentsByPosition.center[0]);
        if (!componentsByPosition.center) {
            throw "Cannot solve layout without plot";
        }

        var total = {
            width: rootWidth ? rootWidth : totalWidth,
            height: rootHeight ? rootHeight : totalHeight
        };
        var availableRegion = {
            width: totalWidth,
            height: totalHeight,
            x: padding[LEFTPADDINGINDEX],
            y: padding[TOPPADDINGINDEX]
        };
        var hasOneModule = {
            center: false
        };
        var uniqueModulePosList = [];
        var length = items.length;
        for (i = 0; i < length; i++) {
            item = items[i];
            if (TypeUtils.isFunction(item)) {
                //extraInfo for dual axis 
                var extraInfo = {
                    preferredSizeTable: preferredSizeTable,
                };

                item(results, availableRegion, extraInfo);
                continue;
            }
            o = {};
            results[item.module.alias] = o;
            option = item.option;
            var module = item.module;
            pos = option.position;
            if(pos === 'center'){
                continue;
            }
            var measureValueName = position2SizeField[pos];
            var refValueName = position2RefSizeField[pos];
            o.padding = option.padding;
            var modulePadding = {
                width: 0,
                height: 0
            };
            modulePadding.height += o.padding.paddingTop + o.padding.paddingBottom;
            modulePadding.width += o.padding.paddingLeft + o.padding.paddingRight;

            var preferredSize = 0;
            var refSize = {},
                rawFixSizeValue = option[layoutNameMapping[measureValueName].fix],
                fixSizeValue = item.module.properties('visible') === true && rawFixSizeValue !== null ? 
                                NumberUtils.getSizeValue(rawFixSizeValue, total[measureValueName]) : undefined;

            if (fixSizeValue === undefined){
                if (TypeUtils.isFunction(module.getPreferredSize)) {
                    var sizeValue = NumberUtils.getSizeValue(
                                        option[layoutNameMapping[measureValueName].max],                    
                                        total[measureValueName]
                                    );
                    sizeValue = sizeValue > availableRegion[measureValueName] ?
                            availableRegion[measureValueName] :
                            sizeValue;
                    refSize[refValueName] = availableRegion[refValueName];
                    refSize[measureValueName] = sizeValue;
                    
                    if(!uniqueModulePosList[pos]) {
                        var tempPrfSize = module.getPreferredSize(refSize);
                        preferredSize = tempPrfSize[measureValueName] + modulePadding[measureValueName];
                        preferredSizeTable[item.module.alias] = tempPrfSize;
                    }
                    sizeValue = preferredSize > sizeValue ? sizeValue : preferredSize;
                    availableRegion[measureValueName] = availableRegion[measureValueName] - sizeValue;
                    o[measureValueName] = sizeValue;                
                } else {
                    o[measureValueName] = 0;
                }
            }else{
                fixSizeValue = fixSizeValue > availableRegion[measureValueName] ?
                                    availableRegion[measureValueName] :
                                    fixSizeValue;
                if(TypeUtils.isFunction(module.getPreferredSize)){
                    // Still call getPreferredSize to gain its side effect,
                    // such as deciding whether we need a scroll bar in time axis.
                    refSize[refValueName] = availableRegion[refValueName];
                    refSize[measureValueName] = fixSizeValue;
                    if(!uniqueModulePosList[pos]) {
                        preferredSize = module.getPreferredSize(refSize, options);
                        preferredSizeTable[item.module.alias] = preferredSize;
                    }
                }

                availableRegion[measureValueName] = availableRegion[measureValueName] - fixSizeValue;
                o[measureValueName] = fixSizeValue;
            }
            
            if(preferredSize && item.option.unique) {
                uniqueModulePosList[pos] = true;
            }
        }    

        for (i = 0; i < length; i++) {
            item = items[i];
            if (!item) {
                continue;
            } else if (TypeUtils.isFunction(item)) {
                continue;
            }
            o = results[item.module.alias];
            if (!o.hasOwnProperty('width')) {
                o.width = availableRegion.width;
            } else if (!o.hasOwnProperty('height')) {
                o.height = availableRegion.height;
            }
            switch (item.option.position) {
                case "top":
                    availableRegion.y = availableRegion.y + o.height;
                    break;
                case "left":
                    availableRegion.x = availableRegion.x + o.width;
                    break;
            }
        }

        var topY = availableRegion.y,
            leftX = availableRegion.x,
            bottomY = availableRegion.y + availableRegion.height,
            rightX = availableRegion.x + availableRegion.width;

        for (i = length - 1; i >= 0; i--) {
            item = items[i];
            if (TypeUtils.isFunction(item)) {
                continue;
            }
            else if(item) {
                option = item.option;
                o = results[item.module.alias];

                switch (option.position) {
                    case "top":
                        o.x = availableRegion.x;
                        o.y = topY -= o.height;
                        break;
                    case "left":
                        o.x = leftX -= o.width;
                        o.y = availableRegion.y;
                        break;
                    case "bottom":
                        o.x = availableRegion.x;
                        o.y = bottomY;
                        bottomY += o.height;
                        break;
                    case "right":
                        o.x = rightX;
                        rightX += o.width;
                        o.y = availableRegion.y;
                        break;
                    case "center":
                        o = results[item.module.alias] = {};
                        o.x = availableRegion.x;
                        o.y = availableRegion.y;
                        o.width = availableRegion.width;
                        o.height = availableRegion.height;
                        break;
                }

                if (!TypeUtils.isPlainObject(o.padding)) {
                    o.padding = option.padding;
                }
                if (option.position === 'top') {
                    o.y += o.padding.paddingTop;
                }
                if (option.position === 'left') {
                    o.x += o.padding.paddingLeft;
                }
                o.height -= o.padding.paddingTop + o.padding.paddingBottom;
                o.width -= o.padding.paddingLeft + o.padding.paddingRight;

                availableRegion.height = availableRegion.height > 0 ? availableRegion.height : 0;
                availableRegion.width = availableRegion.width > 0 ? availableRegion.width : 0;
            }
        }
        return results;
    };

    // Utility -----------------------------------------------

    function getLayoutInfomation(layout) {
        return {
            paddingTop: parseFloat(layout.paddingTop),
            paddingBottom: parseFloat(layout.paddingBottom),
            paddingLeft: parseFloat(layout.paddingLeft),
            paddingRight: parseFloat(layout.paddingRight)
        };
    }

    function getFloatValueOrZero(v) {
        var ret = parseFloat(v);
        if (isNaN(ret)) {
            ret = 0;
        }
        return ret;
    }

    function isValidSize(v){
        
        var value = parseFloat(v);
        
        return TypeUtils.isNumber(value) && value >= 0;
    }

    return XYLayout;
});

define('sap/viz/chart/components/container/utils/xyTransformUtils',[
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/TypeUtils'
], function (
    DataGraphics,
    TypeUtils
) {
    function zoomScale(xyc) {
        var cchild = xyc.getChildrenByPosition("center")[0],
            realSz = cchild.getRealSize(),
            viewSz = cchild.getSize();
        var x = realSz.width / viewSz.width;
        var y = realSz.height / viewSz.height;
        if (!isFinite(x)) {
            if (realSz.width === 0) {
                x = 1;
            } else {
                return null;
            }
        }

        if (!isFinite(y)) {
            if (realSz.height === 0) {
                y = 1;
            } else {
                return null;
            }
        }
        
        return {x: x, y: y};
    }

    function defstatus(xyc) {
        return {
            "scale": {
                set: function(v) {
                    xyc.zoom(v);
                    xyc.getChildrenByPosition("center")[0].update();
                    return zoomScale(xyc);
                },
                get: zoomScale.bind(null, xyc)
            },
            "translate": {
                set: function(v) {
                    if (v.x !== undefined || v.y !== undefined) {
                        xyc.scroll(v);
                    } else if (v.translateByPage) {
                        xyc.scrollByPage(v.translateByPage);
                    }
                    return v;
                },
                get: function() {
                    var plotAreaObj = xyc.getChildrenByPosition("center")[0];
                    var translateObj = plotAreaObj.getOffset();
                    if(!translateObj) {
                        translateObj = {};
                    }
                    
                    translateObj.position = 0;
                    if(xyc._paginationScrollbarRef) {
                        translateObj.position = xyc._paginationScrollbarRef._thumbPosition /
                            xyc._paginationScrollbarRef._maxThumbPosition;
                        if(isNaN(translateObj.position)) {
                            translateObj.position = 0;
                        }
                    }
                    
                    return translateObj;
                }
            }
        };
    }

    function adjustXYTranslate(node, scale, translate) {
        var data = DataGraphics.getData(node);
        if (!data || !scale) {
            return;
        }

        var transX = 0;
        var transY = 0;
        if (TypeUtils.isExist(data.initPosX)) {
            transX = data.initPosX * scale.x + translate.x;
        }
        else if (TypeUtils.isExist(data.initPosY)) {
            transY = data.initPosY * scale.y + translate.y;
        }

        node.setAttribute("transform", "translate(" + transX + "," + transY + ")");
    }

    return {
        defstatus: defstatus,
        adjustXYTranslate: adjustXYTranslate
    };
});

define('sap/viz/chart/components/container/XYContainer',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/container/UIContainer",
    "sap/viz/framework/common/util/PositionUtil",
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/FiscalUtil',
    "sap/viz/chart/layout/XYLayout",
    'sap/viz/framework/common/util/PropertyZoneUtil',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/FeedingZoneUtil',
    "sap/viz/chart/components/container/utils/xyTransformUtils",
    "sap/viz/chart/behavior/config/SelectionUtil"
], function(
        oo,
        UIContainer,
        PositionUtil,
        TypeUtils,
        FiscalUtil,
        XYLayout,
        PropertyZoneUtil,
        NumberUtils,
        Constants,
        FeedingZoneUtil,
        xyTransformUtils,
        SelectionUtil
) {
    var XYContainer = function(runtime, options) {
        XYContainer.superclass.constructor.apply(this, arguments);
        this._initLayout();
        this._layoutSequence = null;
        this._roughSize = {
            width: 0,
            height: 0
        };
        this._posToModuleMap = {};
        this._vScrollbar = null;
        this._hScrollbar = null;
        this._registerZoneManager(runtime, options);
        runtime.statusManager().proxy("plot.transform").add(xyTransformUtils.defstatus(this));
        this._exposeMoreEvents("reRenderComplete");
        this._zoomer = this._getZoomer();
    };
    oo.extend(XYContainer, UIContainer);

    XYContainer.prototype._registerZoneManager = function(runtime) {
        runtime.zoneManager().add(PropertyZoneUtil.plot(this));
        runtime.zoneManager().add(FeedingZoneUtil.plot(this));
    };

    XYContainer.prototype._getLayoutDefinition = function() {
        return XYLayout;
    };

    XYContainer.prototype._initLayout = function() {
        var LayoutClazz = this._getLayoutDefinition();
        this.setLayoutAlgorithm(new LayoutClazz());
    };

    XYContainer.prototype.setRoughSize = function(value) {
        if (value.width != null) {
            this._roughSize.width = value.width;
        }
        if (value.height != null) {
            this._roughSize.height = value.height;
        }
        var updatedScaleValue = this.updateValueScale();
        var statusManager = this.runtime().statusManager();
        if(updatedScaleValue && statusManager.has("updatedScaleValue")){
            statusManager.set('updatedScaleValue', updatedScaleValue);
        }
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                if(this._children[key].module && this._children[key].module.setRoughSize){
                    this._children[key].module.setRoughSize(value);
                }
            }
        }
        return this;
    };

    XYContainer.prototype.getVScrollbar = function() {
        return this._vScrollbar;
    };

    XYContainer.prototype.getHScrollbar = function() {
        return this._hScrollbar;
    };

    XYContainer.prototype.updateValueScale = function(value) {};

    XYContainer.prototype.setLayoutSequence = function(value) {
        this._layoutSequence = value;
        return this;
    };

    XYContainer.prototype.render = function(rootElement) {
        XYContainer.superclass.render.apply(this, arguments);
        if (this._size.width > 0 && this._size.height > 0 && this._layoutResult) {
            this._initRenderBase(rootElement);
            PositionUtil.positionElements(this._layoutResult, this._selections);
            this._preRender();
            this._renderSub();
            this._postRender();
        }
    };

    function _onVScroll(e) {
        this._scroll({
            y: e.offset
        });
    }

    function _onHScroll(e) {
        this._scroll({
            x: e.offset
        });
    }

    XYContainer.prototype._preRender = function() {
        var centerModule = this.getChildrenByPosition("center")[0];
        if (centerModule && (this._vScrollbar || this._hScrollbar)) {            
            var size = centerModule.getSize();
            var realSize = centerModule.getRealSize();
            if (this._vScrollbar) {
                this._vScrollbar.setTrackSize(size.height).setContentSize(realSize.height);
                this._vScrollbar.getDispatch().on("scroll.xycontainer", _onVScroll.bind(this));
            }
            if (this._hScrollbar) {
                this._hScrollbar.setTrackSize(size.width).setContentSize(realSize.width);
                this._hScrollbar.getDispatch().on("scroll.xycontainer", _onHScroll.bind(this));
            }
        }
    };

    XYContainer.prototype._postRender = function() {
        var zoomer = this.getZoomer();
        if (zoomer) {
            zoomer.reset(this._selections);
        }
    };

    XYContainer.prototype.scroll = function(offset) {
        var centerModule = this.getChildrenByPosition("center")[0];
        var size = centerModule.getSize();
        var realSize = centerModule.getRealSize();
        var x, y, maxOffset, thumbRatio, pos;
        if (offset.x !=  null) {
            maxOffset = size.width - realSize.width;
            x = Math.min(0, Math.max(maxOffset, offset.x));
            if (this._hScrollbar) {
                pos = -x;
                thumbRatio = this._hScrollbar.getThumbRatio();
                if (thumbRatio){
                    pos /= thumbRatio;
                }
                this._hScrollbar.setThumbPosition(pos);
            }
        }
        if (offset.y !=  null) {
            maxOffset = size.height - realSize.height;
            y = Math.min(0, Math.max(maxOffset, offset.y));
            if (this._vScrollbar) {
                pos = -y;
                thumbRatio = this._vScrollbar.getThumbRatio();
                if (thumbRatio){
                    pos /= thumbRatio;
                }
                this._vScrollbar.setThumbPosition(pos);
            }
        }
        var offsetNow = this.getOffset();
        this._scroll({
            x: TypeUtils.isNumber(x) ? x : offsetNow.x,
            y: TypeUtils.isNumber(y) ? y : offsetNow.y
        });
    };

    XYContainer.prototype.scrollByPage = function(translate) {
        var offset;
        if (translate.context) {
            var categoryModule = this.getChild("categoryAxis").module;
            if (categoryModule) {
                var axisBodyModule = categoryModule.getChild("axisBody").module;
                offset = axisBodyModule.getLabelOffsetByCtx(translate.context);
            }
        }
        if (TypeUtils.isNumber(translate.offset)) {
            var centerModule = this.getChildrenByPosition("center")[0];
            offset = centerModule.getRemainingPlotOffset(offset, translate.offset);
        }
        if (offset !== null && offset !== undefined) {
            this.scroll(offset);
        }
    };

    function zoomChild(scale, child){
        var fn = child.zoom;
        if (fn) {
            fn.call(child, scale);
        }
    }

    XYContainer.prototype.zoom = function(scale){
        var centerModule = this.getChildrenByPosition("center")[0];
        var size = centerModule.getSize();
        var realSize = centerModule.getRealSize();
        var fn;
        if (scale.x) { // to filter out falsy values like NaN, 0, null and undefined
            fn = zoomChild.bind(null, {
                x: scale.x,
                y: 1
            });
            realSize.width = size.width * scale.x;
            this.getChildrenByPosition("top").forEach(fn);
            this.getChildrenByPosition("bottom").forEach(fn);
        }

        if (scale.y) {
            fn = zoomChild.bind(null, {
                x: 1,
                y: scale.y
            });
            realSize.height = size.height * scale.y;
            this.getChildrenByPosition("left").forEach(fn);
            this.getChildrenByPosition("right").forEach(fn);
        }
        centerModule.setRealSize(realSize);
        if (this._vScrollbar) {
            this._vScrollbar.setContentSize(realSize.height).render();
        }
        if (this._hScrollbar) {
            this._hScrollbar.setContentSize(realSize.width).render();
        }
        var centerChild = this.getChildrenByPosition("center")[0];
        if (centerChild) {
            zoomChild(scale, centerChild);
        }
    };

    XYContainer.prototype.getOffset = function(){
        var child = this.getChildrenByPosition("center")[0];
        return child && child.getOffset();
    };

    function scrollChild(offset, child){
        var fn = child.scroll;
        if (fn) {
            fn.call(child, offset);
        }
    }

    XYContainer.prototype._scroll = function(offset) {
        if (!offset) {
            return;
        }
        var fn;
        if (offset.x != null) {
            fn = scrollChild.bind(null, {
                x: offset.x,
                y: 0
            });
            this.getChildrenByPosition("top").forEach(fn);
            this.getChildrenByPosition("bottom").forEach(fn);
        }

        if (offset.y != null) {
            fn = scrollChild.bind(null, {
                x: 0,
                y: offset.y
            });
            this.getChildrenByPosition("left").forEach(fn);
            this.getChildrenByPosition("right").forEach(fn);
        }

        var centerChild = this.getChildrenByPosition("center")[0];
        if (centerChild) {
            scrollChild(offset, centerChild);
        }

        this.runtime().fireInteractionEvent('plotScroll', offset);
        this.runtime().eventDispatcher().fire('plotScroll', offset);
    };

    XYContainer.prototype.setChild = function(key, module, option) {
        XYContainer.superclass.setChild.apply(this, arguments);
        if (option.position) {
            var pos = option.position;
            var posToModuleMap = this._posToModuleMap;
            if (!posToModuleMap.hasOwnProperty(pos)){
                posToModuleMap[pos] = [];
            }
            var array = posToModuleMap[pos];
            var ii, tempMod;
            var appendToEnd = true;
            for(ii = 0; ii < array.length; ii++){
                tempMod = array[ii];
                if(tempMod === module || tempMod.alias == module.alias){
                    appendToEnd = false;
                    array[ii] = module;
                    break;
                }
            }

            if(appendToEnd){
                array.push(module);
            }
            
            if (module.setPosition) {
                module.setPosition(pos);
            }
        }
    };

    XYContainer.prototype.getChildrenByPosition = function(pos) {
        return this._posToModuleMap[pos] || [];
    };

    XYContainer.prototype.removeChild = function(key){
        var child = this._children[key];
        var array = this._posToModuleMap[child.option.position];
        array.splice(array.indexOf(child.module), 1);
        delete this._children[key];
    };

    // Only used for legend group to align with plot instead of plotArea.
    // See ChartView.layout
    XYContainer.prototype.getPlotPosition = function() {
        return (this._layoutResult && this._layoutResult.plot);
    };

    XYContainer.prototype._configLayout = function(options) {
        var getPositiveInt = NumberUtils.getPositiveInt;
        var originProp = this._properties.origin;
        var paddingInfo = this.calculatePaddingInPX(originProp, this._roughSize.width, this._roughSize.height);

        var padding = getPositiveInt(paddingInfo.propertyPaddingInPX, paddingInfo.constantPaddingInPX);
        var paddingTop = getPositiveInt(paddingInfo.propertyPaddingTopInPX, padding);
        var paddingRight = getPositiveInt(paddingInfo.propertyPaddingRightInPX, padding);
        var paddingBottom = getPositiveInt(paddingInfo.propertyPaddingBottomInPX, padding);
        var paddingLeft = getPositiveInt(paddingInfo.propertyPaddingLeftInPX, padding);
        
        var layoutConfig = this._layoutAlgorithm.config;
        layoutConfig.set('totalWidth', this._size.width);
        layoutConfig.set('totalHeight', this._size.height);
        layoutConfig.set('rootWidth', this._roughSize.width - (paddingRight + paddingLeft));
        layoutConfig.set('rootHeight', this._roughSize.height - (paddingTop + paddingBottom));
        layoutConfig.set('paddings', [paddingTop, paddingLeft, paddingBottom, paddingRight]);
        layoutConfig.set('layoutSequence', this._layoutSequence);

        //Set layout info
        for ( var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var child = this.getChild(key);
                var option = child.option;
                var layoutProps = this._properties.proxy(key + '.layout');
                
                var maxWidth = layoutProps.get("maxWidth");
                var maxHeight = layoutProps.get("maxHeight");
                var width = layoutProps.get("width");
                var height = layoutProps.get("height");
                
                if (width){
                    option.width = width;
                }else{
                    option.width = null;
                } 
                if (height){
                    option.height = height;
                }else{
                    option.height = null;
                } 
                if (maxWidth) {
                    option.maxWidth = maxWidth;
                }
                
                if (maxHeight) {
                    option.maxHeight = maxHeight;
                }
                
                if(options && options.pagination && 
                   options.pagination.mode === Constants.PAGINATION_MODE.UPDATE && 
                   options.plotAreaLayout && options.plotAreaLayout[key]) {
                    var moduleSize = options.plotAreaLayout[key].module._size;
                    if(!option.width && moduleSize.width) {
                        option.width = moduleSize.width;
                    }
                    
                    if(!option.height && moduleSize.height) {
                        option.height = moduleSize.height;
                    }
                }
            }
        }
        return this._children;
    };

    XYContainer.prototype._postLayout = function(results) {
        for(var key in this._children){
            if(this._children.hasOwnProperty(key)){
                var module = this._children[key].module;
                var size = results[key];
                module.setSize(size, module._needOtherSize ? results : undefined);
            }
        }
    };
    
    XYContainer.prototype.paginationOptions = function() {
        var dataModel = this._runtime && this._runtime._interaction &&
            this._runtime._interaction._service && this._runtime._interaction._service.getDataModel();
        var paginationOptions;
        if(dataModel && dataModel.getPaginationOptions) {
            paginationOptions = dataModel.getPaginationOptions();
        }
        return paginationOptions;
    };

    XYContainer.prototype.getAddtionalInfo = function () {
    };

    XYContainer.prototype._renderSub = function() {
        var categoryAxisChild = this.getChild("categoryAxis");
        var categoryAxisModule;
        if(categoryAxisChild) {
            categoryAxisModule = categoryAxisChild.module;
        }
        var positions = this._layoutSequence || ['left', 'right', 'bottom', 'top'];
        if(positions.indexOf("center") <0 ){
            positions.push("center");
        }
        var fn = function(child){
            //if categoryAxis is top or bottom, it means pagination bar 
            //is top or bottom, so we need to draw XYContainer scrollbar
            if(!this.paginationOptions() ||
                child.alias !== Constants.SCROLLBAR.ALIAS ||
                !categoryAxisModule ||
                categoryAxisModule._position === "top" ||
                categoryAxisModule._position === "bottom") {
                child.render(this._selections[child.alias], this.getAddtionalInfo(child));
            }
        }.bind(this);
        for(var i=0; i< positions.length; i++){
            this.getChildrenByPosition(positions[i]).forEach(fn);
        }
    };

    XYContainer.prototype._initRenderBase = function(parentNode) {
        if (this._selections) {
            return;
        }
        this._selections = {};
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                if (this._selections[key] == null) {
                    if (this._children[key].option.position === "center") {
                        this._selections[key] = parentNode.insert("g", ":first-child").attr('class', 'v-m-' + key);
                    } else {
                        this._selections[key] = parentNode.append("g").attr('class', 'v-m-' + key);
                    }
                }
            }
        }
    };

    XYContainer.prototype.destroy = function() {
        XYContainer.superclass.destroy.call(this);
        this._layoutSequence = null;
        this._layoutResult = null;
        this._roughSize = null;
        this._posToModuleMap = {};
        this._vScrollbar = null;
        this._hScrollbar = null;
        if(this._zoomer){
            this._zoomer.destroy();
            this._zoomer = null;
        }
    };

    XYContainer.prototype.getZoomer = function() {
        return this._zoomer;
    };

    XYContainer.prototype._getZoomer = function() {
        return null;
    };

    XYContainer.prototype._hasScrollbar = function(){
        var isFixedDataPointSize = !!this._properties.get('plotArea.isFixedDataPointSize');
        var windowStart = this._properties.get("plotArea.window.start");
        var windowEnd = this._properties.get("plotArea.window.end");

        var values = FiscalUtil.startEndConvertor(windowStart, windowEnd, this._properties.origin);
        windowStart = values.start;
        windowEnd = values.end;

        var isInteractive = !this._properties.get("interaction.noninteractiveMode");
        var ret = (isFixedDataPointSize || !!windowStart || !!windowEnd) && isInteractive &&
            !(windowStart === "firstDataPoint" && windowEnd === "lastDataPoint");
        return ret;
    };    
    
    return XYContainer;
});

define('sap/viz/chart/components/axis/sub/AxisComponent',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/components/UIComponent",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/PositionUtil"
], function(oo, Constants, UIComponent, NumberUtils, TextUtils, PositionUtils) {

    var AXIS_VCLASS = Constants.CSS.CLASS.AXIS;

    var AxisComponent = function(runtime, options) {
        AxisComponent.superclass.constructor.apply(this, arguments);
        this._position = null;
        this._formerProperties = null;
        this._preferredSize = {
            minWidth: 0,
            minHeight: 0
        };
    };

    oo.extend(AxisComponent, UIComponent);

    AxisComponent.prototype.setPosition = function(pos) {
        this._position = pos;
        return this;
    };

    AxisComponent.prototype._isVertical = function() {
        return PositionUtils.isVertical(this._position);
    };

    AxisComponent.prototype._isHorizontal = function() {
        return PositionUtils.isHorizontal(this._position);
    };

    AxisComponent.prototype._measureTextSize = function(text, style) {
        var size = TextUtils.canvasMeasure(text, style['fontSize'], style['fontWeight'], style['fontFamily'],
                    style['letterSpacing']);
        return NumberUtils.preciseObject(size);
    };

    AxisComponent.prototype._measureTextSizeForFixPadding = function(text, style) {
        var size = TextUtils.fastMeasure(text, style['fontSize'], style['fontWeight'], style['fontFamily'], 
                style['letterSpacing']);
        return NumberUtils.preciseObject(size);
    };

    AxisComponent.prototype._updatePfdSize = function(size) {
        if (size.minWidth != null) {
            this._preferredSize.minWidth = size.minWidth;
        }
        if (size.minHeight != null) {
            this._preferredSize.minHeight = size.minHeight;
        }
    };

    AxisComponent.prototype._isSpaceEnough = function() {
        if (this._realSize.width === 0 || this._realSize.height === 0) {
            return false;
        }
        var pfdSize = this._preferredSize;
        return Math.ceil(pfdSize.minWidth) <= Math.ceil(this._realSize.width) && 
            Math.ceil(pfdSize.minHeight) <= Math.ceil(this._realSize.height);
    };

    AxisComponent.prototype.mayOnlyFirstAndLastLabel = function() {
        return false;
    };

    AxisComponent.prototype.destroy = function() {
        AxisComponent.superclass.destroy.call(this);
        this._position = null;
        this._formerProperties = null;
        this._preferredSize = null;
    };
    
    return AxisComponent;

});
define('sap/viz/migrate/PropertyUtil',[ 'sap/viz/framework/common/util/ObjectUtils', 'sap/viz/framework/common/util/TypeUtils' ], function Setup(
        ObjectUtils, TypeUtils) {

    var propertyUtil = {};
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function isEmpty(obj) {
        if (!obj) {
            return true;
        }
        for ( var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        if (TypeUtils.isFunction(obj)) {
            return false;
        }
        return true;
    }
    
    function clearEmptyPropertiesWithSrcPath(properties, path) {
        var paths = path.split('.'), i, j;
        for (i = paths.length - 2; i >= 0; i--) {
            var current = properties;
            for (j = 0; j < i; j++) {
                current = current[paths[j]];
            }
            if (isEmpty(current[paths[i]])) {
                delete current[paths[i]];
            }
        }
    }
    
    function isContain(rules, subProp){
        if(!rules){
            return false;
        }
        
        for(var i = 0; i < rules.length; ++i){
            if(rules[i].properties && rules[i].properties[subProp]){
                return true;
            }
        }
        
        return false;
    }
    
    propertyUtil.getProperty = function(properties, path) {
        var paths = path.split('.'), current = properties, i;

        for (i = 0; i < paths.length; i++) {
            // the given path is broken:
            // e.g. the given path is a.b.c, but a.b=null
            if (current === null) {
                return undefined;
            }
            // we do not have the key a.b, or a.b=undefined
            if (current[paths[i]] === undefined ) {
                return undefined;
            }
            current = current[paths[i]];
        }
        return current;
    };

    propertyUtil.setProperty = function(properties, path, value) {
        var paths = path.split('.'), current = properties, i;

        for (i = 0; i < paths.length - 1; i++) {
            if (current[paths[i]] === undefined || current[paths[i]] === null) {
                current[paths[i]] = {};
            }
            current = current[paths[i]];
        }
        current[paths[paths.length - 1]] = value;
    };

    propertyUtil.setPropertyWithMergence = function(properties, path, value) {
        var paths = path.split('.'), newObj = {}, tmp = newObj, i;
        for (i = 0; i < paths.length - 1; i++) {
            tmp[paths[i]] = {};
            tmp = tmp[paths[i]];
        }
        tmp[paths[paths.length - 1]] = value;
        ObjectUtils.extend(true, properties, newObj);
    };
    
    propertyUtil.removeProperty = function(properties, path) {
        var paths = path.split('.'), current = properties, i;

        for (i = 0; i < paths.length - 1; i++) {
            if (current[paths[i]] === undefined) {
                return;
            }
            current = current[paths[i]];
        }
        delete current[paths[paths.length - 1]];
        clearEmptyPropertiesWithSrcPath(properties, path);
    };
    
    function removeProperties(toProperty, subProp){
        if(toProperty && toProperty.rules && toProperty.rules.length){
            var rules = toProperty.rules;
            for(var i = rules.length - 1; i >= 0; --i){
                var rule = rules[i];
                var properties = rule.properties;
                delete properties[subProp];
                if(TypeUtils.isEmptyObject(properties)){
                    rules.splice(i, 1);
                }
            }
        }
    }
    
    propertyUtil.migrateSeriesStyle = function(properties, srcPath, srcProperty, action){
        var toProperty = propertyUtil.getProperty(properties, action.to);
        
        removeProperties(toProperty, action.subProp);
        toProperty = toProperty || {rules:[]};
        if(srcProperty && srcProperty.rules){
            var srcRules = srcProperty.rules;
            for(var i = 0; i < srcRules.length; ++i){
                var target = {};
                var rule = srcRules[i];
                ObjectUtils.extend(true, target, rule);
                if(rule && rule.dataContext && rule.dataContext.length){
                    var dataContext = rule.dataContext;
                    for(var j = 0; j < dataContext.length; ++j){
                        if(dataContext[j] === undefined){
                            target.dataContext[j] = undefined;
                        }
                    }
                }
                if(target.properties){
                    var temp = target.properties;
                    delete target.properties;
                    target.properties = {};
                    target.properties[action.subProp] = temp;
                }
                
                toProperty.rules.push(target);
            }
            
        }
        propertyUtil.setProperty(properties, action.to, toProperty);

    };

    propertyUtil.getComplexProperty = function(key, value, idx, propMgr) {
        var ret;
        if (value[idx] !== undefined) {
            ret = value[idx];
        } else {
            // fallback to template/default value if value[idx] is not set
            var templateValue = propMgr.get(key, 'templateValue');
            if (templateValue && templateValue[idx]) {
                ret = templateValue[idx];
            } else {
                var defaultValue = propMgr.get(key, 'defaultValue');
                if (TypeUtils.isArray(defaultValue)) {
                    ret = defaultValue[idx];
                } else {
                    ret = defaultValue;
                }
            }
        }
        return ret;
    };

    return propertyUtil;
});
define('sap/viz/chart/components/axis/sub/AxisTitle',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/AxisComponent",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/util/StyleUtils",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/migrate/PropertyUtil"
], function(Constants, oo, AxisComponent, TypeUtils, NumberUtils, StyleUtils,
    TextUtils, UADetector, NameColorUtils, DataGraphics, PropertyUtil) {

    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;

    var AxisTitle = function(runtime, options) {
        AxisTitle.superclass.constructor.apply(this, arguments);
        this._valueAxes = options ? options.valueAxes : [];
        this.visibleItemsNumber = -1;
    };
    oo.extend(AxisTitle, AxisComponent);

    AxisTitle.prototype._adjustTitleItems = function(items, layerNumber) {
        var i;
        for (i = 0; i < items.length; i++) {
            if (i >= layerNumber) {
                items[i].isHidden = true;
            } else {
                items[i].isHidden = false;
            }
        }
    };

    AxisTitle.prototype._isApplyAxisLineColor = function() {
        if (this._properties.has("title.style.color", "value")){
            return false;
        }
        var applyAxislineColor = this._properties.get('title.applyAxislineColor');
        if (TypeUtils.isArray(applyAxislineColor)) {
            //we support BooleanArray for combinationEx
            var idx = this._valueAxes.length > 1 ? 1 : 0;
            applyAxislineColor = PropertyUtil.getComplexProperty('title.applyAxislineColor', 
                applyAxislineColor, idx, this._properties);
        }
        return  applyAxislineColor === true;
    };

    AxisTitle.prototype._convertStyleColor = function(value){
        if(this._isApplyAxisLineColor()){
            value = this._properties.get('color');
        }
        return this._isAllHidden() ? Constants.AXIS.HIDDEN_TITLE.COLOR : value;
    };

    AxisTitle.prototype.render = function(selection) {
        selection.select("g." + AXIS_CLASS_NAMES.TITLE).remove();
        selection.selectAll(".v-m-axisTitleEventLayer").remove();
        var properties = this._properties;
        if (TypeUtils.isString(this._data.text) && this._isSpaceEnough() &&
            properties.get('visible') && properties.get('title.visible')) {
            var text = this._data.text;
            var postfix = this._getPostFix();
            var className = AXIS_CLASS_NAMES.TITLE + " " + AXIS_CLASS_NAMES.TITLE_BACKWORD;
            var hiddenClassName = AXIS_CLASS_NAMES.TITLE_HIDDEN;
            var styles = properties.get('title.style');
            var hasLetterSpacing = true;
            var letterSpacing = properties.get('title.style.letterSpacing');
            if (letterSpacing === undefined || letterSpacing === null) {
                hasLetterSpacing = false;
                letterSpacing = 0;
            }
            styles.letterSpacing = parseFloat(letterSpacing).toString() + 'px';
            if(styles && styles.color){
                styles.color = this._convertStyleColor(styles.color);
                styles.color = NameColorUtils.convertColor(styles.color);
            }

            var textOffset = TextUtils.getTextBaselineOffset(styles);
            var effectManager = this.runtime().effectManager();

            var colorProps = properties.get('color');
            if (TypeUtils.isArray(colorProps)) {
                //we support StringArray for combinationEx
                var idx = this._valueAxes.length > 1 ? 1 : 0;
                colorProps = PropertyUtil.getComplexProperty("color", colorProps, idx, properties);
            }
            var styleColor = effectManager.register({
                fillColor: (this._isApplyAxisLineColor()) ? 
                    NameColorUtils.convertColor(colorProps) :
                    styles.color
            });
            var hiddenStyleColor = effectManager.register({
                fillColor: Constants.AXIS.HIDDEN_TITLE.COLOR
            });

            var titleText = selection.append("g")
                .attr("class", className)
                .attr("fill", styleColor)
                .attr("font-size", styles.fontSize)
                .attr("font-weight", styles.fontWeight)
                .attr("font-family", styles.fontFamily)
                .attr("letter-spacing", styles.letterSpacing)
                .attr("font-style", styles.fontStyle)
                .append("text")
                .text(text + postfix)
                .attr("dominant-baseline", "auto");

            //add text-anchor
            var envManager = this.runtime().envManager();
            if (envManager) {
                titleText = titleText.attr("text-anchor", envManager.textAnchor());
            }

            var eTitleText = "";
            var cssString = StyleUtils.convertToCss(styles);

            var sizeLimit;
            if (this._isVertical()) {
                sizeLimit = this._size.height;
            } else {
                sizeLimit = this._size.width;
            }
            var options = {};
            options.needRealLength = true;
            options.reverseDots = (envManager && envManager.reverseDots());
            options.hasLetterSpacing = hasLetterSpacing;
            var textObj = TextUtils.ellipsis(text, titleText.node(), sizeLimit, cssString,
                            options, postfix);
            eTitleText = textObj.text;
            var textRealLength = textObj.realLength;

            if (this._isVertical()) {
                titleText.attr("x", this._size.width - textOffset - textRealLength / 2)
                    .attr("y", this._size.height / 2)
                    .attr("transform", "rotate(-90," + (this._size.width - textOffset) + "," + (this._size.height /
                        2) + ")");
            } else {
                titleText.attr("x", this._size.width / 2 - textRealLength / 2)
                    .attr("y", this._size.height - textOffset);
            }

            var useCustomColor = properties.has('title.style.color', 'value');
            var titleObj = this._data;
            if (!titleObj.isCustomized) {
                this._adjustTitleItems(titleObj.items, this.visibleItemsNumber);

                titleText.text("");
                if (eTitleText !== text && titleText.select("title").empty()) {
                    titleText.append("title").text(text + postfix);
                }

                var iItemIndex;
                for (iItemIndex = 0; iItemIndex < titleObj.items.length; iItemIndex++) {
                    var tItem = titleText.append("tspan");
                    tItem.attr("class", className);
                    tItem.attr("dominant-baseline", "auto");

                    if (titleObj.items[iItemIndex].isHidden && !this._isApplyAxisLineColor() &&
                        !useCustomColor && !titleObj.noNeedApplyHiddenTitleColor) {
                        //note: you have to set v-hidden-title css after v-title (because of css rules)
                        tItem.attr("class", className + " " + hiddenClassName);
                        tItem.attr("fill", hiddenStyleColor);
                    }

                    var itemText = titleObj.items[iItemIndex].text + postfix;

                    if (eTitleText.length > itemText.length) {
                        if (((eTitleText.length - 3) < itemText.length) &&
                            eTitleText.substring(eTitleText.length - 3) === "...") {
                            tItem.text(eTitleText);
                            break;
                        } else {
                            tItem.text(itemText);
                            eTitleText = eTitleText.substring(itemText.length);
                        }
                    } else {
                        tItem.text(eTitleText);
                        break;
                    }
                }
            } else {
                //for dual charts, we may set titleObj.isCustomizedColor to keep customized color.
                if (!titleObj.isCustomizedColor && this.visibleItemsNumber === 0 && !useCustomColor &&
                    !this._isApplyAxisLineColor()) {
                    titleText.attr("class", className + " " + hiddenClassName);
                    titleText.attr("fill", hiddenStyleColor);  
                }
            }
        }
    };

    AxisTitle.prototype._isAllHidden = function() {
        var useCustomColor = this._properties.has('title.style.color', 'value');
        var titleObj = this._data;
        if(titleObj){
            if(!useCustomColor && titleObj.isCustomized && !titleObj.isCustomizedColor &&
                    this.visibleItemsNumber === 0 && !titleObj.noNeedApplyHiddenTitleColor){
                return true;
            }
            if(!useCustomColor && !titleObj.isCustomized && !this._isApplyAxisLineColor() &&
                !titleObj.noNeedApplyHiddenTitleColor){
                var len = titleObj.items.length;
                for(var i = 0; i < len; ++i){
                    if(!titleObj.items[i].isHidden){
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    };

    AxisTitle.prototype.setTitleHiddenItems = function(_items) {
        this.visibleItemsNumber = _items;
    };

    AxisTitle.prototype._getPostFix = function(){
        var result = "";
        if(this._name.indexOf("valueAxis") > -1){
            var dynamicScale = this._runtime.statusManager().get("dynamicScale");
            if(dynamicScale && !dynamicScale.onlyChartTitle &&
                dynamicScale[this._name] && dynamicScale[this._name].postfix){
                result = dynamicScale[this._name].postfix;
            }
        }
        return result;
    };

    AxisTitle.prototype.getPreferredSize = function() {
        var pfdSize = {
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0,
            spacings: [{
                "interval": 0,
                "type": Constants.SPACING_TYPE.STEP
            }]
        };
        var props = this._properties;
        if (TypeUtils.isString(this._data.text) &&
                props.get('visible') &&
                props.get('title.visible')) {
            var titleStyle = props.get('title.style');
            var letterSpacing = props.get('title.style.letterSpacing');
            if (letterSpacing === undefined || letterSpacing === null) {
                letterSpacing = 0;
            }
            if (letterSpacing.toString().indexOf('px') === -1) {
                titleStyle.letterSpacing = letterSpacing.toString() + 'px';
            }
            var text = this._data.text + this._getPostFix();
            var isFixedPadding = props.origin.get('general.layout.isFixedPadding');
            var size = isFixedPadding ? this._measureTextSizeForFixPadding(text, titleStyle) : 
                this._measureTextSize(text, titleStyle);
            var minTextWidth = this._getMinTextWidth(text, titleStyle);
            if (this._isVertical()) {
                pfdSize.minWidth = size.height;
                pfdSize.maxWidth = size.height;
                pfdSize.minHeight = minTextWidth;
                pfdSize.maxHeight = size.width;
            } else {
                pfdSize.minWidth = minTextWidth;
                pfdSize.maxWidth = size.width;
                pfdSize.minHeight = size.height;
                pfdSize.maxHeight = size.height;
            }
            pfdSize.spacings[0].interval = size.height;
        }
        var precisedSize = NumberUtils.preciseObject(pfdSize);
        this._updatePfdSize(precisedSize);
        return precisedSize;
    };

    AxisTitle.prototype._getMinTextWidth = function(text, style) {
        var size = this._measureTextSize(text, style);
        var minTextWidth = size.width;
        if (minTextWidth > 0 && text.length) {
            var minSize = this._measureTextSize(text[0] + "...", style);
            if (minTextWidth > minSize.width) {
                minTextWidth = minSize.width;
            }
        }
        return minTextWidth;
    };

    AxisTitle.prototype.destroy = function() {
        this._properties.add('title.style.color', {
            get: null
        });
        AxisTitle.superclass.destroy.call(this);
        this.visibleItemsNumber = null;
    };

    return AxisTitle;

});

define('sap/viz/chart/components/axis/renderer/DefaultCategoryLabelRenderer',["sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/util/StyleUtils",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/DataGraphics"
], function (Constants, SVG, NumberUtils, StyleUtils, TextUtils, DataGraphics) {

    function measureTextSize(text, style, wrap, maxWidth) {
        if (wrap && wrap > 1) {
            //sync with measureInCanvas
            var textHeight = NumberUtils.preciseSimple(parseFloat(style.fontSize) * 1.2);
            var wrappedText = TextUtils.wrapText(text, [" "], maxWidth, wrap, style);
            var width = wrappedText.maxWidth;
            var lLength = wrappedText.lines.length;
            if (wrappedText.beyond) {
                width = TextUtils.getTextLength(wrappedText.lines[lLength - 1],
                    StyleUtils.convertToCss(style));
            }
            return {
                "width": width,
                "height": lLength * textHeight,
                "minHeight": textHeight
            };
        } else {
            return TextUtils.canvasMeasure(text, style.fontSize, style.fontWeight, style.fontFamily);
        }
    }

    var updateTextNode = function (textNode, config) {
        var VERTICAL_ANGLE = 90;
        var TICK_SIZE = 5;
        var LABEL_OFFSET = 6;
        var textOffset = LABEL_OFFSET;
        var text = config.text;
        var style = config.styles;
        var labelOffset = config.labelOffset;
        var size = config.size;
        var sizeLimit = config.sizeLimit;
        var offset = TextUtils.getTextBaselineOffset({
            fontSize: style.fontSize,
            fontWeight: style.fontWeight,
            fontFamily: style.fontFamily
        });
        var needRowAxisOffset = config.needRowAxisOffset;
        var textSize = measureTextSize(text, style);
        //Remove all child node for updating
        var child = textNode.firstChild;
        while (child) {
            textNode.removeChild(child);
            child = textNode.firstChild;
        }
        var textWarpper = d3.select(textNode);
        var textHeight, textWidth, spanItems;
        textHeight = NumberUtils.preciseSimple(textSize.height);
        var needWrap = false;
        var wrap = config.wrap;
        if (wrap && wrap > 1) {
            var boundHeight = (size.height - TICK_SIZE - LABEL_OFFSET).toFixed(1);
            wrap = Math.min(wrap, Math.floor(boundHeight / textHeight));
            needWrap = wrap > 1;
        }
        var ellipsisedText, ellipsisedTextSize;
        var options;
        if (needWrap) {
            options = {};
            options.middleText = true;
            textWidth = TextUtils.drawWrappedText(textWarpper, text, [" "], wrap, sizeLimit,
                textHeight, style, options);
            spanItems = textWarpper.selectAll("tspan")[0];
            textHeight = textHeight * spanItems.length;
        } else {
            textWidth = NumberUtils.preciseSimple(textSize.width);
            if (sizeLimit >= 0 && textWidth > sizeLimit) {
                if(config.noEllipsis){
                    ellipsisedText = "";
                    ellipsisedTextSize = 0;
                }else{
                    options = {};
                    options.needRealLength = true;
                    options.reverseDots = config.reverseDots;
                    var textObj = TextUtils.ellipsis(text, textNode, sizeLimit, StyleUtils.convertToCss(style),
                                    options);
                    textWidth = textObj.realLength;
            
                    ellipsisedText = textObj.text;
                    ellipsisedTextSize = textWidth; 
                }
            } else {
                textNode.textContent = text;
            }
        }

        var x, y;
        var realTextSize = ellipsisedTextSize || textWidth;

        switch (config.position) {
            case Constants.POSITION.LEFT:
            case Constants.POSITION.RIGHT:
                y = textHeight / 2 - offset;
                if (needRowAxisOffset) {
                    y += textHeight / 2 - offset + labelOffset;
                }
                else {
                    var yOffset = 0;
                    if (config.labelAlignment !== "center" &&
                        config.childCells && config.childCells.length) {
                        var visibleNum = 0;
                        for (var iCell = 0; iCell < config.childCells.length; iCell++) {
                            if (config.childCells[iCell].isVisible) {
                                visibleNum++;
                                //to add last child yOffset
                                if (config.childCells[iCell].yOffset) {
                                    yOffset += config.childCells[iCell].yOffset;
                                }
                                else {
                                    yOffset += config.childCells[iCell].cellHeight / 2;
                                }
                                //if parent style is set, it is possible that the parent font size is larger,
                                //so the offset may be not enough to display the parent text completely.
                                if (yOffset < textHeight / 2) {
                                    yOffset = textHeight / 2;
                                }
                                break;
                            }
                            else {
                                yOffset += config.childCells[iCell].cellHeight;
                            }
                        }

                        if (visibleNum === 0) {
                            yOffset = size.height / 2;
                        }
                    } else {
                        yOffset = size.height / 2;
                    }

                    y += yOffset;
                    if (yOffset === size.height / 2) {
                        //for the leaf node, we have special yOffset.
                        config.cell.yOffset = config.cell.cellHeight / 2;
                    }
                    else {
                        config.cell.yOffset = yOffset;
                    }
                }

                if (config.position === Constants.POSITION.LEFT) {
                    x = size.width - textOffset - textWidth;
                } else {
                    x = textOffset;
                }
                break;
            case Constants.POSITION.TOP:
                if (config.rotated) {
                    x = size.width / 2 + textHeight / 2 - offset;
                    y = size.height - textOffset;
                } else {
                    x = size.width / 2 - textWidth / 2;
                    y = size.height - textOffset - offset;
                }
                break;
            case Constants.POSITION.BOTTOM:
                if (config.rotated) {
                    x = size.width / 2 + textHeight / 2 - offset;
                    y = textOffset;

                    //we have to adjust x and y because of no text-anchor:end
                    x -= textWidth * (Math.cos(config.rotationAngle * Math.PI / 180));
                    y += textWidth * (Math.sin(config.rotationAngle * Math.PI / 180));
                } else {
                    if(config.alignMode === "ALIGIN_RIGHT_MOST") {
                        x = config.cellWidth - realTextSize / 2;
                    } else if(config.alignMode === "ALIGIN_LEFT_MOST") {
                        x = realTextSize / 2;
                    } else {
                        x = size.width / 2;  
                    }
                    x -= textWidth / 2;
                    y = textOffset + textHeight - offset;

                }
                break;
        }

        textNode.setAttribute("x", x);
        textNode.setAttribute("y", y);
        if (config.rotated) {
            var textHeightOffset = getRotatedTextHeightOffset(textHeight, config.rotationAngle);
            textNode.setAttribute("transform",
                "translate(0," + textHeightOffset + ") rotate(-" + config.rotationAngle + "," + x + "," + y + ")");
        }
        if (needWrap) {
            //Sync with measureInCanvas because the real height is smaller than text height
            var paddingTop = NumberUtils.preciseSimple(parseFloat(style.fontSize) * 0.2);
            textWarpper.selectAll("tspan")
                .attr("dy", "1em")
                .attr("y", null); //remove child y and use parent offset
            //This is only for wrap text and Wrap text is only for horizontal category axis, so don't
            //need to add additional judgment like: if config.position === Constants.POSITION.BOTTOM
            textWarpper.attr("y", textOffset - offset + paddingTop);
        }

        var nodeLocation = {};
        nodeLocation.x = x;
        nodeLocation.y = y;
        return nodeLocation;
    };

    function defaultLabelRenderer(config) {
        var textNode = SVG.create("text");
        updateTextNode(textNode, config);
        DataGraphics.setCustomizationInfo(textNode, { 'defaultRenderer': true });
        return textNode;
    }

    var getRotatedTextHeightOffset = function (textHeight, textAngle) {
        return (textHeight * Math.cos(textAngle * Math.PI / 180) * 0.7);
    };

    defaultLabelRenderer.update = function (textNode, config) {
        var nodeLocation = updateTextNode(textNode, config);
        if (config.rotated) {
            var rotation = {
                'r': '-' + config.rotationAngle,
                'x': nodeLocation.x,
                'y': nodeLocation.y
            };
            DataGraphics.setData(textNode, rotation);
        } else {
            //"RemoveAttribute("transform")" doesn't work as expected to remove the attribute in IE10.  
            textNode.setAttribute("transform", "translate(0,0)");
        }
    };

    defaultLabelRenderer.getPreferredSize = function (config) {
        var VERTICAL_ANGLE = 90;
        var LABEL_OFFSET = 6;
        var text = config.text,
            style = config.styles;
        var wrap = config.wrap;
        if (config.disableAutoRotation === false || config.rotationAngle !== 0) {
            //support only fixed rotation and the angle must be 0 currently
            wrap = 1;
        }
        var size = config.size;
        var minText = Constants.AXIS.FIRST_LETTER;
        if (text && text.length > 0) {
            minText = text[0];
        }
        minText += Constants.AXIS.FIRST_LETTER;

        var textSize = measureTextSize(text, style, wrap, size);
        var minTextSize = config.noEllipsis? textSize: measureTextSize(minText, style);

        var textHeight = textSize.height;
        var textHeightOffset = getRotatedTextHeightOffset(textHeight, config.rotationAngle);
        var cellHeight = textSize.height,
            cellWidth = textSize.width,
            rotated;
        if ((config.rotated || textSize.width > config.size) &&
            (config.position === Constants.POSITION.TOP || config.position === Constants.POSITION
                .BOTTOM)) {
            if (!config.rotated && config.disableAutoRotation) {
                //keep horizontal, but update cellWidth
                rotated = false;
                cellWidth = config.size;
            }
            else {
                //rotation
                rotated = true;
                cellWidth = textSize.height;
                if (config.rotationAngle === VERTICAL_ANGLE) {
                    cellHeight = textSize.width;
                }
                else {
                    var labelLocation = config.cellWidth / 2 + config.cellStart +
                        (config.additionalWidth ? config.additionalWidth : 0);
                    var labelSize = labelLocation / (Math.cos(config.rotationAngle * Math.PI / 180));
                    if (textSize.width < labelSize) {
                        labelSize = textSize.width;
                    }

                    cellHeight = labelSize * (Math.sin(config.rotationAngle * Math.PI / 180));
                    cellHeight += textHeightOffset;

                    //cellWidth should consider rotation angle
                    var cellWidthPlusRotation = (cellWidth / Math.sin(config.rotationAngle * Math.PI / 180)) * 0.9;
                    if (cellWidthPlusRotation > cellWidth) {
                        cellWidth = cellWidthPlusRotation;
                    }
                }
            }
        }
        var ret = {
            cellWidth: cellWidth,
            cellHeight: cellHeight,
            rotated: rotated,
            textSize: textSize
        };
        if (config.position === Constants.POSITION.TOP || config.position === Constants.POSITION
            .BOTTOM) { //horizontal
            if (rotated) {
                ret['minCellHeight'] = Math.min(minTextSize.width, textSize.width);
                if (config.rotationAngle !== VERTICAL_ANGLE) {
                    ret['minCellHeight'] = ret['minCellHeight'] *
                                           Math.sin(config.rotationAngle * Math.PI / 180);
                    ret['minCellHeight'] += (2 * textHeightOffset - 2 * LABEL_OFFSET + 1);
                }
            }
            else {
                if (textSize.hasOwnProperty("minHeight")) {
                    ret['minCellHeight'] = textSize.minHeight;
                } else {
                    ret['minCellHeight'] = textSize.height;
                }
                if(ret.cellWidth < Math.min(minTextSize.width, textSize.width)) {
                    ret.noLabelSpace = true;
                }
            }
        } else { //vertical
            ret['minCellWidth'] = Math.min(minTextSize.width, textSize.width);
        }

        //customer render may need AbsoluteTextBaselineOffset to adjust
        //text location
        var offset = TextUtils.getAbsoluteTextBaselineOffset({
            fontSize: style['fontSize'],
            fontWeight: style['fontWeight'],
            fontFamily: style['fontFamily']
        });
        ret.absoluteTextBaselineOffset = offset;
        return ret;
    };

    defaultLabelRenderer.autoHide = function (isVertical, layer) {
        return true;
    };

    defaultLabelRenderer.expose = {
        renderer: defaultLabelRenderer,
        update: defaultLabelRenderer.update,
        getPreferredSize: defaultLabelRenderer.getPreferredSize,
        autoHide: defaultLabelRenderer.autoHide
    };

    return defaultLabelRenderer;
});

define('sap/viz/chart/components/util/BuildLayerUtil',[
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/DataUtils",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/chart/components/axis/renderer/DefaultCategoryLabelRenderer"
], function(
    NumberUtils,
    DataUtils,
    ArrayUtils,
    DefaultCategoryLabelRenderer
) {

    var LABEL_OFFSET = 6;
    var TICK_SIZE = 5;
    var VERTICAL_ANGLE = 90;

    var _buildUtils = {};

    _buildUtils._filter = function(rawlayers, bindingFields) {
        return bindingFields.reduce(function(layers, bd, i) {
            return (!bd.invisible && rawlayers[i]) ? layers.concat(rawlayers[i]) : layers;
        }, []);
    };

    _buildUtils._getLayerslength = function(domain) {
        var ret = 0;
        if (domain.length && domain[0].length) {
            ret = domain[0].length;
        }
        return ret;
    };

    _buildUtils._getDisplayTexts = function(domain, bindingFields) {
        return ArrayUtils.map(domain, DataUtils.getDisplayTextsConverter(bindingFields));
    };


    function mergeHierarchyCtx(original, newOne) {
        if (original && !original.or) {
            var temp = {
                or: [original]
            };
            temp.or.push(newOne);
            original = temp;
        } else {
            original.or.push(newOne);
        }
        return original;
    }


    _buildUtils._mergeCtx = function(firstCtx, bindingFieldIds) {
        var length = firstCtx.length;
        var ret = {};
        for (var i = 0; i < length; ++i) {
            var value = firstCtx[i];
            var field = bindingFieldIds[i];
            if (!DataUtils.isPlainValue(value)) {
                ret[field] = DataUtils.getDimensionValue(value);
                ret[field + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX] =
                    DataUtils.getDimensionDisplayName(value);
            } else {
                ret[field] = value;
            }
        }
        return ret;
    };

    function domainIsEqual(a, b) {
        return DataUtils.getDimensionValue(a) === DataUtils.getDimensionValue(b);
    }

    _buildUtils.mergeLabels = function(axisBody, domain, bindingFieldIds,config, onlyKeepFirstAndLast) {
        var layers = [];
        var layersLength = this._getLayerslength(domain);
        var displayTexts = this._getDisplayTexts(domain, axisBody._bindingFields);
        var cellDict = axisBody._cellDict = {};
        var id = 0;
        var parentCellSpans;
        var domainLength = domain.length;

        for (var i = 0; i < layersLength; ++i) {
            var cells = new Array(domainLength);
            var cellSpans = new Array(domainLength + 1);
            var cellsCount = 0;
            var spaceCount = 0;
            var spaceCountHelper = 0;
            var formerLayerIndex = 0;
            var pushNext = true;
            var parentLayer = layers[i - 1];
            var parentCellIndex = 0;

            for (var j = 0; j < domainLength; ++j) {
                var ctx = this._mergeCtx(domain[j], bindingFieldIds);
                var space = 1;

                //If last layer, don't merge.
                if (i !== layersLength - 1) {
                    ++spaceCount;
                    ++spaceCountHelper;
                    space = spaceCount;
                    spaceCount = 0;
                    //When the 1st item, force push
                    //If it is not the 1st item, try to merge if necessary.
                    pushNext = spaceCountHelper === 1;
                    if (i > 0 && spaceCountHelper >= layers[i - 1].cells[formerLayerIndex].space) {
                        spaceCountHelper = 0;
                        ++formerLayerIndex;
                    }
                    if (j > 0 && !pushNext && domainIsEqual(domain[j][i], domain[j - 1][i])) {
                        var offset = cellsCount - 1;
                        cells[offset].ctx = mergeHierarchyCtx(cells[offset].ctx, ctx);
                        cells[offset].space++;
                        continue;
                    }
                }

                var text = onlyKeepFirstAndLast && (j !== 0 && j !== domainLength-1)? "" : displayTexts[j][i];

                var cell = cellDict[id] = cells[cellsCount] = {
                    id: id,
                    layer: i,
                    text: text,
                    ctx: ctx,
                    space: space
                };
                cellSpans[cellsCount] = j;
                cellsCount++;
                id++;

                if (parentLayer) {
                    if (j >= parentCellSpans[parentCellIndex + 1]) {
                        parentCellIndex++;
                    }
                    var parentCell = parentLayer.cells[parentCellIndex];
                    parentCell.children = parentCell.children || [];
                    parentCell.children.push(cell);
                }
            }
            cells.length = cellsCount;
            cellSpans[cellsCount] = domainLength;
            cellSpans.length = cellsCount + 1;
            parentCellSpans = cellSpans;
            layers.push({
                cells: cells
            });
        }
        return layers;
    };

    _buildUtils.assignCellSize = function(axisBody, layers, rangeInterval, size) {
        var isVertical = axisBody._isVertical();
        for (var i = 0, iLength = layers.length; i < iLength; ++i) {
            var layer = layers[i];
            var spaceCount = 0;
            var cells = layer.cells;
            for (var j = 0, jLength = cells.length; j < jLength; ++j) {
                var cell = cells[j];
                _misc.getRangeInfo(rangeInterval, spaceCount, size, cell, isVertical);
                spaceCount += cell.space;
            }
        }
    };


    function isOnlyOneLayer(layers) {
        //we may need to update the function to return whether
        //there is only one visible layer. To implement it, the first layer
        //rotation angle must be fixed.
        return layers.length === 1;
    }

    function isUsedByTrellis(objectInstance) {
        return objectInstance._isTrellisAxis || objectInstance._isInTrellis;
    }

    function checkDisableRotation(cells, layerNumber, layers, truncatedLabelRatio, pSizeCache,
            getPreferredSize, noAutoHide, cellSizeField) {
        //calculate how many labels are allowed to be rotated.
        //the function is just for multiply layers. For the 1st layer,
        //we have dealt with it.
        var layer = layers[layerNumber];
        var maxAllowdTruncationNumber = cells.length * truncatedLabelRatio;
        var toRotateLabelNumber = 0;

        var disableRotation;
        if (layer.rotated || truncatedLabelRatio === 0) {
            //for backward compatibility
            disableRotation = false;
        } else if (truncatedLabelRatio === 1) {
            disableRotation = true;
        } else {
            disableRotation = true;
            var i;
            for (i = 0; i < cells.length; i++) {
                var cell = cells[i];
                var psize = getPreferredSize(cell, layerNumber, layer);
                pSizeCache.push(psize);

                if (psize.rotated && !layer.rotated) {
                    toRotateLabelNumber++;
                    if (toRotateLabelNumber > maxAllowdTruncationNumber) {
                        disableRotation = false;
                        break;
                    }
                }

                if (!noAutoHide && psize[cellSizeField] > cell[cellSizeField]) {
                    //the layer will be hidden. So do not need to check isLayerRotated
                    disableRotation = false;
                    break;
                }
            }
        }

        if (disableRotation || (pSizeCache.length !== cells.length)) {
            //if cache has all cell sizes, we keep the cache. Or we clean it.
            pSizeCache.splice(0, pSizeCache.length);
        }

        return disableRotation;
    }

    _buildUtils.layoutCells = function(axisBody, layers, range, config, onlyKeepFirstAndLast) {
        if (!config) {
            return;
        }
        var propStyle = config.propStyle;
        var labelVisible = config.labelVisible;

        var checkLabelVisible = config.checkLabelVisible;

        var truncatedLabelRatioSetting = +config.truncatedLabelRatioSetting;
        if (isNaN(truncatedLabelRatioSetting)) {
            truncatedLabelRatioSetting = 0.2;
        }
        truncatedLabelRatioSetting = Math.max(0, Math.min(1, truncatedLabelRatioSetting));

        //the rotationAngle may be set to 0, 30, 45, 60, 90,
        var defaultRotationAngle = config.defaultRotationAngle;

        var autoRotateSetting = config.autoRotateSetting;
        if (autoRotateSetting !== "auto" && autoRotateSetting !== "fixed") {
            autoRotateSetting = "auto";
        }

        var rotationAngleSetting = config.rotationAngleSetting;
        var supportedRotationAngleList = [0, 30, 45, 60, 90];
        if (supportedRotationAngleList.indexOf(rotationAngleSetting) < 0) {
            rotationAngleSetting = defaultRotationAngle;
        }

        var labelRenderer = config.labelRenderer || DefaultCategoryLabelRenderer;
        var psize;
        var isVertical = axisBody._isVertical();
        var getPreferredSize = function(cell, layerIndex, layer, disableAutoRotation, rotationAngle) {
            var labelStyle = propStyle;
            if(layer.isParentLayer) {
                labelStyle = config.propParentStyle;
            }
            return _misc.fillPreferredSize(labelRenderer, isVertical, cell, labelStyle,
                layerIndex, axisBody._position, layer.rotated, disableAutoRotation, rotationAngle,
                config.otherSize, config.wrap, config.noEllipsis);
        };

        var offset = LABEL_OFFSET + TICK_SIZE;
        var rangeBound = range.slice();
        if (rangeBound[0] > rangeBound[1]) {
            rangeBound.reverse();
        }
        var layer, cells, cell;
        var i, iLength, j, jLength, maxRefSize, refSize;

        var cellSizeField, minCellBandField, cellRefSizeField;
        if (axisBody._isVertical()) {
            cellSizeField = "cellHeight";
            minCellBandField = "minCellWidth";
            cellRefSizeField = "cellWidth";
        } else {
            cellSizeField = "cellWidth";
            minCellBandField = "minCellHeight";
            cellRefSizeField = "cellHeight";
        }
        
        var layoutCtx = {};
        layoutCtx.getPreferredSize = getPreferredSize;
        layoutCtx.cellSizeField = cellSizeField;
        layoutCtx.minCellBandField = minCellBandField;
        layoutCtx.cellRefSizeField = cellRefSizeField;
        layoutCtx.offset = offset;
        layoutCtx.isVertical = isVertical;
        
        iLength = layers.length;

        for (i = iLength - 1; i >= 0; --i) {
            var noAutoHide = !labelRenderer.autoHide || 
                !labelRenderer.autoHide(axisBody._isVertical(), i, DefaultCategoryLabelRenderer.expose);
            layer = layers[i];
            layer.onlyKeepFirstAndLast = onlyKeepFirstAndLast;
            layer.isVisible = true;
            layer.rotated = false;
            cells = layer.cells;
            maxRefSize = 0;
            
            if(i !== (iLength - 1)) {
                layer.isParentLayer = true;
            }

            if (checkLabelVisible && labelVisible === false) {
                layer.isVisible = false;
                continue;
            }
            
            var truncatedLabelRatio = truncatedLabelRatioSetting;
            var isTrellis = isUsedByTrellis(axisBody);
            if(isTrellis) {
                //disable it for Trellis
                truncatedLabelRatio = 0;
            } else if(config.paginationOptions || onlyKeepFirstAndLast) {
                //for pagination (BITSDC2-3423), we disable category axis label rotation
                //also for BITSDC2-3916 [Fiori] Improve Responsiveness of horizontal Categorical Axis
                truncatedLabelRatio = 1;
            }
            
            //the flag means we have to show some of labels, so we need to to 
            //reCalculate layer context. If we recalculate layer context, we keep current layer rotation
            var maxMinLayerBand;
            if (i === 0) {
                var availableCells, minLayerBand;
                maxMinLayerBand = 0;

                //these variables are just used as input auguments in getPreferredSize.
                var rotated = false;
                var rotationAngle = rotationAngleSetting;
                var disableAutoRotation = false;
                if (rotationAngleSetting === 0) {
                    disableAutoRotation = true;
                }

                var onlyOneLayer = isOnlyOneLayer(layers);
                if (!onlyOneLayer || isTrellis) {
                    //if there are two or more layers, the 1st layer has to follow the "default" behavior
                    if(axisBody._isVertical()) {
                        rotationAngle = 0;
                    }
                    else {
                        rotationAngle = VERTICAL_ANGLE;
                    }
                }

                var getPreferredSizeFn = function(cell) {
                    return getPreferredSize(cell, 0, layer, disableAutoRotation, rotationAngle);
                };

                var filteredCells;
                if(onlyKeepFirstAndLast){
                    cells[0].isFirstLabel = true;
                    if(cells.length > 1){
                        cells[cells.length-1].isLastLabel = true;
                        filteredCells = [cells[0], cells[cells.length-1]];
                    }else{
                        filteredCells = [cells[0]];
                    }
                }else{
                    filteredCells = cells.slice();
                }
                 
                //the function will check if the layer is rotation, and
                //change the step (the variable will be used to calculate size)
                var step;
                var isLayerRotated = function() {
                    var previousCell;
                    var allRotate = false;

                    if (!noAutoHide && !onlyKeepFirstAndLast) {
                        _misc.excludeCrossBoundCells(filteredCells, rangeBound, getPreferredSizeFn);
                    }

                    //determine initial step value
                    var len = filteredCells.length;
                    step = noAutoHide ? 1 : _misc.getStep(filteredCells, 0, getPreferredSizeFn);
                    if(truncatedLabelRatio === 1) {
                        //no rotation. So we have to check each label "noLabelSpace"
                        step = 1;
                    }

                    var prevIdx = 0;
                    var rotateLabelNumber = 0;
                    var labelNumber = 0;
                    for (j = 0; j < len; j += step) {
                        cell = filteredCells[j];
                        if (step === undefined || j < 0) { //even one label can't be fully-drawn
                            allRotate = true;
                            break;
                        }
                        psize = getPreferredSizeFn(cell);

                        //account numbers
                        labelNumber++;
                        if (psize.rotated) {
                            rotateLabelNumber++;
                        }

                        if (truncatedLabelRatio === 0 && rotateLabelNumber > 0) {
                            allRotate = true;
                            break;
                        }

                        if (!noAutoHide && j !== 0 && cell.start < previousCell.end - 0.001) { //overlapped
                            rotateLabelNumber = 0;
                            labelNumber = 0;
                            j = -step;
                            //step changed
                            step = _misc.getStep(filteredCells, prevIdx, getPreferredSizeFn);
                            continue;
                        }
                        prevIdx = j;
                        previousCell = cell;
                    }

                    if (rotationAngle === 0 || (truncatedLabelRatio === 1 && autoRotateSetting !== "fixed")) {
                        allRotate = false;
                    }
                    else if (!isVertical && filteredCells.length === 0) {
                        //no labels to show. We may need to reLayout layer and display some cells
                        allRotate = true;
                    }
                    else {
                        if (autoRotateSetting === "fixed" && onlyOneLayer) {
                            allRotate = true;
                        }
                        if (rotateLabelNumber > 0 && labelNumber > 0) {
                            if (NumberUtils.preciseSimple(rotateLabelNumber / labelNumber) >
                                NumberUtils.preciseSimple(truncatedLabelRatio)) {
                                allRotate = true;
                            }
                        }
                    }
                    return allRotate;
                };

                //for the only one layer, we will need to check the rotation using a ratio
                layer.rotated = isLayerRotated();
                if (layer.rotated) {
                    layer.rotationAngle = rotationAngle;
                }
                if (rotationAngle === 0 && config.wrap) {
                    layer.wrap = config.wrap;
                } else {
                    layer.wrap = null;
                }
                rotated = layer.rotated;
                disableAutoRotation = true;

                if (!noAutoHide && !onlyKeepFirstAndLast) {
                    _misc.excludeCrossBoundCells(filteredCells, rangeBound,
                        getPreferredSizeFn);
                }

                //Go go all cells to build availableCells, and calculate size
                availableCells = [];
                maxRefSize = maxMinLayerBand = 0;
                var minMinLayerBand = Infinity;
                for (j = 0; j < filteredCells.length; j += step) {
                    cell = filteredCells[j];
                    if (step === undefined) { //even one label can't be fully-drawn
                        if (layer.rotated && layer.rotationAngle !== VERTICAL_ANGLE) {
                            //we do not add the special cell for rotated cells
                            break;
                        } else {
                            if (!cell._preferredSize.noLabelSpace) {
                                availableCells.push(cell);
                                psize = cell._preferredSize;
                                maxRefSize = psize[cellRefSizeField];
                                maxMinLayerBand = psize[minCellBandField];
                            }
                            break;
                        }
                    }

                    if (checkLabelVisible === false && labelVisible === false) {
                        psize = {
                            cellWidth: 0,
                            cellHeight: 0,
                            minCellHeight: 0
                        };
                        if (cell) {
                            cell._preferredSize = psize;
                        }
                    } else {
                        psize = getPreferredSizeFn(cell);
                    }   

                    //skip labels if they are likely to truncate
                    //it works during layout getPreferedSize
                    //add extra padding because layout algo tends to give more space than rendering algo
                    if(config.noEllipsis && config.refSize && 
                        psize.cellWidth + offset > config.refSize.width){
                        continue;
                    }

                    if (!psize.noLabelSpace || onlyKeepFirstAndLast) {
                        availableCells.push(cell);
                    } else {
                        continue;
                    }

                    psize = cell._preferredSize;
                    if (maxRefSize < psize[cellRefSizeField]) {
                        maxRefSize = psize[cellRefSizeField];
                    }
                    minLayerBand = psize[minCellBandField];
                    if (minLayerBand && maxMinLayerBand < minLayerBand) {
                        maxMinLayerBand = minLayerBand;
                    }

                    if (minLayerBand && minMinLayerBand > minLayerBand) {
                        minMinLayerBand = minLayerBand;
                    }
                }

                if (availableCells.length === 0) {
                    layer.isVisible = false;
                    maxRefSize = -offset;
                    maxMinLayerBand = -offset;
                    minMinLayerBand = -offset;
                }
                refSize = NumberUtils.preciseSimple(maxRefSize + offset);
                for (j = 0, jLength = cells.length; j < jLength; ++j) {
                    cell = cells[j];
                    cell.isVisible = false;
                }

                for (j = 0, jLength = availableCells.length; j < jLength; ++j) {
                    cell = availableCells[j];
                    cell[cellRefSizeField] = refSize;
                    cell.isVisible = true;
                }
                
                layer.layerBand = refSize;
                layer.minLayerBand = config.noEllipsis ?
                        NumberUtils.preciseSimple(minMinLayerBand + offset):
                        NumberUtils.preciseSimple(maxMinLayerBand + offset);
                
                if(config.isFlexibleLayers && (isVertical || layer.rotated)) {
                    layer.reCalculateLayerContext = true;
                }
            } else {
                maxMinLayerBand = 0;
                var pSizeCache = [];
                
                var disableRotation = checkDisableRotation(layer.cells, i, layers,
                        truncatedLabelRatio, pSizeCache, getPreferredSize, noAutoHide, cellSizeField);
                
                for (j = 0, jLength = cells.length; j < jLength; ++j) {
                    cell = cells[j];
                    cell.isVisible = true;
                    if (pSizeCache.length > 0) {
                        psize = pSizeCache[j];
                    } else {
                        psize = getPreferredSize(cell, i, layer, disableRotation);
                    }
                    
                    if (psize[minCellBandField] && maxMinLayerBand < psize[minCellBandField]) {
                        maxMinLayerBand = psize[minCellBandField];
                    }

                    if (psize.rotated && !layer.rotated) {
                        layer.rotated = true;
                        layer.rotationAngle = VERTICAL_ANGLE;
                        j = -1;
                        continue;
                    }
                    else if (psize.noLabelSpace) {
                        cell.isVisible = false;
                    }
                    
                    if (maxRefSize < psize[cellRefSizeField]) {
                        maxRefSize = psize[cellRefSizeField];
                    }
                    if (!noAutoHide && psize[cellSizeField] > cell[cellSizeField]) {
                        if(config.isFlexibleLayers) {
                            layer.reCalculateLayerContext = true;
                        }
                        else {
                            layer.isVisible = false;
                            maxRefSize = -offset;
                        }
                        break;
                    }
                }
                refSize = NumberUtils.preciseSimple(maxRefSize + offset);
                
                var visibleLabelNum = 0;
                for (j = 0, jLength = cells.length; j < jLength; ++j) {
                    cells[j][cellRefSizeField] = refSize;
                    if(cells[j].isVisible) {
                        visibleLabelNum++;
                    }
                }
                
                layer.layerBand = refSize;
                layer.minLayerBand = NumberUtils.preciseSimple(maxMinLayerBand + offset);
                
                if(visibleLabelNum <= 0) {
                    layer.isVisible = false;
                }
            }
            
            if(layer.reCalculateLayerContext) {
                reCalculateLayerContext(layers, i, layoutCtx, config.isAllowEmptySegement, config.isSetParentStyleProp);
            }
            
            if(!layer.isVisible) {
                //if one layer is hide, we have to hide all sub layers
                for (var iLayer = layers.length - 1; iLayer > i; iLayer--) {
                    layers[iLayer].isVisible = false;
                }
            }
            
            //recount niceLayerBand for flexibleLayoutLayers
            calculateNiceLayerBand(layer, isVertical);
        }
    };
    
    var reCalculateLayerContext = function(layers, layerIndex, layoutCtx, isAllowEmptySegement, isSetParentStyleProp) {
        //flexibleLayoutLayers does not need to set isSetParentStyleProp. 
        //isSetParentStyleProp is just for layoutCells
        var layer = layers[layerIndex];
        //in this function, we have to remove overlap labels. 
        //"overlap labels" means 2 or more labels are overlapped. We do not detect overlapping   
        //layer.rotate should be detected.

        
        //firstly, we have to remember all parentIndex for each cell in this layer
        var cellIndex;
        var iChild;
        if(layerIndex > 0) {
            var parentLayerCells = layers[layerIndex - 1].cells;
            for(cellIndex = 0; cellIndex < parentLayerCells.length; cellIndex++) {
                for(iChild = 0; iChild < parentLayerCells[cellIndex].children.length; iChild++) {
                    parentLayerCells[cellIndex].children[iChild].parentIndex = cellIndex;
                }
            }
        }
        else {
            for(cellIndex = 0; cellIndex < layer.cells.length; cellIndex++) {
                layer.cells[cellIndex].parentIndex = -1;
            }
        }
        
        var cellsToShow = [];
        var cellsToMeasure = [];
        //the function will change cellsToShow. To fill cellsToShow with all visible cells. Cells must be references.
        hideOverlappedLabels(layer.cells, layers, layerIndex, layoutCtx.isVertical, cellsToShow, 
                cellsToMeasure, isAllowEmptySegement);

        if (cellsToShow.length === 0 && isSetParentStyleProp &&
            layerIndex < (layers.length - 1) && layers[layerIndex + 1].isVisible) {
            //if isSetParentStyleProp is true, the case means the last layer can be displayed, but the second last 
            //layer cannot be displayed. We should hide the last layer, and then try again.
            //Or we will hide both the last and the second last layers (it looks bad).
            var iLayer;
            for (iLayer = layerIndex + 1; iLayer < layers.length ; iLayer++) {
                layers[iLayer].isVisible = false;
            }

            cellsToMeasure = [];
            hideOverlappedLabels(layer.cells, layers, layerIndex, layoutCtx.isVertical, cellsToShow,
                cellsToMeasure, isAllowEmptySegement);
        }
        
        //hide all, and then visible some.
        for (cellIndex = 0; cellIndex < layer.cells.length; cellIndex++) {
            layer.cells[cellIndex].isVisible = false;
        }        

        //cellsToMeasure contains all cellsToShow 
        for (cellIndex = 0; cellIndex < cellsToMeasure.length; cellIndex++) {
            if(layoutCtx.getPreferredSize) {
                var psize = layoutCtx.getPreferredSize(cellsToMeasure[cellIndex], layerIndex, layer);

                cellsToMeasure[cellIndex].textBand = psize[layoutCtx.cellRefSizeField];
                cellsToMeasure[cellIndex].minTextBand = psize[layoutCtx.minCellBandField];
            }
        }

        if(cellsToShow.length > 0) {            
            layer.isVisible = true;
            layer.layerBand = 0;
            layer.minLayerBand = 0;
            
            for (cellIndex = 0; cellIndex < cellsToShow.length; cellIndex++) {
                cellsToShow[cellIndex].isVisible = true;
                          
                if (layer.layerBand < cellsToShow[cellIndex].textBand) {
                    layer.layerBand = cellsToShow[cellIndex].textBand;
                }
                
                if (layer.minLayerBand < cellsToShow[cellIndex].minTextBand) {
                    layer.minLayerBand = cellsToShow[cellIndex].minTextBand;
                }
            }
            
            layer.layerBand = NumberUtils.preciseSimple(layer.layerBand + layoutCtx.offset);
            for (cellIndex = 0; cellIndex < cellsToShow.length; cellIndex++) {
                cellsToShow[cellIndex][layoutCtx.cellRefSizeField] = layer.layerBand;
            }
            layer.minLayerBand = NumberUtils.preciseSimple(layer.minLayerBand + layoutCtx.offset);
            calculateNiceLayerBand(layer, layoutCtx.isVertical);
        }
        else {
            layer.isVisible = false;
        }
    };
    
    var hideOverlappedLabels = function(allCells, layers, layerIndex, isVertical, cellsToShow, 
            cellsToMeasure, isAllowEmptySegement) {
        //detect text height
        var labelBand;        
        for(var i = 0; i < allCells.length; i++) {
            if(isVertical) {
                if(allCells[i].contentHeight) {
                    labelBand = allCells[i].contentHeight;
                    break;
                }
            }
            else {
                if(allCells[i].contentHeight) {
                    labelBand = allCells[i].contentWidth;
                    break;
                }
            }
        }
        
        //we detect last visible layer index. Last visible layer will have special rules.
        var iLayer;
        var lastVisibleLayerIndex = -1;
        for (iLayer = (layers.length - 1); iLayer >= 0; iLayer--) {
            if(layers[iLayer].isVisible || 
               layers[iLayer].isVisible === undefined) {
                lastVisibleLayerIndex = iLayer;
                break;
            }
        }
        
        //then we need to build Segments.
        var cellSegments = [];
        var iCell;
        var segmentItem = null;
        var previousParentIndex = null;
        for(iCell = 0; iCell < allCells.length; iCell++) {
            if(previousParentIndex === null ||
                previousParentIndex !== allCells[iCell].parentIndex) {
                if(segmentItem) {
                    cellSegments.push(segmentItem);
                }
                segmentItem = [];
                previousParentIndex = allCells[iCell].parentIndex;                
            }
            if(previousParentIndex === allCells[iCell].parentIndex) {
                segmentItem.push(allCells[iCell]);
            }
            
            if(iCell === (allCells.length - 1)) {
                cellSegments.push(segmentItem);
            }
        }
        
        //hide some cells
        var iSegment;
        for(iSegment = 0; iSegment < cellSegments.length; iSegment++) {
            if(layerIndex !== lastVisibleLayerIndex) {
                availableCellsInSegment(labelBand, cellSegments[iSegment], isVertical, cellsToMeasure);
                //visible cells: simple rule
                for(iCell = 0; iCell < cellSegments[iSegment].length; iCell++) {
                    if(isVertical) {
                        if(labelBand < cellSegments[iSegment][iCell].cellHeight) {
                            cellsToShow.push(cellSegments[iSegment][iCell]);                           
                        }
                    }
                    else {
                        if(labelBand < cellSegments[iSegment][iCell].cellWidth) {
                            cellsToShow.push(cellSegments[iSegment][iCell]);                           
                        }
                    }
                }
                //merge cellsToShow and cellsToMeasure, because cellsToMeasure has to handle 2 cases.
                for(iCell = 0; iCell < cellsToShow.length; iCell++) {
                    if(cellsToMeasure.indexOf(cellsToShow[iCell]) < 0) {
                        cellsToMeasure.push(cellsToShow[iCell]);
                    }
                }
            }
            else {
                var availableNum = availableCellsInSegment(labelBand, cellSegments[iSegment], isVertical, cellsToShow);
                if(!isAllowEmptySegement) {
                    if(availableNum === 0) {
                        cellsToShow.splice(0, cellsToShow.length);
                        break;
                    }
                }
                for(iCell = 0; iCell < cellsToShow.length; iCell++) {
                    cellsToMeasure.push(cellsToShow[iCell]);
                }
            }
        }
    };
    
    var availableCellsInSegment = function(labelBand, segment, isVertical, cellsToShow) {
        var cellBand = "cellWidth";
        if(isVertical) {
            cellBand = "cellHeight";
        }
        
        var availableNum = 0;
        var iCell;
        var endCellLocation = 0;
        for(iCell = 0; iCell < segment.length; iCell++) {
            endCellLocation += segment[iCell][cellBand];
        }

        var previousLabelEnd = 0;
        var currentLabelStart;
        for(iCell = 0; iCell < segment.length; iCell++) {
            //count current cell label start
            if(iCell === 0) {
                currentLabelStart = segment[iCell][cellBand]/2 - labelBand/2;                
            }
            else {
                currentLabelStart +=
                    (segment[iCell - 1][cellBand]/2 + segment[iCell][cellBand]/2);
            }
            if(currentLabelStart > previousLabelEnd && (currentLabelStart + labelBand) <= endCellLocation) {
                previousLabelEnd = currentLabelStart + labelBand;
                cellsToShow.push(segment[iCell]); 
                availableNum++;
            }
        }
        
        return availableNum;
    };
    
    var calculateNiceLayerBand = function(layer, isVertical) {
        //each layer should have 3 sizes:
        //layer.maxLayerBand (max text size)
        //layer.minLayerBand (min text size. "M...")
        //layer.niceLayerBand (sort cell sizes, and then choose the 8th size in the 10 cells)
        var NICE_RATIO = 0.8;

        if(!isVertical && !layer.rotated) {
            //text height
            layer.niceLayerBand = layer.layerBand;
            layer.maxLayerBand = layer.layerBand;

        }
        else {
            var minBand = layer.layerBand;
            if(layer.minLayerBand) {
                minBand = layer.minLayerBand;
            }
            
            layer.minLayerBand = minBand;
            layer.maxLayerBand = minBand;
            layer.niceLayerBand = minBand;
        
            if(layer.isVisible) {
                if(layer.layerBand) {
                    layer.maxLayerBand = NumberUtils.preciseSimple(layer.layerBand);
                }
    
                var contentSizes = [];
                var iCell;
                for(iCell = 0; iCell < layer.cells.length; iCell++) {
                    if(layer.cells[iCell].isVisible) {
                        if(isVertical) {
                            if(layer.cells[iCell].contentWidth !== undefined && 
                               layer.cells[iCell].contentWidth !== null) {
                                contentSizes.push(layer.cells[iCell].contentWidth); 
                            }
                        }
                        else {
                            if(layer.cells[iCell].contentHeight !== undefined && 
                               layer.cells[iCell].contentHeight !== null) {
                                contentSizes.push(layer.cells[iCell].contentHeight);
                            }
                        }
                    }
                }
                var compareNumbers = function (a, b) {
                    return a - b;
                };
                contentSizes.sort(compareNumbers);
                var niceValue = contentSizes[Math.ceil(contentSizes.length * NICE_RATIO) - 1];
                layer.niceLayerBand = NumberUtils.preciseSimple(niceValue);
                
                if(layer.maxLayerBand < layer.minLayerBand) {
                    layer.maxLayerBand = layer.minLayerBand;
                }
                
                if(layer.niceLayerBand < layer.minLayerBand) {
                    layer.niceLayerBand = layer.minLayerBand;
                }
            }
        }
    };
    
    var flexibleLayoutCore = function(layers, sizeLimit) {
        var NP = NumberUtils.preciseSimple;
        //first we need to count visible layers
        var allSize = 0;
        var visibleItems = 0;
        var iLayer;
        var allSizeLimit = NP(sizeLimit);
        var needReCalculate;
        
        //we count all visible layers according to allSizeLimit
        for(iLayer = 0; iLayer < layers.length; iLayer++) {
            if(NP(layers[iLayer].minLayerBand) > NP(allSizeLimit)) {
                break;                
            }
            else {
                visibleItems++;
                allSizeLimit -= layers[iLayer].minLayerBand;
            }
        }
        
        //init
        for(iLayer = 0; iLayer < layers.length; iLayer++) {
            layers[iLayer].isVisible = false;
            layers[iLayer].layerBand = 0;
        }   
        
        if(visibleItems > 0) {
            //visibleItems means we always show these itmes. 
            var visbleLayers = [];
            var visbleAllNice = 0;
            var allMax = 0;
            for(iLayer = 0; iLayer < visibleItems; iLayer++) {
                layers[iLayer].isVisible = true;
                visbleLayers.push(layers[iLayer]);
                
                visbleAllNice += layers[iLayer].niceLayerBand;
                allMax += layers[iLayer].maxLayerBand;
            }
            
            visbleAllNice = NP(visbleAllNice);
            allMax = NP(allMax);
            allSizeLimit = NP(sizeLimit);
            
            //layout steps:
            if(allSizeLimit >= allMax) {
                //Edge case
                for(iLayer = 0; iLayer < visbleLayers.length; iLayer++) {
                    visbleLayers[iLayer].layerBand = visbleLayers[iLayer].maxLayerBand;
                }
            }
            else {   
                //1. from inside to outside, set the layer size.
                //If some of them smaller than minSize, set them to minSize.
                var liveAllNice = visbleAllNice;
                for(iLayer = (visbleLayers.length - 1); iLayer >= 0; iLayer--) {
                    visbleLayers[iLayer].layerBand = allSizeLimit * 
                            (visbleLayers[iLayer].niceLayerBand / liveAllNice);
                }                
                
                //After init, we adjust to make sure all layers are >= min
                for(var i = 0; i < visbleLayers.length; i++) {
                    //since we will adjust at least one item once, we 
                    //need at most visbleLayers.length times.
                    allSizeLimit = sizeLimit;
                    liveAllNice = visbleAllNice;
                    needReCalculate = false;
                    
                    for(iLayer = (visbleLayers.length - 1); iLayer >= 0; iLayer--) {
                        if(visbleLayers[iLayer].layerBand < visbleLayers[iLayer].minLayerBand) {
                            visbleLayers[iLayer].layerBand = visbleLayers[iLayer].minLayerBand;
                            visbleLayers[iLayer].adjusted = true;
                            needReCalculate = true;
                        }
                        
                        if(visbleLayers[iLayer].adjusted) {
                            allSizeLimit -= visbleLayers[iLayer].layerBand;
                            
                            liveAllNice -= visbleLayers[iLayer].niceLayerBand;                     
                        }                    
                    }
                    if(needReCalculate) {
                        for(iLayer = (visbleLayers.length - 1); iLayer >= 0; iLayer--) {
                            if(!visbleLayers[iLayer].adjusted) {
                                visbleLayers[iLayer].layerBand = allSizeLimit * 
                                (visbleLayers[iLayer].niceLayerBand / liveAllNice);
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
                
                //2. from outside to inside, set the layer size.
                //If some of them bigger than maxSize, set them to maxSize.
                allSizeLimit = NP(sizeLimit);
                liveAllNice = NP(visbleAllNice);                
                for(iLayer = 0; iLayer < visbleLayers.length; iLayer++) {
                    delete visbleLayers[iLayer].adjusted;
                    needReCalculate = false;
                    
                    if(visbleLayers[iLayer].layerBand > visbleLayers[iLayer].maxLayerBand) {
                        visbleLayers[iLayer].layerBand = visbleLayers[iLayer].maxLayerBand;
                        needReCalculate = true;
                    }
                    
                    allSizeLimit -= visbleLayers[iLayer].layerBand;
                    
                    liveAllNice -= visbleLayers[iLayer].niceLayerBand;
                    
                    if(needReCalculate) {
                        for(var j = iLayer + 1; j < visbleLayers.length; j++) {
                            visbleLayers[j].layerBand = allSizeLimit * 
                            (visbleLayers[j].niceLayerBand / liveAllNice);
                        }
                    }                    
                }
                
                //3. if allSizeLimit still have some, we add them.
                for(iLayer = 0; iLayer < visbleLayers.length; iLayer++) {
                    if(allSizeLimit > 0) {
                        if(visbleLayers[iLayer].layerBand < visbleLayers[iLayer].maxLayerBand) {
                            if(allSizeLimit > (visbleLayers[iLayer].maxLayerBand - visbleLayers[iLayer].layerBand)) {
                                allSizeLimit -= (visbleLayers[iLayer].maxLayerBand - visbleLayers[iLayer].layerBand);
                                visbleLayers[iLayer].layerBand = visbleLayers[iLayer].maxLayerBand;
                            }
                            else {
                                visbleLayers[iLayer].layerBand += allSizeLimit;
                                allSizeLimit = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            
            //count allSize
            allSize = 0;
            for(iLayer = 0; iLayer < visbleLayers.length; iLayer++) {
                allSize += visbleLayers[iLayer].layerBand;
            }
            allSize = NP(allSize);
        }
        
        return allSize;
    };
    
    _buildUtils.flexibleLayoutLayers = function(layers, isVertical, sizeLimit, isAllowEmptySegement) {
        //the function will set layers[i].layerBand and layers[i].isVisible
        //and return the actual size according to sizeLimit
        //the layout rule, please refer to <JIRA>BITSDC1-6985
        var offset = LABEL_OFFSET + TICK_SIZE;
        var allSize = 0;
        var iLayer;
        var iCell;
        if(sizeLimit === undefined || sizeLimit === null) {
            sizeLimit = Infinity;
        }

        var visibleLayers = [];
        for(iLayer = 0; iLayer < layers.length; iLayer++) {
            if(layers[iLayer].isVisible === undefined || 
               layers[iLayer].isVisible === true) {
                visibleLayers.push(layers[iLayer]);
            }
            //record "hasEmptyCell"
            if(layers[iLayer].isVisible && layers[iLayer].cells) {
                layers[iLayer].hasEmptyCell = false;
                for(iCell = 0; iCell < layers[iLayer].cells.length; iCell++) {
                    if(!layers[iLayer].cells[iCell].isVisible) {
                        layers[iLayer].hasEmptyCell = true;
                        break;
                    }
                }
            }
        }
       
        
        for(iLayer = 0; iLayer < layers.length; iLayer++)
        {
            //we need at most layers.length loops
            var originalVisibleLayerNum = visibleLayers.length;
            //some layers may be hidden
            allSize = flexibleLayoutCore(visibleLayers, sizeLimit);
            
            //more layers may be hidden
            if(!isAllowEmptySegement) {
                for(iLayer = 0; iLayer < visibleLayers.length; iLayer++) {
                    var hideAllSubLayers = false;
                    
                    if(visibleLayers[iLayer].isVisible &&
                       visibleLayers[iLayer].hasEmptyCell && iLayer !== (visibleLayers.length - 1)) {
                        //we have to hide all sub layers, and reCalculateLayerContext last visible layer.
                        hideAllSubLayers = true;
                    }
                    
                    //if one cell's all children is empty, we hide sub layers.
                    if(visibleLayers[iLayer].isVisible && visibleLayers[iLayer].cells) {
                        for(iCell = 0; iCell < visibleLayers[iLayer].cells.length; iCell++) {
                            if(allChildrenEmpty(visibleLayers[iLayer].cells[iCell])) {
                                hideAllSubLayers = true;
                                break;
                            }
                        }
                    }
                    
                    if(hideAllSubLayers) {
                        for (var i = visibleLayers.length - 1; i > iLayer; i--) {
                            visibleLayers[i].isVisible = false;
                        }
                    }
                }
            }
            
            visibleLayers = [];
            for(iLayer = 0; iLayer < layers.length; iLayer++) {
                if(layers[iLayer].isVisible === undefined || 
                   layers[iLayer].isVisible === true) {
                    visibleLayers.push(layers[iLayer]);
                }
            }
            
            if(visibleLayers.length > 0 && 
               originalVisibleLayerNum !== visibleLayers.length &&
               visibleLayers[visibleLayers.length - 1].cells &&
               visibleLayers[visibleLayers.length - 1].reCalculateLayerContext) {
                //we have to reCalculateLayerContext for the last visible layer, because 
                //last visible layer has special rules. 
                var layoutCtx = {};
                if(isVertical) {
                    layoutCtx.cellSizeField = "cellHeight";
                    layoutCtx.minCellBandField = "minCellWidth";
                    layoutCtx.cellRefSizeField = "cellWidth";
                } else {
                    layoutCtx.cellSizeField = "cellWidth";
                    layoutCtx.minCellBandField = "minCellHeight";
                    layoutCtx.cellRefSizeField = "cellHeight";
                }
                layoutCtx.offset = (LABEL_OFFSET + TICK_SIZE);
                layoutCtx.isVertical = isVertical;                
                reCalculateLayerContext(visibleLayers, visibleLayers.length - 1, layoutCtx, isAllowEmptySegement);
            }
            else {
                break;
            }
        }
        
        //if cells are too many, we have to filter cells in layoutCells.
        //adjust cellWidth/cellHeight. For contenWidth/contentHeight, render function will adjust them.
        for(iLayer = 0; iLayer < layers.length; iLayer++) {
            if(layers[iLayer].isVisible && layers[iLayer].cells) {
                for(iCell = 0; iCell < layers[iLayer].cells.length; iCell++) {
                    if(isVertical) {
                        layers[iLayer].cells[iCell].cellWidth = layers[iLayer].layerBand;
                        
                        if(layers[iLayer].cells[iCell].contentWidth > layers[iLayer].layerBand - offset) {
                            layers[iLayer].cells[iCell].contentWidth = layers[iLayer].layerBand - offset;
                        }
                    } 
                    else {
                        if(layers[iLayer].cells[iCell].cellHeight > layers[iLayer].layerBand) {
                            //rotated and layerBand should be smaller.
                            layers[iLayer].cells[iCell].cellHeight = layers[iLayer].layerBand;
                        }
                        
                        if(layers[iLayer].cells[iCell].contentHeight > layers[iLayer].layerBand - offset) {
                            layers[iLayer].cells[iCell].contentHeight = layers[iLayer].layerBand - offset;
                        }
                    }
                    

                }
            }
        }
        
        allSize = NumberUtils.preciseSimple(allSize);
        return allSize;
    };
    
    var allChildrenEmpty = function(cell) {
        var allEmpty = true;
        if(cell.children) {
            for(var iCell = 0; iCell < cell.children.length; iCell++) {
                if(cell.children[iCell].isVisible) {
                    allEmpty = false;
                    break;
                }
            }
        }
        return allEmpty;
    };

    _buildUtils.getVisibleLayers = function(axisBody, layers) {
        var visibleLayers = [];
        if (axisBody._properties.get('label.hideSubLevels')) {
            if (layers.length) {
                if (layers[0].isVisible) {
                    visibleLayers.push(layers[0]);
                }
                visibleLayers = [layers[0]];
            }
        } else {
            for (var i = 0, length = layers.length; i < length; ++i) {
                if (layers[i].isVisible) {
                    visibleLayers.push(layers[i]);
                }
            }
        }
        return visibleLayers;
    };



    /****************************************************************************/
    /****************************************************************************/
    /* misc utilities
     * context should NOT be changed, i.e. it should always be _misc itself
     */
    var _misc = {};

    _misc.defaultLabelGetPreferredSize = function(config) {
        return {
            cellWidth: config.size,
            cellHeight: config.size
        };
    };

    _misc.getRangeInfo = function(rangeInterval, offset, size, cell, isVertical) {
        var ret = 0;
        var start, end;
        var length = cell.space;
        for (var i = 0; i < length; ++i) {
            var range = rangeInterval[i + offset];
            var a = range[0] * size;
            var b = range[1] * size;
            ret += Math.abs(a - b);
            if (i === 0) {
                start = a;
            }
            if (i === length - 1) {
                end = b;
            }
        }
        if(isVertical){
            cell.cellHeight = ret;
        }else{
            cell.cellWidth = ret;
        }
        cell.cellStart = start;
        cell.cellEnd = end;
        cell.middle = (start + end) / 2;
    };

    _misc.fillPreferredSize = function(renderer, isVertical, cell, style, layer, position,
        rotated, disableAutoRotation, rotationAngle, otherSize, wrap, noEllipsis) {
        var cellSizeField, minCellBandField;
        if (isVertical) {
            cellSizeField = "cellHeight";
            minCellBandField = "minCellWidth";
        } else {
            cellSizeField = "cellWidth";
            minCellBandField = "minCellHeight";
        }
        var labelGetPreferredSize , psize;
        // If the custom renderer doesn't specify getPreferredSize function.
        // use the default renderer Function to calcuate the size.
        var hasPreferredSizeFunction = renderer.getPreferredSize !== undefined;
        if(hasPreferredSizeFunction){
            labelGetPreferredSize = renderer.getPreferredSize;
        }else{
            labelGetPreferredSize = DefaultCategoryLabelRenderer.getPreferredSize;
        }

        if (rotationAngle === undefined) {
            rotationAngle = VERTICAL_ANGLE;
        }
        var additionalWidth = 0;
        if(otherSize) {
            if(otherSize.valueAxis) {
                additionalWidth = otherSize.valueAxis.width;
            }
            else if(otherSize.categoryAxis2) {
                additionalWidth = otherSize.categoryAxis2.width;
            }
        }
        //get psize
        var config = {
            ctx: cell.ctx,
            styles: style,
            text: cell.text,
            layer: layer,
            size: cell[cellSizeField],
            position: position,
            rotated: rotated,
            rotationAngle: rotationAngle,
            cellWidth: cell.cellWidth,
            cellStart: cell.cellStart,
            disableAutoRotation: disableAutoRotation,
            additionalWidth: additionalWidth,
            noEllipsis: noEllipsis
        };
        if (!rotated || rotationAngle === 0) {
            config.wrap = wrap;
        }

        psize = labelGetPreferredSize.call(renderer, config, DefaultCategoryLabelRenderer.expose);
        if (!psize) { //custom renderer doesn't want to draw this cell, default renderer will do it
            psize = DefaultCategoryLabelRenderer.getPreferredSize(config);
        }
        if (psize[minCellBandField] === undefined) {
            psize[minCellBandField] = 0;
        }
        cell._preferredSize = psize;
        cell.contentWidth = psize.cellWidth;
        cell.contentHeight = psize.cellHeight;
        //calculate start/end
        var middle = cell.middle;
        var halfRange = psize[cellSizeField] / 2;
        cell.start = middle - halfRange;
        cell.end = middle + halfRange;
        return psize;
    };


    _misc.isCellOutOfBound = function(cell, bound) {
        var cellBound = [cell.start, cell.end];
        if (cellBound[0] > cellBound[1]) {
            cellBound.reverse();
        }
        return cellBound[0] < bound[0] || cellBound[1] > bound[1];
    };

    //  _misc.isOverLapped = function(item1, item2) {
    //    return (item1.start > item2.start && item1.start < item2.end) ||
    //      (item1.end > item2.start && item1.end < item2.end);
    //  };

    _misc.findBoundaryBinary = function(cells, rangeBound, getPreferredSizeFn, start, end) { //start is out, end is in
        if (end - start === 1) {
            return start;
        }
        var mid = Math.floor((end + start) / 2);
        getPreferredSizeFn(cells[mid]);
        if (_misc.isCellOutOfBound(cells[mid], rangeBound)) { //find in right
            return _misc.findBoundaryBinary(cells, rangeBound, getPreferredSizeFn, mid, end);
        } else { //find in left
            return _misc.findBoundaryBinary(cells, rangeBound, getPreferredSizeFn, start, mid);
        }
    };

    _misc.excludeCrossBoundCells = function(cells, rangeBound, getPreferredSizeFn) {
        var boundIdx;
        //exclude left side
        var step = Math.floor(cells.length * 0.1) || 1;
        var i, inIdx = -1,
            len = cells.length;
        for (i = 0; i < len;) {
            getPreferredSizeFn(cells[i]);
            if (!_misc.isCellOutOfBound(cells[i], rangeBound)) {
                inIdx = i;
                break;
            }
            if (i === len - 1) {
                break;
            }
            i = Math.min(i + step, len - 1);
        }
        if (inIdx > 0) {
            boundIdx = _misc.findBoundaryBinary(cells, rangeBound, getPreferredSizeFn, inIdx -
                step, inIdx);
        } else if (inIdx < 0) {
            cells.splice(0);
            return;
        }
        //exclude right side
        if (boundIdx !== undefined) {
            cells.splice(0, boundIdx + 1);
            len = cells.length;
            var start = len - (boundIdx + 1);
            if (start >= 0) {
                boundIdx = undefined;
                getPreferredSizeFn(cells[start]);
                if (_misc.isCellOutOfBound(cells[start], rangeBound)) {
                    boundIdx = start;
                    for (i = start - 1; i >= 0; i--) {
                        getPreferredSizeFn(cells[i]);
                        if (!_misc.isCellOutOfBound(cells[i], rangeBound)) {
                            break;
                        }
                        boundIdx = i;
                    }
                } else {
                    for (i = start + 1; i < len; i++) {
                        getPreferredSizeFn(cells[i]);
                        if (_misc.isCellOutOfBound(cells[i], rangeBound)) {
                            boundIdx = i;
                            break;
                        }
                    }
                }
                cells.splice(boundIdx, len - boundIdx);
            }
        }
    };

    _misc.getStep = function(cells, startIdx, getPreferredSizeFn) {
        if (cells.length <= 1) {
            return 1;
        }
        var step;
        var cell0 = cells[startIdx];
        var end0 = cell0.end - 0.001; //fix javascript precision issue
        var len = cells.length;
        var cell;
        for (var j = startIdx + 1; j < len; j++) {
            cell = cells[j];
            if (cell.cellStart >= end0) { //TODO: use cell.start to compare for better space usage
                for (var k = j; k < len; k++) {
                    getPreferredSizeFn(cells[k]);
                    if (cells[k].start >= end0) {
                        step = k - startIdx;
                        break;
                    }
                }
                break;
            }
        }
        return step;
    };

    return _buildUtils;
});

define('sap/viz/chart/layout/AxisLayout',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/PositionUtil",
    "sap/viz/chart/layout/BaseLayout",
    "sap/viz/chart/components/util/BuildLayerUtil"
], function(oo, Constants, NumberUtils, PositionUtil, BaseLayout, BuildLayerUtil) {

    var STACK_DIRECTION_HORIZONTAL = Constants.DIRECTION.HORIZONTAL;
    var STACK_DIRECTION_VERTICAL = Constants.DIRECTION.VERTICAL;
    var SPACING_TO_ROUGH = Constants.AXIS.SPACING_TO_ROUGH;
    var SPACING_MAX_IN_PX = Constants.AXIS.SPACING_MAX_IN_PX;
    var FIX_SPACING_MAX_IN_PX = Constants.AXIS.FIX_SPACING_MAX_IN_PX;
    var AXIS_TITLE = "axisTitle";

    var psFn = NumberUtils.preciseSimple;

    function stack_sortOrderDefault(a, b) {
        return a.option.order - b.option.order;
    }

    function stack_sortPriorityDefault(a, b) {
        return a.option.priority - b.option.priority;
    }

    function stack_sizeDefault(x, refSize) {
        return x.module.getPreferredSize(refSize);
    }

    function stack_offsetDefault(x, rootField) {
        if(x.option.offsetType === Constants.AXIS.FIX_LAYOUT_TYPE){
            return Constants.AXIS.FIX_TITLE_OFFSET;
        }else{
            return x.option.offset * rootField;
        }
    }

    var AxisLayout = function() {
        AxisLayout.superclass.constructor.apply(this, arguments);
        this.config.add({
            sortOrderFn: stack_sortOrderDefault,
            sortPriorityFn: stack_sortPriorityDefault,
            offsetFn: stack_offsetDefault,
            sizeFn: stack_sizeDefault,
            rootWidth: 0,
            rootHeight: 0,
            roughWidth: 0,
            roughHeight: 0,
            position: '',
            layoutAlgorithm: 'auto',
            isFlexibleLayers : false
        });
    };

    oo.extend(AxisLayout, BaseLayout);

    /*
     * components:
     * [{
     *     module: null,
     *     offset: 1,
     *     order: 1,
     *     priority: 1
     * }]
     */
    AxisLayout.prototype.layout = function(components){
        var config = this.config;
        var totalWidth = config.get('totalWidth');
        var totalHeight = config.get('totalHeight');
        var axisPosition = config.get('position');
        var offsetFn = config.get('offsetFn');
        var sizeFn = config.get('sizeFn');
        var rootWidth = config.get('rootWidth');
        var rootHeight = config.get('rootHeight');
        var roughWidth = config.get('roughWidth');
        var roughHeight = config.get('roughHeight');
        var isFlexibleLayers = config.get('isFlexibleLayers');
        var isFixedPadding = config.get('isFixedPadding');

        var refSize = getRefSize(axisPosition, totalWidth, totalHeight);
        var spaceLimit = getSpaceLimit(axisPosition, totalWidth, totalHeight);
        var gravity = getGravity(axisPosition);
        var direction = getDirection(axisPosition);

        var componentsArray = this._dictToArray(components);
        var componentsPriority = getComponentsPriority(componentsArray, config);
        var componentsOrder = getComponentsOrder(componentsArray, config);

        var isStackHorizontal = direction === STACK_DIRECTION_HORIZONTAL;
        var sizeField, refSizeField, coordField, minSizeField, maxSizeField, minRefSizeField, rootField, roughField;

        roughField = Math.min(roughWidth, roughHeight);
        if (isStackHorizontal) {
            minSizeField = "minWidth";
            maxSizeField = "maxWidth";
            minRefSizeField = "minHeight";
            sizeField = "width";
            refSizeField = "height";
            coordField = "x";
            rootField = rootWidth;
        } else {
            minSizeField = "minHeight";
            maxSizeField = "maxHeight";
            minRefSizeField = "minWidth";
            sizeField = "height";
            refSizeField = "width";
            coordField = "y";
            rootField = rootHeight;
        }

        //judge whether component has enough space by "priority"
        var limit = spaceLimit; //+ 0.00001; //eliminate precision loss of javascript float
        var i = 0,
            length = componentsPriority.length,
            component, moduleSize, offset;
        var hideRest = false;
        var rootOffsetInPX = 0;
        var roughOffsetInPX = SPACING_TO_ROUGH * roughField;
        for (; i < length; ++i) {
            component = componentsPriority[i];
            if (hideRest) {
                component.isEnough = false;
                continue;
            }
            moduleSize = sizeFn(component);
            rootOffsetInPX = offsetFn(component, rootField);
            offset = Math.min(rootOffsetInPX, roughOffsetInPX);
            offset = isFixedPadding && component.module.alias === "axisTitle" ? 
                FIX_SPACING_MAX_IN_PX : Math.min(offset, SPACING_MAX_IN_PX);
            if (moduleSize[maxSizeField] &&
                    psFn(limit - offset - moduleSize[minSizeField]) >= 0 &&
                    Math.ceil(moduleSize[minRefSizeField]) <= Math.ceil(refSize)) {
                component.isEnough = true;
                limit = psFn(limit - offset);
                if (limit >= moduleSize[maxSizeField]) {
                    component[sizeField] = moduleSize[maxSizeField];
                    limit = psFn(limit - moduleSize[maxSizeField]);
                } else {
                    component[sizeField] = getFitSize(limit, moduleSize.spacings, isFlexibleLayers);
                    limit = 0;
                }
            } else {
                component.isEnough = false;
                if (moduleSize[maxSizeField]) {
                    hideRest = true;
                }
            }
            limit = psFn(limit);
        }

        //calculate position for components which has enough space by "order"
        i = 0;
        length = componentsOrder.length; // reset temporary variables
        var anchorResult = {};
        var anchor, start;
        if (gravity < 0) {
            start = 0;
            for (; i < length; ++i) {
                anchor = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                component = componentsOrder[i];
                if (component.isEnough) {
                    rootOffsetInPX = offsetFn(component, rootField);
                    offset = Math.min(rootOffsetInPX, roughOffsetInPX);
                    offset = isFixedPadding && component.module.alias === "axisTitle" ? 
                        FIX_SPACING_MAX_IN_PX : Math.min(offset, SPACING_MAX_IN_PX);
                    start += offset;
                    anchor[coordField] = start;
                    start += (anchor[sizeField] = component[sizeField]);
                    anchor[refSizeField] = refSize;

                    // BITSDC1-6654: When it's fixed layout, axis title would apply right/bottom alignment.
                    if (config.get("layoutAlgorithm") === "fixed" && component.module.alias === AXIS_TITLE) {
                        anchor[coordField] = spaceLimit - component[sizeField];
                    }
                }
                anchorResult[component.module.alias] = anchor;
            }
        } else {
            start = spaceLimit;
            for (; i < length; ++i) {
                anchor = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                component = componentsOrder[i];
                if (component.isEnough) {
                    rootOffsetInPX = offsetFn(component, rootField);
                    offset = Math.min(rootOffsetInPX, roughOffsetInPX);
                    offset = isFixedPadding && component.module.alias === "axisTitle" ? 
                        FIX_SPACING_MAX_IN_PX : Math.min(offset, SPACING_MAX_IN_PX);
                    start -= offset;
                    start -= (anchor[sizeField] = component[sizeField]);
                    anchor[refSizeField] = refSize;

                    // BITSDC1-6654: When it's fixed layout, axis title would apply left/top alignment.
                    if (config.get("layoutAlgorithm") === "fixed" && component.module.alias === AXIS_TITLE) {
                        start = 0;
                    }
                }
                anchor[coordField] = start;
                anchorResult[component.module.alias] = anchor;
            }
        }
        return anchorResult;
    };

    AxisLayout.prototype.getPreferredSize = function(components) {
        var config = this.config;

        var totalWidth = config.get('totalWidth');
        var totalHeight = config.get('totalHeight');
        var axisPosition = config.get('position');
        var sizeFn = config.get('sizeFn');
        var offsetFn = config.get('offsetFn');
        var componentsArray = this._dictToArray(components);
        var rootWidth = config.get('rootWidth');
        var rootHeight = config.get('rootHeight');
        var roughWidth = config.get('roughWidth');
        var roughHeight = config.get('roughHeight');
        var isFixedPadding = config.get('isFixedPadding');

        var spacings = [];
        var i = 0;
        var size = 0;
        var componentsPriority = getComponentsPriority(componentsArray, config);
        var length = componentsPriority.length;
        var direction = getDirection(axisPosition);
        var isStackHorizontal = direction === STACK_DIRECTION_HORIZONTAL;
        var majorSizeName = isStackHorizontal ? 'height' : 'width';
        var minorSizeName = isStackHorizontal ? 'width' : 'height';
        var refSize = getRefSize(axisPosition, totalWidth, totalHeight);
        var sizeLimit = PositionUtil.isVertical(axisPosition) ? totalWidth : totalHeight;
        var component, moduleSize, spacing, offset, maxSizeField, minRefSizeField, rootField, roughField;

        roughField = Math.min(roughWidth, roughHeight);
        if (isStackHorizontal) {
            maxSizeField = "maxWidth";
            minRefSizeField = "minHeight";
            rootField = rootWidth;
        } else {
            maxSizeField = "maxHeight";
            minRefSizeField = "minWidth";
            rootField = rootHeight;
        }
        
        var hideRest = false;
        var visibleComponents = [];
        var componentsPrfSize = {};

        for (; i < length && !hideRest; ++i) {
            component = componentsPriority[i];
            var rootOffsetInPX = offsetFn(component, rootField);
            var roughOffsetInPX = SPACING_TO_ROUGH * roughField;
            offset = Math.min(rootOffsetInPX, roughOffsetInPX);
            offset = isFixedPadding && component.module.alias === "axisTitle" ? 
                FIX_SPACING_MAX_IN_PX : Math.min(offset, SPACING_MAX_IN_PX);
            var componentRefSize = {};
            componentRefSize[minorSizeName] = sizeLimit - size - offset;
            componentRefSize[majorSizeName] = refSize;
            moduleSize = sizeFn(component, componentRefSize);
            if (Math.ceil(moduleSize[minRefSizeField]) <= Math.ceil(refSize) && moduleSize[maxSizeField] &&
                psFn(size + offset + moduleSize[maxSizeField]) <= psFn(sizeLimit)) {
                size += offset + moduleSize[maxSizeField];

                visibleComponents.push(component.module.alias);
                componentsPrfSize[component.module.alias] = moduleSize[maxSizeField];

            } else if (moduleSize[maxSizeField] !== 0) {
                hideRest = true;
            }

        }
        var width = 0,
            height = 0;
        if (isStackHorizontal) {
            width = size;
            height = refSize;
        } else {
            width = refSize;
            height = size;
        }
        return {
            width: width,
            height: height,
            extra:{
                visibleComponents: visibleComponents,
                componentsPrfSize: componentsPrfSize
            }
        };
    };

    function getFitSize(limit, spacings, isFlexibleLayers) {
        var size;
        if(isFlexibleLayers) {
            size = BuildLayerUtil.flexibleLayoutLayers(spacings, true, limit);
        }
        else {
            size = 0;
            var spacing;
            if (!spacings) { //it's true when chart is resized to very small
                return size;
            }
            for (var i = 0, length = spacings.length; i < length; ++i) {
                spacing = spacings[i];
                size += spacing.interval;
                size = psFn(size); //precision trap, careful!!
                if (size > limit) {
                    switch (spacing.type) {
                        case Constants.SPACING_TYPE.STEP:
                            size -= spacing.interval;
                            break;
                        case Constants.SPACING_TYPE.RANGE:
                            size = limit;
                            break;
                    }
                }
            }
        }
        return size;
    }

    function getGravity(position) {
        if (position === Constants.POSITION.TOP || position === Constants.POSITION.LEFT) {
            return 1;
        } else {
            return -1;
        }
    }

    function getDirection(position) {
        if (position === Constants.POSITION.TOP || position === Constants.POSITION.BOTTOM) {
            return STACK_DIRECTION_VERTICAL;
        } else {
            return STACK_DIRECTION_HORIZONTAL;
        }
    }

    function getRefSize(position, width, height){
        return PositionUtil.isVertical(position) ? height : width;
    }

    function getSpaceLimit(position, width, height){
        return PositionUtil.isVertical(position) ? width : height;
    }

    function getComponentsPriority(components, config){
        return components.slice().sort(config.get('sortPriorityFn'));
    }

    function getComponentsOrder(components, config){
        return components.slice().sort(config.get('sortOrderFn'));
    }

    return AxisLayout;
});

define('sap/viz/chart/components/util/AxisBodyUtil',[],function() {
    var setTransform = function(instance, translate) {
        var translateString = "translate(" + translate.x + ", " + translate.y + ")";
        if (instance._tickGroupNode) {
            instance._tickGroupNode.attr("transform", translateString);
        }
        if (instance._labelGroupNode) {
            instance._labelGroupNode.attr("transform", translateString);
        }
    };
    var getBindingFields = function(metaData){
        var bindingFields;
        if (metaData) {
            bindingFields = [];
            for (var i = 0, len = metaData.length; i < len; ++i) {
    
                var bindingField = {
                    id: metaData[i].id,
                    name: metaData[i].name,
                    invisible: metaData[i].hidden
                };
    
                // measureNames
                if (metaData[i].values) {
                    var mapping = {};
                    metaData[i].values.forEach(function(item) {
                        mapping[item.id] = item.name;
                    });
                    bindingField.values = mapping;
                }
    
                bindingFields.push(bindingField);
            }
        }
        return bindingFields;
    };
    return {
        setTransform: setTransform,
        getBindingFields: getBindingFields
    };
});

define('sap/viz/chart/components/axis/AxisContainer',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/container/UIContainer",
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/framework/common/util/PositionUtil",
    'sap/viz/chart/components/util/BoundUtil',
    "sap/viz/chart/components/axis/sub/AxisTitle",
    "sap/viz/chart/components/scrollbar/Scrollbar",
    "sap/viz/chart/layout/AxisLayout",
    'sap/viz/framework/common/util/PropertyZoneUtil',
    'sap/viz/framework/common/util/FeedingZoneUtil',
    'sap/viz/chart/components/util/AxisBodyUtil',
    'sap/viz/framework/interaction/Constants'
], function(Constants,
         oo,
         UIContainer,
         NumberUtils,
         TypeUtils,
         PositionUtils,
         BoundUtil,
         AxisTitle,
         Scrollbar,
         AxisLayout,
         PropertyZoneUtil,
         FeedingZoneUtil,
         AxisBodyUtil,
         InteractionConstants) {
    var DEFAULT_TITLE_TEXT = "Axis Title";

    var POSITION_CLASS_MAPPING = {
        'left': 'v-m-yAxis',
        'top': 'v-m-xAxis2',
        'right': 'v-m-yAxis2',
        'bottom': 'v-m-xAxis'
    };

    var AxisContainer = function(runtime, options) {
        AxisContainer.superclass.constructor.apply(this, arguments);

        this._valueAxes = options.valueAxes;
        this._disableTitle = !!options.disableTitle;
        this.categoryTitleXoffset = null;
        this.categoryTitleYoffset = null;
        this._roughSize = {
            width: 0,
            height: 0
        };
        this._bodyLayersNumber = -1;
        var properties = this._properties;
        var that = this;

        if (options && options.hasScrollbar) {
            this.setChild(Constants.AXIS.SCROLLBAR_NAME, new Scrollbar(runtime, {
                name: 'plotArea.scrollbar'
            }), {
                order: 2,
                priority: 0,
                offset: 0
            });
        }

        ['height', 'width'].forEach(function(e){
            var prop = {
                    set: function(value, obj){
                        if(value === null || parseFloat(value)>=0){
                            return value;
                        }else{
                            return obj.value; /**no change*/
                        }
                    }
                },
            fullPathprop = {
                    layout:{}
                };
            fullPathprop.layout[e] = prop;
            properties.add(fullPathprop);
        });

        if (!options.isTrellis) {
            var axisPropertyZone = {},
                axisFeedingZone = {};
            axisPropertyZone[this._name] = {
                value: [],
                readonly: true,
                serializable: false,
                get: function() {
                    var result = [],
                        zonenamePrefix, boundRect, boundRect1, bound, bound1, temp, root;
                    var categoryTitleXoffset = 0;
                    var categoryTitleYoffset = 0;
                    if (that._properties.get('title.visible') &&
                        that._selections && that._selections["axisTitle"] &&
                        that._selections["axisTitle"].length > 0) {
                        boundRect = that._selections["axisTitle"].node().getBoundingClientRect();
                        if (boundRect.width > 1.5 && boundRect.height > 1.5) {
                            bound = [
                                []
                            ];
                            bound[0].push([boundRect.left, boundRect.top]);
                            bound[0].push([boundRect.right, boundRect.top]);
                            bound[0].push([boundRect.right, boundRect.bottom]);
                            bound[0].push([boundRect.left, boundRect.bottom]);
                            result.push({
                                "name": that._name + ' title',
                                "bound": bound
                            });
                        }
                    }
                    if (that._parent && that._parent.select(".v-m-axisBody").node()) {
                        //if .v-m-axisBody has covered by clippath, we have to use BoundingClientRect of clippath.
                        var axisBodyVisibleElement = that._parent.select(".v-m-axisBody").node();

                        var axisBodyClipPath = axisBodyVisibleElement.getAttribute('clip-path');
                        if(axisBodyClipPath && axisBodyClipPath.length > 0) {
                            //remove all spaces
                            axisBodyClipPath = axisBodyClipPath.replace(/\s/g, "");

                            //remove prefix
                            var prefixStr = /^url\(/;
                            axisBodyClipPath = axisBodyClipPath.replace(prefixStr, "");

                            //remove suffix
                            axisBodyClipPath = axisBodyClipPath.replace(/\)$/, "");

                            //fix BITSDC1-5040, filter "" because IE will automatically add "" in URL()
                            axisBodyClipPath = axisBodyClipPath.replace(/^\"/, "");
                            axisBodyClipPath = axisBodyClipPath.replace(/\"$/, "");

                            //select clippath
                            axisBodyVisibleElement = that._parent.select(axisBodyClipPath).node();
                        }

                        temp = axisBodyVisibleElement.getBoundingClientRect();

                        // Fix BITSDC4-4467:
                        // Lumira's CEF engine return empty size of clippath, we need to get its rect's dimension.
                        if (axisBodyClipPath && axisBodyClipPath.length > 0) {
                            if (temp.width === 0 && temp.height === 0) {
                                var clipRectNode = axisBodyVisibleElement.querySelector('rect');
                                if (clipRectNode) {
                                    temp = clipRectNode.getBoundingClientRect();
                                }
                            }
                        }

                        if (temp.width > 1.5 || temp.height > 1.5) {
                            boundRect1 = {
                                left: temp.left,
                                right: temp.right,
                                top: temp.top,
                                bottom: temp.bottom
                            };

                            bound1 = [
                                []
                            ];
                            bound1[0].push([boundRect1.left + categoryTitleXoffset,
                                boundRect1.top + categoryTitleYoffset
                            ]);
                            bound1[0].push([boundRect1.right + categoryTitleXoffset,
                                boundRect1.top + categoryTitleYoffset
                            ]);
                            bound1[0].push([boundRect1.right + categoryTitleXoffset,
                                boundRect1.bottom + categoryTitleYoffset
                            ]);
                            bound1[0].push([boundRect1.left + categoryTitleXoffset,
                                boundRect1.bottom + categoryTitleYoffset
                            ]);

                            result.push({
                                "name": that._name,
                                "bound": bound1
                            });
                        }
                        root = that._parent.node().ownerSVGElement;
                    }
                    PropertyZoneUtil.calcOffsetFromChart(root, result);
                    return result;
                }
            };

            axisFeedingZone[this._name] = {
                value: [],
                readonly: true,
                serializable: false,
                get: function() {
                    var result, zonenamePrefix, feeding;
                    if (that._parent) {
                        var root = d3.select(that._parent.node().ownerSVGElement);
                        result = FeedingZoneUtil.buildRes(that._name, feeding, root, that.isByBound());
                    }
                    return result;
                }
            };

            runtime.zoneManager().add({
                tempPropertyZone: axisPropertyZone,
                tempFeedingZone: axisFeedingZone
            });
        }

        this.setLayoutAlgorithm(new AxisLayout());
        this._scale = null;
        this._bindingFields = [];
        if (!this._disableTitle) {
            this.setChild("axisTitle", new AxisTitle(runtime, options), {
                order: 3,
                priority: 1,
                offset: Constants.AXIS.SPACING_TO_ROOT
            });
        }

        this._position = null;
        this._parent = null;

        var graphicModel = this.runtime().graphicModel();
        if (graphicModel) {
            graphicModel.registerExposedModule(options.name);
        }
    };
    oo.extend(AxisContainer, UIContainer);

    AxisContainer.prototype.zoom = function (scale){
        if (scale){
            this._realSize.width = this._size.width * scale.x;
            this._realSize.height = this._size.height * scale.y;
            this._updateData(this._getSizeInfo());
        }
        this._updateSubModules(scale);
    };

    AxisContainer.prototype.update = function(){
        this._updateData(this._getSizeInfo());
        this._updateSubModules();
    };

    AxisContainer.prototype._updateSubModules = function (){
        if (this.getChild("axisBody")){
            this.getChild("axisBody").module.update();
        }
    };

    AxisContainer.prototype.scroll = function(offset){
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var module = this.getChild(key).module;
                if (module.scroll){
                    module.scroll(offset);
                }
            }
        }
    };

    AxisContainer.prototype.setData = function(data) {
        this._bindingFields = AxisBodyUtil.getBindingFields(data.metaData) || this._bindingFields;
    };
    AxisContainer.prototype.setPosition = function(pos) {
        var props = this._properties;
        var visible = props.get('visible');
        var height = parseFloat(props.get('layout.height'));
        var width = parseFloat(props.get('layout.width'));

        this._position = pos;
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var child = this.getChild(key);
                child.module.setPosition(this._position);

                if (key === 'axisTitle'){
                    var option = child.option;
                    if (visible && PositionUtils.isHorizontal(option.position) ? height >= 0 : width >= 0){
                        //set type of axis title layout
                        option.offsetType = Constants.AXIS.FIX_LAYOUT_TYPE;
                    }
                }
            }
        }
        return this;
    };

    AxisContainer.prototype._isVertical = function() {
        return PositionUtils.isVertical(this._position);
    };

    AxisContainer.prototype._isHorizontal = function() {
        return PositionUtils.isHorizontal(this._position);
    };


    AxisContainer.prototype._updateData = function() {
        if (!this._disableTitle) {
            this.getChild("axisTitle").module.setData(this._getTitle());
        }
    };

    AxisContainer.prototype._getTitle = function() {
        //we cannot just return title text. Axis Title should be an object.
        var titleObj = {};
        titleObj.text = "";
        titleObj.isCustomized = false;
        titleObj.items = [];
        //an item is an obj as {text: "abc", isHidden: false}

        var text = "";

        var titleText = this._properties.get('title.text');

        if (TypeUtils.isString(titleText)) {
            text = titleText;
            titleObj.isCustomized = true;
        } else if (this._bindingFields) {
            //we should build the items of axis title. _constructTitle will change
            //titleObj.items
            text = this._constructTitle(this._bindingFields, titleObj.items);
        } else {
            text = DEFAULT_TITLE_TEXT;
            titleObj.isCustomized = true;
        }

        titleObj.text = text;
        return titleObj;
    };

    AxisContainer.prototype._constructTitle = function(header, titleItems) {
        return "";
    };

    AxisContainer.prototype.getParent = function() {
        if (this._parent) {
            return this._parent.select("g." + Constants.CSS.CLASS.AXIS.CONTAINER);
        } else {
            return null;
        }
    };

    AxisContainer.prototype.addARIATag = function(rootElement){
    };

    AxisContainer.prototype.renderAddition = function (dpContext) {
        this.getChild("axisBody").module.renderValueBasedColorLine(dpContext);
    };

    AxisContainer.prototype.render = function (rootElement) {
        this.addARIATag(rootElement);
        
        this._parent = rootElement;
        AxisContainer.superclass.render.apply(this, arguments);
        BoundUtil.drawBound(rootElement, this._size.width, this._size.height, undefined, true);
        var parent = rootElement.select("g." + Constants.CSS.CLASS.AXIS.CONTAINER);
        if (this._size.width > 0 || this._size.height > 0) {
            if (!parent.node()) {
                delete this._selections;
                this._selections = null;
                parent = rootElement.append("g").attr("class", Constants.CSS.CLASS.AXIS.CONTAINER);
            }
            this._initRenderBase(parent);
            this.layout();
            if (this.getChild("axisBody")) {
                var bodyLayersNumber = this.getChild("axisBody").module.getAvailableLayersNumber();
                this._bodyLayersNumber = bodyLayersNumber;
                if (!this._disableTitle) {
                    this.getChild("axisTitle").module.setTitleHiddenItems(bodyLayersNumber);
                }
            }
            this._renderSub();
        }

        var synonymClass = POSITION_CLASS_MAPPING[this._position];
        rootElement.classed(synonymClass, true);
    };

    AxisContainer.prototype.isVisible = function() {
        return this._bodyLayersNumber > 0;
    };

    AxisContainer.prototype.setChild = function(key, module, option) {
        AxisContainer.superclass.setChild.apply(this, arguments);
        if (module.setPosition && option.position) {
            module.setPosition(option.position);
        }
    };

    AxisContainer.prototype._setupLayout = function(info, options) {
        this._updateData(info);
        // this._updateProperties();
        var getPositiveInt = NumberUtils.getPositiveInt;
        var originProp = this._properties.origin;
        var paddingInfo = this.calculatePaddingInPX(originProp, this._roughSize.width, this._roughSize.height);

        var padding = getPositiveInt(paddingInfo.propertyPaddingInPX, paddingInfo.constantPaddingInPX);
        var paddingTop = getPositiveInt(paddingInfo.propertyPaddingTopInPX, padding);
        var paddingRight = getPositiveInt(paddingInfo.propertyPaddingRightInPX, padding);
        var paddingBottom = getPositiveInt(paddingInfo.propertyPaddingBottomInPX, padding);
        var paddingLeft = getPositiveInt(paddingInfo.propertyPaddingLeftInPX, padding);

        var isFlexibleLayers = false;
        var axisBody = this.getChild("axisBody");
        if(axisBody && axisBody.module) {
            if(axisBody.module.isFlexibleLayers) {
                isFlexibleLayers = axisBody.module.isFlexibleLayers();
            }
        }
        
        var layoutConfig = this._layoutAlgorithm.config;
        layoutConfig.set('position', this._position);
        layoutConfig.set('rootWidth', this._roughSize.width - (paddingRight + paddingLeft));
        layoutConfig.set('rootHeight', this._roughSize.height - (paddingTop + paddingBottom));
        layoutConfig.set('roughWidth', this._roughSize.width);
        layoutConfig.set('roughHeight', this._roughSize.height);
        layoutConfig.set('isFlexibleLayers', isFlexibleLayers);
        if (info.width !== undefined) {
            layoutConfig.set('totalWidth', info.width);
        }
        if (info.height !== undefined) {
            layoutConfig.set('totalHeight', info.height);
        }


        if ((['left', 'right'].indexOf(this._position) > -1 && this._properties.get("layout.width") !== null) ||
            (['top', 'bottom'].indexOf(this._position) > -1 && this._properties.get("layout.height") !== null) ||
            (options && options.pagination)) {
            //we fix chart layout for pagination
            layoutConfig.set("layoutAlgorithm", "fixed");
        }
    };

    AxisContainer.prototype._getSizeInfo = function(info) {
        var sizeInfo = {
            width: this._size.width,
            height: this._size.height
        };

        if (info) {
            if (info.width) {
                sizeInfo.width = info.width;
            }
            if (info.height) {
                sizeInfo.height = info.height;
            }
        } else if (this._realSize.width > this._size.width ||
            this._realSize.height > this._size.height) {
            if (this._isHorizontal()) {
                sizeInfo.width = this._realSize.width;
            } else {
                sizeInfo.height = this._realSize.height;
            }
        }
        return sizeInfo;
    };

    AxisContainer.prototype._configLayout = function() {
        this._setupLayout(this._getSizeInfo());
    };

    AxisContainer.prototype._postLayout = function() {
        var results = this._layoutResult;

        var selections = this._selections;
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var module = this._children[key].module;
                var selection = selections ? selections[key] : null;
                var anchor = results[key];
                if (this._isHorizontal()) {
                    module.setSize({
                        width: this._size.width,
                        height: anchor.height
                    });
                } else {
                    module.setSize({
                        width: anchor.width,
                        height: this._size.height
                    });
                }
                module.setRealSize({
                    width: anchor.width,
                    height: anchor.height
                });
                if (module.layout) { //force category axis body to layout with new size
                    module.layout();
                }
                if (selection) {
                    selection.attr("transform", "translate(" + anchor.x + "," + anchor.y + ")");
                    if ((this._name == "categoryAxis" || this._name == "categoryAxis2" ) && key == "axisBody") {
                        this.categoryTitleXoffset = anchor.x;
                        this.categoryTitleYoffset = anchor.y;
                    }
                }
            }
        }
    };

    AxisContainer.prototype.getPreferredSize = function(info, options) {

        this._setupLayout(this._getSizeInfo(info), options);
        this._layoutAlgorithm.config.add({
            isFixedPadding : this._properties.origin.get('general.layout.isFixedPadding')
        });
        var layoutSize = this._layoutAlgorithm.getPreferredSize(this._children);
        return NumberUtils.preciseObject(layoutSize);
    };

    AxisContainer.prototype._renderSub = function() {
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                this.getChild(key).module.render(this._selections[key]);
            }
        }
    };

    function eraseRectangle(b1, b2, position) {
        var br = {
            left: b1.left,
            right: b1.right,
            top: b1.top,
            bottom: b1.bottom
        };
        if (position === 'left') {
            br.left = b2[0][1][0] + 1;
        } else if (position === 'right') {
            br.right = b2[0][0][0] - 1;
        } else if (position === 'top') {
            br.top = b2[0][3][1] + 1;
        } else if (position === 'bottom') {
            br.bottom = b2[0][0][1] - 1;
        }
        return br;
    }

    AxisContainer.prototype.appendSynonymClass = function(element, synonym) {

        var synonymClass = POSITION_CLASS_MAPPING[this._position];
        element.classed(synonymClass, true);
    };

    AxisContainer.prototype.destroy = function() {
        AxisContainer.superclass.destroy.call(this);
        this._bindingFields = null;
        this._disableTitle = null;
        this._parent = null;
        this._position = null;
        this.categoryTitleXoffset = null;
        this.categoryTitleYoffset = null;
    };

    AxisContainer.prototype.setRoughSize = function(value) {
        if (value.width != null) {
            this._roughSize.width = value.width;
        }
        if (value.height != null) {
            this._roughSize.height = value.height;
        }
    };

    AxisContainer.prototype.isByBound = function(data) {
        return false;
    };

    return AxisContainer;
});

define('sap/viz/chart/components/axis/renderer/ValueBodyRenderer',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/PositionUtil",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/property/PropertyManager",
    'sap/viz/chart/components/util/ValueAxisUtils',
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/migrate/PropertyUtil"
], function(
    Constants,
    NumberUtils,
    PositionUtil,
    TextUtils,
    TypeUtils,
    SVG,
    PropertyManager,
    ValueAxisUtils,
    NameColorUtils,
    PropertyUtil
) {

    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;

    var TINY_TICK_INTERVAL = 1;
    var SMALLEST_TICK_INTERVAL = 6;

    var TICK_SIZE = 5;
    var LABEL_OFFSET = 6;
    var TRELLIS_VALUEAXIS_PADDING = 3;

    var ret = {};

    ret.drawLines = function(selection, range, width, height, position, props, effectManager, valueAxes) {
        
        var lineClass = AXIS_CLASS_NAMES.PERIMETER + " " + AXIS_CLASS_NAMES.LINE;
        var isPropMgr = props instanceof PropertyManager;
        var color = isPropMgr ? props.get('color') : props.color;

        if (TypeUtils.isArray(color) && valueAxes) {
            //we support StringArray for combinationEx
            var idx = valueAxes.length > 1 ? 1 : 0;
            color = PropertyUtil.getComplexProperty("color", color, idx, props);
        }
        var x1 = 0;
        var y1 = 0;
        var x2 = 0;
        var y2 = 0;
        var stroke = effectManager.register({
            fillColor: NameColorUtils.convertColor(color)
        });
        var strokeWidth = isPropMgr ? props.get('axisLine.size') : props.axisLine.size;
        if (!TypeUtils.isNumber(strokeWidth)) {
            strokeWidth = 1;
        }
        var start, end, len;
        if (position === Constants.POSITION.TOP || position === Constants.POSITION.BOTTOM) {
            len =  width;
        } else {
            len = height;
        }
        
        if (range[0] < range[1]) {
            start = range[0] - strokeWidth / 2;
            end = len + strokeWidth / 2;
        } else {
            start = range[1] - strokeWidth / 2;
            end = len + strokeWidth / 2;
        }

        switch (position) {
            case Constants.POSITION.LEFT:
                x1 = width;
                y1 = start;
                x2 = width;
                y2 = end;
                break;
            case Constants.POSITION.RIGHT:
                x1 = 0;
                y1 = start;
                x2 = 0;
                y2 = end;
                break;
            case Constants.POSITION.TOP:
                x1 = start;
                y1 = height;
                x2 = end;
                y2 = height;
                break;
            case Constants.POSITION.BOTTOM:
                x1 = start;
                y1 = 0;
                x2 = end;
                y2 = 0;
                break;
        }

        var line = selection.select("." + AXIS_CLASS_NAMES.LINE);
        if (!line.node()) {
            line = selection.append("line")
                .style("pointer-events", "none" )
                .attr("class", lineClass)
                .attr("shape-rendering", "crispEdges");
        }

        //this need to be updated each time
        line.attr("stroke", stroke)
            .attr("stroke-width", strokeWidth);

        line.attr("x1", x1).attr("y1", y1)
            .attr("x2", x2).attr("y2", y2);
        return line;
    };

    var TICK_SELECTOR = "." + AXIS_CLASS_NAMES.TICK + ", ." + AXIS_CLASS_NAMES.LONGTICK;

    function removeExtraTicks(ticks, minInterval){
        var length = ticks.length;
        if(length <= 2){
            return ticks;
        }
        var showOnlyTwo = true;
        var i;
        for(i = length - 1; i > 0; --i){
            if(Math.abs(ticks[i] - ticks[i - 1]) >= minInterval){
                showOnlyTwo = false;
                break;
            }
        }
        if(showOnlyTwo){
            ticks.splice(1, length - 2);
        }else {
            for(i = length - 1; i > 0; --i){
                if(Math.abs(ticks[i] - ticks[i - 1]) < minInterval){
                    ticks.splice(i - 1 || i, 1);
                }
            }
        }
        return ticks;
    }
    function getTicksToDraw(ticks, force){
        var results = [];
        if (ticks && TypeUtils.isArray(ticks)) {
            results = ticks.slice(0);
            removeExtraTicks(results, TINY_TICK_INTERVAL);
            if(!force){
                removeExtraTicks(results, SMALLEST_TICK_INTERVAL);
            }
        }
        return results;
    }
    ret.drawTicks = function(selection, ticks, width, height, position, props, effectManager, force, valueAxes) {
        var isPropMgr = props instanceof PropertyManager;
        var tickClass = AXIS_CLASS_NAMES.PERIMETER + " " + AXIS_CLASS_NAMES.TICK;
        var color = isPropMgr ? props.get('color') : props.color;
        if (TypeUtils.isArray(color) && valueAxes) {
            //we support StringArray for combinationEx
            var idx = valueAxes.length > 1 ? 1 : 0;
            color = PropertyUtil.getComplexProperty("color", color, idx, props);
        }

        var stroke = effectManager.register({
            fillColor: NameColorUtils.convertColor(color)
        });
        var strokeWidth = isPropMgr ? props.get('axisLine.size') : props.axisLine.size;

        var ticksToDraw = getTicksToDraw(ticks, force);
        var i = 0, length = ticksToDraw.length;
        var x1s = [],
            y1s = [],
            x2s = [],
            y2s = [];
        switch (position) {
            case Constants.POSITION.LEFT:
                for (; i < length; ++i) {
                    x1s[i] = width;
                    y1s[i] = ticksToDraw[i];
                    x2s[i] = width - TICK_SIZE;
                    y2s[i] = ticksToDraw[i];
                }
                break;
            case Constants.POSITION.RIGHT:
                for (; i < length; ++i) {
                    x1s[i] = 0;
                    y1s[i] = ticksToDraw[i];
                    x2s[i] = TICK_SIZE;
                    y2s[i] = ticksToDraw[i];
                }
                break;
            case Constants.POSITION.TOP:
                for (; i < length; ++i) {
                    x1s[i] = ticksToDraw[i];
                    y1s[i] = height;
                    x2s[i] = ticksToDraw[i];
                    y2s[i] = height - TICK_SIZE;
                }
                break;
            case Constants.POSITION.BOTTOM:
                for (; i < length; ++i) {
                    x1s[i] = ticksToDraw[i];
                    y1s[i] = 0;
                    x2s[i] = ticksToDraw[i];
                    y2s[i] = TICK_SIZE;
                }
                break;
        }
        var tickSelections = selection.selectAll(TICK_SELECTOR).data(ticksToDraw);

        tickSelections.enter().append("line").each(function(){
            this.setAttribute("class", tickClass);
            this.setAttribute("stroke", stroke);
            this.setAttribute("stroke-width", strokeWidth);
            this.setAttribute("shape-rendering", "crispEdges");
        });
        tickSelections.exit().remove();

        tickSelections.each(function(d, i) {
            this.setAttribute("x1", NumberUtils.preciseSimple(x1s[i]));
            this.setAttribute("y1", NumberUtils.preciseSimple(y1s[i]));
            this.setAttribute("x2", NumberUtils.preciseSimple(x2s[i]));
            this.setAttribute("y2", NumberUtils.preciseSimple(y2s[i]));
        });
    };

    ret.getTrellisBaseValueIndex = function(labels) {
        var lastIndex = labels.length - 1;
        var firstValue = labels[0].value,
            lastValue = labels[lastIndex].value;
        var index = ValueAxisUtils.getTrellisBaseValueIndex(firstValue, lastValue);
        return (index === 1) ? lastIndex : index;
    };

    ret.drawLabels = function(selection, scale, labels, width, height, position, props, options, 
        effectManager, isAdjustLastLabel) {
        if (!selection) {
            return;
        }
        var labelClass = AXIS_CLASS_NAMES.LABEL + " " + AXIS_CLASS_NAMES.MORPHABLE_LABEL + " " +
            AXIS_CLASS_NAMES.LABEL_BACKWORD;
        var styles = props instanceof PropertyManager ? props.get('label.style') : props.label.style;
        var offset = TextUtils.getTextBaselineOffset(styles);
        var i = 0;
        var length = labels.length;
        var label;
        var inTrellis = !!options.applyTrellisBehavior;
        var trellisBaseValueIndex = ret.getTrellisBaseValueIndex(labels);
        
        var textAnchor = null;
        var envManager = this.runtime().envManager();
        if (envManager) {
            textAnchor = envManager.textAnchor();
        }
  
        if (PositionUtil.isVertical(position)) {
            for (; i < length; ++i) {
                label = labels[i];
                label.textAnchor = textAnchor;
                label.x = TICK_SIZE + LABEL_OFFSET;
                if (position === Constants.POSITION.LEFT) {
                    label.x = (width - label.x - label.width);
                }
                label.y = scale.scale(label.value) - offset;
                label.y += (inTrellis && i === trellisBaseValueIndex) ?
                    -TRELLIS_VALUEAXIS_PADDING : label.height / 2;
            }
        } else {
            for (; i < length; ++i) {
                label = labels[i];
                label.textAnchor = textAnchor;
                label.x = scale.scale(label.value);
                if (isAdjustLastLabel && (i === length - 1)) {
                    //end
                    label.x -= label.width;
                } 
                else if (inTrellis && i === trellisBaseValueIndex) {
                    //start. Do not need to change it
                    label.x += TRELLIS_VALUEAXIS_PADDING;
                }
                else {
                    //middle
                    label.x -= label.width / 2;
                }
                if (position === Constants.POSITION.TOP) {
                    label.y = height - TICK_SIZE - LABEL_OFFSET - offset;
                } else {
                    label.y = TICK_SIZE + LABEL_OFFSET + label.height - offset;
                }
            }
        }

        var fill = effectManager.register({
            fillColor: styles.color
        });
        var fontSize = styles['fontSize'];
        var fontWeight = styles['fontWeight'];
        var fontFamily = styles['fontFamily'];
        var fontStyle = styles['fontStyle'];

        var labelSelections = selection.selectAll("." + AXIS_CLASS_NAMES.LABEL).data(labels);
        labelSelections.enter().append("g")
            .each(function(d, i) {
                this.setAttribute("class", labelClass);
                this.setAttribute("fill", fill);
                this.setAttribute("font-size", fontSize);
                this.setAttribute("font-weight", fontWeight);
                this.setAttribute("font-family", fontFamily);
                this.setAttribute("font-style", fontStyle);
                var text = SVG.create("text");
                this.appendChild(text);
            });
        labelSelections.exit().remove();

        labelSelections.each(function(d, i) {
            var text = this.querySelector('text');
            text.textContent = d.text;
            text.setAttribute("text-anchor", d.textAnchor);
            text.setAttribute("x", d.x);
            text.setAttribute("y", d.y);
        });
    };

    return ret;
});

define('sap/viz/chart/components/util/ClippathUtil',['sap/viz/framework/common/util/ObjectUtils', 'sap/viz/framework/common/util/Constants'], function Setup(
    ObjectUtils, Constants) {
    var className = Constants.CSS.CLASS.CLIPPATH;

    var ClipPathUtil = {
        drawClippath: function(selection, width, height, x, y, postfix) {
            var clazz = className;
            if (postfix){
                clazz = clazz + "-" + postfix;
            }
            if (width < 0) {
                width = 0;
            }
            if (height < 0) {
                height = 0;
            }
            if (selection.select('.' + clazz).node() === null) {
                var id = 'clip-path-' + ObjectUtils.guid();
                var clipath = selection.insert('clipPath', ':first-child')
                    .attr('class', clazz)
                    .attr('id', id);
                clipath.append('rect')
                    .attr('x', x)
                    .attr('y', y)
                    .attr('width', width)
                    .attr('height', height);
                return id;
            } else {
                selection.select('.' + clazz)
                    .select('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('x', x)
                    .attr('y', y);
                return selection.select('.' + clazz)
                    .attr('id');
            }
        }
    };

    return ClipPathUtil;

});
define('sap/viz/chart/components/axis/sub/ValueAxisBody',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/AxisComponent",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/util/BoundUtil",
    "sap/viz/chart/components/axis/renderer/ValueBodyRenderer",
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/util/ValueAxisUtils",
    "sap/viz/framework/common/format/UnitFormat",
    "sap/viz/chart/components/util/ClippathUtil",
    "sap/viz/chart/components/util/AxisBodyUtil",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/framework/common/format/FormatManager"
], function(
    oo,
    AxisComponent,
    Constants,
    NumberUtils,
    BoundUtil,
    ValueBodyRenderer,
    ValueScaleUtil,
    ObjectUtils,
    ValueAxisUtils,
    UnitFormat,
    ClippathUtil,
    AxisBodyUtil,
    TypeUtils,
    DataGraphics,
    ValueScale,
    FormatManager
) {

    var TICK_SIZE = 5;
    var LABEL_OFFSET = 6;
    var VALUEAXIS_DEFAULT_PADDING = 5;
    var VALUEAXIS_PADDING = 3;

    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;

    var ValueAxisBody = function(runtime, options) {
        ValueAxisBody.superclass.constructor.apply(this, arguments);
        this._isPercentageMode = false;
        this._tickGroupNode = null;
        this._labelGroupNode = null;
        this._offset = {
            x: 0,
            y: 0
        };
        this._valueAxes = options.valueAxes;
    };
    oo.extend(ValueAxisBody, AxisComponent);

    ValueAxisBody.prototype.setPercentageMode = function(_) {
        this._isPercentageMode = !!_;
        return this;
    };

    ValueAxisBody.prototype.update = function() {

        var props = this._properties;
        if (props.get('visible') && this._data) {
            var width = this._size.width;
            var height = this._size.height;
            var position = this._position;
            var scale = this._data;
            if (this._isSpaceEnough()) {
                var ticks = this._getTicksToRender();
                var ticksPosition = ValueScaleUtil.getTicksPosition(ticks, scale);
                var labels = this._getAllLabels(ticks, scale);
                var effectManager = this.runtime().effectManager();
                if (props.get('axisTick.visible')) {
                    this.drawTicks(this._tickGroupNode, ticksPosition, width, height, position, props,
                        effectManager);
                }
                if (props.get('label.visible') && labels.length) {
                    this.drawLabels(this._labelGroupNode, scale, labels, width, height, position, props,
                        this._options, effectManager, this._adjustLastLabel);
                }
            }

        }
    };

    ValueAxisBody.prototype.scroll = function(offset) {
        AxisBodyUtil.setTransform(this, offset);
        this._offset.x = offset.x;
        this._offset.y = offset.y;
    };

    ValueAxisBody.prototype.render = function(selection) {
        var props = this._properties;

        var width = this._size.width;
        var height = this._size.height;
        BoundUtil.drawBound(selection, width, height, null, true);
        selection.select("g." + AXIS_CLASS_NAMES.LINE_GROUP).remove();
        selection.select("g." + AXIS_CLASS_NAMES.TICK_GROUP).remove();
        selection.select("g." + AXIS_CLASS_NAMES.LABEL_GROUP).remove();

        if (this._data && props.get('visible')) {
            var position = this._position;

            var scale = this._data;
            var range = scale.getRange();

            var group = null;
            var effectMgr = this.runtime().effectManager();

            if (this._isSpaceEnough()) {
                var isVertical = this._isVertical();

                if (props.get('axisLine.visible')) {
                    group = selection.append("g").attr("class", AXIS_CLASS_NAMES.LINE_GROUP);
                    var line = this.drawLines(group, range, width, height, position, props, effectMgr, this._valueAxes);
                    DataGraphics.setData(group.node(), {
                        isVertical: isVertical,
                        isPercentage: this._isPercentageMode
                    });
                }
                var ticks = this._getTicksToRender();

                var ticksPosition = ValueScaleUtil.getTicksPosition(ticks, scale);
                var labels = this._getAllLabels(ticks, scale, false);

                var clippathid;
                if (props.get('axisTick.visible')) {
                    clippathid = ClippathUtil.drawClippath(selection, this._size.width + 2,
                        this._size.height + 2, -1, -1, "ticks");
                    group = selection.append("g").attr('clip-path', 'url(#' + clippathid + ')');
                    this._tickGroupNode = group.append("g").attr("class", AXIS_CLASS_NAMES.TICK_GROUP);
                    this.drawTicks(this._tickGroupNode, ticksPosition, width, height, position, props, effectMgr);
                }
                if (props.get('label.visible') && labels.length) {
                    var padding = this.getPadding(this._data);
                    var clipPathConfig = {
                        x: 0,
                        y: 0,
                        width: this._size.width,
                        height: this._size.height
                    };
                    var actualSize = this._getWidestLabel(labels) + LABEL_OFFSET + TICK_SIZE;
                    var delta = 0;
                    if (isVertical) {
                        clipPathConfig.y -= padding.start;
                        clipPathConfig.height += padding.start + padding.end;
                        delta = actualSize - clipPathConfig.width;
                        if(this._noReLayout && delta > 0){
                            clipPathConfig.width += delta;
                            clipPathConfig.x -= delta;
                        }
                    } else {
                        clipPathConfig.x -= padding.start;
                        clipPathConfig.width += padding.start + padding.end;
                        delta = actualSize - clipPathConfig.height;
                        if(this._noReLayout && delta > 0){
                            clipPathConfig.height += delta;
                            clipPathConfig.y -= delta;
                        }
                    }
                    clippathid = ClippathUtil.drawClippath(selection, clipPathConfig.width + 2,
                        clipPathConfig.height + 2, clipPathConfig.x - 1, clipPathConfig.y - 1,
                        "labels");
                    group = selection.append("g").attr('clip-path', 'url(#' + clippathid + ')');
                    this._labelGroupNode = group.append("g").attr("class", AXIS_CLASS_NAMES.LABEL_GROUP);
                    this.drawLabels(this._labelGroupNode, scale, labels, width, height, position, props,
                        this._options, effectMgr, this._adjustLastLabel);
                }
            }
        }
        if (this._offset.x || this._offset.y) {
            AxisBodyUtil.setTransform(this, this._offset);
        }
    };

    ValueAxisBody.prototype._getTicksToRender = function() {
        return ValueScaleUtil.getTicks(this._data);
    };

    ValueAxisBody.prototype.drawLines = ValueBodyRenderer.drawLines;
    ValueAxisBody.prototype.drawTicks = function(grp, ticksPos, w, h, pos, props, effectMgr) {
        return ValueBodyRenderer.drawTicks(grp, ticksPos, w, h, pos, props, effectMgr, false, this._valueAxes);
    };
    ValueAxisBody.prototype.drawLabels = ValueBodyRenderer.drawLabels;

    ValueAxisBody.prototype.setData = function(data, noReLayout){
        this._noReLayout = noReLayout;
        if(noReLayout){
            // In case this method is called multiple times, and this._data is already changed.
            this._fullScale = this._fullScale || this._data;
        }else{
            this._fullScale = null;
        }
        ValueAxisBody.superclass.setData.apply(this, arguments);
    };
    
    ValueAxisBody.prototype.paginationOptions = function() {
        var options;
        if(this._runtime && this._runtime._interaction && 
            this._runtime._interaction._service &&
            this._runtime._interaction._service.getDataModel) {
            var dataModel = this._runtime._interaction._service.getDataModel();
            
            options = dataModel && dataModel._rawData && dataModel._rawData._FlatTableD && 
                dataModel._rawData._FlatTableD._dataset && 
                dataModel._rawData._FlatTableD._dataset.metadata &&
                dataModel._rawData._FlatTableD._dataset.metadata.options;
        }
        return options;
    };
    
    ValueAxisBody.prototype.getMaximizedLabelWidth = function(existingLabelSize, scale) {
        //if maximizedDomain is set, we enlarge label width.
        var maximizedLabelWidth = existingLabelSize;
        var maxLabelWidth = 0;
        var domain = scale._domain;
        var maximizedDomain = scale.maximizedDomain;
        var paginationOptions = this.paginationOptions();
        
        if(paginationOptions && 
            maximizedDomain && domain && !scale.isFixed()) {
            //to check NaN
            if(!TypeUtils.isNumber(maximizedDomain[0])) {
                maximizedDomain[0] = 0;
            }
            if(!TypeUtils.isNumber(maximizedDomain[1])) {
                maximizedDomain[1] = 0;
            }
            
            //we have to get all labels according to maximizedDomain, and then use the 
            //widest formatted label.
            var tickHint = scale.getTickHint();
            var maxScale = new ValueScale(maximizedDomain, scale.getRange());

            //we get more ticks here, because we need to know the widest label in the future.
            //it cannot 100% guarantee, but it is a nice approximation. 
            var tickNum = tickHint * tickHint;
            maxScale.setTickHint(tickNum);
            
            //to avoid too many decimals
            ValueScaleUtil.perfectTicks(maxScale, tickNum);  
            var ticks = ValueScaleUtil.getTicks(maxScale);
            
            //we do not filter labels
            var labels = this._getAllLabels(ticks, maxScale, true, true);
            maxLabelWidth = this._getWidestLabel(labels);
        }
        if(maximizedLabelWidth < maxLabelWidth) {
            maximizedLabelWidth = maxLabelWidth;
        }
        return maximizedLabelWidth;
    };

    ValueAxisBody.prototype.getPreferredSize = function() {
        var pfdSize = {
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0,
            spacings: [{
                "interval": 0,
                "type": Constants.SPACING_TYPE.STEP
            }]
        };
        var props = this._properties;
        if (this._data && props.get('visible')) {
            var scale = this._noReLayout ? this._fullScale : this._data;
            var range = scale.getRange();
            var rangeLong = Math.abs(range[0] - range[1]);
            var spacing = LABEL_OFFSET + TICK_SIZE;
            var ticks = [],
                labels = [];
            if (props.get('label.visible')) {
                ticks = ValueScaleUtil.getTicks(scale);
                labels = this._getAllLabels(ticks, scale, true);
            }
            if (this._isVertical()) {
                var existingLabelSize = this._getWidestLabel(labels);
                spacing += existingLabelSize;
                pfdSize.minWidth = spacing;
                pfdSize.maxWidth = LABEL_OFFSET + TICK_SIZE + 
                    this.getMaximizedLabelWidth(existingLabelSize, scale);
                
                pfdSize.minHeight = rangeLong;
                pfdSize.maxHeight = rangeLong;
            } else {
                spacing += this._getHighestLabel(labels);
                pfdSize.minWidth = rangeLong;
                pfdSize.maxWidth = rangeLong;
                pfdSize.minHeight = spacing;
                pfdSize.maxHeight = spacing;
            }
            pfdSize.spacings = [{
                "interval": spacing,
                "type": Constants.SPACING_TYPE.STEP
            }];
        }
        var precisedSize = NumberUtils.preciseObject(pfdSize);
        this._updatePfdSize(precisedSize);
        return precisedSize;
    };

    ValueAxisBody.prototype.getAvailableLayersNumber = function() {
        var layers = 0;
        if (this._data && this._properties.get('visible') && this._isSpaceEnough()) {
            layers = 1;
        }
        return layers;
    };

    ValueAxisBody.prototype.formatTickValue = function(val, isPercentMode, properties, scale){
        var formatString = properties.get("label.formatString");
        var unitFormatType = properties.get("label.unitFormatType");
        var formattedVal = val;
        var element;
        var options = {
            decimalFormatString: 
            UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.VALUEAXIS)
        };
        if (isPercentMode) {
            if(formatString && (formatString.indexOf("u")  !== formatString.length -1)){
                formattedVal = UnitFormat.format(val,formatString, unitFormatType, options);
            }else{
                formattedVal = NumberUtils.preciseSimple(val * 100).toString();
            }
        } else {
            var dynamicScale = this._runtime.statusManager().get("dynamicScale");
            var dynamicFactor = dynamicScale && dynamicScale[this._name];

            if(formatString || unitFormatType){
                formattedVal = (dynamicFactor || UnitFormat).format(val,formatString, unitFormatType, options);
            }else{
                formattedVal = NumberUtils.preciseSimple(val).toString();
            }
        }
        return formattedVal;

    };

    ValueAxisBody.prototype.getPadding = function(scale) {
        var domain = scale.getDomain();
        var axisVisible = this._properties.get("visible");
        var style = this._properties.get("label.style");
        var labelVisible = this._properties.get("label.visible");
        if (!axisVisible || !labelVisible) {
            return {
                start: VALUEAXIS_DEFAULT_PADDING,
                end: VALUEAXIS_DEFAULT_PADDING
            };
        }

        var padding = {
            start: VALUEAXIS_PADDING,
            end: VALUEAXIS_PADDING
        };
        padding.start += this._getPadding(this.formatTickValue(
                    domain[0], this._isPercentageMode, this._properties, scale), style);
        
        if(this._isVertical() || !this._adjustLastLabel){
            padding.end += this._getPadding(this.formatTickValue(
                    domain[1], this._isPercentageMode, this._properties, scale), style);
        }
        return padding;
    };

    ValueAxisBody.prototype._getPadding = function(text, style) {
        var padding = 0;
        var size = this._measureTextSize(text, style);
        if (this._isVertical()) {
            padding = size.height / 2;
        } else { //if (this._isHorizontal(position)) { //TOP || BOTTOM
            padding = size.width / 2;
        }
        return padding;
    };

    ValueAxisBody.prototype._getAllLabels = function(ticks, scale, isLayOutStage, disableFilter) {
        var labels = [];
        var tickLength = ticks.length;
        for ( var i = 0; i < tickLength; i++) {
            var tickItem = {};
            var tick = ticks[i];
            tickItem.value = tick;
            tickItem.text = this.formatTickValue(tick , this._isPercentageMode, this._properties);

            labels.push(tickItem);
        }

        this._setLabelsPosition(labels, scale);
        
        var labelResult = labels;
        if(!disableFilter) {
            labelResult = this._filterLabels(labels, isLayOutStage);
        }
        return labelResult;
    };

    ValueAxisBody.prototype._setLabelsPosition = function(labels, scale) {
        var labelsLength = labels.length;
        var props = this._properties;
        var labelStyle = props.get('label.style');
        var inTrellis = this._options && this._options.applyTrellisBehavior;
        var trellisBaseValueIndex = inTrellis ? ValueBodyRenderer.getTrellisBaseValueIndex(
            labels) : -1;
        for (var i = 0; i < labelsLength; ++i) {
            var label = labels[i];
            if (!NumberUtils.isNoValue(label.value)) {
                var size = this._measureTextSize(label.text, labelStyle);
                var width = size.width,
                    height = size.height;
                label.width = width;
                label.height = height;
                var center = scale.scale(label.value);
                if (this._isVertical()) {
                    if (trellisBaseValueIndex === i) {
                        if (i === 0) {
                            label.start = center;
                            label.end = center + height;
                        } else {
                            label.start = center - height;
                            label.end = center;
                        }
                    } else {
                        label.start = center - height / 2;
                        label.end = center + height / 2;
                    }
                } else { //TOP || BOTTOM
                    if (trellisBaseValueIndex === i) {
                        if (i === 0) {
                            label.start = center;
                            label.end = center + width;
                        } else {
                            label.start = center - width;
                            label.end = center;
                        }
                    } else {
                        if((i === labelsLength - 1) && (this._isAdjustLastLabel(width))){
                            label.start = center - width;
                            label.end = center + width;
                        } else {
                            label.start = center - width / 2;
                            label.end = center + width / 2;
                        }
                    }
                }
            }
        }
    };

    ValueAxisBody.prototype._getOriginalDomainMinMaxSize = function(labels){
        var labelStyle = this._properties.get('label.style');
        return labels.map(function(label){
            var text = this.formatTickValue(label, this._isPercentageMode, this._properties, this._data);
            return this._measureTextSize(text, labelStyle);
        }.bind(this));

    };

    ValueAxisBody.prototype._isAdjustLastLabel = function(lastLabelWidth){
        var _isAdjustLastLabel = false;
        var statusManager = this._runtime.statusManager();
        var paddingInfo = statusManager.get('ChartPaddingInfo');
        if(paddingInfo){
            var paddingInfoRight = paddingInfo.paddingRight ? 
                    paddingInfo.paddingRight : paddingInfo.padding;
            if(!this._isVertical() && (lastLabelWidth / 2 > paddingInfoRight) &&
                ((this._properties.origin.get('legendGroup.computedVisibility') === false) ||
                    (statusManager.get('legendGroup.isHorizontal') !== false))) {
                //Horizontal value axis + hide legend / legend in the bottom/top
                _isAdjustLastLabel = true;
            }
        }
        this._adjustLastLabel = _isAdjustLastLabel;
        return _isAdjustLastLabel;
    };

    ValueAxisBody.prototype._getWidestLabel = function(labels) {
        var temp = 0;
        var length = labels.length;
        var size = [];
        var globalDomain = this._name === 'valueAxis2' ? this._runtime.statusManager().get('globalDomain2') :
                this._runtime.statusManager().get('globalDomain');
        if(globalDomain){
            size = this._getOriginalDomainMinMaxSize(globalDomain);
        }
        for (var i = 0; i < length; ++i) {
            if (temp < labels[i].width) {
                temp = labels[i].width;
            }
        }
        size.forEach(function(item){
            if (temp < item.width) {
                temp = item.width;
            }
        });
        return temp;
    };

    ValueAxisBody.prototype._getHighestLabel = function(labels) {
        var temp = 0;
        var length = labels.length;
        for (var i = 0; i < length; ++i) {
            if (temp < labels[i].height) {
                temp = labels[i].height;
            }
        }
        return temp;
    };

    //Copying original axis' code here
    ValueAxisBody.prototype._filterLabels = function(allTicksLabels, isLayOutStage) {
        var needAdjustScale = this._runtime.propertyManager().get("plotArea.adjustScale");
        var labelsToDraw = [];
        var oldDomain;
        var newDomain = this._data.getDomain();
        var isRemoveNegativeValue = false;

        if (needAdjustScale && !isLayOutStage && this._data.getDomainChanged()) {
            var statusMgr = this.runtime().statusManager();
            var setAdjustScaleFlag = function (oldDomain, newDomain) {
                if (oldDomain && newDomain) {
                    if (oldDomain[0] >= 0 && newDomain[0] < 0) {
                        isRemoveNegativeValue = true;
                    }
                }
            };
            if (this.getName() === "valueAxis") {
                oldDomain = statusMgr.get("valueAxisScaleDomain");
                setAdjustScaleFlag(oldDomain, newDomain);
            } else if (this.getName() === "valueAxis2") {
                oldDomain = statusMgr.get("valueAxis2ScaleDomain");
                setAdjustScaleFlag(oldDomain, newDomain);        
            }            
        }

        if (allTicksLabels.length > 0) {
            //split allTicksLabels if it is required.
            var ticksLength = allTicksLabels.length;
            if ((allTicksLabels[0].value < 0 || allTicksLabels[ticksLength - 1].value < 0) &&
                (allTicksLabels[0].value > 0 || allTicksLabels[ticksLength - 1].value > 0)) {
                var negativeArray = [];
                var positiveArray = [];
                for (var i = 0; i < allTicksLabels.length; i++) {
                    if (allTicksLabels[i].value <= 0) {
                        negativeArray.push(allTicksLabels[i]);
                    }
                    if (allTicksLabels[i].value >= 0) {
                        positiveArray.push(allTicksLabels[i]);
                    }
                }
                var head;
                var nal = negativeArray.length;
                if (negativeArray[0].value <= negativeArray[nal - 1].value) {
                    head = negativeArray[0];
                } else {
                    head = negativeArray[nal - 1];
                }
                var tail;
                var pal = positiveArray.length;
                if (positiveArray[0].value <= positiveArray[pal - 1].value) {
                    tail = positiveArray[pal - 1];
                } else {
                    tail = positiveArray[0];
                }
                negativeArray = ValueAxisUtils.calculateLabelsToDrawHelper(negativeArray, false);
                positiveArray = ValueAxisUtils.calculateLabelsToDrawHelper(positiveArray, false);
                if (negativeArray[0].value > negativeArray[negativeArray.length - 1].value) {
                    negativeArray.reverse();
                }
                if (positiveArray[0].value > positiveArray[positiveArray.length - 1].value) {
                    positiveArray.reverse();
                }
                if (negativeArray[negativeArray.length - 1].value === 0 && positiveArray[0].value ===
                    0) {
                    negativeArray.pop();
                }
                var labelsToDrawTemp = negativeArray.concat(positiveArray);
                if (head.value !== labelsToDrawTemp[0].value) {
                    labelsToDrawTemp.splice(0, 0, head);
                }
                if (tail.value !== labelsToDrawTemp[labelsToDrawTemp.length - 1].value) {
                    labelsToDrawTemp.push(tail);
                }
                if (labelsToDrawTemp[0].start > labelsToDrawTemp[labelsToDrawTemp.length - 1].start) {
                    labelsToDrawTemp.reverse();
                }
                labelsToDraw = ValueAxisUtils.calculateLabelsToDrawHelper(labelsToDrawTemp, isRemoveNegativeValue);
            } else {
                labelsToDraw = ValueAxisUtils.calculateLabelsToDrawHelper(allTicksLabels, false);
            }
            //When the height/width of vertical/horizontal axis is small that can only hold one axis label,
            //the label should be hidden.
            if (labelsToDraw.length <= 1 || (labelsToDraw.length === 2 && ValueAxisUtils.isOverLapped(
                labelsToDraw[0],
                labelsToDraw[1]))) {
                labelsToDraw = [];
            }
        }

        var removeNegativeLabels = function (oldDomain, newDomain, labels, isAscending) {
            if (oldDomain && newDomain) {
                var labelsLen = labels.length;
                var i = isAscending ? 0 : labelsLen - 1;
                for (; isAscending ? i < labels.length : i > 0; isAscending ? i++ : i--) {
                    if (labels[i].value < 0) {
                        labels[i].text = "";
                    } else {
                        break;
                    }
                }
            }
        };

        if (isRemoveNegativeValue) {
            if (this.getName() === "valueAxis") {
                removeNegativeLabels(oldDomain, newDomain, labelsToDraw,
                    this._position === "left"? false : true);
            } else if (this.getName() === "valueAxis2") {
                removeNegativeLabels(oldDomain, newDomain, labelsToDraw, false);       
            }                
        }

        return labelsToDraw;
    };

    ValueAxisBody.prototype.destroy = function() {
        ValueAxisBody.superclass.destroy.call(this);
        this._isPercentageMode = null;
        this._tickGroupNode = null;
        this._labelGroupNode = null;
    };

    return ValueAxisBody;
});

define('sap/viz/chart/components/axis/ValueAxis',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/AxisContainer",
    "sap/viz/chart/components/axis/sub/ValueAxisBody",
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/framework/common/util/Constants"
], function(oo, AxisContainer, ValueAxisBody, ValueScale, Constants) {

    var ValueAxis = function(runtime, options) {
        ValueAxis.superclass.constructor.apply(this, arguments);

        this.setChild("axisBody", new ValueAxisBody(runtime, options), {
            order: 1,
            priority: 2,
            offset: 0
        });
        var that = this;
        var autoMin, autoMax, min, max, scaleName, fixedRange;
        if (this._name === 'valueAxis') {
            scaleName = 'primaryScale';
        }
        if (this._name === 'valueAxis2') {
            scaleName = 'secondaryScale';
        }
        autoMin = 'plotArea.' + scaleName + '.autoMinValue';
        autoMax = 'plotArea.' + scaleName + '.autoMaxValue';
        min = 'plotArea.' + scaleName + '.minValue';
        max = 'plotArea.' + scaleName + '.maxValue';
        fixedRange = 'plotArea.' + scaleName + '.fixedRange';

        this._properties.origin.add(autoMin, {
            defaultValue : [],
            serializable: false,
            get : function() {
                return (that._scale ? (that._scale.getAutoDomain() ? that._scale.getAutoDomain()[0] : 
                    that._scale.getDomain()[0]) : undefined);
            }
        });
        this._properties.origin.add(autoMax, {
            defaultValue : [],
            serializable: false,
            get : function() {
                return (that._scale ? (that._scale.getAutoDomain() ? that._scale.getAutoDomain()[1] : 
                    that._scale.getDomain()[1]) : undefined);
            }
        });
        
        this._properties.origin.add(min, {
            defaultValue : [],
            serializable: false,
            get : function() {
                if (that._scale && that._scale.getDomainFixed()[0]) {
                    return that._scale.getDomain()[0];
                }
                return null;
            }
        });
        this._properties.origin.add(max, {
            defaultValue : [],
            serializable: false,
            get : function() {
                if (that._scale && that._scale.getDomainFixed()[1]) {
                    return that._scale.getDomain()[1];
                }
                return null;
            }
        });
        this._properties.origin.add(fixedRange, {
            defaultValue : [],
            serializable: false,
            get : function() {
                if (that._scale && that._scale.getDomainFixed()) {
                    var domainFixed = that._scale.getDomainFixed();
                    var fixedMin = domainFixed[0];
                    var fixedMax = domainFixed[1];
                    if (!fixedMin && !fixedMax) {
                        return false;
                    }
                    return true;
                }
                return false;
            }
        });
    };

    oo.extend(ValueAxis, AxisContainer);
    ValueAxis.prototype.setPercentageMode = function(_) {
        this.getChild("axisBody").module.setPercentageMode(!!_);
        return this;
    };

    ValueAxis.prototype.getMaxZoomRatio = function(){
        var ratio = this._scale.getTickHint();
        if (ratio >= 1){
            return ratio;
        } else {
            return Number.MAX_VALUE;
        }
    };

    ValueAxis.prototype.setScale = function(data) {
        if (data.scale) {
            this._scale = new ValueScale(data.scale.getDomain(), [0, 1], 
                    data.scale.getDomainFixed(), {maximizedDomain:
                    data.scale.maximizedDomain});
            this._scale.setDomainChanged(data.scale.getDomainChanged());
            this._scale.setZeroAdjusted(data.scale.getZeroAdjusted());

            var allowDecimals = true;
            if (this._properties.has("label.allowDecimals")){
                allowDecimals = this._properties.get("label.allowDecimals");
            }
            this._scale.setAllowDecimals(allowDecimals);
        }
    };
    ValueAxis.prototype.setData = function(data, noReLayout) {
        this._noReLayout = noReLayout;
        ValueAxis.superclass.setData.apply(this, arguments);
        this.setScale(data);
        if(data.scale){
            this._scale.setAutoDomain(data.scale.getAutoDomain());
            this._scale.setTickHint(data.tickHint);
        }

    };

    ValueAxis.prototype.getPadding = function(scale){
        var axisBody = this.getChild("axisBody");
        if(!axisBody || !scale){
            return {
                start: 0,
                end:0
            };
        }
        return axisBody.module.getPadding(scale);
    };

    ValueAxis.prototype._updateData = function(info) {
        ValueAxis.superclass._updateData.apply(this, arguments);
        if(this._scale) {
            if (this._isVertical()) {
                var valueAxisDir = this._properties.get("layout.direction");
                if(valueAxisDir === "topDown") {
                    this._scale.setRange([0, info.height]);
                }else {
                    this._scale.setRange([info.height, 0]);
                }
            } else {
                this._scale.setRange([0, info.width]);
            }
        }
        // Tell axisBody not to re-layout itself using updated scale
        this.getChild("axisBody").module.setData(this._scale, this._noReLayout);
    };

    /*
     * BCP:1680344776, the title of valueAxis should add percentage label by default for percentage chart.
     */
    ValueAxis.prototype._setPercentageTitle = function(titleText) {
        var chartType;

        if (this._runtime && this._runtime._interaction && this._runtime._interaction._chartType) {
            chartType = this._runtime._interaction._chartType;
        }

        if (chartType && (chartType.indexOf("100") > -1)) {
            titleText = titleText + Constants.CSS.CLASS.AXIS.LABEL_PERCENTAGE;
        }
        return titleText;
    };


    ValueAxis.prototype._constructTitle = function(header, titleItems) {
        var titleText = header.map(function(o) {
            return o.name || o.id;
        }).join(" & ");
        
        titleText = this._setPercentageTitle(titleText);
        var itemObj = {};
        itemObj.isHidden = false;
        itemObj.text = titleText;

        titleItems.push(itemObj);
        return titleText;
    };

    ValueAxis.prototype.destroy = function() {
        ValueAxis.superclass.destroy.call(this);
        this._scale = null;
    };

    ValueAxis.prototype.supportFixedLayout = true;
    
    return ValueAxis;
});

define('sap/viz/chart/components/axis/renderer/OrdinalCommonBodyRenderer',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/axis/renderer/ValueBodyRenderer",
    "sap/viz/chart/components/axis/renderer/DefaultCategoryLabelRenderer",
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/common/util/PositionUtil",
    "sap/viz/framework/common/util/RuleUtil",
    "sap/viz/chart/components/util/StyleUtils",
    "sap/viz/framework/common/util/GeometryUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/ObjectUtils"
], function(
    Constants,
    ArrayUtils,
    NumberUtils,
    TextUtils,
    TypeUtils,
    ValueBodyRenderer,
    DefaultCategoryLabelRenderer,
    SVG,
    PositionUtils,
    RuleUtil,
    StyleUtils,
    GeometryUtils,
    DataGraphics,
    ObjectUtils
) {

    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;
    var CATEGORY_LABEL_ID = "categorylabel-id";
    var TICK_SIZE = 5;
    var LABEL_OFFSET = 6;
    var VERTICAL_ANGLE = 90;

    var LONG_TICK_STROKE = "#B3B3B3";
    var TICK_LABEL_SPACING = TICK_SIZE + LABEL_OFFSET - 1;

    function getLayersBand(layers, depth) {
        var ret = 0;
        for (var i = 0; i < depth; ++i) {
            ret += layers[i].layerBand;
        }
        return ret;
    }

    var calculateSizeLimit = function(config) {

        //the function try to calculate the actual text length as sizeLimit
        var sizeLimit = -1;
        if (config.position === Constants.POSITION.TOP || config.position === Constants.POSITION.BOTTOM) {
            if (config.rotated) {
                sizeLimit = config.size.height;

                if(config.rotationAngle !== VERTICAL_ANGLE) {
                    var style = config.styles;
                    var textHeight = TextUtils.canvasMeasure(config.text, style.fontSize, style.fontWeight,
                                    style.fontFamily).height;
                    textHeight = NumberUtils.preciseSimple(textHeight);

                    var textLengthOffset = (textHeight / Math.tan(config.rotationAngle * Math.PI/180));

                    sizeLimit = sizeLimit/(Math.sin(config.rotationAngle * Math.PI/180));
                    sizeLimit -= textLengthOffset;

                    var labelLocation = config.cellWidth/2 + config.cellStart + 
                        (config.additionalWidth ? config.additionalWidth : 0);
                    var labelSize = labelLocation/(Math.cos(config.rotationAngle * Math.PI/180));

                    if(sizeLimit > labelSize) {
                        sizeLimit = labelSize;
                    }

                    sizeLimit += TICK_LABEL_SPACING;
                }
            }
            else {
                //horizontal labels does not need spacing, because they may
                //need to be truncated
                sizeLimit = config.size.width + TICK_LABEL_SPACING;
            }
        } else {
            sizeLimit = config.size.width;
        }

        if (sizeLimit >= 0) {
            sizeLimit -= TICK_LABEL_SPACING;
        }

        return sizeLimit;
    };

    var rendererFunc = function() {
        this.defaultCategoryLabelRenderer = DefaultCategoryLabelRenderer;
        this._noEllipsis = false;
    };

    rendererFunc.prototype.drawLines = function(selection, layers, range, width, height, position, props,
        effectManager) {
        ValueBodyRenderer.drawLines(selection, range, width, height, position, props,
            effectManager);
    };

    function getTicksLength(layers, ticks, fixedShortTickSize) {
        var layersNumber = layers.length;
        // Assume layers.length === ticks.length
        var ticksNumber = ticks[layersNumber - 1].length;
        var reversedLayers = layers.slice().reverse();
        var ticksLength = new Array(ticksNumber);

        for (var i = 0; i < ticksNumber; ++i) {
            var depth = layersNumber - 1;
            var tick = ticks[depth][i];
            // No need to check tick in the lowest layer again
            while (depth > 0 && ticks[depth - 1].indexOf(tick) > -1) {
                depth--;
            }
            depth = layersNumber - depth;
            var isLongTick = depth > 1;
            var tickLength = !fixedShortTickSize || isLongTick ? getLayersBand(reversedLayers, depth) : TICK_SIZE;

            ticksLength[i] = {
                length: tickLength,
                isLongTick: isLongTick
            };
        }
        return ticksLength;
    }

    rendererFunc.prototype.drawTicks = function(selection, layers, ticks, bound, 
            position, props, effectManager, bForce) {
        if (!layers.length || !ticks.length){
            return;
        }
        var width = bound.width;
        var height = bound.height;
        var shortTickVisible = props.axisTick.shortTickVisible;
        var visible = props.axisTick.visible;
        var filteredTicks = lazyRenderingTicks(ticks, bound, position);

        var layersLength = layers.length;

        //shortTickVisible visible    Behavior
        //null             True       Display all ticks.
        //null             False      Do not display any ticks.
        //True             True       Display all ticks.
        //True             False      Display short ticks. Do not display long ticks.
        //False            True       Display long ticks. Do not display short ticks.
        //False            False      Do not display any ticks.
        var ticksLength = getTicksLength(layers, filteredTicks, true);
        var allTicksToDraw;
        if (layersLength === 1) {
            allTicksToDraw = filteredTicks[0];
        }
        else {
            allTicksToDraw = filteredTicks[filteredTicks.length - 1];
        }
        //we must filter some ticks in allTicksToDraw and ticksLength
        //if props.axisTick.shortTickVisible is set
        if (((shortTickVisible === false) && visible) ||
            ((shortTickVisible === true) && !visible)) {
            var i;
            for (i = (ticksLength.length - 1) ; i >= 0; i--) {
                if ((visible && !ticksLength[i].isLongTick) ||
                    (!visible && ticksLength[i].isLongTick)) {
                    allTicksToDraw.splice(i, 1);
                    ticksLength.splice(i, 1);
                }
            }
        }

        if (layersLength === 1) {
            if(shortTickVisible || visible) {
                // If lazy rendering is taking effect, do not "smartly" hide any tick.
                var force = bForce || this._isForceDrawTicks(filteredTicks, ticks);
                ValueBodyRenderer.drawTicks(selection, allTicksToDraw, width, height, position, props,
                    effectManager, force);
            }
        } else if (layersLength > 1) {
            this._drawTicks(selection, allTicksToDraw,
                    width, height, position, ticksLength, props, effectManager, props.axisLine.size);
        }

    };

    rendererFunc.prototype._isForceDrawTicks = function(filteredTicks, ticks){
        return filteredTicks[0].length < ticks[0].length;
    };

    rendererFunc.prototype._forceLabelRectRotation = function(){
        return false;
    };

    rendererFunc.prototype._drawTicks = function(selection, ticksToDraw, width, height, position, ticksLength,
        props, effectManager, strokeWidth) {
        var commonClassPrefix = AXIS_CLASS_NAMES.PERIMETER;
        var tickClass = commonClassPrefix + " " + AXIS_CLASS_NAMES.TICK;
        var longTickClass = commonClassPrefix + " " + AXIS_CLASS_NAMES.LONGTICK;
        var stroke = effectManager.register({
            fillColor: props.color
        });

        var i = 0,
            length = ticksToDraw.length;
        var x1s = [],
            y1s = [],
            x2s = [],
            y2s = [];
        switch (position) {
            case Constants.POSITION.LEFT:
                for (; i < length; ++i) {
                    x1s[i] = width;
                    y1s[i] = ticksToDraw[i];
                    x2s[i] = width - ticksLength[i].length;
                    y2s[i] = ticksToDraw[i];
                }
                break;
            case Constants.POSITION.RIGHT:
                for (; i < length; ++i) {
                    x1s[i] = 0;
                    y1s[i] = ticksToDraw[i];
                    x2s[i] = ticksLength[i].length;
                    y2s[i] = ticksToDraw[i];
                }
                break;
            case Constants.POSITION.TOP:
                for (; i < length; ++i) {
                    x1s[i] = ticksToDraw[i];
                    y1s[i] = height;
                    x2s[i] = ticksToDraw[i];
                    y2s[i] = height - ticksLength[i].length;
                }
                break;
            case Constants.POSITION.BOTTOM:
                for (; i < length; ++i) {
                    x1s[i] = ticksToDraw[i];
                    y1s[i] = 0;
                    x2s[i] = ticksToDraw[i];
                    y2s[i] = ticksLength[i].length;
                }
                break;
        }
        var tickSelections = selection.selectAll("." + commonClassPrefix).data(ticksToDraw);
        tickSelections.enter().append("line")
            .each(function(d, i) {
                var className = tickClass;
                if (ticksLength[i].isLongTick) {
                    className = longTickClass;
                }
                this.setAttribute("class", className);
                this.setAttribute("stroke", stroke);
                this.setAttribute("stroke-width", strokeWidth);
                this.setAttribute("shape-rendering", "crispEdges");
            });
        tickSelections.exit().remove();
        tickSelections.each(function(d, i) {
            this.setAttribute("x1", NumberUtils.preciseSimple(x1s[i]));
            this.setAttribute("y1", NumberUtils.preciseSimple(y1s[i]));
            this.setAttribute("x2", NumberUtils.preciseSimple(x2s[i]));
            this.setAttribute("y2", NumberUtils.preciseSimple(y2s[i]));
        });
    };

    rendererFunc.prototype.drawGridTicks = function(selection, layers, ticks, width, height, position, props,
        effectManager) {
        var layersLength = layers.length;
        if (layersLength === 0) {
            return;
        }

        var ticksLength = getTicksLength(layers, ticks);

        this._drawTicks(selection, ticks[ticks.length - 1],
                width, height, position, ticksLength, props, effectManager, props.size);
    };

    rendererFunc.prototype.drawLabels = function(selection, layers, bound, position, props, effectManager,
        needRowAxisOffset, labelOffset, additionalWidth, rebuildUI) {
        var layersReversed = layers.slice().reverse();
        var layersLength = layersReversed.length;
        var baseline = 0;
        var i = 0;

        for (; i < layersLength; ++i) {
            baseline = getLayersBand(layersReversed, i);
            this.drawSingleLayerLabels(selection, layersReversed[i], bound,
                position, props, baseline, i, layersReversed, effectManager,
                needRowAxisOffset, labelOffset, additionalWidth, rebuildUI);
        }
        //remove labels out of layer limitation
        while(selection.select(".index_"+i).node()){
            selection.selectAll(".index_"+i).remove();
            ++i;
        }
    };

    var addRectMargin = function(rect, rotationAngle, xOffset, yOffset) {
        var MARGIN_SIZE = 2;
        var x = parseFloat(rect.getAttribute("x"));
        var y = parseFloat(rect.getAttribute("y"));
        var width = parseFloat(rect.getAttribute("width"));
        var height = parseFloat(rect.getAttribute("height"));
        //add margin
        rect.setAttribute("width", width + 2 * MARGIN_SIZE);
        rect.setAttribute("height", height + 2 * MARGIN_SIZE);
        
        //adjust x and y
        var realXOffset = xOffset;
        var realYOffset = yOffset;

        var baseYOffset = Math.sqrt(2) * MARGIN_SIZE;
        var refAngle;
        if(rotationAngle === VERTICAL_ANGLE/2) {
            realYOffset = yOffset - baseYOffset;
        }
        else if(rotationAngle < VERTICAL_ANGLE/2) {
            refAngle = 2*VERTICAL_ANGLE - (VERTICAL_ANGLE-rotationAngle) - (VERTICAL_ANGLE/2);
            realYOffset = yOffset - baseYOffset * Math.sin(refAngle * Math.PI/180);
            realXOffset = xOffset + baseYOffset * Math.cos(refAngle * Math.PI/180);
        }
        else {
            refAngle = (VERTICAL_ANGLE-rotationAngle) + (VERTICAL_ANGLE/2);
            realYOffset = yOffset - baseYOffset * Math.sin(refAngle * Math.PI/180);
            realXOffset = xOffset - baseYOffset * Math.cos(refAngle * Math.PI/180);
        }

        return "translate(" + realXOffset + "," + realYOffset + ")";
    };

    rendererFunc.prototype._setLabelRectSize = function(rectNode, labelSize, textSize) {
        if(rectNode && labelSize){
            rectNode.setAttribute("width", labelSize.width);
            rectNode.setAttribute("height", labelSize.height);
        }
    };

    function getVisibleRange(bound, position) {
        var size = bound.windowSize || bound;
        var x = 0,
            y = 0;
        if (bound.positionInWindow) {
            x = bound.positionInWindow.x;
            y = bound.positionInWindow.y;
        }
        var width = size.width,
            height = size.height,
            offset = bound.offset;
        var min, max;
        switch (position) {
            case Constants.POSITION.LEFT:
            case Constants.POSITION.RIGHT:
                min = -offset.y - y;
                max = height + min;
                break;
            default:
                min = -offset.x - x;
                max = width + min;
                break;
        }
        //To fix stupid float precision problem on iOS.
        return {
            min: NumberUtils.preciseSimple(min) - 0.0001,
            max: NumberUtils.preciseSimple(max) + 0.0001
        };
    }

    function lazyRenderingTicks(ticks, bound, position) {
        var range = getVisibleRange(bound, position);
        var result = [];
        for (var i = 0, len = ticks.length; i < len; i++) {
            var items = ticks[i];
            var minIdx = ArrayUtils.bisearch(items, range.min);
            var maxIdx = ArrayUtils.bisearch(items, range.max);
            result.push(items.slice(minIdx, maxIdx + 1));
        }
        return result;
    }

    function lazyRenderingLabels(labels, bound, position, isOnlySingleLayer, rotated, isVertical) {
        var range = getVisibleRange(bound, position);
        var result = [];
        for (var i = 0, len = labels.length; i < len; i++) {
            var label = labels[i];

            //when only one layer and the user scrolls and passes the middle of cell
            //the we make the label disappear 
            var passMiddle = (rotated && !isVertical && isOnlySingleLayer && label.middle < range.min);

            if (!passMiddle && label.cellStart <= range.max && label.cellEnd >= range.min) {
                result.push(label);
            }
        }
        return result;
    }
    var labelClass = AXIS_CLASS_NAMES.LABEL + " " + AXIS_CLASS_NAMES.MORPHABLE_LABEL +
            " " + AXIS_CLASS_NAMES.LABEL_BACKWORD + " " + AXIS_CLASS_NAMES.LABEL_SELECTION;

    rendererFunc.prototype._createLabelStyle = function(effectManager, labelProps) {
        this._propStyle = labelProps.style;
        this._propParentStyle = StyleUtils.buildParentStyle(labelProps.style, 
                labelProps.parentStyle);
    };
    
    rendererFunc.prototype._getLabelStyle = function(data, isParentLayer) {
        var labelStyle = ObjectUtils.clone(this._propStyle);
        if(isParentLayer) {
            labelStyle = ObjectUtils.clone(this._propParentStyle);
        }
        return labelStyle;
    };

    var MIN_LABEL_CHAR_NUM = 3;
    var ELLIPSIS_NUM = 3;
    var MIN_SPACING = 24;
    
    rendererFunc.prototype.drawSingleLayerLabels = function(selection, layer, bound, position, props,
        baseline, index, layers, effectManager, needRowAxisOffset, labelOffset, additionalWidth, rebuildUI) {
        var clid = CATEGORY_LABEL_ID;
        var width = bound.width;
        var realWidth = bound.realSize && bound.realSize.width;
        var height = bound.height;
        var labelRenderer = props.labelRenderer;
        var isCustomizedRenderer = true;
        if (!TypeUtils.isFunction(labelRenderer)) {
            labelRenderer = this.defaultCategoryLabelRenderer;
            isCustomizedRenderer = false;
        }

        var keepFirstAndLastLabel = layer.onlyKeepFirstAndLast;

        this._createLabelStyle(effectManager, props.label);
        
        //we pass "null" and data, 
        //because all labels in the same level will have the same color.
        var labelStyle = this._getLabelStyle(null, layer.isParentLayer);
        var fill = effectManager.register({
            fillColor: labelStyle.color
        }); 
        
        var labels = [], 
            rotated = layer.rotated, 
            isVertical = PositionUtils.isVertical(position);
        var i, len, offset;
        for(i = 0, len = layer.cells.length; i < len; ++i){
            var cell = layer.cells[i];
            if(cell.isVisible){
                cell._cellIndex = i;
                labels.push(cell);
                if(rebuildUI !== false) {
                    cell.cellStart = NumberUtils.round(cell.cellStart);
                    cell.cellEnd = NumberUtils.round(cell.cellEnd);
                    cell.cellWidth = NumberUtils.round(cell.cellWidth);
                    cell.end = NumberUtils.round(cell.end);
                    cell.middle = NumberUtils.round(cell.middle);
                    cell.start = NumberUtils.round(cell.start);
                } 
            }
        }
        offset = layers.length === 1 ? LABEL_OFFSET : TICK_SIZE;
        this._setLabelParameters(labels, position, baseline, width, height, offset, layer);

        var sizeLimitForFirstLabel = false;
        if(keepFirstAndLastLabel){

            labels.forEach(function(e, i){
                e.textBiggerThanCell = e._preferredSize.textSize &&
                                       e._preferredSize.textSize.width > e.cellWidth;
                if(e.textBiggerThanCell){
                    //assumption labels.length is 1 or 2
                    e.alignMode = e.isFirstLabel? "ALIGIN_LEFT_MOST": "ALIGIN_RIGHT_MOST";
                }
            });

            var minText, minTextSize;
            if(labels.length === 2 && (labels[0].textBiggerThanCell || labels[1].textBiggerThanCell)){
                var ts1 = labels[0]._preferredSize.textSize.width;
                var ts2 = labels[1]._preferredSize.textSize.width;
                var firstLabelEnd = labels[0].textBiggerThanCell? ts1 : (labels[0].middle + ts1/2);
                var lastLabelBegin = labels[1].textBiggerThanCell? (realWidth - ts2) : (labels[1].middle - ts2/2);
                var firstLabelLimit = lastLabelBegin - MIN_SPACING;
                
                if(firstLabelEnd > firstLabelLimit){
                    if(labels[0].text.length > MIN_LABEL_CHAR_NUM) {
                        minText = labels[0].text.slice(0, MIN_LABEL_CHAR_NUM) + "...";
                        minTextSize = measureTextLength(minText, labelStyle);
                        var minFirstLabelEnd = labels[0].textBiggerThanCell? 
                                                    minTextSize : (labels[0].middle + minTextSize/2);
                        if(minTextSize > firstLabelLimit){
                            labels = [labels[1]];
                        }else{
                            if(labels[0].textBiggerThanCell){
                                sizeLimitForFirstLabel = firstLabelLimit;  
                            }else{
                                sizeLimitForFirstLabel = Math.max((firstLabelLimit - labels[0].middle)*2, 0);  
                            }  
                            if(sizeLimitForFirstLabel < minTextSize){
                                labels = [labels[1]];    
                            }  
                        }
                    }else{
                        labels = [labels[1]];
                    }
                }    
            } 

            if(labels.length === 1 && labels[0].textBiggerThanCell && 
                labels[0]._preferredSize.textSize.width > realWidth){
                if(labels[0].text.length > MIN_LABEL_CHAR_NUM) {
                    minText = labels[0].text.slice(0, MIN_LABEL_CHAR_NUM) + "...";
                    minTextSize = measureTextLength(minText, labelStyle);
                    if(minTextSize > realWidth){
                        labels = [];
                    }
                }else{
                    labels = [];
                }
            }
        }else{
            labels = lazyRenderingLabels(labels, bound, position, (layers.length === 1), rotated, isVertical);
        }

        var cellSizeField = isVertical ? "cellHeight" : "cellWidth";

        var config = {
            cellStart: null,
            cellWidth: null,
            size: null,
            text: null,
            ctx: null,
            childCells: null,
            position: position,
            rotated: rotated,
            rotationAngle: layer.rotationAngle,
            styles: null,
            needRowAxisOffset: needRowAxisOffset,
            labelOffset: labelOffset,
            additionalWidth: additionalWidth,
            reverseDots: props.reverseDots,
            wrap: layer.wrap,
            noEllipsis: !!this._noEllipsis
        };

        var me = this;

        var labelSelections = selection.selectAll(".index_" + index).data(labels);
        //add new g for new data
        labelSelections.enter().append("g").each(function(d, i) {
            var style = me._getLabelStyle(d, layer.isParentLayer);
            this.setAttribute("class", labelClass + " index_" + index);
            this.setAttribute("fill", fill);
            this.setAttribute("font-size", style.fontSize);
            this.setAttribute("font-weight", style.fontWeight);
            this.setAttribute("font-family", style.fontFamily);
            this.setAttribute("font-style", style.fontStyle);
        });
        //remove data that no longer needed
        labelSelections.exit().remove();
        
        var forceLabelRotation = this._forceLabelRectRotation();
       
        labelSelections.each(function(d, i) {
            var propStyle = me._getLabelStyle(d, layer.isParentLayer);
            var fontSize = propStyle.fontSize;
            var fontWeight = propStyle.fontWeight;
            var fontFamily = propStyle.fontFamily;
            var fontStyle = propStyle.fontStyle;
            
            config.styles = propStyle;
            
            this.setAttribute(clid, d.id);
            this.setAttribute("transform", "translate(" + d.x + "," + d.y + ")");
            var psize = d._preferredSize;
            var refSize = Math.max(d[cellSizeField], psize[cellSizeField]);

            config.size = isVertical ? {
                width: d.cellWidth,
                height: refSize
            } : {
                width: refSize,
                height: d.cellHeight
            };
            config.cellStart = d.cellStart;
            config.cellWidth = d.cellWidth;
            config.text = d.text;
            config.ctx = d.ctx;
            //we just use children, not all leaf nodes. (getLeafChildCells)
            var hasVisibleSubLayer = false;
            if(layers[index - 1] && layers[index - 1].isVisible) {
                hasVisibleSubLayer = true;
            }
            
            if(layers.length > 1 && hasVisibleSubLayer) {
                config.childCells = layers[index].cells[d._cellIndex].children;
            }
            config.unfilteredFirstChild = d.children && d.children[0];
            //here we need to calculate the real label length
            var sizeLimit ;

            if(keepFirstAndLastLabel){
                if(d.isFirstLabel && sizeLimitForFirstLabel !== false){
                    sizeLimit = sizeLimitForFirstLabel;
                }else{
                    sizeLimit = realWidth;
                }
            }else{
                sizeLimit = calculateSizeLimit(config);
            }

            config.sizeLimit = sizeLimit;
            config.cell = d;
            config.labelAlignment = "top";

            if(props.label.alignment === "center") {
                config.labelAlignment = props.label.alignment;
            }

            var fullTextSize = measureTextLength(d.text, propStyle);
            var MIN_TEXT_WIDTH = 0;
            if(d.text.length > 1) {
                MIN_TEXT_WIDTH = measureTextLength(d.text[0] + "...", propStyle);
            }

            var rect = null;
            if(sizeLimit >= Math.min(MIN_TEXT_WIDTH, fullTextSize)) {
                //the axis can display the label text. we draw the rect.
                rect = this.querySelector("." + AXIS_CLASS_NAMES.BACKGROUND_RECT);
                if (!rect) {
                    rect = SVG.create("rect");
                    rect.setAttribute("class", AXIS_CLASS_NAMES.BACKGROUND_RECT);
                    rect.setAttribute("fill", "transparent");
                    this.appendChild(rect);
                }else if(keepFirstAndLastLabel){
                    rect.setAttribute("fill", "transparent");  
                }

                rect.setAttribute("x", d.rectX);
                rect.setAttribute("y", d.rectY);
            }

            if(d.alignMode){
                config.alignMode = d.alignMode;
            }else{
                delete config.alignMode;
            }

            var gNode = this.querySelector(".v-axis-label-wrapper");
            var textNode = null;
            if (gNode && TypeUtils.isFunction(labelRenderer.update)) {
                if(gNode.childNodes && gNode.childNodes.length>0){
                    textNode = gNode.childNodes[0];
                }
                // revert to legacy handle
                // Only update when <update> function defined
                labelRenderer.update(gNode.firstChild, config, DefaultCategoryLabelRenderer.expose);
            } else {
                textNode = labelRenderer(config, DefaultCategoryLabelRenderer.expose);
                if (textNode === undefined) {
                    textNode = me.defaultCategoryLabelRenderer(config);
                }

                if (textNode) {
                    if (gNode) {
                        gNode.parentNode.removeChild(gNode);
                    }
                    gNode = SVG.create("g");
                    gNode.setAttribute("class", "v-axis-label-wrapper");
                    gNode.appendChild(textNode);
                    this.appendChild(gNode);
                }
            }
            fill = effectManager.register({
                fillColor: config.styles.color
            }); 
            this.setAttribute("fill", fill);
            this.setAttribute("font-size", config.styles.fontSize);
            this.setAttribute("font-weight", config.styles.fontWeight);
            this.setAttribute("font-family", config.styles.fontFamily);
            this.setAttribute("font-style", config.styles.fontStyle);
            //for CustomizedRenderer in Lumira, users have already handled 
            //text location, so we cannot change text-anchor here 
            if(!isCustomizedRenderer && props.textAnchor) {
                textNode.setAttribute("text-anchor", props.textAnchor);
            }

            if (rect) {
                var textNodeSize;
                if(me.labelRectSizeNeedTextNodeSize){
                    if(textNode){
                        var nodeSize = GeometryUtils.getBBox(textNode);
                        if(forceLabelRotation && rotated){
                            textNodeSize = {
                                width: nodeSize.height,
                                height:nodeSize.width
                            };
                        }else{
                            textNodeSize = nodeSize;
                        }
                    }
                }

                var labelSize = {
                    width: forceLabelRotation && rotated ? d.rectHeight :d.rectWidth,
                    height: forceLabelRotation && rotated ? d.rectWidth: d.rectHeight
                };
                me._setLabelRectSize(rect, labelSize, textNodeSize);
                var textSize, textHeight, textWidth;

                if(layer.rotated && layer.rotationAngle !== VERTICAL_ANGLE && layer.rotationAngle !== 0) {
                    if(d.isEventRectLimited) {
                        textSize = TextUtils.canvasMeasure(d.text, fontSize, fontWeight, fontFamily);
                        textHeight = NumberUtils.preciseSimple(textSize.height);
                        textWidth = NumberUtils.preciseSimple(textSize.width);

                        var rectHeight = Math.min(sizeLimit, textWidth);

                        rect.setAttribute("width", textHeight);
                        rect.setAttribute("height", rectHeight);

                        var rectOffset = textHeight/4 * Math.sin(config.rotationAngle * Math.PI/180);

                        //enlarge rect size to add margin
                        var translateStr = addRectMargin(rect, config.rotationAngle, -rectOffset, TICK_SIZE);
                        var rotateStr = "rotate(" + (90 - config.rotationAngle) + "," +
                            d.rectX + "," + d.rectY + ") ";

                        rect.setAttribute("transform", translateStr + ' ' + rotateStr);
                    } else {
                        rect.setAttribute("transform", "skewX(-" + (90-layer.rotationAngle) + ")");

                        var refRectWidth = d.contentWidth * 3;
                        if(refRectWidth < d.cellWidth) {
                            rect.setAttribute("width", refRectWidth);
                            rect.setAttribute("x", d.rectX + d.cellWidth/2 - refRectWidth/2);
                        }
                    }
                }else {
                    rect.removeAttribute("transform");
                }
            }

            if (gNode) {
                // store cell index in the node, so we can know which cell it belongs when we have a node.
                // This is for the "label lock" effect (see TrellisAxis.js)
                this._cellIndex = d._cellIndex;
                var offset = d[cellSizeField] - psize[cellSizeField];
                if (offset < 0) {
                    gNode.setAttribute("transform", "translate(" + (isVertical ? (
                        "0, " + offset / 2) : (offset / 2 + ",0")) + ")");
                } else {
                    gNode.removeAttribute("transform");
                }
            }
        });
    };

    var measureTextLength = function(text, style) {
        var textLength = TextUtils.canvasMeasure(text, style['fontSize'], style['fontWeight'],
            style['fontFamily']).width;
        textLength = NumberUtils.preciseSimple(textLength);
        return textLength;
    };

    function getLeafChildCells(layers, layerIndex, cellIndex) {
        if (!layers || layerIndex < 1 || !layers.length || !layers[0].cells.length) {
            return null;
        }
        var childCells = [];
        var lastLayer = layers[0].cells[0].layer;
        var currentCell = layers[layerIndex].cells[cellIndex];
        if(currentCell.children){
            var q = currentCell.children.slice();
            while(q.length){
                var cell = q.shift();
                if(cell.layer < lastLayer){
                    q = q.concat(cell.children);
                }else if(cell.layer === lastLayer){
                    childCells.push(cell);
                }
            }
        }
        return childCells;
    }

    rendererFunc.prototype._setLabelParameters = function(labels, position, baseline, width, height, textOffset,
        layer) {
        var i = 0,
            length = labels.length,
            label;
        switch (position) {
            case Constants.POSITION.LEFT:
                for (i = 0; i < length; ++i) {
                    label = labels[i];
                    label.x = width - baseline - label.cellWidth;
                    label.y = label.cellStart;
                }
                break;
            case Constants.POSITION.RIGHT:
                for (i = 0; i < length; ++i) {
                    label = labels[i];
                    label.x = baseline;
                    label.y = label.cellStart;
                }
                break;
            case Constants.POSITION.TOP:
                for (i = 0; i < length; ++i) {
                    label = labels[i];
                    label.x = label.cellStart;
                    label.y = height - baseline - label.cellHeight;
                }
                break;
            case Constants.POSITION.BOTTOM:
                for (i = 0; i < length; ++i) {
                    label = labels[i];
                    label.x = label.cellStart;
                    label.y = baseline;
                }
                break;
        }
        
        //for each label, we have to check isEventRectLimited
        for (i = 0; i < length; ++i) {
            var isEventRectLimited = false;
            
            switch (position) {
                case Constants.POSITION.LEFT:
                case Constants.POSITION.RIGHT:
                    if (labels[i].cellHeight - 2 < labels[i].contentHeight) {
                        isEventRectLimited = true;
                    }
                    break;
                case Constants.POSITION.TOP:
                case Constants.POSITION.BOTTOM:
                    if(!layer.rotated || layer.rotationAngle === 0) {
                        isEventRectLimited = false;
                    }
                    else {
                        if (labels[i].cellWidth - 2 < labels[i].contentWidth) {
                            isEventRectLimited = true;
                        }
                        if(layer.rotated && layer.rotationAngle !== VERTICAL_ANGLE &&
                            labels[i].cellWidth < (labels[i].contentWidth * 3)) {
                            isEventRectLimited = true;
                        }
                    }
                    break;
            }
            
            label = labels[i];
            if (isEventRectLimited) {
                switch (position) {
                    case Constants.POSITION.LEFT:
                        label.rectX = label.cellWidth - label.contentWidth - textOffset;
                        label.rectY = (label.cellHeight - label.contentHeight) / 2;
                        label.rectWidth = label.contentWidth;
                        label.rectHeight = label.contentHeight;
                        break;
                    case Constants.POSITION.RIGHT:
                        label.rectX = textOffset;
                        label.rectY = (label.cellHeight - label.contentHeight) / 2;
                        label.rectWidth = label.contentWidth;
                        label.rectHeight = label.contentHeight;
                        break;
                    case Constants.POSITION.TOP:
                        label.rectX = (label.cellWidth - label.contentWidth) / 2;
                        label.rectWidth = label.contentWidth;
                        label.rectHeight = label.contentHeight;
                        label.rectY = label.cellHeight - label.contentHeight - textOffset;
                        break;
                    case Constants.POSITION.BOTTOM:
                        label.rectX = (label.cellWidth - label.contentWidth) / 2;
                        label.rectY = textOffset;
                        label.rectWidth = label.contentWidth;
                        label.rectHeight = label.contentHeight;
                        break;
                }

                if(position === Constants.POSITION.BOTTOM || position === Constants.POSITION.TOP) {
                    if(layer.rotated && layer.rotationAngle !== VERTICAL_ANGLE) {
                        labels[i].rectY = 0;
                        labels[i].rectX = label.cellWidth / 2;
                    }
                }     
            }
            else {
                label.rectX = 1;
                label.rectY = 1;
                label.rectWidth = label.cellWidth - 2 < 0 ? 0 : label.cellWidth - 2;
                label.rectHeight = label.cellHeight - 2 < 0 ? 0 : label.cellHeight - 2;
            }
            label.isEventRectLimited = isEventRectLimited;
        }
    };

    return rendererFunc;
});

define('sap/viz/chart/components/axis/sub/OrdinalCommonAxisBody',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/StatusConstants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/AxisComponent",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/util/StyleUtils",
    "sap/viz/chart/components/util/BoundUtil",
    "sap/viz/chart/components/axis/renderer/OrdinalCommonBodyRenderer",
    "sap/viz/chart/components/util/ClippathUtil",
    "sap/viz/chart/components/util/AxisBodyUtil",
    "sap/viz/chart/components/axis/renderer/DefaultCategoryLabelRenderer",
    "sap/viz/chart/components/util/BuildLayerUtil"
], function (Constants,
        StatusConstants,
        oo,
        AxisComponent,
        NumberUtils, 
        TypeUtils,
        StyleUtils,
        BoundUtil, 
        OrdinalCommonBodyRenderer,
        ClippathUtil,
    AxisBodyUtil,
    DefaultCategoryLabelRenderer,
    BuildLayerUtil) {

    var CONST_CONTEXT_IN = 'in';
    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;
    var VERTICAL_ANGLE = 90;
    //the max wrapped text line
    var MAX_LINE_LIMIT = 3;

    var OrdinalCommonAxisBody = function() {
        OrdinalCommonAxisBody.superclass.constructor.apply(this, arguments);
        //this.__className = "sap.viz.chart.elements.axis.sub.OrdinalCommonAxisBody";
        this._layers = null;
        this._domainChanged = true;
        this._rawLayers = null;
        this._bindingFieldIds = null;
        this._hasNegativeValue = false;
        this._styleChanged = true;
        this._localeChanged = true;
        //Default offset for trellis axis label is 5.
        this._labelOffset = 5;
        var styleChangeCallBack = function() {
            this._styleChanged = true;
        };
        ["fontFamily", "fontSize", "fontWeight", "fontStyle"].forEach(function(e) {
            this[e + "PW"] = this._properties.watch("label.style." + e, styleChangeCallBack.bind(this));
            this[e + "ParentPW"] = this._properties.watch("label.parentStyle." + e, styleChangeCallBack.bind(this));
        }, this);
        this._isInTrellis = false;

        this._tickGroupNode = null;
        this._labelGroupNode = null;
        this._offset = {
            x : 0,
            y : 0
        };
        this._cellDict = {};
        this._bodyRenderer = new OrdinalCommonBodyRenderer();
        this._deltaBound = null;
        this._otherSize = null;
        this._buildUtils = BuildLayerUtil;
        this._selection = null;
    };
    oo.extend(OrdinalCommonAxisBody, AxisComponent);

    OrdinalCommonAxisBody.prototype.setBuildLayerUtil = function(buildUtil) {
        this._buildUtils = buildUtil;
    };

    OrdinalCommonAxisBody.prototype.setBodyRenderer = function(renderer) {
        if(renderer){
            this._bodyRenderer = renderer;
        }
    };

    OrdinalCommonAxisBody.prototype.setData = function(_) {
        var data = this._data;
        if (!data){
            this._domainChanged = true;
        } else {
            var oldDomain = data.getDomain();
            var newDomain = _.getDomain();
            // FIXME: any faster way to check domain change?
            if(oldDomain !== newDomain && JSON.stringify(oldDomain()) !== JSON.stringify(newDomain())){
                this._domainChanged = true;
            }
        }
        return OrdinalCommonAxisBody.superclass.setData.apply(this, arguments);
    };

    OrdinalCommonAxisBody.prototype.setInTrellis = function(_inTrellis) {
        this._isInTrellis = _inTrellis;
    };

    OrdinalCommonAxisBody.prototype.isFlexibleLayers = function(layersNum) {
        var isFlexibleLayers = false;
        if(!this._isInTrellis && this._rawLayers) {
            if(this._rawLayers.length > 1) {
                isFlexibleLayers = true;
            }
        }
        return isFlexibleLayers;
    };

    OrdinalCommonAxisBody.prototype.isAllowEmptySegement = function() {
        //if we allow EmptySegement, we may show more axis layers. Accodring to UX, we do not allow it now. 
        //but if users use customer renderer, we allow empty segement.
        var isAllow = false;
        if(this._properties) {
            var labelRenderer = this._properties.get('labelRenderer');
            if(labelRenderer && (labelRenderer !== DefaultCategoryLabelRenderer)) {
                if(labelRenderer.isAllowEmptySegement && 
                   TypeUtils.isFunction(labelRenderer.isAllowEmptySegement)) {
                    isAllow = labelRenderer.isAllowEmptySegement();
                }
                else {
                    isAllow = true;
                }
            }
        }
        return isAllow;
    };

    OrdinalCommonAxisBody.prototype.setBindingFields = function(_) {
        var bindingFieldIds = _.map(function(o) {
            return o.id;
        });
        if (JSON.stringify(this._bindingFieldIds) !== JSON.stringify(bindingFieldIds)) {
            this._domainChanged = true;
        }
        this._bindingFieldIds = bindingFieldIds;
        this._bindingFields = _;

        return this;
    };

    OrdinalCommonAxisBody.prototype.setHasNegativeValue = function(value) {
        this._hasNegativeValue = !!value;
        return this;
    };

    OrdinalCommonAxisBody.prototype.getAdditionalWidth = function(){
        var choices = [this._otherSize.valueAxis, this._otherSize.categoryAxis2, this._otherSize.leftCallouts];
        var result = 0;
        for(var ii = 0; ii < choices.length; ii++){
            if(choices[ii] && choices[ii].width > 0){
                result = choices[ii].width;
                break;
            }
        }
        return result;
    };

    OrdinalCommonAxisBody.prototype.update = function() {
        this._update(true);
        var additionalWidth = 0;
        if(this._needExtened() && this._otherSize) {
            additionalWidth = this.getAdditionalWidth();
        }
        var rect = this._selection.select('.v-clippath rect');
        rect.attr('width', this._size.width + 2 + additionalWidth).attr('x', -1 - additionalWidth);        
    };

    OrdinalCommonAxisBody.prototype._update = function(rebuildUI) {
        if(!this._tickGroupNode && !this._labelGroupNode){
            return;
        }
        var properties = this._properties.get();
        if (this._data && properties.visible) {
            var width = this._size.width;
            var height = this._size.height;
            var position = this._position;

            if(rebuildUI){
                this._layers = this._buildLayers(this._data);
                this.layout();
            }
            var layers = this._getAvailableLayers();
            var realLayers = layers.length > 0 ? layers : this._layers;
            if (this._isSpaceEnough()) {
                var bound = {
                    width : width,
                    height : height,
                    offset : this._offset,
                    windowSize : this._windowSize,
                    positionInWindow : this._positionInWindow,
                    realSize: this._realSize
                };
                if (properties.axisTick && (properties.axisTick.visible || properties.axisTick.shortTickVisible)) {
                    if(rebuildUI){
                        this._ticks = this._getTicks(realLayers);
                    }
                    var ticks = this._ticks;
                    this._bodyRenderer.drawTicks(this._tickGroupNode, realLayers, ticks, bound,
                        position, properties, this.runtime().effectManager(), this._froce);
                }
                if (properties.label && properties.label.visible) {
                    this._renderLabels(properties, layers, bound, position, rebuildUI);
                }
            }
        }
    };

    OrdinalCommonAxisBody.prototype.setVisibleWindow = function(size, position) {
        this._windowSize = size;
        this._positionInWindow = position;
        this._update(false);
    };

    OrdinalCommonAxisBody.prototype.scroll = function(offset) {
        AxisBodyUtil.setTransform(this, offset);
        this._offset.x = offset.x;
        this._offset.y = offset.y;
        this._update(false);
    };

    OrdinalCommonAxisBody.prototype.render = function(selection) {
        this._selection = selection;
        selection.select("g." + AXIS_CLASS_NAMES.LINE_GROUP).remove();
        selection.select("g." + AXIS_CLASS_NAMES.TICK_GROUP).remove();
        selection.select("g." + AXIS_CLASS_NAMES.LABEL_GROUP).remove();

        var additionalWidth = 0;
        if(this._needExtened() && this._otherSize) {
            additionalWidth = this.getAdditionalWidth();
        }
        var clippathid = ClippathUtil.drawClippath(d3.select(selection.node()),
            this._size.width + 2 + additionalWidth, this._size.height + 2, -1 - additionalWidth, -1);
        selection.attr('clip-path', 'url(#' + clippathid + ')');
        var properties = this._properties.get();

        if (this._data && properties.visible) {
            var width = this._size.width;
            var height = this._size.height;
            var position = this._position;
            var layers = this._getAvailableLayers();

            if (this._isSpaceEnough()) {
                var effectManager = this.runtime().effectManager();
                var bound = {
                    width : width,
                    height : height,
                    offset : this._offset,
                    windowSize : this._windowSize,
                    positionInWindow : this._positionInWindow,
                    realSize: this._realSize
                };
                
                this._drawTicks(layers, width, height, position, properties, selection, effectManager, bound);

                var originProps = this._properties.origin;
                if (this._hasNegativeValue === true &&
                    originProps.get("plotArea.gridline.zeroLine.unhighlightAxis") === true) {
                    properties.color = originProps.get("plotArea.gridline.color");
                }
                this._drawAxisLine(layers, width, height, position, properties, selection, effectManager);

                if (properties.label && properties.label.visible) {
                    this._labelGroupNode = selection.append("g").attr("class", AXIS_CLASS_NAMES.LABEL_GROUP);
                    this._renderLabels(properties, layers, bound, position);
                }
            }
        }

        if(this._offset.x || this._offset.y) {
            AxisBodyUtil.setTransform(this, this._offset);
        }
    };
    
    OrdinalCommonAxisBody.prototype._renderLabels = function(properties, layers, bound, position, rebuildUI) {
        var envManager = this.runtime().envManager();
        if (envManager) {
            properties.textAnchor = envManager.textAnchor();
            properties.reverseDots = envManager.reverseDots();
        }

        this._bodyRenderer.drawLabels(this._labelGroupNode, layers, bound, position,
            properties, this.runtime().effectManager(), this._needRowAxisOffset(), this._labelOffset, 
            this._needExtened() ? this.getAdditionalWidth(): 0, rebuildUI);
        
        if(this._bodyRenderer && this._bodyRenderer.applyLabelStyle){
            this._bodyRenderer.applyLabelStyle(this._labelGroupNode);
        }
    };
    
    OrdinalCommonAxisBody.prototype._drawAxisLine = function(
            layers, width, height, position, properties, selection, effectManager) {
        
        var group;
        
        if (properties.axisLine && properties.axisLine.visible) {
            group = selection.append("g").attr("class", AXIS_CLASS_NAMES.LINE_GROUP);
            var axisSize = this._isVertical() ? height : width;
            var range = [0, axisSize];
            var line = this._bodyRenderer.drawLines(group, layers, range, width, height,
                position, properties, effectManager);
        }
        return group;
    };
    
    OrdinalCommonAxisBody.prototype._drawTicks = function(
            layers, width, height, position, properties, selection, effectManager, bound) {
        
        var ticks = this._ticks = this._getTicks(layers);

        if (properties.axisTick && (properties.axisTick.visible || properties.axisTick.shortTickVisible)) {
            this._tickGroupNode = selection.append("g").attr("class", AXIS_CLASS_NAMES.TICK_GROUP);
            this._bodyRenderer.drawTicks(this._tickGroupNode, layers, ticks, bound,
                position, properties, effectManager, this._froce);
        }
    };
    
    OrdinalCommonAxisBody.prototype.getPreferredSize = function(refSize) {
        var layers;
        if (this._data && this._properties.get('visible')) {
            layers = (this._layers = this._buildLayers(this._data, refSize));
        }
        var pfdSize = {
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0,
            spacings: [{
                "interval": 0,
                "type": Constants.SPACING_TYPE.STEP
            }]
        };
        // Set a nonzeron value to make sure the axis line is always drawn
        if (this._isVertical()) {
            pfdSize.minWidth = pfdSize.maxWidth = 0.1;
        } else {
            pfdSize.minHeight = pfdSize.maxHeight = 0.1;
        }
        if (layers) {
            var range = this._data.getRange();
            var rangeLong = Math.abs(range[0] - range[1]);

            var field = this._isVertical() ? "height" : "width";
            rangeLong *= this._realSize[field];
            var viewportWidth = refSize ? refSize[field] : (this._size[field] || rangeLong);

            var i, length = layers.length;
            var minSize, maxSize, spacings, layer;
            if (length) {
                spacings = (pfdSize.spacings = []);
                for (i = 0; i < length; ++i) {
                    layer = layers[i];
                    if(this.isFlexibleLayers()) {
                        //for flexibleLayers, we have to add layers "3 values" into spacings
                        var spaceItem = {};
                        if (!layer.maxLayerBand && !layer.minLayerBand && !layer.niceLayerBand) {
                            spaceItem.maxLayerBand = 0;
                            spaceItem.minLayerBand = 0;
                            spaceItem.niceLayerBand = 0;
                        } else {
                            spaceItem.maxLayerBand = layer.maxLayerBand;
                            spaceItem.minLayerBand = layer.minLayerBand;
                            spaceItem.niceLayerBand = layer.niceLayerBand;
                        }
                        spacings.push(spaceItem);
                    }
                    else {
                        if (i === 0 && //(this._isVertical() || (!this._isVertical() && layer.rotated)) &&
                            layer.minLayerBand < layer.layerBand) {
                            spacings.push({
                                "interval": layer.minLayerBand,
                                "type": Constants.SPACING_TYPE.STEP
                            });
                            spacings.push({
                                "interval": layer.layerBand - layer.minLayerBand,
                                "type": Constants.SPACING_TYPE.RANGE
                            });
                        } else {
                            spacings.push({
                                "interval": layer.layerBand,
                                "type": Constants.SPACING_TYPE.STEP
                            });
                        }
                    }
                }
                minSize = this._getMinLayersSize(spacings);
                var sizeLimit = refSize && refSize[this._isVertical() ? 'width' : 'height'];
                
                if(this.isFlexibleLayers()) {
                    //to get maxLayersSize, we have to relayout "spacings" according to sizeLimit.
                    maxSize = this._buildUtils.flexibleLayoutLayers(spacings, this._isVertical(), 
                            sizeLimit, this.isAllowEmptySegement());
                }
                else {
                    maxSize = this._getMaxLayersSize(spacings, sizeLimit);
                }
                if (this._isVertical()) {
                    pfdSize.minWidth = minSize;
                    pfdSize.maxWidth = maxSize;
                    pfdSize.minHeight = viewportWidth;
                    pfdSize.maxHeight = viewportWidth;
                } else { //position === Constants.POSITION.TOP || position === Constants.POSITION.BOTTOM
                    pfdSize.minWidth = viewportWidth;
                    pfdSize.maxWidth = viewportWidth;
                    pfdSize.minHeight = minSize;
                    pfdSize.maxHeight = maxSize;
                }
            }
        }
        var precisedSize = NumberUtils.preciseObject(pfdSize);
        this._updatePfdSize(precisedSize);
        return precisedSize;
    };
    OrdinalCommonAxisBody.prototype.destroy = function() {

        //remove watchers
        ["fontFamily", "fontSize", "fontWeight", "fontStyle"].forEach(function(e) {
            if (this[e + "PW"] == null) {
                return;
            }
            this[e + "PW"].remove();
            this[e + "PW"] = null;
            
            //remove parent style watcher
            if (this[e + "ParentPW"] == null) {
                return;
            }
            this[e + "ParentPW"].remove();
            this[e + "ParentPW"] = null;
        }, this);

        OrdinalCommonAxisBody.superclass.destroy.apply(this, arguments);
        this._layers = null;
        this._rawLayers = null;
        this._bindingFieldIds = null;
        this._bindingFields = null;
        this._domainChanged = null;
        this._hasNegativeValue = null;
        this._styleChanged = null;
        this._tickGroupNode = null;
        this._labelGroupNode = null;
        this._cellDict = null;
        this._otherSize = null;
        this._deltaBound = null;
        this._selection = null;
    };

    OrdinalCommonAxisBody.prototype._getMinLayersSize = function(spacings) {
        var minSize = spacings[0].interval;
        if(this.isFlexibleLayers()) {
            minSize = spacings[0].minLayerBand;
        }
        return minSize;
    };

    OrdinalCommonAxisBody.prototype._getMaxLayersSize = function(spacings, sizeLimit) {
        var sum = 0;
        for (var i = 0, length = spacings.length; i < length; ++i) {
            if (typeof sizeLimit !== 'number' || sum + spacings[i].interval <= sizeLimit) {
                sum += spacings[i].interval;
            } else {

                if (spacings[i].type === Constants.SPACING_TYPE.RANGE) {
                    sum = Math.min(sum + spacings[i].interval, sizeLimit);
                }
                break;
            }
        }
        return sum;
    };

    OrdinalCommonAxisBody.prototype._getTicks = function(layers) {
        var ticksArray = [];
        var cellTickSizeField = this._isVertical() ? "cellHeight" : "cellWidth";
        var layerCount = layers.length;

        for (var i = 0; i < layerCount; ++i) {
            var cursor = 0;
            var cells = layers[i].cells;
            var cellCount = cells.length;
            var ticks = new Array(cellCount + 1);
            ticks[0] = 0;

            for (var j = 0; j < cellCount; ++j) {
                cursor += cells[j][cellTickSizeField];
                // If only one layer, no need to preciseSimple since no need
                // to compare with other layers to find the long ticks.
                ticks[j + 1] = layerCount === 1 ? cursor : NumberUtils.preciseSimple(cursor);
            }
            ticksArray.push(ticks);
        }
        return ticksArray;
    };

    OrdinalCommonAxisBody.prototype.getAvailableLayersNumber = function() {
        var layers = this._getAvailableLayers();
        return layers.length;
    };

    OrdinalCommonAxisBody.prototype._getAvailableLayers = function() {
        var spaceLimit;
        if (this._isVertical()) {
            spaceLimit = NumberUtils.preciseSimple(this._realSize.width);
        } else {
            spaceLimit = NumberUtils.preciseSimple(this._realSize.height);
        }
        var layers = this._layers;
        var layer;
        var availableLayers = [];
        
        if(this.isFlexibleLayers()) {
            this._buildUtils.flexibleLayoutLayers(layers, this._isVertical(), 
                    spaceLimit, this.isAllowEmptySegement());
            for(var iLayer = 0; iLayer < layers.length; iLayer++) {
                if(layers[iLayer].layerBand > 0 && layers[iLayer].isVisible) {
                    availableLayers.push(layers[iLayer]); 
                }
            }
        }
        else {
            if (layers) {
                for (var i = 0, length = layers.length; i < length; ++i) {
                    layer = layers[i];
                    spaceLimit -= layer.layerBand;
                    spaceLimit = NumberUtils.preciseSimple(spaceLimit);
                    if (spaceLimit < 0) {
                        if (i === 0 && //(this._isVertical() || (!this._isVertical() && layer.rotated)) &&
                            NumberUtils.preciseSimple(spaceLimit + layer.layerBand - layer.minLayerBand) >= 0) {
                            availableLayers.push(layer);
                        }
                        break;
                    } else {
                        availableLayers.push(layer);
                    }
                }
            }
        }
        this._availableLayers = availableLayers;
        return availableLayers;
    };

    OrdinalCommonAxisBody.prototype.getActiveLevels = function() {
        return this._availableLayers;
    };

    OrdinalCommonAxisBody.prototype.getCellPosition = function(cellId){
        var cell = this._cellDict[cellId];
        return {
            x: cell.x,
            y: cell.y,
            width: cell.cellWidth,
            height: cell.cellHeight
        };
    };

    OrdinalCommonAxisBody.prototype._getCellsRange = function(scale){
        return scale.getRangeInterval();
    };

    OrdinalCommonAxisBody.prototype.getLayoutCellsConfig = function(){
        var config = {};
        if(this._properties) {
            var properties = this._properties;
            
            var propStyle = properties.get('label.style');
            var propParentStyle = StyleUtils.buildParentStyle(propStyle,
                    properties.get('label.parentStyle'));
            config = {
                propStyle: propStyle,
                propParentStyle: propParentStyle,
                isSetParentStyleProp: !!(properties.get('label.parentStyle')),
                labelVisible: properties.get('label.visible'),
                truncatedLabelRatioSetting: parseFloat(properties.get("label.truncatedLabelRatio")),
                autoRotateSetting: properties.get("label.rotation"),
                labelRenderer: properties.get('labelRenderer'),
                defaultRotationAngle:parseInt(properties.getDefault("label.angle")),
                rotationAngleSetting : parseInt(properties.get("label.angle")),
                checkLabelVisible: true,
                labelOverlapBehavior: properties.get("label.overlapBehavior")
            };
        }

        return config;
    };
    OrdinalCommonAxisBody.prototype._getScaleDomain = function(scale){
        return scale.getDomain();
    };

    OrdinalCommonAxisBody.prototype.mayOnlyFirstAndLastLabel = function(config, layerNumber){
        return  config.labelVisible && config.autoRotateSetting === "auto" &&
                layerNumber === 1 && !this._isVertical() &&
                this._options.name === "categoryAxis" && !this._isInTrellis && 
                config.labelOverlapBehavior === "showFirstLastOnly";
    };

    OrdinalCommonAxisBody.prototype._buildLayers = function(scale, refSize) {
        var config = this.getLayoutCellsConfig();
        var rawLayers;

        if (this._domainChanged || this._styleChanged || this._localeChanged || 
            this.mayOnlyFirstAndLastLabel(config, this._rawLayers.length)) {
            //scale change or style change will affect the result of label layer merging
            this._domainChanged = false;
            this._styleChanged = false;
            this._localeChanged = false;
            rawLayers = this._buildUtils.mergeLabels(this, this._getScaleDomain(scale),
                                                         this._bindingFieldIds, config);
            this._rawLayers = this._buildUtils._filter(rawLayers, this._bindingFields);
            this._formatLayerLabel();
        }
        var sizeField = this._isVertical() ? 'height' : 'width';
        var size = this._realSize[sizeField];
        // "plotRealSize" is set by XYPlotArea
        var plotRealSize = this.runtime().statusManager().get('plotRealSize');
        if(plotRealSize){
            size = Math.max(plotRealSize[sizeField] || 0, size);
            this.runtime().statusManager().set('plotRealSize', null);
        }

        var labelLayers = this._rawLayers;
        this._buildUtils.assignCellSize(this, labelLayers, this._getCellsRange(scale), size);
        var range = scale.getRange();
        if(this._needExtened && this._otherSize) {
            config.otherSize = this._otherSize;
        }

        //wrap text is only for one layer horizontal category axis when
        //rotation is auto or rotation angle is 0.
        if (this._options.name === "categoryAxis" && this._isHorizontal() &&
            !this._isInTrellis && labelLayers.length === 1 &&
            config.rotationAngleSetting === 0) {
            var wrap = this._getWrapText();
            if (wrap > 1) {
                config.wrap = wrap;
            }
        }
        config.isFlexibleLayers = this.isFlexibleLayers();
        config.isAllowEmptySegement = this.isAllowEmptySegement();
        config.paginationOptions = this.paginationOptions();
        config.refSize = refSize;
        this._buildUtils.layoutCells(this, labelLayers, [0, range[1] * size], config);

        this._isOnlyShowingFirstAndLastLabel = false;
        if(this.mayOnlyFirstAndLastLabel(config, labelLayers.length) && 
            this.willHaveTruncationOrRotation(labelLayers)){
            //no text wrap when only first and last
            delete config.wrap;

            rawLayers = this._buildUtils.mergeLabels(this, this._getScaleDomain(scale),
                                                         this._bindingFieldIds, config, true);
            this._rawLayers = this._buildUtils._filter(rawLayers, this._bindingFields);
            this._formatLayerLabel();
            this._buildUtils.layoutCells(this, labelLayers, [0, range[1] * size], config, true);
            this._isOnlyShowingFirstAndLastLabel = true;
        } 
        
        //for flexibleLayout, we need to calculate niceLayerBand, 
        //and then layout layers
        if(this.isFlexibleLayers()) {
            this._buildUtils.flexibleLayoutLayers(labelLayers, this._isVertical(), 
                    Infinity, this.isAllowEmptySegement());
        }
        
        return this._buildUtils.getVisibleLayers(this, labelLayers);
    };

    OrdinalCommonAxisBody.prototype.isOnlyShowingFirstAndLastLabel = function() {
        return this._isOnlyShowingFirstAndLastLabel;
    };

    OrdinalCommonAxisBody.prototype.willHaveTruncationOrRotation = function(labelLayers){
        var layer = labelLayers[0];
        if(layer.rotated){
            return true;
        }

        var cells = layer.cells;
        var ii, cell;
        for (ii = 0; ii < cells.length; ii++) {
            cell = cells[ii];
            if(cell._preferredSize.textSize && 
                cell._preferredSize.textSize.width > cell.cellWidth){
                return true;
            }
        }

        return false;
    };

    
    OrdinalCommonAxisBody.prototype.paginationOptions = function() {
        var dataModel = this._runtime && this._runtime._interaction &&
            this._runtime._interaction._service && this._runtime._interaction._service.getDataModel();
        var paginationOptions;
        if(dataModel && dataModel.getPaginationOptions) {
            paginationOptions = dataModel.getPaginationOptions();
        }
        return paginationOptions;
    };    

    OrdinalCommonAxisBody.prototype._getWrapText = function() {
        var wrap = 1;
        //we disable word-warp for RTL, because RTL is not for Lumira,
        //but word-warp is for Lumira
      
        if (!this._isRTL()) {
            //the line num is between 1 - 3 as PO demand
            wrap = parseInt(this._properties.get('label.linesOfWrap'));
            if (isNaN(wrap) || wrap < 1) {
                //return default value if the property is invalid
                wrap = 1;
            } else if (wrap > MAX_LINE_LIMIT) {
                wrap = MAX_LINE_LIMIT;
            }
        }
        return wrap;
    };

    OrdinalCommonAxisBody.prototype._formatLayerLabel = function() {
    };

    OrdinalCommonAxisBody.prototype.layout = function() {
        if (!(this._layers && this._layers.length)) { //even first layer is hidden
            return;
        }
        //change layer band regarding to width/height
        var bandTotal = this._isVertical() ? this._size.width : this._size.height;
        var layer0 = this._layers[0],
            cells, cell, i;
        if (bandTotal < layer0.layerBand && bandTotal >= layer0.minLayerBand) {
            cells = layer0.cells;
            for (i = -1; ++i < cells.length;) {
                cell = cells[i];
                if (this._isVertical()) {
                    if (cell.cellWidth > 0) {
                        cell.cellWidth = bandTotal;
                    }
                } else {
                    if (cell.cellHeight > 0) {
                        cell.cellHeight = bandTotal;
                    }
                }
            }
        }
    };

    OrdinalCommonAxisBody.prototype._needRowAxisOffset = function() {
        return false;
    };

    OrdinalCommonAxisBody.prototype.statusChanged = function(status){
        if(status === StatusConstants.LOCALE_CHANGED){
            this._localeChanged = true;
        }
    };
    
    OrdinalCommonAxisBody.prototype._needExtened = function() {
        var layers = this._layers, needExtened;
        var sizeField = this._isVertical() ? 'height' : 'width';
        var size = this._realSize[sizeField];
        if(layers && layers.length > 0) {
            needExtened = (layers[0].rotated && layers[0].rotationAngle !== VERTICAL_ANGLE);
        }
        else {
            needExtened = false;
        }
        return needExtened;
    };

    OrdinalCommonAxisBody.prototype.getLabelOffsetByCtx = function(context) {
        if(!this._layers) {
            this._layers = this._buildLayers(this._data);
        }
        var innerLayer = this._layers[this._layers.length - 1];
        var id;
        innerLayer.cells.forEach(function(cell) {
            var result = true;
            for (var item in cell.ctx) {
                if (context[item] !== cell.ctx[item]) {
                    result = false;
                    break;
                }
            }
            if (result) {
                id = cell.id;
            }
        });
        if (id !== undefined) {
            var cell = this._cellDict[id];
            var pos = {
                start: cell.cellStart,
                width: cell.cellWidth,
                height: cell.cellHeight
            };
            if (this._isHorizontal()) {
                return {x: -(pos.start + pos.width - this.getSize().width)};
            } else {
                return {y: -(pos.start + pos.height - this.getSize().height)};
            }
        } else {
            return null;
        }

    };

    return OrdinalCommonAxisBody;
});

define('sap/viz/chart/components/axis/renderer/CategoryBodyRenderer',[
    "sap/viz/chart/components/axis/renderer/OrdinalCommonBodyRenderer",
], function(OrdinalCommonBodyRenderer) {
    // Add the CategoryBodyRenerer itself functions.
    return OrdinalCommonBodyRenderer;
});

define('sap/viz/chart/components/axis/sub/CategoryAxisBody',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/OrdinalCommonAxisBody",
    "sap/viz/chart/components/axis/renderer/CategoryBodyRenderer",
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/SVG'
], function(oo, OrdinalCommonAxisBody, CategoryBodyRenderer, DOMUtil, SVG) {

    var CategoryAxisBody = function() {
        CategoryAxisBody.superclass.constructor.apply(this, arguments);
        this.setBodyRenderer(new CategoryBodyRenderer());

        if (this._properties.has("layout.categoryWidth")) {
            this._properties.set("layout.categoryWidth", function() {
                //categoryAxis's total width divide the number of the inner most units is categoryWidth.
                //this._data may not exist,this._data._domain.length may be 0.
                if (this._realSize.width > 0 && 
                    this._data && this._data._domain && 
                    this._data._domain.length > 0) {
                    return this._realSize.width/this._data._domain.length;
                } else {
                    return 0;
                }
            }.bind(this), true, "get");
        }

        if (this._properties.has("layout.offsetToChart")) {
            this._properties.set("layout.offsetToChart", function() {
                if (!this._selection) {
                    return 0;
                }

                var node = this._selection.node();
                while (!DOMUtil.hasClass(node, "v-m-root") && !DOMUtil.hasClass(node, "v-m-categoryAxis")) {
                    node = node.parentNode;
                }

                if (DOMUtil.hasClass(node, "v-m-categoryAxis")) {
                    var transform = SVG.getTransformToElement(node, node.ownerSVGElement);
                    if (transform) {
                        return  transform.e;                        
                    }
                } else {
                    return 0;
                }

            }.bind(this), true, "get");
        }


    };
    
    oo.extend(CategoryAxisBody, OrdinalCommonAxisBody);
    
    CategoryAxisBody.prototype._setOtherSize = function(otherSizeInfo) {
        this._otherSize = otherSizeInfo;
        this._deltaBound = {
                'width' : 0,
                'height' : 0,
                'x' : 0,
                'y' : 0
            };
        if(this._otherSize) {
            var choices = [this._otherSize.valueAxis, this._otherSize.categoryAxis2, this._otherSize.leftCallouts];
            for(var ii = 0; ii < choices.length; ii++){
                if(choices[ii] && choices[ii].width > 0){
                    this._deltaBound.width = choices[ii].width;
                    this._deltaBound.x = -choices[ii].width;
                }
            }
        }
        return this;
    };

    return CategoryAxisBody;
});

define('sap/viz/chart/components/accessibility/CategoryAxisNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/ChartComponentNavigator",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/TypeUtils"
], function(oo, ChartComponentNavigator, ObjectUtils, TypeUtils) {

    function CategoryLabelNavigator(options) {
        CategoryLabelNavigator.superclass.constructor.apply(this, arguments);
        this._categoryLabels = [];
        if(TypeUtils.isFunction(options.cells)){
            this._cells = options.cells;
        }else{
            this._cells = this.layers2cells(options.cells);
        }
    }

    oo.extend(CategoryLabelNavigator, ChartComponentNavigator);

    var prot = CategoryLabelNavigator.prototype;

    //Because not all children cell are visible, we have to count "VisibleSpace"
    var countVisibleSpace= function(cell) {
        if(!cell.visibleSpace) {
            var visibleSpace = 0;
            if(cell.children && cell.children.length) {
                var iCell;
                for(iCell = 0; iCell < cell.children.length; iCell++) {
                    if(cell.children[iCell].isVisible === undefined ||
                       cell.children[iCell].isVisible === true) {
                        visibleSpace += countVisibleSpace(cell.children[iCell]);
                    }
                }
            }
            
            if(visibleSpace <= 0) {
                visibleSpace = 1;
            }
            cell.visibleSpace = visibleSpace;
        }
        return cell.visibleSpace;
    };
    
    prot.layers2cells = function(layers) {
        var cells = [];
        for (var i = 0; i < layers.length; ++i) {
            cells[i] = [];
            var spaceCount = 0, col = 0;
            for (var j = 0; j < layers[i].cells.length; ++j) {
                if (layers[i].cells[j].isVisible){
                    var cell = layers[i].cells[j];
                    var visibleSpace = countVisibleSpace(cell);
                    cells[i].push(cell);
                    cell.spaceStart = spaceCount;
                    cell.spaceEnd = spaceCount + visibleSpace - 1;
                    spaceCount += visibleSpace;
                    cell.index = {row: i, col: col++};
                    this._categoryLabels[cell.id] = {};
                    this._categoryLabels[cell.id].index = cell.index;
                }
            }
        }
        return cells;
    };

    prot.init = function() {
    };

    prot.destroy = function() {
        CategoryLabelNavigator.superclass.destroy.apply(this, arguments);
        this._cells = null;
        this._categoryLabels = null;
    };

    prot.up = function(id) {
        if (this.isSingleLayer() || !this._isVerticalRender){
            return this.getSiblingCell(id, -1);
        } else {
            return this.getFirstChildCell(id);
        }
    };

    prot.down = function(id) {
        if (this.isSingleLayer() || !this._isVerticalRender){
            return this.getSiblingCell(id, 1);
        } else {
            return this.getParentCell(id);
        }
    };
    
    prot.left = function(id) {
        if (this.isSingleLayer() || this._isVerticalRender){
            return this.getSiblingCell(id, -1);
        } else {
            return this.getParentCell(id);
        }
    };
    
    prot.right = function(id) {
        if (this.isSingleLayer() || this._isVerticalRender){
            return this.getSiblingCell(id, 1);
        } else {
            return this.getFirstChildCell(id);
        }
    };

    prot.getCategoryLabelNode = function(id) {
        return this._categoryLabels[id].cl;
    };

    prot.getCells = function(){
        if(TypeUtils.isFunction(this._cells)){
            return this.layers2cells(this._cells());
        }else{
            return this._cells;
        }
    };

    prot.getCell = function(id){
        var index = this._categoryLabels[id].index;
        return this.getCells()[index.row][index.col] || null;
    };

    prot.getSiblingCell = function(id, direction) {
        var index = this._categoryLabels[id].index;
        var siblingCell = this.getCells()[index.row][index.col + direction];
        return siblingCell ? siblingCell : null;
    };

    prot.getFirstChildCell = function(id) {
        var index = this._categoryLabels[id].index;
        var childLayer = this.getCells()[index.row + 1];
        if (!childLayer){
            return null;
        }
        var cell = this.getCells()[index.row][index.col];
        var i;
        for (i = 0; i < childLayer.length; ++i){
            if (cell.spaceStart == childLayer[i].spaceStart){
                return childLayer[i];
            }
        }        
    };

    prot.getParentCell = function(id) {
        var index = this._categoryLabels[id].index;
        var parentLayer = this.getCells()[index.row - 1];
        if (!parentLayer){
            return null;
        }
        var cell = this.getCells()[index.row][index.col];
        var i;
        for (i = 0; i < parentLayer.length; ++i){
            if (cell.spaceStart >= parentLayer[i].spaceStart && cell.spaceEnd <= parentLayer[i].spaceEnd){
                return parentLayer[i];
            }
        }            
    };

    prot.getFirstStartPoint = function() {
        var cells = this.getCells();
        return cells[cells.length - 1][0];
    };

    prot.isSingleLayer = function() {
        return this.getCells().length == 1 ? true : false;
    };

    prot.updateCells = function(layers) {
        this._categoryLabels = [];
        this._cells = this.layers2cells(layers);
    };

    prot.findCell = function(ctx, id) {
        if (!ctx) {
            return null;
        }

        var cells = this.getCells();

        for (var c, i = 0, iLen = cells.length; i < iLen; i++) {
            for (var j = 0, jLen = cells[i].length; j < jLen; j++) {
                c = this._cells[i][j];
                if (ObjectUtils.deepEqual(c.ctx, ctx)) {
                    return c;
                }
            }
        }

        return null;
    };

    return CategoryLabelNavigator;
});

define('sap/viz/chart/components/axis/CategoryAxis',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/AxisContainer",
    "sap/viz/chart/scales/CategoryScale",
    "sap/viz/chart/components/axis/sub/CategoryAxisBody",
    "sap/viz/chart/components/axis/renderer/DefaultCategoryLabelRenderer",
    "sap/viz/framework/common/util/DataUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/TypeUtils" ,
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/CategoryAxisNavigator",
    "sap/viz/chart/components/util/ChartConstants"
], function(Constants, 
    oo,
    AxisContainer,
    CategoryScale,
    CategoryAxisBody,
    DefaultCategoryLabelRenderer,
    DataUtils,
    LangManager,
    NumberUtils,
    TextUtils,
    TypeUtils,
    ChartNavigator,
    ItemNavigator,
    ChartConstants) {

    var MEASURE_NAMES = "measureNames";
    
    var CategoryAxis = function(runtime, options) {
        
        CategoryAxis.superclass.constructor.apply(this, arguments);
        this._hasNegativeValue = null;
        this._isAxisBodyOptional = false;
        this._isInTrellis = false;
        this._needOtherSize = true;
        this._otherSize = null;
        this._setAxisBody(runtime, options);
    };
    oo.extend(CategoryAxis, AxisContainer);

    CategoryAxis.prototype.addARIATag = function(rootElement){
        rootElement.attr('role', 'listbox');     
    };

    CategoryAxis.prototype._setAxisBody = function(runtime, options) {
        this.setChild("axisBody", new CategoryAxisBody(runtime, options), {
            order: 1,
            priority: 2,
            offset: 0
        });
    };

    
    CategoryAxis.prototype.setInTrellis = function(_inTrellis) {
        this._isInTrellis = _inTrellis;
        this.getChild("axisBody").module.setInTrellis(_inTrellis);
    };

    CategoryAxis.prototype.setData = function(data, hasNegativeValue, patternData) {
        CategoryAxis.superclass.setData.call(this, data);
        this._hasNegativeValue = hasNegativeValue;
        if (data.scale) {
            this._scale = data.scale;
        }
    };

    CategoryAxis.prototype.isAxisBodyOptional = function(flag){
        this._isAxisBodyOptional = flag;
    };

    CategoryAxis.prototype._getTitle = function(){
        var titleObj = CategoryAxis.superclass._getTitle.call(this);
        if(this._isAxisBodyOptional){
            titleObj.noNeedApplyHiddenTitleColor = true;
        }
        return titleObj;
    };
    CategoryAxis.prototype.getMaxZoomRatio = function(){
        var ratio = Number.MAX_VALUE;
        if (this._scale && this._scale.getRangeInterval().length){
            var intervals = this._scale.getRangeInterval();
            var interval = Math.abs(intervals[0][0] - intervals[0][1]);
            ratio = 1 / interval;
        }
        return ratio;
    };

    CategoryAxis.prototype.setVisibleWindow = function(size, position) {
        var axisBody = this.getChild("axisBody");
        if(axisBody && axisBody.module){
            axisBody.module.setVisibleWindow(size, position);
        }
    };

    CategoryAxis.prototype._updateData = function(info) {
        CategoryAxis.superclass._updateData.apply(this, arguments);
        if (!this._scale) {
            return;
        }
        var axisBody = this.getChild("axisBody").module;
        var size = axisBody.getSize();
        var realSize = axisBody.getSize();
        if (this._isVertical()) {
            size.height = this._size.height;
            realSize.height = info.height;
        } else {
            size.width = this._size.width;
            realSize.width = info.width;
        }
        if(!this._isAxisBodyOptional){
            axisBody.setSize(size)
                .setRealSize(realSize)
                .setData(this._scale)
                .setBindingFields(this._bindingFields)
                .setHasNegativeValue(this._hasNegativeValue);
        }
        if(this._needOtherSize) {
            axisBody._setOtherSize(this._otherSize);
        }
    };
    
    CategoryAxis.prototype._constructTitle = function(header, titleItems) {
        if(header.length > 0){
            var toDraw = header.filter(function(hd) {
                return !hd.invisible;
            }).map(function(o) {
                var title =  o.name || o.id;
                if(title === MEASURE_NAMES){
                    title = LangManager.get("IDS_DEFAULTMND");
                }
                
                return title;
            });

            titleItems.splice(0, titleItems.length);
            var allText = "";
            var itemText = "";

            for (var i = 0; i < toDraw.length; i++) {
                if (i === 0) {
                    itemText = toDraw[i];
                } else {
                    itemText = " / " + toDraw[i];
                }

                allText += itemText;

                var itemObj = {};
                itemObj.isHidden = false;
                itemObj.text = itemText;
                //an item is an obj as {text: "abc", isHidden: false}
                titleItems.push(itemObj);
            }
            return allText;
        }
    };
    
    CategoryAxis.prototype.getLabelOffset = function() {
        //When axis visible is false, there are no cells in axisBody.
        //For this scenario, return 0 for labelOffset
        var layers = this._children.axisBody.module._getAvailableLayers();        
        var innerLayer = layers[layers.length-1];
        var cells;
        if (innerLayer) {
            cells = innerLayer.cells;           
        } else {
            return 0;
        }      
        var cellMiddle;
        //Get cell middle position for visible layer
        cells.some(function(e) {
            if (e.isVisible === true) {
                cellMiddle = e.middle;
                return true;
            }
        });
        var prop = this._properties.get();
        //since the function just uses the innerLayer, we do not need to use parent layer
        var propStyle = prop.label.style;
        var textHeight = this._getTextHeight(propStyle);
        var offset = this._getBaseLineOffset(propStyle);
        return cellMiddle - textHeight / 2 + offset;
    };
    
    CategoryAxis.prototype._getTextHeight = function(propStyle) {

        var textHeight = TextUtils.canvasMeasure('', propStyle['fontSize'], propStyle['fontWeight'],
            propStyle['fontFamily'], propStyle['letterSpacing']).height;
        textHeight = NumberUtils.preciseSimple(textHeight);
        return textHeight;    
    };
    
    CategoryAxis.prototype._getBaseLineOffset = function(propStyle) {
        var offset = TextUtils.getTextBaselineOffset({
            fontSize: propStyle['fontSize'],
            fontWeight: propStyle['fontWeight'],
            fontFamily: propStyle['fontFamily'],
            letterSpacing: propStyle['letterSpacing']
        }); 
        return offset;   
    };
    
    CategoryAxis.prototype.isByBound = function() {
        return true;
    };
    
    CategoryAxis.prototype.destroy = function() {
        CategoryAxis.superclass.destroy.call(this);
        this._scale = null;
        this._hasNegativeValue = null;
    };
    
    CategoryAxis.prototype.paginationOptions = function() {
        var dataModel = this._runtime && this._runtime._interaction &&
            this._runtime._interaction._service && this._runtime._interaction._service.getDataModel();
        var paginationOptions;
        if(dataModel && dataModel.getPaginationOptions) {
            paginationOptions = dataModel.getPaginationOptions();
        }
        return paginationOptions;
    };
    
    CategoryAxis.prototype._renderSub = function() {
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var child = this.getChild(key).module;
                if(!this.paginationOptions() ||
                   key !== Constants.AXIS.SCROLLBAR_NAME) {
                    child.render(this._selections[key]);
                }
                
                if(TypeUtils.isFunction(child._needExtened) &&
                        child._needExtened() && child._deltaBound) {
                    var bound = this._parent.select('.v-bound');
                    if(bound) {
                        for(var k in child._deltaBound) {
                            if(child._deltaBound.hasOwnProperty(k)) {
                                var attr = (bound.attr(k) ? parseFloat(bound.attr(k)) : 0) + 
                                    (child._deltaBound[k] ? parseFloat(child._deltaBound[k]) : 0);
                                bound.attr(k, attr);
                            }
                        }
                    }
                }
            }
        }
    };
    
    CategoryAxis.prototype.setSize = function(sizeInfo, otherSizeInfo) {
        CategoryAxis.superclass.setSize.apply(this, arguments);
        if(this._needOtherSize) {
            this._otherSize = otherSizeInfo;
        }
        return this;
    };

    CategoryAxis.prototype.supportFixedLayout = true;
    ChartNavigator.register(ChartConstants.CATEGORYAXIS_NAVIGATOR, null, ItemNavigator);
    return CategoryAxis;

});

define('sap/viz/chart/components/plots/XYPlotFactory',[
], function(
) {
    var plotMapping = {};
    return {
        getPlotClazz: function(renderType) {
            var config = plotMapping[renderType];
            return config && config.plotClazz;
        },
        registerClazz: function(renderType, plotClazz){
            plotMapping[renderType] = {plotClazz: plotClazz};
        }
    };

});

define('sap/viz/chart/components/zoom/ZoomLimit',[], function() {
    var bar_pattern = /(bar|column|combination|bullet|waterfall)/;
    var isBar = bar_pattern.test.bind(bar_pattern);

    function Bar(modules, dir) {
        var plot = modules.plot,
            isHorizontal = plot.isHorizontal(),
            props = plot._properties,
            sizeRef = isHorizontal ? "height" : "width",
            max, extendRealSize;
        var baseSize = plot.getSize()[sizeRef];
        //For timeseries chart, when set plotArea.window.start and plotArea.window.end,
        //it may need extend domain. In this case, the extendSize may be larger.
        extendRealSize = modules.main._isTruncatedWindowInput ? 
            plot.getRealSize()[sizeRef] : 0;
        max = (Math.max(plot.getRealSizeByFixedDPSize(props.get("dataPointSize.max")), 
            extendRealSize)) / baseSize;

        return [1, Math.max(max, 1)];
    }

    function Regular(modules, dir) {
        var components = dir.split("").reduce(function(list, d) {
                return list.concat(modules.axisByDirection[d]);
            }, []),
            compo_max = components.map(function(compo) {
                return compo ? compo.getMaxZoomRatio() : Number.MAX_VALUE;
            });
        return [1, Math.max(Math.min.apply(null, compo_max), 1)];
    }

    return {
        Bar: Bar,
        Regular: Regular,
        byChart: function(modules, dir) {
            var fn = isBar(modules.main._renderType) ? Bar : Regular;
            return fn(modules, dir);
        }
    };
});

define('sap/viz/chart/components/zoom/XYZoomer',[
    "sap/viz/chart/components/zoom/ZoomLimit",
    "sap/viz/framework/interaction/utils/PlotZoomUtils",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/framework/common/util/Constants'
], function(
    ZoomLimit,
    PlotZoomUtils,
    UADetector,
    TypeUtils,
    Constants
) {
    var ZOOM_RESET_PROPS = [
        "plotArea.isFixedDataPointSize",
        "interaction.zoom.direction",
        "interaction.zoom.enablement",
        "plotArea.gap",
        "plotArea.markerRenderer",
        "plotArea.dataLabel.renderer",
        "plotArea.lineRenderer",
        "plotArea.line.lineRenderer",
        "plotArea.window.start",
        "plotArea.window.end",
        "plotArea.dataPointSize",
        "general.groupData",
        "interaction.syncValueAxis",
        "interaction.noninteractiveMode",
        "timeAxis.interval",
        "plotArea.scrollbar.visible",
        "plotArea.series"
    ];

    function XYZoomer(plotArea) {
        var runtime = plotArea.runtime();
        this._runtime = runtime;
        this._props = runtime.propertyManager().proxy("interaction.zoom");
        this._status = runtime.statusManager();
        this._limit = {
            x: {},
            y: {}
        };

        this._status.add({
            "plot.zoom.direction": {
                readonly: true,
                serializable: false,
                get: this.direction.bind(this)
            },
            "plot.zoom.enabled": {
                readonly: true,
                serializable: false,
                get: this.enabled.bind(this)
            },
            "plot.zoom.limit": {
                readonly: true,
                serializable: false,
                get: this.limits.bind(this)
            },
            "plot.zoom.currentZoomLevel": {
                readonly: true,
                serializable: false,
                get: this.calcCurrentZoomLevel.bind(this)
            }
        });
        var that = this;
        function __discardSavedZoom(newVal, oldVal) {
            if (newVal !== oldVal) {
                that._status.set('zooming', false);
                runtime.fireInteractionEvent("discardSavedZoom");
            }
        }
        this._watchers = ZOOM_RESET_PROPS.map(function(p) {
            return runtime.propertyManager().watch(p, __discardSavedZoom);
        });

        //when change the level, discard the zoom and going back to global view
        function __discardSavedZoomForTimeLevels(newVal, oldVal) {
            var supportTimeseries = [
                "timeseries_column",
                "timeseries_line",
                "timeseries_combination",
                "timeseries_bullet"
            ];
            if (!TypeUtils.equals(newVal, oldVal) && supportTimeseries.indexOf(plotArea._renderType) > -1) {
                that._status.set('zooming', false);
                runtime.fireInteractionEvent("discardSavedZoom");
            }
        }

        this._watchers.push(runtime.propertyManager().watch("timeAxis.levels", 
            __discardSavedZoomForTimeLevels));
    }

    XYZoomer.prototype.calcCurrentZoomLevel = function() {
        return PlotZoomUtils._calcCurrentZoomLevel(this._status);
    };

    XYZoomer.prototype.enabled = function() {
        switch (this._props.get("enablement")) {
            case "enabled":
                return true;
            case "auto":
                return UADetector.isMobile();
            default:
                return false;
        }
    };

    XYZoomer.prototype.direction = function() {
        if (!this.enabled()) {
            return "";
        }
        switch (this._props.get("direction")) {
            case "all":
                return "xy";
            case "categoryAxis":
                return this._modules.isHorizontal ? "y" : "x";
            default:
                return "";
        }
    };

    XYZoomer.prototype.limits = function() {
        return this._limit;
    };

    XYZoomer.prototype.init = function(modules) {
        this._modules = modules;
    };

    XYZoomer.prototype.destroy = function() {
        this._status.remove("plot.zoom.enabled");
        this._status.remove("plot.zoom.direction");
        this._status.remove("plot.zoom.limit");
        this._status.remove("plot.zoom.currentZoomLevel");
        this._watchers.forEach(function(w) {
            w.remove();
        });
        this._watchers = [];
        this._plotNode = null;
    };

    XYZoomer.prototype.reset = function(selections) {
        this._plotNode = selections.plot.node().querySelector("." + PlotZoomUtils.ZOOM_CONTAINER_CLASS);
        if (this.enabled()) {
            this._limit = this._calcZoomLimit(this._modules, this.direction());
        }
    };

    XYZoomer.prototype.zoom = function(ratio, pos, nSteps, minOffset, ignore) {
        if (!ignore) {
            PlotZoomUtils.applyZoom(ratio, pos, this._plotNode, this._status, this._runtime, nSteps, minOffset);
        } else {
            PlotZoomUtils.applyZoom(ratio, pos, this._plotNode, this._status, null, nSteps, minOffset);
        }
    };

    XYZoomer.prototype.zoomInOut = function(inOut, pos, nSteps, minOffset) {
        var r0 = this._status.get("plot.transform.scale"),
            limits = this.limits();
        if (!nSteps) {
            nSteps = Constants.ZOOM.DEFAULT_ZOOM_LEVEL_STEPS;
        }
        if (!minOffset) {
            minOffset = Constants.ZOOM.DEFAULT_ZOOM_LEVEL_MINOFFSET;
        }
        var r1 = PlotZoomUtils.zoomInOut(inOut, r0, limits, nSteps, minOffset);
        this.zoom(r1, pos, nSteps, minOffset);
    };

    XYZoomer.prototype._calcZoomLimit = function(mod, dir) {
        var limit = {
                x: {},
                y: {}
            },
            perRule = ZoomLimit.byChart(mod, dir);
        limit.x.min = perRule[0];
        limit.x.max = perRule[1];
        limit.y.min = perRule[0];
        limit.y.max = perRule[1];
        return limit;
    };

    return XYZoomer;
});

define('sap/viz/chart/components/datalabels/DataLabels',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ColorUtils",
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DOM',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/format/FormatManager",
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/chart/components/UIComponent',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/components/util/ColorUtil",
    "sap/viz/framework/common/util/RuleUtil",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/FiscalUtil',
    "sap/viz/framework/common/util/GeometryUtils",
    "sap/viz/framework/common/lang/LangManager"
], function (oo,
    TypeUtils,
    ColorUtils,
    SVG,
    DOM,
    DataGraphics,
    Constants,
    FormatManager,
    UnitFormat,
    UIComponent,
    DataPointUtils,
    ColorUtil,
    RuleUtil,
    ObjectUtils,
    FiscalUtil,
    GeometryUtils,
    langManager) {

    function defaultRenderer(config) {
        var text = SVG.create("text");
        text.textContent = config.text;
        DataGraphics.setCustomizationInfo(text, {'defaultRenderer' : true});
        return text;
    }

    defaultRenderer.expose = {
        renderer: defaultRenderer
    };
    var CSSCLASS = Constants.CSS.CLASS;

    var DATA_LABEL_CLASS = Constants.CSS.CLASS.DATALABEL + " " + Constants.CSS.CLASS.MORPHABLELABEL,
        DATA_LABELS_GROUP_CLASS = Constants.CSS.CLASS.DATALABEL_GROUP,
        DATA_LABELS_GROUP_TAG = "g";

    /**
     * Get the combined property for a data point using properties and semantic properties
     *
     * @param ctx data point context
     * @param prop property as defined in chart's properties
     * @param semantic manager
     * @Param additional binding measure values in the same flat table row
     *
     * @return property value created from using matched semantic properties to override defined properties
     */
    function combinePropWithRule(ctx, prop, semanticMgr, additionCtx) {

        var ruleProp = semanticMgr.analyzeDataPointDataLabel(ctx, additionCtx),
            combined = ObjectUtils.extend(true, {}, prop);
        if (ruleProp && ruleProp.hasOwnProperty("dataLabel")) {
            // Adopt the dataLabel config object, works but not in requirement
            // combined = Objects.extend(true, combined, ruleProp.dataLabel);
            if (ruleProp.dataLabel instanceof Object && ruleProp.dataLabel.hasOwnProperty(
                "visible")) {
                combined.visible = ruleProp.dataLabel.visible;
            } else {
                combined.visible = !!ruleProp.dataLabel;
            }
        }
        return combined;
    }


    var DataLabels = function(runtime, options) {
        DataLabels.superclass.constructor.apply(this, arguments);

        this._options = options;
        this._labelPosition = "up";
        this._horizontal = options.horizontal;
        this._ignoreEmptyDataLabel = false;
        this._isTrellis = false;
        this._trellisCellSize = null;
        this._trellisPadding = null;
    };
    oo.extend(DataLabels, UIComponent);

    DataLabels.prototype.setDataShapesGroupNode = function(value) {
        this._dataShapesGroupNode = value;
    };

    DataLabels.prototype._getDataLabelInfo = function(node) {
        var dataModel = this._data && this._data.rawData && this._data.rawData.dataModel;
        var ctx = DataPointUtils.getContextByDataModel(node, dataModel);
        return {
            key: ctx.measureNames,
            value: ctx[ctx.measureNames]
        };
    };

    DataLabels.prototype._processDataLabelRendererConfig = function(config, node) {
        var shapeBBox = config.dpBBox || GeometryUtils.getBBox(node);
        config.dataPointWidth = shapeBBox.width;
        config.dataPointHeight = shapeBBox.height;
    };

    DataLabels.prototype._getMarkFromNode = function(node) {
        return null;
    };

    DataLabels.prototype._getDataLabelSizeFromMark = function (mark) {
        if (!mark) {
            return null;
        }

        var bbox = GeometryUtils.getBBox(mark);

        return {
            width: bbox.width,
            height: bbox.height
        };
    };

    DataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition,
        labelBBox, config, node) {
        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;

        if (labelPosition === "up" || labelPosition === "down" ||
            labelPosition === "inside") {
            x = (nodeX + shapeBBox.width / 2) -
                (labelBBox.x + labelBBox.width / 2);
            if (labelPosition !== "inside") {
                y = nodeY - (labelBBox.y + labelBBox.height);
                if (labelPosition === "down") {
                    y += shapeBBox.height;
                }
            }
        }

        if (labelPosition === "left" || labelPosition === "right" ||
            labelPosition === "inside") {
            y = (nodeY + shapeBBox.height / 2) -
                (labelBBox.y + labelBBox.height / 2);
            if (labelPosition !== "inside") {
                x = nodeX - (labelBBox.x + labelBBox.width);
                if (labelPosition === "right") {
                    x += shapeBBox.width + labelBBox.width;
                }
            }
        }
        return [x, y];
    };

    DataLabels.prototype.needForceInner = function (labelPosition) {
        return true;
    };

    DataLabels.prototype._forceInner= function(locationArray, labelBBox, labelPosition, config) {
        //force data label is displayed in the plot.
        //BITSDC1-7704 Improve data label display when it's going to cut off by border
        //BOUND_OFFSET is defined by UX
        var BOUND_OFFSET = Constants.DATALABEL.BOUND_OFFSET;
        var bound = this.getBound();

        //refer to function getDataLabelInfo, labelBBox has offset as well.
        //left: x + labelBBox.x,
        //right: x + labelBBox.x + labelBBox.width,
        //top: y + labelBBox.y,
        //bottom: y + labelBBox.y + labelBBox.height
        //to adjust x offset
        if (locationArray && locationArray.length > 1 && this.needForceInner(labelPosition, config)) {
            if ((locationArray[0] + labelBBox.x + labelBBox.width) > (bound.width + bound.left)) {
                locationArray[0] = (bound.width + bound.left) -
                    BOUND_OFFSET - labelBBox.width - labelBBox.x;
            }
            if ((locationArray[0] + labelBBox.x) < bound.left) {
                locationArray[0] =  bound.left + BOUND_OFFSET - labelBBox.x;
            }

            //to adjust y offset
            if ((locationArray[1] + labelBBox.y + labelBBox.height) > (bound.height + bound.top)) {
                locationArray[1] = (bound.height + bound.top) -
                    BOUND_OFFSET - labelBBox.height - labelBBox.y;
            }
            if ((locationArray[1] + labelBBox.y) < bound.top) {
                locationArray[1] = bound.top + BOUND_OFFSET - labelBBox.y;
            }
        }
    };

    DataLabels.prototype._computeDataLabelTranslate = function(node, ctm,
        labelPosition, labelBBox, config) {
        var locationArray = this._computeDataLabelPosition(ctm, this._fixBBoxWhenInvisible(node,
            config && config.dpBBox), labelPosition, labelBBox,
            config, node);
        this._forceInner(locationArray, labelBBox, labelPosition, config);
        return locationArray;
    };

    /**
     * Fix the bug of method getBBox.
     * When container tag is invisible(eg.width is 0, but height is not 0.),
     * the return value of getBBox is not right(width&height=0).
     *
     */

    DataLabels.prototype._fixBBoxWhenInvisible = function(node, cachedBBox) {
        var org = cachedBBox || GeometryUtils.getBBox(node);
        var shapeBBox = {
            "height": org.height,
            "width": org.width,
            "y": org.y,
            "x": org.x
        };

        //case if there exists clip path, the position of datalabel should be calculated by the bbox of clip path
        var clipPathTag = node.querySelector && node.querySelector(".v-clippath");
        if (clipPathTag) {
            var bBox = GeometryUtils.getBBox(clipPathTag);
            shapeBBox = {
                "height": bBox.height,
                "width": bBox.width,
                "y": bBox.y,
                "x": bBox.x
            };
            if (shapeBBox.height === 0 && shapeBBox.width === 0) {
                shapeBBox.height = clipPathTag.getAttribute("height") != null?
                    +clipPathTag.getAttribute("height"): 0;
                shapeBBox.width = clipPathTag.getAttribute("width") != null?
                    +clipPathTag.getAttribute("width"): 0;
                shapeBBox.x = clipPathTag.getAttribute("x") != null?
                    +clipPathTag.getAttribute("x"): 0;
                shapeBBox.y = clipPathTag.getAttribute("y") != null?
                    +clipPathTag.getAttribute("y"): 0;
            }
        }
        if (shapeBBox.height !== 0 || shapeBBox.width !== 0) {
            return shapeBBox;
        }

        var childNodes = node.childNodes;
        for (var index = 0, len = childNodes.length; index < len; index++) {
            var height = +childNodes[index].getAttribute("height");
            var width = +childNodes[index].getAttribute("width");
            if (height > shapeBBox.height) {
                shapeBBox.height = height;
            }

            if (width > shapeBBox.width) {
                shapeBBox.width = width;
            }
        }
        return shapeBBox;
    };

    DataLabels.prototype._getStyle = function(dp) {
        var data;
        if(dp) {
            data = DataGraphics.getData(dp);
        }
        var props = this._properties;
        var color = ColorUtils.getColorFromEffectManager(props.get('style.color'),
            this._runtime.effectManager(), data ? data.color : "#000000");
        var fill = this.runtime().effectManager().register({
            fillColor: color
        });
        return {
            "fill": fill,
            "font-family": props.get('style.fontFamily'),
            "font-size": props.get('style.fontSize'),
            "font-weight": props.get('style.fontWeight'),
            "font-style": props.get('style.fontStyle'),
            "cssString": "fill:" + fill +
                ";font-family:" + props.get('style.fontFamily') +
                ";font-size:" + props.get('style.fontSize') +
                ";font-weight:" + props.get('style.fontWeight') +
                ";font-style:" + props.get('style.fontStyle') + ";"
        };
    };

    DataLabels.prototype.respectShapeWidth = function(dataLabelInfos) {
        //Overwrite the function in sub-dataLabel classes
    };

    DataLabels.prototype.truncateText = function(dataLabelInfos) {
        //if bar/dual_bar use "valueAndColor", "color" as type,
        //we may need to truncateText
    };

    DataLabels.prototype.sortDataLabelInfos = function(dataLabelInfos) {
        dataLabelInfos.sort(function (a, b) {
            var result = 0;
            if (a.dataPoint && b.dataPoint) {
                //"dataPoint is undefined" means total label for flexible stack.
                result = DataPointUtils.getDataId(a.dataPoint) - DataPointUtils.getDataId(b.dataPoint);
            }
            return result;
        });
    };

    DataLabels.prototype.hideLabelsWhenOutOfPlotArea = function(dataLabelInfos, bound){
        var len = dataLabelInfos.length;
        //detect if datalabel out of the plotarea
        for (var k = 0; k < len; k++) {
            var info = dataLabelInfos[k];
            if (info.left < bound.left || info.right > bound.width || info.top < bound.top || info.bottom >
                bound.height) {
                info.skip = true;
            }
        }
    };

    DataLabels.prototype.getBound = function(){
        return {
            left: 0,
            width: this._realSize.width,
            top: 0,
            height: this._realSize.height
        };

    };

    DataLabels.prototype.hideConditional = function(dataLabelInfos) {
        var bound = this.getBound();
        this.sortDataLabelInfos(dataLabelInfos);
        this.hideLabelsWhenOutOfPlotArea(dataLabelInfos, bound);
        this.detectAndRemoveOverlappedDataLabel(dataLabelInfos);
    };

    DataLabels.prototype.detectAndRemoveOverlappedDataLabel = function(dataLabelInfos){
        var fontSize = parseFloat(this._properties.get('style.fontSize'));
        var horizontalPadding = fontSize * Constants.DATALABEL.HORIZONTAL_OVERLAPPING_PADDING;
        var len = dataLabelInfos.length;
        var i;
        var j;
        //O(n^2) overlapping detection
        for (i = len - 1; i >= 0; --i) {
            var src = dataLabelInfos[i];
            if (src.skip) {
                continue;
            }
            for (j = i - 1; j >= 0; --j) {
                var dest = dataLabelInfos[j];
                if (!dest.skip) {
                    dest.skip = !((src.left >= (dest.right + horizontalPadding)) ||
                                  (src.top >= dest.bottom) ||
                                  (src.right <= (dest.left - horizontalPadding)) ||
                                  (src.bottom <= dest.top));
                }
            }
        }

        for (i = dataLabelInfos.length - 1; i >= 0; i--) {
            if (dataLabelInfos[i].skip) {
                DOM.remove(dataLabelInfos[i].node);
                dataLabelInfos.splice(i, 1);
            }
        }
    };

    DataLabels.prototype.isDataLabelWidthOutOfDataPoint = function(dataLabelNode,
        dataPointNode) {
        var outOfDataPoint = true;
        var dataLabelBBox = dataLabelNode.getBoundingClientRect();
        var dataPointBBox = dataPointNode.getBoundingClientRect();

        if ((dataLabelBBox.left >= dataPointBBox.left) &&
            (dataLabelBBox.right <= dataPointBBox.right)
        ) {
            outOfDataPoint = false;
        }

        return outOfDataPoint;
    };
    DataLabels.prototype._isKeepMND = function(){
        return true;
    };

    DataLabels.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var outOfDataPoint = true,
            dataLabelBBox = dataLabelNode.getBoundingClientRect(),
            dataPointBBox = item.dataPoint.getBoundingClientRect();

        if ((dataLabelBBox.left >= dataPointBBox.left) &&
            (dataLabelBBox.top >= dataPointBBox.top) &&
            (dataLabelBBox.right <= dataPointBBox.right) &&
            (dataLabelBBox.bottom <= dataPointBBox.bottom)
        ) {
            outOfDataPoint = false;
        }

        return outOfDataPoint;
    };

    DataLabels.prototype.intersectResult = function(dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint){
        return null;
    };


    DataLabels.prototype.indexOfDataLabelIntersectDataPoints = function(dataLabelBBox,
        dataPointBoxes, allDataPoints, currectDataPoint) {
        var intersectIndex = -1;
        var i;
        //it is used by combinational, it has a special rule
        var obj = this.intersectResult(dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint);

        if(!obj || (!obj.intersected && !obj.hitPoint)) {
            for (i = 0; i < dataPointBoxes.length; i++) {
                //ignore currectDataPoint
                if(allDataPoints[i] !== currectDataPoint) {
                    var dataPointBox = dataPointBoxes[i];
                    if (!(dataLabelBBox.left > dataPointBox.right ||
                        dataLabelBBox.right < dataPointBox.left ||
                        dataLabelBBox.top > dataPointBox.bottom ||
                        dataLabelBBox.bottom < dataPointBox.top)) {
                        intersectIndex = i;
                        break;
                    }
                }
            }
        }

        return intersectIndex;
    };

    DataLabels.prototype._setDataLabelColor = function(item, range, backgroundColor, color, referColor) {
        if(!color || range === 'outside'){
            //dataLabelColor may need to be calculated.
            //check if dataLabel "covers" dataPoint.
            var outOfDataPoint = this.isDataLabelOutOfDataPoint(item.node, item);
            //backcolor is refercolor or backgroundColor
            var backColor = null;
            if(color && range === 'outside' && !outOfDataPoint){
            // process case then customer set a data label color and set "colorRange" to "outside"
                backColor = referColor|| "#000000";
            } else if(!color){
                backColor = (outOfDataPoint ? backgroundColor : referColor) || "#000000";
            }
            if(backColor){
                color = ColorUtil.getDataLabelColor(backColor);
                var fill = this.runtime().effectManager().register({
                    fillColor: color
                });
                item.node.setAttribute("fill", fill);
            }
        }
    };

    DataLabels.prototype.updateColor = function(dataLabelInfos, backgroundColor) {
        var dataLabelColor = this._properties.get('style.color');
        var range = this._properties.get("style.colorRange");
        for (var iG = 0; iG < dataLabelInfos.length; iG++) {
            var item = dataLabelInfos[iG];
            if (item.node) {
                this._setDataLabelColor(item, range, backgroundColor, dataLabelColor, item.referColor);
            }
        }
    };

    DataLabels.prototype.drawZero = function() {
        return true;
    };



    DataLabels.prototype.setTrellisCell = function(cellPadding, cellSize) {
        this._isTrellis = true;
        this._trellisPadding = cellPadding;
        this._trellisCellSize = cellSize;
    };
    DataLabels.prototype.updatePosition = function(selection, dataPoints) {
        var parentNode = selection.node();
        var dataLabelsGroup = parentNode.querySelector("." + DATA_LABELS_GROUP_CLASS);
        var dpMaps = {};
        var lableGroupMaps = {};

        if (dataLabelsGroup) {
            var dataShapesGroupNode =  parentNode.querySelector("g." + CSSCLASS.DATAPOINT_GROUP);
            var updatedDpIds = [];
            var dataLabelsNode = dataLabelsGroup.querySelectorAll(".v-datalabel");
            for (var i = 0, len = dataLabelsNode.length; i < len; i++) {
                var dataLabelGroup = dataLabelsNode[i];
                var dataLabelId = DataGraphics.getData(dataLabelGroup).id;
                var dp = DataPointUtils.find(dataShapesGroupNode, dataLabelId);
                if (!dp){
                    DOM.remove(dataLabelGroup);
                    continue;
                }
                var datapointId = DataPointUtils.getDataPointId(dp);
                var dataLabelStyle = this._getStyle(dp);
                updatedDpIds.push(dataLabelId);
                var dataLabelCtx = DataPointUtils.getContext(dp),
                    dataLabelInfo = this._getDataLabelInfo(dp),
                    dataLabelText = d3.select(dataLabelGroup).text();
                var config = {
                    dataLabelInfo: dataLabelInfo,
                    val: dataLabelInfo.value,
                    text: dataLabelText,
                    ctx: dataLabelCtx,
                    styles: dataLabelStyle,
                    horizontal: this._horizontal,
                    plotSize:this.getSize()
                };

                if (this.getDataLabelDefaultPosition){
                    this.getDataLabelDefaultPosition(dp);
                }
                this._processDataLabelRendererConfig(config, dp);
                dpMaps[datapointId] = config;

                var labelBBox = GeometryUtils.getBBox(dataLabelGroup);

                var labelTranslate = this._computeDataLabelTranslate(dp,
                    SVG.getTransformToElement(dp, parentNode), this._labelPosition,
                    labelBBox, config);
                if (labelTranslate) {
                    lableGroupMaps[datapointId] = {trans: labelTranslate, bbox : labelBBox};
                    var x = labelTranslate[0],
                        y = labelTranslate[1];
                    dataLabelGroup.setAttribute("transform", "translate(" + x + "," + y + ")");
                } else {
                    DOM.remove(dataLabelGroup);
                    continue;
                }
            }
            if (dataPoints) {
                var newDatapoints = dataPoints.filter(function(dp) {
                    return updatedDpIds.indexOf(DataPointUtils.getDataId(dp)) === -1;
                });
                if (newDatapoints.length) {
                    var filteredDataPoints = this._beforeRender(newDatapoints);
                    this._render(selection, filteredDataPoints);
                }
            }
        }
        this._afterRender(selection, dpMaps, lableGroupMaps);

    };

    DataLabels.prototype._removeExtraNodes = function(selection){
        var node = selection.node();
        var dataLabelsGroup = node.querySelector("." + DATA_LABELS_GROUP_CLASS);
        if(dataLabelsGroup){
            var dataPointG = node.querySelector("g." + CSSCLASS.DATAPOINT_GROUP);
            var allDataPoints = DataPointUtils.findAll(dataPointG);
            var existDataLabelNodes = dataLabelsGroup.querySelectorAll("." + Constants.CSS.CLASS.DATALABEL);
            var labelIdMap = {};
            var i, len;
            for(i = 0; i < existDataLabelNodes.length; ++i){
                labelIdMap[DataPointUtils.getDataPointId(existDataLabelNodes[i])]= existDataLabelNodes[i];
            }
            for(i = 0; i < allDataPoints.length; ++i){
                var datapointId = DataPointUtils.getDataPointId(allDataPoints[i]);
                if(labelIdMap[datapointId]){
                    delete labelIdMap[datapointId];
                }
            }

            for(var item in labelIdMap){
                if(labelIdMap[item]){
                    dataLabelsGroup.removeChild(labelIdMap[item]);
                }
            }
        }

    };


    DataLabels.prototype.render = function(selection, dataPoints) {
        this._removeExtraNodes(selection);
        dataPoints =  dataPoints || DataPointUtils.findAll(this._dataShapesGroupNode) || [];
        var filteredDataPoints = this._beforeRender(dataPoints);
        this._render(selection, filteredDataPoints);
        this._afterRender(selection);
    };

    DataLabels.prototype._beforeRender = function(dataPoints) {
        var dataLabelProps = this._properties.get();
        var semanticMgr = this.runtime().semanticManager();

        var filteredDataPoints;
        if (semanticMgr.hasDataPointDataLabelStyle()) {
            var dataModel = this._data.rawData.dataModel;
            filteredDataPoints = Array.prototype.slice.call(dataPoints)
                .filter(function(dp) {
                    var id = DataPointUtils.getDataPointId(dp);
                    var dataPoint = dataModel.getDataPoint(id);
                    return combinePropWithRule(dataPoint.context(),
                        dataLabelProps, semanticMgr, dataPoint.additionCtx()).visible;
                });
        } else {
            if (dataLabelProps.visible) {
                filteredDataPoints = dataPoints;
            }
        }
        return filteredDataPoints;
    };

    DataLabels.prototype._afterRender = function(selection, dpMaps, lableGroupMaps) {
        var visible = this._isVisible();
        if (!visible && !this.runtime().semanticManager().hasDataPointDataLabelStyle()) {
            return;
        }
        var dataLabelInfos = [];
        var parentNode = selection;
        var dataPointsNode = selection.node().querySelectorAll("." + Constants.CSS.CLASS.DATAPOINT);
        for (var i = 0; i < dataPointsNode.length; i++) {
            var dp = dataPointsNode[i];
            var dataLabelStyle = this._getStyle(dp);
            var datapointId = DataPointUtils.getDataPointId(dp);
            var dataLabelGroup = selection.selectAll("g.v-datalabel[data-datapoint-id='" + datapointId + "']").node();
            if (dataLabelGroup) {
                var config = dpMaps && dpMaps[datapointId];
                var dataLabelInfo;
                if(!config){
                    var dataLabelCtx = DataPointUtils.getContext(dp),
                    dataLabelText = d3.select(dataLabelGroup).text();
                    dataLabelInfo = this._getDataLabelInfo(dp);

                    config = {
                        val: dataLabelInfo.value,
                        text: dataLabelText,
                        ctx: dataLabelCtx,
                        styles: dataLabelStyle,
                        horizontal: this._horizontal,
                        plotSize:this.getSize(),
                        zeroLineAdjust:true
                    };

                    if (this.getDataLabelDefaultPosition) {
                        this.getDataLabelDefaultPosition(dp);
                    }

                    this._processDataLabelRendererConfig(config, dp);
                }else{
                    dataLabelInfo = config.dataLabelInfo;
                }
                var labelTranslate = lableGroupMaps && lableGroupMaps[datapointId] &&
                                         lableGroupMaps[datapointId].trans;
                var labelBBox  = lableGroupMaps && lableGroupMaps[datapointId] &&
                                    lableGroupMaps[datapointId].bbox;
                if(!labelTranslate){
                    labelBBox = GeometryUtils.getBBox(dataLabelGroup);
                    labelTranslate = this._computeDataLabelTranslate(dp,
                        SVG.getTransformToElement(dp, parentNode.node()), this._labelPosition,
                        labelBBox, config);
                }
                if (labelTranslate) {
                    dataLabelInfos.push(getDataLabelInfo(parentNode.node(), dataLabelGroup,
                        dp, labelTranslate, dataLabelInfo, labelBBox));
                }
            }
        }

        if (dataLabelInfos) {
            this.truncateText(dataLabelInfos);
            var hideWhenOverlap = this._properties.get('hideWhenOverlap');
            if (hideWhenOverlap) {
                this.hideConditional(dataLabelInfos, dataPointsNode);
            }
            var parentNodeDOM = selection.node();
            var backgroundColor = ColorUtil.getBackgroundColor(parentNodeDOM);
            //change data label color according to referColor
            this.updateColor(dataLabelInfos, backgroundColor);

            //draw data label line. Pie chart may have data label line.
            this.renderDataLabelLine(dataLabelInfos);
        }
    };

    DataLabels.prototype.renderDataLabelLine = function (dataLabelInfos) {
    };

    DataLabels.prototype._render = function(selection, dataPoints) {
        var parentNodeDOM = selection.node();
        var size = this._size;
        var props = this._properties;
        var showDataLabel = props.get('visible');
        if (!showDataLabel && this.runtime().semanticManager().hasDataPointDataLabelStyle()) {
            showDataLabel = dataPoints.length > 0;
        }

        if (showDataLabel) {
            var bKeepMND = this._isKeepMND();
            var dataLabelsGroup = parentNodeDOM.querySelector("." + DATA_LABELS_GROUP_CLASS);
            if(!dataLabelsGroup){
                dataLabelsGroup = SVG.create(DATA_LABELS_GROUP_TAG, parentNodeDOM);
                dataLabelsGroup.setAttribute("class", DATA_LABELS_GROUP_CLASS);
            }

            var textAnchor = null;
            var envManager = this.runtime().envManager();
            if (envManager) {
                textAnchor = envManager.textAnchor();
            }
            dataLabelsGroup.setAttribute("text-anchor", textAnchor);

            var labelRenderer = props.get('renderer') || defaultRenderer;
            var hideWhenOverlap = props.get('hideWhenOverlap');
            var formatPatterns;

            var existDataLabelNodes = dataLabelsGroup.querySelectorAll("." + Constants.CSS.CLASS.DATALABEL);

            var dynamicScale = this._runtime.statusManager().get("dynamicScale");
            var units = this.runtime().statusManager().get("data.unit") || {};

            for (var i = 0, len = dataPoints.length; i < len; i++) {
                var dp = dataPoints[i];
                var dataLabelStyle = this._getStyle(dp);
                var dataLabelInfo = this._getDataLabelInfo(dp);
                var isMetaDataFormat = false;
                formatPatterns = props.get('formatString');

                if (!formatPatterns && this._data && this._data.rawData) {
                    formatPatterns = this._formatStrFromMetadata(this._data,
                        this._data.rawData.dataModel._bindingFeeds, dataLabelInfo.key);
                    isMetaDataFormat = true;
                }

                var dataLabelCtx = DataPointUtils.getContext(dp);
                var unit = units[dataLabelInfo.key];
                dataLabelInfo.unit = unit;
                dataLabelInfo.keepMND = bKeepMND;
                dataLabelInfo.dynamicScale = dynamicScale;

                var dataLabelText = this._buildDataLabelText(
                    formatPatterns,
                    dataLabelInfo,
                    dataLabelCtx,
                    isMetaDataFormat,
                    dp
                );

                if(this._ignoreEmptyDataLabel === true && (dataLabelText === null || dataLabelText === undefined)){
                    continue;
                }
                if(TypeUtils.isExist(dataLabelText) && TypeUtils.isExist(dataLabelText.text)) {
                    //dataLabelText is a object. Use string and record formattedValue.
                    dataLabelInfo.formattedValue = dataLabelText.formattedValue;
                    dataLabelText = dataLabelText.text;
                }

                var datapointId = DataPointUtils.getDataPointId(dp);
                var dataLabelGroup =  DataPointUtils.findByDataPointIds(existDataLabelNodes, datapointId);
                if (dataLabelGroup.length){

                    dataLabelGroup = dataLabelGroup[0];
                    //reset dom structure
                    var child = dataLabelGroup.firstChild;
                    while(child){
                        dataLabelGroup.removeChild(child);
                        child = dataLabelGroup.firstChild;
                    }
                } else {
                    dataLabelGroup = SVG.create("g", dataLabelsGroup);
                    DataPointUtils.setDataPointId(dataLabelGroup, datapointId);
                    DataGraphics.setContext(dataLabelGroup, dataLabelCtx);
                    DataGraphics.setData(dataLabelGroup, {
                        "id": DataPointUtils.getDataId(dp)
                    });
                    dataLabelGroup.setAttribute("class", DATA_LABEL_CLASS);
                }

                if (!dataLabelCtx) {
                    dataLabelCtx = this._data.rawData.dataModel.getDataPoint( datapointId ).context();
                }
                var config = {
                    val: dataLabelInfo.value,
                    text: dataLabelText,
                    ctx: dataLabelCtx,
                    info: dataLabelInfo,
                    styles: dataLabelStyle,
                    horizontal: this._horizontal,
                    // both _processDataLabelRendererConfig and _fixBBoxWhenInvisible need dpBBox,
                    // so calculate it for only one time here
                    dpBBox: GeometryUtils.getBBox(dp),
                    plotSize: this.getSize(),
                    zeroLineAdjust:true
                };

                this._processDataLabelRendererConfig(config, dp);

                var labelContentNode = labelRenderer(config, defaultRenderer.expose) || defaultRenderer(config);

                if (labelContentNode) {
                    dataLabelGroup.appendChild(labelContentNode);

                    //set group's style after render since custom renderer will customize the style
                    for (var j in config.styles) {
                        if (config.styles.hasOwnProperty(j)) {
                            dataLabelGroup.setAttribute(j, config.styles[j]);
                        }
                    }

                    if (this.getDataLabelDefaultPosition){
                        this.getDataLabelDefaultPosition(dp);
                    }

                    var labelBBox = GeometryUtils.getBBox(dataLabelGroup);
                    var ctm = SVG.getTransformToElement(dp, parentNodeDOM);
                    var labelTranslate = this._computeDataLabelTranslate(dp, ctm, this._labelPosition,
                            labelBBox, config);

                    this._renderAfterPositioning(dp, dataLabelGroup);

                    if (!labelTranslate) {
                        dataLabelGroup.removeChild(labelContentNode);
                        continue;
                    }
                    var x = labelTranslate[0];
                    var y = labelTranslate[1];
                    dataLabelGroup.setAttribute("transform", "translate(" + x + "," + y + ")");

                     // specify for pie and dount
                    if(this.setExtraDataOfDataPoint){
                        dp = this.setExtraDataOfDataPoint(DataGraphics, dp, dataLabelGroup);
                    }
                }
            }

        }else{
            //  remove the decoras of data point, current it only supports pie and donut chart.
            //  for other info chart, add the function also.
            if (this.removeExtraDataOfDataPoint  && dataPoints) {
                for (var m = 0, length = dataPoints.length; m < length; m++) {
                    var datapoint = dataPoints[m];
                    this.removeExtraDataOfDataPoint(DataGraphics, datapoint);
                }
            }
        }
    };

    /*
    * Get formatString from metadata
    * @param dataset
    * @param [String] bindings for example:["valueAxis", "valueAxis2", "color", "shape"]
    * @param String value id
    * @return String formatString
    */
    DataLabels.prototype._formatStrFromMetadata = function(dataset, bindings, key) {
        var formatStr = null;
        if (bindings) {
            bindings.some(function(value) {
                if(dataset[value] && dataset[value].metaData){
                    for(var i = 0; i < dataset[value].metaData.length; i++) {
                        if (dataset[value].metaData[i].id === key) {
                            formatStr = dataset[value].metaData[i].formatString;
                            return true;
                        }
                    }
                }
            });
        }
        return formatStr;
    };

    DataLabels.prototype._renderAfterPositioning = function(){
    };

    /*
    * Build data label text
    * @getTypesFn {Function}
    *       Get valid types from property "plotArea.dataLabel.type" and split types into array.
    *       Overwrite by BarDataLabels, BubbleDataLabels, PieDataLabels, PercentageDataLabelUtil.
    * @mergeDataLabelsFn {Function}
    *       Merge formatted datalabels according to type.
    *       Overwrite by BarDataLabels, BubbleDataLabels, PieDataLabels, PercentageDataLabelUtil.
    * @buildDataLabelAdditionalTextFn {Function}
    *       Build data label context when type is "color" or "shape".
    *       Overwrite by BarDataLabels, BubbleDataLabels, PieDataLabels.
    */
    DataLabels.buildDataLabelText = function(properties, formatPatterns, dataLabelInfo, dataLabelCtx, isMetaDataFormat,
        getTypesFn, mergeDataLabelsFn, buildDataLabelAdditionalTextFn) {
        //adapt every type of datalabel.formatString to array
        var formatPatternArray = (dataLabelInfo.value !== null && formatPatterns !== null) ?
            toFormatPatternArray(formatPatterns, dataLabelInfo) : [];

        //default type is  ['value'].
        var types = getTypesFn ? getTypesFn(properties) : ['value'];

        //If using metaData format, consider first item of array as 'value', second as 'percentage'
        formatPatternArray = isMetaDataFormat ? adaptMetadataFormat(formatPatternArray, types) : formatPatternArray;

        var formattedArray = formatDataLabel(types, formatPatternArray, dataLabelCtx, dataLabelInfo, properties,
            buildDataLabelAdditionalTextFn);

        //merge datalabels according to datalabel.type.
        var dataLabelText = mergeDataLabelsFn ? mergeDataLabelsFn(properties, formattedArray, dataLabelInfo) :
                formattedArray[0];

        return dataLabelText;
    };

    DataLabels.prototype._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx,
        isMetaDataFormat, dp) {
        if (dataLabelInfo.value === 0 && !this.drawZero(dp)) {
            return null;
        }
        return DataLabels.buildDataLabelText(
            this._properties,
            formatPatterns,
            dataLabelInfo,
            dataLabelCtx,
            isMetaDataFormat
        );
    };

    DataLabels.prototype._isVisible = function() {
        return this._properties.get('visible') || this._properties.get('showTotal') ||
            this._properties.get('showRecap');
    };

    function toFormatPatternArray(formatPatterns, dataLabelInfo) {
        var formatPatternArray = [];
        if (TypeUtils.isArray(formatPatterns) && TypeUtils.isArray(formatPatterns[0])) {
            //handle the two dimension array
            formatPatternArray = formatPatterns[0];
        } else if (TypeUtils.isPlainObject(formatPatterns)) {
            //handle object when value is array and is not array
            formatPatternArray = formatPatterns[dataLabelInfo.key];
            if (!TypeUtils.isArray(formatPatternArray)) {
                formatPatternArray = [formatPatternArray];
            }
        } else if (!TypeUtils.isArray(formatPatterns)) {
            //handle string
            formatPatternArray = [formatPatterns];
        } else {
            //handle one dimension array
            formatPatternArray = formatPatterns;
        }
        return formatPatternArray;
    }

    function formatDataLabel(types, formatPatterns, ctx, dataLabelInfo, properties,
        buildDataLabelAdditionalTextFn) {
        var i, formatPattern, dataLabelText, dataLabelPercentage, type, formattedValues = [];
        var additionCounts = 0;
        for (i = 0; i < types.length; i++) {
            type = types[i];

            //needFormat true will always format text even if current formatPattern is undefined.
            if (needFormat(type)) {
                dataLabelText = dataLabelInfo.value;
                dataLabelPercentage = dataLabelInfo.percentage;
                formatPattern = formatPatterns[i - additionCounts];
                var dynamicFactor;
                var dynamicScale = dataLabelInfo.dynamicScale;

                if (dataLabelText !== null) {
                    if (type === 'date') {
                        if (FiscalUtil.hasFiscalLevel(properties && properties.origin)) {
                            //no format for fiscal
                            dataLabelInfo.formattedValue = dataLabelText;
                        }
                        else {
                            dataLabelInfo.formattedValue = FormatManager.format(new Date(dataLabelText),
                                "dd/mm/yyyy hh:mm");
                        }
                    } else {
                        var options = {
                            decimalFormatString:
                            UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.DATALABEL)
                        };

                        dynamicFactor = dynamicScale && dynamicScale.getScaleFactor(dataLabelInfo.key);

                        var unitFormat = properties.get('unitFormatType');
                        dataLabelInfo.formattedValue = (dynamicFactor || UnitFormat).
                                    format(dataLabelText, formatPattern, unitFormat , options);

                        if(dynamicFactor && dynamicScale.showSymbolOnDatalabel){
                            dataLabelInfo.formattedValue += dynamicFactor.symbol;
                        }
                    }
                } else {
                    dataLabelInfo.formattedValue = langManager.get("IDS_ISNOVALUE");
                }
                if (dataLabelPercentage !== null) {
                    dataLabelInfo.formattedPercentage = UnitFormat.format(dataLabelPercentage,
                        formatPattern || FormatManager.getPercentagePattern(1), properties.get('unitFormatType'),
                        UnitFormat.SUPPORT_CUSTOM_COMPONENTS.DATALABEL);
                }

                if (dataLabelInfo.unit && (!dynamicFactor || dynamicScale.showUnitOnDataLabel)) {
                    dataLabelInfo.formattedValue += " " + dataLabelInfo.unit;
                }
                if (type === 'percentage') {
                    dataLabelText = dataLabelInfo.formattedPercentage;
                } else {
                    dataLabelText = dataLabelInfo.formattedValue;
                }
                formattedValues.push(dataLabelText);
            } else {
                if (buildDataLabelAdditionalTextFn) {
                    formattedValues.push(buildDataLabelAdditionalTextFn(ctx, dataLabelInfo));
                    additionCounts++;
                }
            }
        }
        return formattedValues;
    }

    function adaptMetadataFormat(formatArray, types) {
        var metaDataFormat;
        if (types.indexOf('percentage') > -1 && types.indexOf('value') === -1) {
            //shift the first item of array if type has percentage but no value
            metaDataFormat = [formatArray[1]];
        } else {
            metaDataFormat = formatArray;
        }
        return metaDataFormat;
    }

    function needFormat(type) {
        if (type === 'valueAxis' || type === 'valueAxis2' || type === 'bubbleWidth' || type === 'value' ||
            type === 'percentage' || type === 'date') {
            return true;
        } else {
            return false;
        }
    }

    DataLabels.getFirstFormatPattern = function(formatPatterns, dataLabelInfo) {
        return toFormatPatternArray(formatPatterns, dataLabelInfo)[0];
    };

    DataLabels.prototype.destroy = function() {
        DataLabels.superclass.destroy.call(this);
        this._labelPosition = null;
        this._dataShapesGroupNode = null;
        this._isTrellis = null;
        this._trellisCellSize = null;
        this._trellisPadding = null;
    };

    function getDataLabelInfo(parentNodeDOM, lblNode, dpNode, translate, dataLabelInfo, labelBBox) {
        var x = translate[0],
            y = translate[1];
        var ctm = SVG.getTransformToElement(dpNode, parentNodeDOM);
        var referColor = getReferColor(parentNodeDOM, dpNode);
        return {
            node: lblNode,
            referColor: referColor,
            dataPoint: dpNode,
            center:{
                x: ctm.e,
                y: ctm.f
            },
            info: dataLabelInfo,
            left: x + labelBBox.x,
            right: x + labelBBox.x + labelBBox.width,
            top: y + labelBBox.y,
            bottom: y + labelBBox.y + labelBBox.height,
            originalCenterX: translate.originalCenterX,
            originalCenterY: translate.originalCenterY,
        };
    }

    function getReferColor(parentNodeDOM, dp) {
        var referColor,
            backgroundColor = ColorUtil.getBackgroundColor(parentNodeDOM),
            eData = DataGraphics.getData(dp);
        if (eData) {
            if (eData.pattern === "noFill") {
                referColor = backgroundColor;
            } else {
                var dataPointColorOpacity = 1,
                    dataPointColor = eData.color;
                if (eData.fillOpacity !== undefined) {
                    dataPointColorOpacity = eData.fillOpacity;
                }
                referColor = ColorUtil.getMixedColor(dataPointColor, backgroundColor,
                dataPointColorOpacity);
            }
        }
        return referColor;
    }

    return DataLabels;
});

define('sap/viz/chart/components/datalabels/BarDataLabels',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/DOM",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/datalabels/DataLabels',
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/GeometryUtils",
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/Constants'
], function(
    oo,
    DOM,
    TypeUtils,
    DataGraphics,
    DataLabels,
    TextUtils,
    GeometryUtils,
    UnitFormat,
    SVG,
    Constants
    ) {
    var BarDataLabels = function(ctx, options) {
        BarDataLabels.superclass.constructor.apply(this, arguments);
        // this for combination chart
        this._labelPosition = "outside";
    };

    oo.extend(BarDataLabels, DataLabels);
    var SPLIT_STR = " / ";
    var EMPTY_STR = " ";
    var OMIT_STR = "...";

    //it needs an offset because of the requirment of UX
    BarDataLabels.labelOffset = Constants.DATALABEL.HORIZONTAL_LABEL_OFFSET;

    BarDataLabels.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var outOfDataPoint = true;
        var dataLabelBBox = dataLabelNode.getBoundingClientRect();
        var dataPointBBox = item.dataPoint.getBoundingClientRect();

        if((dataLabelBBox.left >= dataPointBBox.left) && 
           (dataLabelBBox.top >= (dataPointBBox.top - (dataPointBBox.height)) ) && 
           (dataLabelBBox.right <= dataPointBBox.right) && 
           (dataLabelBBox.bottom <= ( dataPointBBox.bottom + (dataPointBBox.height)) )
          ) {
            outOfDataPoint = false;
        }

        return outOfDataPoint;
    };

    BarDataLabels.prototype._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx,
        isMetaDataFormat) {
        return DataLabels.buildDataLabelText(
            this._properties,
            formatPatterns,
            dataLabelInfo,
            dataLabelCtx,
            isMetaDataFormat,
            getTypes,
            mergeDataLabels,
            buildDataLabelAdditionalText
        );
    };

    function getTypes(properties) {
        var type = properties.get('type');
        var result;
        if (type === 'valueAndColor') {
            result = ['value', 'color'];
        } else if (type === 'color') {
            result = ['color'];
        } else {
            //default type is "value"
            result = ['value'];
        }
        return result;
    }

    function buildDataLabelAdditionalText(ctx, dataLabelInfo) {
        /*initialize text with empty string, otherwise, dataLabelObj can not be correctly transformed 
        to a string to display */
        var addtionalText = '';
        if(dataLabelInfo.colorLegendData) {
            addtionalText = dataLabelInfo.colorLegendData.join(SPLIT_STR);
        }
        return addtionalText;
    }

    function mergeDataLabels(properties, formattedArray) {
        var type = properties.get('type');
        var dataLabelText;
        if(type === "valueAndColor") {
            formattedArray = formattedArray.filter(function(item) {
                return !(item === undefined || item === null);
            });
            dataLabelText = formattedArray.slice().reverse().join(EMPTY_STR);
        } else {
            dataLabelText = formattedArray[0];
        }
        var dataLabelObj = {
            formattedValue: formattedArray[0],
            text: dataLabelText
        };
        return dataLabelObj;
    }
    
    function findValues(series, val, axis){
     
        for(var i = 0; i < series.length; ++i){
            var vals = series[i];
            for(var j = 0; vals && j < vals.length; ++j){
                // Process dual axis case
                if(vals[j] && vals[j][axis] === val ){
                    return vals[j];
                }
            }
        }
        
        return null;
    }
    
    BarDataLabels.getLabelSize = function(series, value, properties, formatPatterns, axis){
        var size = {width:0, height:0};
        var sData = findValues(series, value, axis || 'valueAxis');
        if(!sData){
            return size;
        }
        var ctx = sData.dp.context();
        var dataLabelInfo = {key: ctx.measureNames, value: ctx[ctx.measureNames], colorLegendData: sData.color};
        
        var props = properties.proxy('plotArea.dataLabel');
        var maxText = DataLabels.buildDataLabelText(
            props,
            formatPatterns,
            dataLabelInfo,
            null,
            false,
            getTypes,
            mergeDataLabels,
            buildDataLabelAdditionalText
        );

        var dataLabelOpt= props.get("style");
        size = TextUtils.fastMeasure(maxText.text, dataLabelOpt.fontSize, 
                dataLabelOpt.fontWeight, dataLabelOpt.fontFamily, 
                dataLabelOpt.fontStyle);
        size.width += BarDataLabels.labelOffset;
        return size;
    };
    
    BarDataLabels.prototype.truncateText = function(dataLabelInfos) {
        var i;
        for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
            var dataPointNode = dataLabelInfos[i].dataPoint;
            var dataLabelNode = dataLabelInfos[i].node;
            var dataLabelLocation = DataGraphics.getData(dataPointNode).dataLabelLocation;

            if(dataLabelLocation === "inside") {
                var dataLabelBBox = dataLabelNode.getBoundingClientRect();
                var dataPointBBox = dataPointNode.getBoundingClientRect();

                if((dataLabelBBox.width + (2 * BarDataLabels.labelOffset)) > dataPointBBox.width) {
                    var dataLabelProps = this._properties.get();
                    var needTruncation = false;
                    
                    var textNode = dataLabelNode.firstChild;
                    var labelText = textNode.textContent;  
                    var addtionalText = "";
                    if(dataLabelInfos[i].info.colorLegendData) {
                        var minText;
                        //we try to truncate the dataLabel if dataLabelInfos[i] has colorData
                        if(dataLabelProps.type === "valueAndColor") {
                            addtionalText = dataLabelInfos[i].info.colorLegendData.join(SPLIT_STR);
                            minText = labelText.substring(0,1) + OMIT_STR + EMPTY_STR + 
                                    labelText.substring(addtionalText.length + 1);
                        }
                        else if(dataLabelProps.type === "color") {
                            minText = labelText.substring(0,1) + OMIT_STR;
                        }
                                             
                        var minTextLength = TextUtils.canvasMeasure(minText, dataLabelProps.style.fontSize,
                                dataLabelProps.style.fontWeight,  dataLabelProps.style.fontFamily).width;
                        if((minTextLength + (2 * BarDataLabels.labelOffset))< dataPointBBox.width) {
                            needTruncation = true;
                        }
                    }

                    if (needTruncation) {
                        var dataLabelStyle = this._getStyle(dataPointNode);
                        var ellipsisOptions = {};
                        var envManager = this.runtime().envManager();
                        ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

                        if(dataLabelProps.type === "valueAndColor") {
                            var valueText = labelText.substring(addtionalText.length + 1);
                            
                            var valueTextLength = TextUtils.canvasMeasure((EMPTY_STR + valueText), 
                                    dataLabelProps.style.fontSize, dataLabelProps.style.fontWeight, 
                                    dataLabelProps.style.fontFamily).width;
                            
                            var truncatedText = TextUtils.ellipsis(labelText, textNode, 
                                    (dataPointBBox.width - (2 * BarDataLabels.labelOffset) - valueTextLength), 
                                    dataLabelStyle.cssString, ellipsisOptions);
                            textNode.firstChild.textContent = truncatedText + EMPTY_STR + valueText;
                        }
                        else if(dataLabelProps.type === "color") {
                            TextUtils.ellipsis(labelText, textNode, 
                                    (dataPointBBox.width - (2 * BarDataLabels.labelOffset)), 
                                    dataLabelStyle.cssString, ellipsisOptions);
                        }
                        
                        //update dataLabelInfos location
                        var labelBBox = GeometryUtils.getBBox(dataLabelNode);                        
                        var ctm = SVG.getTransformToElement(dataPointNode, dataPointNode.parentNode);
                        var config = {
                                val: dataLabelInfos[i].info.value
                            };
                        var labelTranslate = this._computeDataLabelTranslate(dataPointNode, ctm, dataLabelLocation,
                                labelBBox, config);
                        dataLabelNode.setAttribute("transform", "translate(" + labelTranslate[0] + "," + 
                                labelTranslate[1] + ")");
                        dataLabelInfos[i].left = labelTranslate[0];
                        dataLabelInfos[i].right = dataLabelInfos[i].left + labelBBox.width;
                    }
                }
            }
        }
    };

    BarDataLabels.prototype.allowIntersectionCheck = function() {
        return false;
    };

    BarDataLabels.prototype.hideConditional = function(dataLabelInfos, allDataPoints) {
        var i;
        var dataPointBoxes = new Array(allDataPoints.length);
        for (i = 0; i < allDataPoints.length; i++) {
            dataPointBoxes[i] = allDataPoints[i].getBoundingClientRect();
        }
        
        for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
            var dataPointNode = dataLabelInfos[i].dataPoint;
            var dataLabelNode = dataLabelInfos[i].node;
            var dataLabelLocation = DataGraphics.getData(dataPointNode).dataLabelLocation;
            var dataLabelBBox = dataLabelNode.getBoundingClientRect();

            if(dataLabelLocation === "inside") {
                var dataPointBBox = dataPointNode.getBoundingClientRect();

                if( ((dataLabelBBox.width + (2 * BarDataLabels.labelOffset)) > dataPointBBox.width) ||
                    (dataLabelBBox.height > dataPointBBox.height)
                  ) {
                    //remove the dataLabel
                    DOM.remove(dataLabelNode);
                    dataLabelInfos.splice(i, 1);
                }
            }
            else if (!this.allowIntersectionCheck(dataPointNode)) {
                var iIndex = this.indexOfDataLabelIntersectDataPoints(dataLabelBBox, dataPointBoxes, 
                        allDataPoints, dataPointNode);
                if (iIndex !== -1) {
                    DOM.remove(dataLabelNode);
                    dataLabelInfos.splice(i, 1);
                }
            }
        }
        return BarDataLabels.superclass.hideConditional.apply(this, arguments);
    };

    BarDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox,
                                                            config, node) {
        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;
        
        var exData = DataGraphics.getData(node);

        var labelOffset = BarDataLabels.labelOffset;
        var pPos = this._properties.get("position");
        var position  = pPos ? pPos : this._labelPosition;

        // outside by default
        y = (nodeY + shapeBBox.height / 2) -
            (labelBBox.y + labelBBox.height / 2);
        if (config.val >= 0) {
            if(config.val === 0 || position !== 'inside'){
                x = nodeX + shapeBBox.width + labelOffset;
                exData.dataLabelLocation = (config.val === 0 && position === 'inside') ? 'inside' : 'outside';
                if (x + labelBBox.width > this._size.width && position === "outsideFirst" && config.val > 0) {
                    x = nodeX + shapeBBox.width - labelBBox.width - labelOffset;
                    exData.dataLabelLocation = 'inside';
                    DataGraphics.setData(node, exData);
                }
                if(x > this._size.width && config.val === 0) {
                    x = nodeX - labelBBox.width - labelOffset;
                }
            }else{
                x = nodeX + shapeBBox.width - labelBBox.width - labelOffset;
                
            }
        } else {
            if(position !== 'inside'){
                x = nodeX - (labelBBox.x + labelBBox.width) - labelOffset;
                exData.dataLabelLocation = 'outside';
                if (x < 0 && position === 'outsideFirst') {
                    if(labelBBox.width + 2 * labelOffset > shapeBBox.width){
                        x = x + shapeBBox.width;
                    }else{
                        x = nodeX + labelOffset;   
                        exData.dataLabelLocation = 'inside';
                    }
                    DataGraphics.setData(node, exData);
                }
            }else{

                x = nodeX + labelOffset;
            }
        }
      
        return [x, y];
    };
    
    BarDataLabels.prototype._getDataLabelInfo = function(node) {
        var dataLableInfo;
        dataLableInfo = BarDataLabels.superclass._getDataLabelInfo.apply(this, arguments);
        
        var exData = DataGraphics.getData(node);
        dataLableInfo.colorLegendData = exData.colorLegendData;
        return dataLableInfo;
    };    
    
    BarDataLabels.prototype._processDataLabelRendererConfig = function(config, node) {
        BarDataLabels.superclass._processDataLabelRendererConfig.apply(this, arguments);
        var mark = this._getMarkFromNode(node), size;
        if (mark && config.dataPointWidth === 0 && config.dataPointHeight === 0) {
            size = this._getDataLabelSizeFromMark(mark);
            if (size) {
                config.dataPointWidth = size.width;
                config.dataPointHeight = size.height;
            }
        }

        config.horizontal = true;
    };

    BarDataLabels.prototype._getMarkFromNode = function(node) {
        // by default get the rect size
        if (!node) {
            return null;
        }
        var mark = d3.select(node).select('rect:first-child');
        return mark.empty() ? null : mark.node();
    };

    return BarDataLabels;
});

define('sap/viz/chart/components/plotareas/UpdateByTrendlineUtil',[
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/trendline/Trendline',
    "sap/viz/chart/scales/ValueScaleUtil"
],function(ObjectUtils, Trendline, ValueScaleUtil){
    var TRENDLINE_CHART = {
        column: true,
        bar: true,
        line: true,
        timeseries_column: true,
        timeseries_line: true,
        horizontal_line: true,
        dual_column: true,
        dual_bar: true,
        dual_line: true,
        dual_horizontal_line: true
    };
    return  function(newData, range){
        if(TRENDLINE_CHART[this._renderType]){
            var updatedByTrendline = Trendline.updateValueScale(this._plot, {
                valueAxis: range,
                valueAxis2: range
            }, newData);
            var axisKeys = updatedByTrendline && Object.keys(updatedByTrendline);
            if (axisKeys && axisKeys.length > 0) {
                if(newData.valueAxis && newData.valueAxis2){
                    // update dual chart ticks for zero line
                    var valueAxisData = updatedByTrendline.valueAxis ? 
                                            updatedByTrendline.valueAxis :newData.valueAxis;
                    var valueAxisData2 = updatedByTrendline.valueAxis2 ? 
                                            updatedByTrendline.valueAxis2 : newData.valueAxis2;
                    ValueScaleUtil.syncTicks(valueAxisData.scale, valueAxisData2.scale);
                    var autoScale = valueAxisData.autoScale;
                    var autoScale2 = valueAxisData2.autoScale;
                    ValueScaleUtil.syncTicks(autoScale, autoScale2);
                }
                axisKeys.forEach(function(k) {
                    this["_" + k].setData(updatedByTrendline[k]);
                    newData[k] = ObjectUtils.extend(true, {}, newData[k], updatedByTrendline[k]);
                }, this);
            }
            this._updateTrendLineAxis(newData);
        }
        return newData;
    };
});
define('sap/viz/chart/components/plotareas/XYPlotArea',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/chart/components/callout/CalloutContainer',
    'sap/viz/chart/components/container/XYContainer',
    'sap/viz/chart/components/axis/ValueAxis',
    'sap/viz/chart/components/axis/CategoryAxis',
    'sap/viz/chart/components/plots/PlotHelper',
    'sap/viz/chart/components/plots/XYPlotFactory',
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/chart/components/scrollbar/Scrollbar',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/zoom/XYZoomer',
    "sap/viz/chart/components/plots/PlotGeometryKeeper",
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/datalabels/BarDataLabels',
    'sap/viz/chart/components/plotareas/UpdateByTrendlineUtil',
    'sap/viz/chart/scales/CategoryScale',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/SVG'
], function Setup(
    oo,
    ValueScale,
    ValueScaleUtil,
    CalloutContainer,
    XYContainer,
    ValueAxis,
    CategoryAxis,
    PlotHelper,
    PlotFactory,
    ValueAxisUtils,
    Scrollbar,
    UADetector,
    DataUtils,
    TextUtils,
    XYZoomer,
    PlotGeometryKeeper,
    UnitFormat,
    TypeUtils,
    Constants,
    NumberUtils,
    DataLabels,
    BarDataLabels,
    updatedByTrendline,
    CategoryScale,
    ObjectUtils,
    SVG
){
    
    function offsetInValue(me) {
        var h, v,
            plot = me._plot;
        if (plot.isHorizontal()) {
            // bullet chart has no "valueAxis" scale
            h = (me._renderType.indexOf("bullet") > -1 ? "actualValues" : me._valueAxisIndex);
        } else {
            v = (me._renderType.indexOf("bullet") > -1 ? "actualValues" : me._valueAxisIndex);
        }
        function get() {
            return PlotGeometryKeeper.offsetInValue({
                h: h ? me._data[h].scale : null,
                v: v ? me._data[v].scale : null
            }, me.getOffset(), plot.getRealSize());   
        }
        function set(val) {
            var hscale = me._data[h],
                vscale = me._data[v],
                size = plot.getRealSize(),
                offset = {};
            if(!isNaN(val.x) && hscale) {
                offset.x = -hscale.scale.scale(val.x) * size.width;
            }
            if(!isNaN(val.y) && vscale) {
                offset.y = -(1 - vscale.scale.scale(val.y)) * size.height;
            }
            me.scroll(offset);
        }
        return {
            get: get,
            set: set
        };
    }
    function plotInfo(me){
        function get(){
            var pos = ObjectUtils.clone(me.getPlotPosition(), true);
            if(pos){
                pos.x += (me._offset && me._offset.x) || 0;
                pos.y += (me._offset && me._offset.y) || 0;
            }
            return pos;
        }
        return { get:get}; 
    }
    var XYPlotArea = function(runtime, options) {
        XYPlotArea.superclass.constructor.apply(this, arguments);
        this._valueAxisIndex = options.valueAxisIndex || "valueAxis";
        this._init(undefined, options);
        runtime.statusManager().add("plot.offsetInValue", {
            serializable: false,
            get: offsetInValue(this).get,
            set: offsetInValue(this).set
        });
        runtime.statusManager().add("plot.sizeInfo", {
            serializable: false,
            get: plotInfo(this).get
        });
    };

    oo.extend(XYPlotArea, XYContainer);

    XYPlotArea.prototype._isPercentageChart = function() {
        return (this._renderType.indexOf("100_") >= 0);
    };

    XYPlotArea.prototype._isLineChart = function() {
        return (this._renderType.indexOf("line") >= 0);
    };

    XYPlotArea.prototype._isCombinationChart = function() {
        return (this._renderType.indexOf("combination") >= 0);
    };
    
    XYPlotArea.prototype._isMekkoChart = function() {
        return (this._renderType.indexOf("mekko") >= 0);
    };
    XYPlotArea.prototype._isColumnChart = function(){
        return (this._renderType === "column") || 
            (this._renderType === "combination") || 
            (this._renderType === "timeseries_column");
    };
    
    XYPlotArea.prototype._isBarChart = function(){
        return (this._renderType === "bar") || (this._renderType === "horizontal_combination");
    };
    
    XYPlotArea.prototype._isStackedChart = function(){
        return (this._renderType === "stacked_column") || (this._renderType === "stacked_bar");
    };

    XYPlotArea.prototype._isHorizontal = function(){
        if(this._plot && this._plot._options){
            return this._plot._options.isHorizontal;
        }
    };

    XYPlotArea.prototype._getPlotOptions = function() {
        return {
            valueAxisIndex: this._valueAxisIndex || "valueAxis"
        };
    };

    XYPlotArea.prototype._reRenderComplete = function(){
        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };
    
    XYPlotArea.prototype._getDataRange = function(start, end){
        return this._plot._getDataRange && this._plot._getDataRange(start ,end);    
    };

    XYPlotArea.prototype._initRenderBase = function(rootElement) {
        if (this._selections) {
            return;
        }
        XYPlotArea.superclass._initRenderBase.apply(this, arguments);
        if (this._isLineChart() || this._isCombinationChart()) {
            var rootNode = rootElement.node();
            var refNode = this._selections[this._categoryAxis.getName()].node();
            var dataPointNodes = SVG.createSVGNode("g");
            dataPointNodes.setAttribute('class', Constants.CSS.CLASS.DATAPOINTS_MODULE);
            if (rootNode.lastChild === refNode) {
                rootNode.appendChild(dataPointNodes);
            } else {
                rootNode.insertBefore(dataPointNodes, refNode.nextSibling);
            }
        }
    };
    
    XYPlotArea.prototype._init = function(config) {
        var runtime = this.runtime();
        this._plot = PlotHelper.create(this._renderType, this._getPlotClazz(this._renderType), 
                                        runtime, this._getPlotOptions(this._renderType));
        this.setChild("plot", this._plot, {
            position: "center"
        });
        var isHorizontal = this._plot.isHorizontal();
        this._plot.getDispatch().on("reRenderComplete.plotarea", this._reRenderComplete.bind(this));
        
        var CategoryAxis = this._getCategoryAxisClass();
        var position;

        var isInteractive = !this._properties.get("interaction.noninteractiveMode");
        if (isHorizontal) {
            this.setLayoutSequence(['bottom', 'top', 'left', 'right']);
            this._categoryAxis = new CategoryAxis(runtime, {
                name: "categoryAxis"
            });
            this._categoryAxis.setPosition("left");
            this.setChild("categoryAxis", this._categoryAxis, {
                position: "left"
            });
            
            position = this._valueAxisIndex === "valueAxis" ? "bottom" : "top";
            var hasScrollbar = isInteractive;
            //XYYPlotArea will set scrollbar to value axis2
            if (config) {
                position = config.valueAxisPosition;
                hasScrollbar = config.valueAxisScrollbar;
            }
            this._valueAxis = new ValueAxis(runtime, {
                name: this._valueAxisIndex,
                hasScrollbar: hasScrollbar,
                valueAxes: this._valueAxes
            });
            this.setChild(this._valueAxisIndex, this._valueAxis, {
                position: position
            });

            if (hasScrollbar) {
                this._hScrollbar = this._valueAxis.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
            }
        } else {
            this.setLayoutSequence(['left', 'right', 'bottom', 'top']);
            
            this._categoryAxis = new CategoryAxis(runtime, {
                name: "categoryAxis",
                hasScrollbar:isInteractive
            });
            this.setChild("categoryAxis", this._categoryAxis, {
                position: "bottom"
            });

            position = this._valueAxisIndex === "valueAxis" ? "left" : "right";
            this._valueAxis = new ValueAxis(runtime, {
                name: this._valueAxisIndex,
                valueAxes: this._valueAxes
            });

            this.setChild(this._valueAxisIndex, this._valueAxis, {
                position: position
            });
            
            //if charts have callouts
            if(this._properties.get("plotArea.callout.left")) {
                this._leftCallouts = new CalloutContainer(runtime, {
                    name: "plotArea.callout",
                    position: "left"
                });
                this.setChild("leftCallouts", this._leftCallouts, {
                    position: "left",
                    priority: 1,
                    //unique means there is only one component in the positon.
                    //if the "unique" component does not have size, other components can
                    //be layouted.
                    unique: true
                });
            }

            if(this._properties.get("plotArea.callout.top")) {
                this._topCallouts = new CalloutContainer(runtime, {
                    name: "plotArea.callout",
                    position: "top"
                });
                this.setChild("topCallouts", this._topCallouts, {
                    position: "top"
                });
            }

            if (isInteractive) {
                this._hScrollbar = this._categoryAxis.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
            }
        }

        if (isInteractive) {
            this._vScrollbar = new Scrollbar(runtime, {
                name: "plotArea.scrollbar"
            });

            this.setChild("scrollbar", this._vScrollbar, {
                position: "right"
            });
        }

        if (this._isPercentageChart()) {
            this._valueAxis.setPercentageMode(true);
        }
        
        this.getZoomer().init({
            main: this,
            plot: this._plot,
            axisByDirection: {
                x: isHorizontal ? [this._valueAxis] : [this._categoryAxis],
                y: isHorizontal ? [this._categoryAxis] : [this._valueAxis]
            },
            isHorizontal: isHorizontal
        });
    };

    XYPlotArea.prototype._getCategoryAxisClass = function() {
        return CategoryAxis;
    };
    
    XYPlotArea.prototype.layout = function (options, offset) {
        //XYPlotArea has to know _paginationScrollbar, or it cannot return the 
        //position of _paginationScrollbar. We do not destory _paginationScrollbar
        //if we destory XYPlotArea.
        if(options && options._paginationScrollbar) {
            this._paginationScrollbarRef = options._paginationScrollbar;
        }
        else {
            this._paginationScrollbarRef = null;
        }
        
        this._offset = offset;
        return XYPlotArea.superclass.layout.apply(this, arguments); 
    };
    
    XYPlotArea.prototype.destroy = function() {
        XYPlotArea.superclass.destroy.call(this);
        this._plot = null;
        this._hScrollbar = null;
        this._categoryAxis = null;
        this._valueAxis = null;
        this._vScrollbar = null;
        
        this._leftCallouts = null;
        this._topCallouts = null;
    };

    XYPlotArea.prototype._adjustScale = function(scale) {
        var needAdjustScale = this._properties.get("plotArea.adjustScale");
        if (TypeUtils.isExist(needAdjustScale)) {
            if (!scale.isFixed() && needAdjustScale && this._isLineChart()) {
                scale.setZeroAdjusted(false);
            }
        }
    };
    
    XYPlotArea.prototype._calcValueAxisScale = function(key, range, domain) {
        var scale = this._data[key].scale;
        this._adjustScale(scale);
        return ValueAxisUtils.calcScale(scale, range, {
            isLineChart: this._isLineChart(),
            isMekkoChart: this._isMekkoChart(),
            domain: domain
        });
    };

    XYPlotArea.prototype._calcPercentageValueAxisScale = function(range) {
        return ValueAxisUtils.calcPercentageScale(range);
    };

    XYPlotArea.prototype.setData = function(data) {
        XYPlotArea.superclass.setData.apply(this, arguments);
        var updatedData = this.updateValueScale();
        if(updatedData){
            this._setAxisData(updatedData);
            this._setPlotData(updatedData);
        }
        
        if (this._leftCallouts) {
            this._leftCallouts.setData(data);
        }

        if (this._topCallouts) {
            this._topCallouts.setData(data);
        }
    };

    XYPlotArea.prototype._postRender = function() {
        XYPlotArea.superclass._postRender.apply(this, arguments);
        var plot = this._plot, plotSize = plot.getSize();
        var plotRealSize = plot.getRealSize();
        
        var plotNode = this._plot._selection.node();
        var dpPlotNode = this._plot._getDpPlotNode();
        if (this._leftCallouts) {
            this._leftCallouts.postRender(plotNode, plotSize, plotRealSize, 
                dpPlotNode);
        }

        if (this._topCallouts) {
            this._topCallouts.postRender(plotNode, plotSize, plotRealSize,
                dpPlotNode);
        }
    };
    
    XYPlotArea.prototype.zoom = function() {
        XYPlotArea.superclass.zoom.apply(this, arguments);
        var plotRealSize = this._plot.getRealSize();
        var dpPlotNode = this._plot._getDpPlotNode();
        if (this._leftCallouts) {
            this._leftCallouts.setPlotRealSize(plotRealSize);
            this._leftCallouts.afterPlotZoom(dpPlotNode);
        }

        if (this._topCallouts) {
            this._topCallouts.setPlotRealSize(plotRealSize);
            this._topCallouts.afterPlotZoom(dpPlotNode);
        }
    };
    
    XYPlotArea.prototype._scroll = function(offset) {
        XYPlotArea.superclass._scroll.apply(this, arguments);
        var dpPlotNode = this._plot._getDpPlotNode();
        if (this._leftCallouts) {
            this._leftCallouts.afterPlotScroll(offset, dpPlotNode);
        }

        if (this._topCallouts) {
            this._topCallouts.afterPlotScroll(offset, dpPlotNode);
        }
    };    
    
    XYPlotArea.prototype._setPlotData = function(data) {
        this._plot.setData(data);
    };
    
    XYPlotArea.prototype._setAxisData = function(data){
        this._categoryAxis.setData(data.categoryAxis, DataUtils.hasNegativeValue(data));
    };
    
    XYPlotArea.prototype._isAdjustValueScaleForTopLabel = function() {
        var position = this._properties.get("plotArea.dataLabel.position") ||
            this._properties.getDefault("plotArea.dataLabel.position");
        
        //for Combination, we should add offset as line. Adjusting is a temp solution.
        return  this._isStackedChart() || ((this._isColumnChart() || this._isBarChart()) &&  position === "outside") ||
                 this._isCombinationChart();
    };

    XYPlotArea.prototype._calcValueScaleWithTopLabel = function(range){
        var dataLabelOpt = this._properties.get('plotArea.dataLabel');
        var dataLabelStyle = dataLabelOpt.style;
        var valueAxisIndex = this._valueAxisIndex;
        var fixedRangeOpt = (valueAxisIndex === "valueAxis") ? this._properties.get('plotArea.primaryScale.fixedRange')
         : this._properties.get('plotArea.secondaryScale.fixedRange');
        var valueAxis = this._data[valueAxisIndex];
        var valueScale = valueAxis.scale;
        var domain = valueScale.getDomain().slice();
        var isHorizontal = this._plot.isHorizontal();
        var valueAxisData = this._calcValueAxisScale(valueAxisIndex, range);
        var series = this._data.series;

        var extendDM = ValueScaleUtil.extendDomainForDataLabel;
        var EXTRA_VERTICAL_PADDING = 4;
        var EXTRA_HORIZONTAL_PADDING = isHorizontal? 20: EXTRA_VERTICAL_PADDING;


        //no fixed range and want to show all labels
        if((!(fixedRangeOpt || valueScale.getDomainFixed()[1])) && 
                (dataLabelOpt.visible || dataLabelOpt.showTotal) && domain){
            var size = [null,null];

            var formatPattern, measureName, metaDataFormat;
            var formatPatterns = dataLabelOpt.formatString;
            
            if (this._data && this._data[valueAxisIndex] && this._data[valueAxisIndex].metaData) {
                measureName = this._data[valueAxisIndex].metaData[0].id;
                metaDataFormat = this._data[valueAxisIndex].metaData[0].formatString;
            }

            formatPatterns = formatPatterns || metaDataFormat;

            var dataLabelInfo = {
                key: measureName
            };

            if(this._isStackedChart() && dataLabelOpt.showTotal) {

                if(isHorizontal) {
                    formatPattern = DataLabels.getFirstFormatPattern(formatPatterns, dataLabelInfo);
                }
                var labelText;
                var options = {
                    decimalFormatString: 
                    UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.DATALABEL)
                };
                if(domain[1] > 0) {
                    labelText = UnitFormat.format(NumberUtils.preciseSimple(domain[1]), formatPattern,
                            dataLabelOpt.unitFormatType, options);
                    size[1] = TextUtils.fastMeasure(labelText, dataLabelOpt.style.fontSize,
                            dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                            dataLabelOpt.style.fontStyle);
                }
                if(domain[0] < 0) {
                    labelText = UnitFormat.format(NumberUtils.preciseSimple(domain[0]), formatPattern,
                            dataLabelOpt.unitFormatType, options);
                    size[0] = TextUtils.fastMeasure(labelText, dataLabelOpt.style.fontSize,
                            dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                            dataLabelOpt.style.fontStyle);
                }
                valueAxisData = this._calcValueAxisScale(valueAxisIndex, range, 
                        extendDM(domain, range, size, isHorizontal));
            }
            else if(!this._isStackedChart() && dataLabelOpt.visible && domain && (domain[1] > 0 || domain[0] < 0)) {
                
                if(this._isBarChart()){
                    if(domain[1] > 0){
                        size[1] = BarDataLabels.getLabelSize(this._data.series, domain[1],  this._properties,
                            formatPatterns);

                    }
                    if(domain[0] < 0){
                        size[0] = BarDataLabels.getLabelSize(this._data.series, domain[0], this._properties,
                            formatPatterns);
                    }
                }else{
                    //bigger than real
                    var tSize = TextUtils.fastMeasure('M', dataLabelOpt.style.fontSize, 
                            dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                            dataLabelOpt.style.fontStyle);

                    if(domain[1] > 0) {
                        size[1] = tSize;
                    }
                    if(domain[0] < 0) {
                        size[0] = tSize;
                    }
                }

                size.forEach(function(e){
                    if(e){
                        e.height += EXTRA_VERTICAL_PADDING;
                        e.width += EXTRA_HORIZONTAL_PADDING;
                    }
                });
                var tempDomain = extendDM(domain, range, size, isHorizontal);
                valueAxisData = this._calcValueAxisScale(valueAxisIndex, range, tempDomain);
            }
        }

        valueAxisData.scale.setRange([0, 1]);
        valueAxisData.metaData = valueAxis.metaData;
        return valueAxisData;
    };

    XYPlotArea.prototype.updateValueScale = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        if (!data || width <= 0 || height <= 0) {
            return data;
        }

        //range is the rough size of plot
        var range = [0, 1];
        if (this._plot.isHorizontal()) {
            range[1] = width;
        } else {
            range[1] = height;
        }

        range[1] *=  0.8;
        
        var valueAxisData;
        var newData = data;
        
        if (this._isPercentageChart()) {
            valueAxisData = this._calcPercentageValueAxisScale(range);
            valueAxisData.metaData = data.valueAxis.metaData;
            data.valueAxis.tickHint = valueAxisData.tickHint;
            this._valueAxis.setData(valueAxisData);
        } else if (this._isAdjustValueScaleForTopLabel()){
            valueAxisData = this._calcValueScaleWithTopLabel(range);
            this._valueAxis.setData(valueAxisData);
            var srcData = {};
            srcData[this._valueAxisIndex] = valueAxisData;
            newData = this._cloneData(srcData);
        } else {
            valueAxisData = this._calcValueAxisScale("valueAxis", range); 
            data.valueAxis.scale = valueAxisData.scale;
            data.valueAxis.tickHint = valueAxisData.tickHint;

            var valueAxisDir = this._properties.origin.get("valueAxis.layout.direction");
            if(valueAxisDir === "topDown"){
                data.valueAxis.scale.setRange([1, 0]);
            }else {
                data.valueAxis.scale.setRange([0, 1]);
            }
            this._valueAxis.setData(data.valueAxis);
        }

        newData = updatedByTrendline.call(this, newData, range);
        
        return newData;
    };

    XYPlotArea.prototype._updateTrendLineAxis = function(data){
        if(data && data.categoryAxis && data.categoryAxis.scale){
            var  oriDimensions = data.categoryAxis.scale.getDomain(),
                 dimensions = ObjectUtils.extend(true, [], oriDimensions);
            if(dimensions){
                this._plot._expandTrendlineXRange(dimensions);
                data.categoryAxis.scale = new CategoryScale(dimensions, [0, 1]);
            }
        }
    };
        
    XYPlotArea.prototype._getPlotClazz = function(renderType) {
        return PlotFactory.getPlotClazz(renderType);
    };

    XYPlotArea.prototype._preRender = function() {
        var offset = {x:0, y:0};
        // The barWidth need to be calculated in getPreferredSize() no matter _hasScrollbar() return true or false
        var refSize = this._plot.getPreferredSize();
        if (this._hasScrollbar()) {
            offset = this._plot.getOffset();
            this._categoryAxis.setRealSize(refSize);
        }
        XYPlotArea.superclass._preRender.apply(this, arguments);
        if(offset.x || offset.y){
            this.scroll(offset);
        }
    };
    
    XYPlotArea.prototype._configLayout = function() {
        var zoomer = this.getZoomer();
        var isVScrollbarExist = false, isHScrollbarExist = false;
        if (zoomer){
            var zoomDirection = zoomer.direction();
            if (zoomDirection === "xy") {
                isVScrollbarExist = true;
                isHScrollbarExist = true;
            } else if (zoomDirection === "x") {
                isHScrollbarExist = true;
            } else if (zoomDirection === "y") {
                isVScrollbarExist = true;
            }
        }
        
        if (this._hasScrollbar()) {
            if (this._plot.isHorizontal()) {
                isVScrollbarExist = true;
            } else {
                isHScrollbarExist = true;
            }
            // save the real size here for CategoryAxis to correctly calculate its size
            this.runtime().statusManager().add('plotRealSize', {
                value: this._plot.getPreferredSize()
            });
        }
        if (this._vScrollbar) {
            this._vScrollbar.isExist(isVScrollbarExist);
        }
        if (this._hScrollbar) {
            this._hScrollbar.isExist(isHScrollbarExist);
        }

        return XYPlotArea.superclass._configLayout.apply(this, arguments);
    };

    XYPlotArea.prototype._cloneData = function(replaced) {
        var newData = {};
        var data = this._data;
        for(var i in data) {
            if (data.hasOwnProperty(i)) {
                newData[i] = data[i];
            }
        }

        for (var prop in replaced) {
            if (replaced.hasOwnProperty(prop)) {
                newData[prop] = replaced[prop];
            }
        }
        return newData;
    };

    XYPlotArea.prototype._getZoomer  = function()
    {
        return new XYZoomer(this);
    };

    //will be used by TimeYYPlotArea and XYYPlotArea
    //to let both axis body appear/disappear at the same time
    XYPlotArea.prototype.allOrNone = function(result, available, extraInfo) {
        if(!this._properties.get("valueAxis.visible") || !this._properties.get("valueAxis2.visible")){
            return;
        }

        var measureName = this._plot.isHorizontal() ? "height" : "width";
        var size1 = result.valueAxis[measureName],
            size2 = result.valueAxis2[measureName];

        if(extraInfo && size1 > 0 && size2 > 0){
            var table = extraInfo.preferredSizeTable;
            var hasBody1 = table["valueAxis"] && 
                       table["valueAxis"].extra &&
                       table["valueAxis"].extra.visibleComponents.indexOf("axisBody") > -1;
            var hasBody2 = table["valueAxis2"] && 
                       table["valueAxis2"].extra && 
                       table["valueAxis2"].extra.visibleComponents.indexOf("axisBody") > -1;

            if(!hasBody1 || !hasBody2){
                //if one of AXIS BODY is empty, clear both AXIS BODY 
                var bodySize1 = hasBody1 ? table["valueAxis"].extra.componentsPrfSize["axisBody"]: 0;
                var bodySize2 = hasBody2 ? table["valueAxis2"].extra.componentsPrfSize["axisBody"] :0;
    
                result.valueAxis[measureName] -= bodySize1;
                result.valueAxis2[measureName] -= bodySize2;
                available[measureName] += (bodySize1 + bodySize2);  

                size1 = result.valueAxis[measureName];
                size2 = result.valueAxis2[measureName];
            }
        } 

        if (size1 === 0 || size2 === 0) {
            //if one of AXIS is empty, clear both
            result.valueAxis[measureName] = result.valueAxis2[measureName] = 0;
            available[measureName] += (size1 + size2);
        }
    };

    return XYPlotArea;
});

define('sap/viz/chart/components/legend/LineLegend',['sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/legend/ColorLegend',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/scales/ColorScale',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/scale/ColorShapeScaleMerger',
    'sap/viz/chart/components/util/ColorUtil',
], function(oo,
        ColorLegend,
        ObjectUtils,
        TypeUtils,
        ColorScale,
        DrawUtil,
        NameColorUtils, 
        Constants, 
        ColorShapeScaleMerger,
        ColorUtil) {
    var DEFAULT_LINE_COLOR = '#aaaaaa';
    var DEFAULT_EMPTY_COLOR = "#000000";
    var HORIZONTAL_OFFSET = Constants.LEGEND.HORIZONTAL_OFFSET;
    var LINE_TYPE = Constants.LINE_TYPE;

    var LineLegend = function() {
        LineLegend.superclass.constructor.apply(this, arguments);
    };

    oo.extend(LineLegend, ColorLegend);

    /*
     * Override
     * 
     */
   
    
    LineLegend.prototype._createShapeItems = function(groupItems, cDomain, itemInfos){
        var semanticMgr = this.runtime().semanticManager();
        var effectManager = this.runtime().effectManager();
        var propMgr = this.runtime().propertyManager();
        var _isCombination = this._isCombination();
        

        if(this._isShowWideMarker()){
            //Draw legend marker with line if marker.showLine is turn on 
            //or semantic color rules have with lineColor/lineType propreties.
            var markerWidth = cDomain.markerSize;
            var plotLineMarkerSize = propMgr.has("plotArea.marker.size") ? 
                    propMgr.get("plotArea.marker.size") : 
                    propMgr.get("plotArea.line.marker.size");
            if(markerWidth < plotLineMarkerSize){
                plotLineMarkerSize = markerWidth;
            }
            var bgColor = this._getBGColor();
            var that = this;
            groupItems.selectAll('line').remove();
            groupItems.selectAll('path').remove();
            var shapes = groupItems.selectAll('g').data(['shapeWithLine']);
            shapes.enter().append('g');
            shapes.exit().remove();
            shapes.attr('transform', 'translate(' + cDomain.shapeX + ',' + cDomain.shapeY + ')');
            var isRTL = this._isRTL();
            shapes.each(function(d, i, j){
                var options = ObjectUtils.clone(itemInfos[j].shapeOptions);
                if(options.lineColor || options.lineType){
                    var _line = d3.select(this).selectAll('line').data(['shapeWithLine']);
                    _line.enter().append('line');
                    _line.exit().remove();
                    _line.attr('x1', -markerWidth).attr('y1', '0').attr('x2', markerWidth).attr('y2', '0')
                        .attr('stroke', options.lineColor)
                        .attr('stroke-width', options.lineWidth);
                    if(options.lineType === LINE_TYPE.DASHED || options.lineType === LINE_TYPE.DOTTED){
                        _line.attr('stroke-dasharray', 2 *  markerWidth / 7 + "," + markerWidth / 7);
                    }else if(options.lineType === Constants.LINE_TYPE.DOT){
                        var pointCount = Math.round(2 * markerWidth / options.lineWidth);
                        pointCount = pointCount | 1;
                        if(pointCount < 3){
                            pointCount = 3;
                        }
                        var lineWidth = 2 * markerWidth / pointCount;
                        _line.attr('x1', -markerWidth + lineWidth / 2);
                        _line.attr('x2', markerWidth + lineWidth / 2);
                        _line.attr('stroke-dasharray', "0," + lineWidth * 2);
                        _line.attr('stroke-linecap', "round");
                        _line.attr("stroke-width", lineWidth);
                    }
                }
                options.bgColor =  bgColor;
                var stroke;
                if(that._isShowMarkerStroke()){
                    stroke = propMgr.get("plotArea.dataPoint.stroke.color");
                }  
                
                if(options.dpPattern === 'noFill'){
                    options.borderWidth = 1;
                    options.borderColor = stroke;
                }           
               
                if(options.fillColor){
                    var _marker = d3.select(this).selectAll('path').data(['shapeWithLine']);
                    _marker.enter().append('path');
                    _marker.exit().remove();
        
                    options.node = _marker.node();
                    if((options.seriesShape === 'line' || options.seriesShape === 'combination') && 
                            (options.lineColor || options.lineType)) {
                        
                        options.rx = options.ry = plotLineMarkerSize /2;
                        if(options.dpPattern === 'noFill'){
                            options.rx += 1;
                            options.ry += 1;
                        }else{
                            options.borderWidth = 2;
                        }
                        if(that._isShowMarkerStroke()){
                            options.borderColor = stroke;
                        }
                    }
                    // trendline legend  line width become 24
                    if(typeof options.graphType !== "string" && options.graphType.type ==="line"){
                        options.rx = markerWidth;
                        options.ry = markerWidth;
                    }
                    DrawUtil.drawGraph(options, effectManager);   
                    if(that._isShowMarkerStroke()){
                        _marker.attr('stroke-width', "1");
                    }
                    
                }
                
                if(isRTL) {
                    this.setAttribute('transform', 'translate(' + 
                        (itemInfos[j].eventLayerWidth - HORIZONTAL_OFFSET - markerWidth) +
                        ',' + cDomain.shapeY + ')');
                }
            });
            shapes.attr("class", "v-legend-marker");
        }else{
            //Draw default color legend
            LineLegend.superclass._createShapeItems.apply(this, arguments);
        }
    };

    LineLegend.prototype._getGroupItemInfo = function(cDomain){
        var itemInfos = LineLegend.superclass._getGroupItemInfo.apply(this, arguments);
        var semanticMgr = this.runtime().semanticManager();
        var propMgr = this.runtime().propertyManager();
        var effectMgr = this.runtime().effectManager();
        var that = this;
        var lineWidth = propMgr.has('plotArea.line.width') ? 
                propMgr.get('plotArea.line.width') : 
                propMgr.get('plotArea.width');

        itemInfos.map(function(item, i){
            var d = cDomain[i];
            if(d.isSemantic){
                //Has semantic color
                if(semanticMgr.hasDataPointLineStyle()){
                    if(d.lineColor){
                        item.shapeOptions.lineColor = d.lineColor;
                    }
                    if(d.lineType){
                        item.shapeOptions.lineType = d.lineType;    
                        if(!d.lineColor){
                            //Set with default color
                            item.shapeOptions.lineColor = DEFAULT_LINE_COLOR;
                        }
                    }
                    item.shapeOptions.lineWidth = lineWidth;
                }
                if(d.seriesShape){
                    item.shapeOptions.seriesShape = d.seriesShape;
                }
            } else if(that._isShowLine()){
                //lineStyle is defined and showLine is switch on. 
                if(d.seriesShape === 'line' || d.seriesShape === 'combination'){
                    var lineStyle = that._getSereisStyle(d.ctx, that._data, semanticMgr, "line");       
                    if(!TypeUtils.isEmptyObject(lineStyle)){
                        item.shapeOptions.lineColor = (lineStyle.line && lineStyle.line.color) || d.color;
                        item.shapeOptions.lineWidth = (lineStyle.line && lineStyle.line.width) || lineWidth;
                        item.shapeOptions.lineType = (lineStyle.line && lineStyle.line.type) || "line";
                    }else{
                        item.shapeOptions.lineColor = (d.color && 
                            (d.color !== 'null' && d.color !== 'undefined')) ? d.color : DEFAULT_EMPTY_COLOR;
                        item.shapeOptions.lineWidth = lineWidth;
                    }
                    item.shapeOptions.lineColor = NameColorUtils.convertColor(item.shapeOptions.lineColor);
                } 
                if(!item.shapeOptions.fillColor){
                    item.shapeOptions.fillColor = DEFAULT_EMPTY_COLOR;
                }
                if(d.seriesShape){
                    item.shapeOptions.seriesShape = d.seriesShape;
                }
            }
            
          
            return item;
        });
        return itemInfos;
    };

    LineLegend.prototype._isShowMarkerStroke = function(){
        return this.runtime().propertyManager().get("plotArea.dataPoint.stroke.visible");
    };

    LineLegend.prototype._isShowLine = function(){
        var propMgr = this.runtime().propertyManager();
        return this._properties.get("marker.showLine") && 
            (propMgr.has("plotArea.lineVisible") ? 
                    propMgr.get("plotArea.lineVisible") : 
                        propMgr.get("plotArea.line.visible")) && 
            ((propMgr.has('plotArea.line.width') ? 
                    propMgr.get('plotArea.line.width') : 
                        propMgr.get('plotArea.width')) > 0);
    };

    LineLegend.prototype._isCombination = function(){
        var markMgr = this.runtime().markManager();
        return markMgr.getMode() === 'combination';
    };

    LineLegend.prototype._getMarkerWidth = function(){
        var markerWidth = LineLegend.superclass._getMarkerWidth.apply(this, arguments);
        if(this._isShowWideMarker()){
            markerWidth = markerWidth * 2;
        }
        return markerWidth; 
    };

    LineLegend.prototype._isShowWideMarker = function(){
        var semanticMgr = this.runtime().semanticManager();
        return semanticMgr.hasDataPointColorStyle() || semanticMgr.hasDataPointLineStyle() || 
            this._isShowLine();
    };

    LineLegend.prototype._calcMetaInfo = function(cDomain){
        LineLegend.superclass._calcMetaInfo.apply(this, arguments); 
        if(this._isShowWideMarker()){
            //Marker width will change to 2 * height
            var markerSize = cDomain.markerSize;
            var markerWidth = 2 * markerSize;
            var markerMargin = this._markerMargin;
            var textHeight = parseInt(this._labelFont.fontSize, 10);
            var paddingWidth = (this.isHorizontal() ? markerMargin.left + 
                markerMargin.right : markerMargin.right) * textHeight;
            var HORIZONTAL_OFFSET = Constants.LEGEND.HORIZONTAL_OFFSET;

            cDomain.shapeX = markerWidth / 2 + HORIZONTAL_OFFSET;
            cDomain.textX = cDomain.textX + markerSize;
            cDomain.postRenderX = markerWidth / 2 + HORIZONTAL_OFFSET;
            cDomain.miscWidth = cDomain.miscWidth + markerSize;
            cDomain.eachItemWidth = cDomain.eachItemWidth + markerSize;
            
            this._markerSize = markerSize * 2;
        }
    };

    LineLegend.prototype._calcDomain = function(items, hideNoValueLabel){
        var semanticMgr = this.runtime().semanticManager();
        var plotShape = this.runtime().propertyManager().get("plotArea.line.marker.shape");
        var legendShape = this._properties.get("marker.shape");
        var _isCombination = this._isCombination();

        return items.map(function(item, i){
            item.id = i;
            var text = this._toValueString(item.data, hideNoValueLabel);
            var color = item.color;
            if(TypeUtils.isString(color) && color && color.indexOf("url") === -1) {
                color = NameColorUtils.convertColor(color);
            }
            var result = {
                id: i,
                val: item.data,
                text: text,
                ctx: item.context,
                shape: item.shape,
                cls: item.cls,
                pattern: item.pattern,
                isSemantic : item.isSemanticItem
            };

            if(item.isSemanticItem){
                if(semanticMgr.hasDataPointLineStyle()){
                    if(TypeUtils.isString(item.lineColor) && item.lineColor && item.lineColor.indexOf("url") === -1){
                        result.lineColor = NameColorUtils.convertColor(item.lineColor);   
                    }
                    if(item.lineType){
                        result.lineType = item.lineType;    
                    } 
                    if(_isCombination){
                        //When semantic rule doesn't contain line related properties, respect legend.marker.shape.
                        //Otherwise draw line with marker, and the marker will respect plotArea.line.marker.shape.
                        if(item.lineColor || item.lineType){
                            result.shape = plotShape;
                        } else {
                            result.shape = legendShape;
                        }
                    }
                }
                if(semanticMgr.hasDataPointColorStyle()){
                    if(item.color){
                        result.color = color;
                    }
                }
            }else{
                result.color = color;
            }

            if(item.seriesShape){
                result.seriesShape = item.seriesShape;
            }

            return result;
        }, this);
    };

    return LineLegend;
});

define('sap/viz/chart/components/legend/CombinationLegend',['sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/legend/LineLegend',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/scales/ColorScale',
    'sap/viz/framework/scale/ColorShapeScaleMerger'
], function(oo, LineLegend, ObjectUtils, TypeUtils, ColorScale, ColorShapeScaleMerger) {
    var CombinationLegend = function() {
        CombinationLegend.superclass.constructor.apply(this, arguments);
    };

    oo.extend(CombinationLegend, LineLegend);

    function hash(data) {
        if (TypeUtils.isArray(data)) {
            return data.map(function(elm) {
                return hash(elm);
            }).join("-");
        } else {
            return "" + data;
        }
    }

    /**
     * @override 
     */
    CombinationLegend.prototype._buildColorShapeScale = function(colorScales) {
        var enableGroup = this._properties.get("groupByShape"),
            dataMndLookup = {};
        var merger = CombinationLegend.superclass._buildColorShapeScale.apply(this, arguments);
        if (enableGroup && !this._properties.get("order")) {
            colorScales.forEach(function(cScale) {
                if (!cScale.rowArray) {
                    return;
                }
                cScale.rowArray.forEach(function(row) {
                    dataMndLookup[hash(row)] = row.mndIndex;
                });
            });

            //create id to name table
            var id2name = {};
            var metas = [];
            if(this._data.valueAxis2){
                metas = metas.concat(this._data.valueAxis2.metaData);
            }
            if(this._data.valueAxis){
                metas = metas.concat(this._data.valueAxis.metaData);
            }
            metas.forEach(function(metaData){
                id2name[metaData.id] = metaData.name || metaData.id;
            });

            var items = merger.items();
            var colorScaleItems = [], semanticItems = [];
            items.forEach(function(item){
                if(item.isSemanticItem){
                    semanticItems.push(item);
                }else{
                    colorScaleItems.push(item);
                }
            });
            var ordered = flattenGroup(groupByShapeThenMnd(colorScaleItems, dataMndLookup, id2name));
            items.splice(0, items.length);
            items.push.apply(items, semanticItems);
            items.push.apply(items, ordered);
        }

        return merger;
    };

    function flattenGroup(groups) {
        return Object.keys(groups).reduce(function(arr, k) {
            var grp = groups[k];
            return arr.concat(TypeUtils.isArray(grp) ? grp : flattenGroup(grp));
        }, []);
    }

    function groupByShapeThenMnd(colorShapes, mndLookup, id2name) {
        var groups = groupBy(colorShapes, function(i) {
            return i.seriesShape;
        });
        Object.keys(groups).forEach(function(k) {
            groups[k] = groupBy(groups[k], function(item){
                var key = hash(item.data);
                var measureId = item.context.measureNames;
                if(measureId){
                    var data = item.data.slice();
                    var index = data.indexOf(id2name[measureId]);
                    if(index > -1){
                        data[index] = measureId;
                        key = hash(data);
                    }
                }
                return mndLookup[key];
            });
        });
        return groups;
    }

    function groupBy(items, keyFn) {
        return items.reduce(function(cache, item) {
            var key = keyFn(item);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = [];
            }
            cache[key].push(item);
            return cache;
        }, {});
    }

    return CombinationLegend;
});

define('sap/viz/chart/chains/RawDataParserFactory',[
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/util/FunctionUtils',
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/framework/common/util/oo'
], function(
    TimeUtil,
    FiscalUtil,
    FunctionUtils,
    LangManager,
    oo
){

    var Parser = function(option){
        this._option = option || {};
    };

    Parser.prototype.parse = function(e){
        return e === undefined ? null : e;
    };

    var DateParser = function(option) {
        DateParser.superclass.constructor.apply(this, arguments);
        this._skipDateChecking = option && option.skipDateChecking;
        this._cache = {};
    };

    oo.extend(DateParser, Parser);
    DateParser.prototype.parse = function (e){
        var value;
        var returnValue = null;
        if (this._option && this._option.fiscalObj) {
            e = parseInt(e);
        }
        if (typeof e !== 'number') {
            // typeof e ==> 'object', new Date(null).getTime() ==> 0
            if (e != null && typeof e === 'object') {
                if (e.v != null) {
                    value = new Date(e.v).getTime();
                } else if ( e.v == null) {
                    return null;
                }
            } else {
                value = new Date(e).getTime();
            }
            if (!isNaN(value)) {
                returnValue = {
                    parsedValue: value,
                    v: e
                };
                if (e.d != null) {
                    returnValue.d = e.d;
                }
                if (e.v != null) {
                    returnValue.v = e.v;
                }
            } else if(!this._skipDateChecking) {
                FunctionUtils.error(LangManager.getLogMessage('IDS_ERROR_DATE_HAVE_INVALID_FORMAT'));
            }
        } else {
            returnValue = {
                v: e
            };

            if (this._option && this._option.fiscalObj) {
                returnValue.parsedValue = FiscalUtil.fiscalToQuantity(e, this._option.fiscalObj);
            }
            else {
                returnValue.parsedValue = e;
            }
        }
        //We will do validation and truncation if dataTimeLevel is set.
        var dataTimeLevel = (this._option && this._option.dataTimeLevel);
        if (returnValue != null && dataTimeLevel != null) {
            var oriValue = returnValue.parsedValue;
            if (this._cache[oriValue]) {
                returnValue.parsedValue = this._cache[oriValue];
            } else {
                value = TimeUtil.truncate(returnValue.parsedValue, dataTimeLevel, this._option.showAsUTC,
                    this._option.fiscalObj, this._option.weekConfig);
                this._cache[oriValue] = value;
                returnValue.parsedValue = value;
            }
        }
        return returnValue;
    };

    var RawDataParserFactory = {
        get : function(type, option, bindingName) {
            var parser;
            type = type || '';
            type = type.toLowerCase();
            if (type === "date" && bindingName === "timeAxis") {
                parser = new DateParser(option);
            } else {
                parser = new Parser(option);
            }
            return parser;
        }
    };

    return RawDataParserFactory;
});
define('sap/viz/chart/chains/ChainUtils',[
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/chains/RawDataParserFactory',
    'sap/viz/framework/common/util/ArrayUtils'
], function Setup(
    TypeUtils, 
    DataUtils, 
    ObjectUtils,
    FiscalUtil,
    Constants,
    RawDataParserFactory,
    ArrayUtils
) {
    var TYPENAME_DIMENSION = "Dimension";
    var TYPENAME_MEASURE = "Measure";
    var MEASURE_NAMES = "measureNames";
    var FEED_COLUMN = 'trellisColumn';
    var FEED_ROW = 'trellisRow';
    var CONST_COLUMN = 'trellis.columnCategory';
    var CONST_ROW = 'trellis.rowCategory';
    var CONST_FRAME = 'frame.data';
    var CONTEXT_ID_NAME = "_context_row_number";
    var utils = {};

    var getDimensionValue = DataUtils.getDimensionValue;

    utils._BULLET_MEASURES = ["actualValues", "additionalValues", "targetValues", "forecastValues"];



    var extractBindingDefinition = function(bindingDefinition) {
        var returnValue = {};
        bindingDefinition.forEach(function(item) {
            returnValue[item.role] = item.id;
        });
        return returnValue;
    };

    var buildNewBindingResult = function(dimensions, measures, contextResults, rowId, columnId, isRowFirst, addCtx) {
        var newResult = {};
        var i;
        var values;
        for (i in dimensions) {
            if (dimensions.hasOwnProperty(i)) {
                newResult[i] = dimensions[i];
            }
        }
        var resultRowId = isRowFirst ? rowId : columnId;
        var resultColumnId = isRowFirst ? columnId : rowId;

        for (i in measures) {
            if (measures.hasOwnProperty(i)) {

                if (!TypeUtils.isArray(measures[i].values[rowId])) {
                    values = [];
                } else {
                    values = measures[i].values[rowId][columnId];
                }
                newResult[i] = {
                    range: measures[i].range,
                    values: values,
                    metaData: measures[i].metaData
                };

                if (measures[i].categorySum) {
                    if (!TypeUtils.isArray(measures[i].categorySum[resultRowId])) {
                        measures[i].categorySum[resultRowId] = [];
                    }
                    if (TypeUtils.isArray(values)) {
                        measures[i].categorySum[resultRowId][resultColumnId] = utils.sumByCategory(values);
                    } else {
                        measures[i].categorySum[resultRowId][resultColumnId] = values;
                    }
                }
            }
        }
        function addCtxValues(context, name ){
            var contextValues = [], contextMeta = [];
            var metaDatas = context && context.metaData;
            var ctxValues = context && context.values;
            
            for(i = 0; metaDatas && i < metaDatas.length; ++i){
                var meta = metaDatas[i];
                var value = ctxValues[i];
                if (value[rowId]) {
                    contextValues.push(value[rowId][columnId]);
                    contextMeta.push(meta);
                }
            }
            newResult[name] = {values:contextValues, metaData:contextMeta};
        }
        addCtxValues(contextResults, "context");
        addCtxValues(addCtx, "additionInfo");

        return newResult;
    };
    
    var checkRowFirst = function(bindings) {
        var length = bindings.length;
        for (var i = 0; i < length; i++) {
            if (bindings[i].feed === FEED_ROW) {
                return true;
            } else if (bindings[i].feed === FEED_COLUMN) {
                return false;
            }
        }
        throw "Binding not match";
    };
    var addTrellisRow = function(measures, bindingResults) {
        for (var i in measures) {
            if (measures.hasOwnProperty(i)) {
                var bindingResult = bindingResults[i];
                if (bindingResult) {
                    bindingResult.values = [bindingResult.values];
                }
            }

        }
    };
    
    var addTrellisColumn = function(measures, bindingResults) {
        for (var i in measures) {
            if (measures.hasOwnProperty(i)) {
                var bindingResult = bindingResults[i];
                bindingResult.values.forEach(function(item, j) {
                    bindingResult.values[j] = [bindingResult.values[j]];
                });
            }
        }
    };
    
    // context structure, the first array is contexts, one context as one element
    var addTrellisColumnContext = function(measures, bindingResults) {
        for (var i in measures) {
            if (measures.hasOwnProperty(i)) {
                var oneContext = bindingResults[i];
                for(var j = 0; j < oneContext.values.length; ++j){
                    var curSet =  oneContext.values[j];
                    for(var t =0; t < curSet.length; ++t){
                        curSet[t] = [curSet[t]];
                    }
                    
                }
               
            }
        }
    };

    var addTrellisRowContext = addTrellisColumn;

    var getMeasures = function(results, bindingDefinition) {
        var measures = {};
        bindingDefinition.forEach(function(item) {
            if (item.type === TYPENAME_MEASURE) {
                var id = item.id;
                var result = results[id];
                if (result) {
                    measures[id] = result;
                }
            }
        });
        return measures;
    };

    var getDimensions = function(results, bindingDefinition) {
        var dimensions = {};
        bindingDefinition.forEach(function(item) {
            if (item.role !== FEED_ROW && item.role !== FEED_COLUMN) {
                var id = item.id;
                var result = results[id];
                if (result) {
                    dimensions[id] = result;
                }
            }
        });
        return dimensions;
    };
    

    var getPlayBindingSeries = function(getSeriesFn, rawData, dimensions, measures, bindingResults,
        bindings, bindingDefinition, playDimension, playLength, options) {
        var allDimensions = getDimensions(bindingResults, bindingDefinition);
        var measureResults = getMeasures(bindingResults, bindingDefinition);
        var contextResults = bindingResults.context;
        var addCtx = bindingResults.additionInfo;
        addTrellisRow(measureResults, bindingResults);
        if (contextResults) {
            addTrellisRowContext({
                context: contextResults
            }, bindingResults);
        }
        if(addCtx){
            addTrellisRowContext({
                additionInfo: addCtx
            }, bindingResults);
        }

        var allSeries = [];
        var seriesContext = [];
        for (var i = 0; i < playLength; i++) {
            var tmpBindingResult;
            tmpBindingResult = buildNewBindingResult(allDimensions,
                measureResults, contextResults, 0, i, true, addCtx);

            var newDimensions = dimensions.filter(function(item) {
                return item !== "dataFrame";
            });
            tmpBindingResult.seriesType = bindingResults.seriesType;

            getSeriesFn(rawData, newDimensions, measures, tmpBindingResult, 
                undefined, options, bindingDefinition);
            allSeries[i] = tmpBindingResult.series;
            for(var j = 0; j < tmpBindingResult.seriesContext.length; j++){
                seriesContext.push(tmpBindingResult.seriesContext[j]);
            }
        }
        bindingResults.allSeries = allSeries;
        bindingResults.series = allSeries[0];
        bindingResults.seriesContext = seriesContext;
        ["", "2"].forEach(function(e){
            var valueAxis = "valueAxis" + e;
            var allCategorySum = "allCategorySum" + e;
            if (bindingResults[valueAxis] &&
                bindingResults[valueAxis].categorySum &&
                bindingResults[valueAxis].categorySum[0] &&
                Array.isArray(bindingResults[valueAxis].categorySum[0])) {
                bindingResults[allCategorySum] = bindingResults[valueAxis].categorySum[0];
                bindingResults[valueAxis].categorySum = bindingResults[allCategorySum][0];
            }
        });
    };

    var getTrellisBindingSeries = function(getSeriesFn, rawData, dimensions, measures,
        bindingResults, bindings, bindingDefinition,
        rowDimension, columnDimension, rowLength, columnLength) {
        var isRowFirst = checkRowFirst(bindings);
        var allDimensions = getDimensions(bindingResults, bindingDefinition);
        var trellisBindItem = 2;
        var measureResults = getMeasures(bindingResults, bindingDefinition);
        var contextResults = bindingResults.context;
        var addCtx = bindingResults.additionInfo;
        if (rowLength === 0) {
            addTrellisRow(measureResults, bindingResults);
            if (contextResults) {
                addTrellisRowContext({
                    context: contextResults
                }, bindingResults);
            }
            if(addCtx){
                addTrellisRowContext({
                    additionInfo: addCtx
                }, bindingResults);
            }
            rowLength = 1;
            trellisBindItem = 1;
            isRowFirst = true;
        }
        if (columnLength === 0) {
            addTrellisColumn(measureResults, bindingResults);
            if (contextResults) {
                addTrellisColumnContext({
                    context: contextResults
                }, bindingResults);
            }
            
            if(addCtx){
                addTrellisColumnContext({
                    additionInfo: addCtx
                }, bindingResults);
            }
            columnLength = 1;
            trellisBindItem = 1;
        }
        var series = [];

        for (var i = 0; i < rowLength; i++) {
            for (var j = 0; j < columnLength; j++) {
                var tmpBindingResult;
                if (isRowFirst) {
                    tmpBindingResult = buildNewBindingResult(allDimensions, measureResults,
                        contextResults, i, j, isRowFirst, addCtx);
                } else {
                    tmpBindingResult = buildNewBindingResult(allDimensions, measureResults,
                        contextResults, j, i, isRowFirst, addCtx);
                }

                var newDimensions = dimensions.slice(trellisBindItem);
                tmpBindingResult.seriesType = bindingResults.seriesType;

                var trellisInfo;
                if (!series[i]) {
                    series[i] = [];
                }
                trellisInfo = {
                    trellisRow: rowDimension ? rowDimension.rowArray[i] : undefined,
                    trellisColumn: columnDimension ? columnDimension.rowArray[j] : undefined
                };
                getSeriesFn(rawData, newDimensions, measures, tmpBindingResult, trellisInfo, {}, bindingDefinition);
                series[i][j] = tmpBindingResult.series;
            }
        }
        bindingResults.series = series;
    };

    var handleMND = function(categoryArray, mndInfo, bindingInfoLength) {
        var mnd = mndInfo.items;
        var mndLength = mnd.length;
        var mndPosition = mndInfo.position;
        var totalLength = categoryArray.length;
        var singleMeasureLength = totalLength / bindingInfoLength;
        var copyedArray = [];
        var startPosition;
        var i, j, k, idx;

        copyedArray.length = totalLength * mndLength;

        if (mndPosition === bindingInfoLength - 1 && mndInfo.respectOrder) {
            for (i = 0; i < singleMeasureLength; i++) {
                startPosition = i * mndLength;
                for (j = 0; j < mndLength; j++) {
                    idx = (startPosition + j) * bindingInfoLength;
                    for(k = 0; k < bindingInfoLength - 1; ++k){
                        copyedArray[idx + k] = categoryArray[i * bindingInfoLength + k];
                    }
                    copyedArray[idx + k] = mnd[j];
                }
            }
        } else {
            copyedArray = categoryArray;
            var tmpArray;
            for (i = 0; i < mndLength - 1; ++i) {
                tmpArray = tmpArray || JSON.parse(JSON.stringify(categoryArray));
                copyedArray = copyedArray.concat(tmpArray);
            }
            for (i = mndLength; i--;) {
                startPosition = i * totalLength;
                for(j = singleMeasureLength; j--;){
                    idx = startPosition + j * bindingInfoLength + mndPosition;
                    copyedArray[idx] = mnd[i];
                }
            }
        }
        return copyedArray;
    };

    var groupDomain = function(domains) {
        var len = domains.length;
        var multiplier = 1;
        var domainObj = [];
        for (var i = len - 1; i >= 0; i--) {
            var domainItem = domains[i];
            var length = domainItem.length;
            var tmpObj = {};
            for (var j = 0; j < length; j++) {
                tmpObj[domainItem[j]] = j;
            }
            domainObj[i] = {
                multiplier: multiplier,
                value: tmpObj
            };
            multiplier = multiplier * length;
        }
        return domainObj;
    };
    
    var getDistinctValues = function(array) {
        var returnArray = [],
            dimValue;
        var obj = {};
        for (var i = 0, len = array.length; i < len; i++) {
            dimValue = getDimensionValue(array[i]);
            // Force to distinguish with built-in keys
            var key = ',' + dimValue;
            if (!obj[key]) {
                returnArray.push(dimValue);
                obj[key] = true;
            }
        }
        return returnArray;
    };

    var sortByDomain = function(indexArray, rawData, bindingInfo, mnd, parsedData, parserOption) {
        //only necessary to sort by domain then generate distinct domain and build domain set.
        var i, len;
        var domain = [];
        for (i = 0, len = bindingInfo.length; i < len; ++i){
            var bindItem = bindingInfo[i];
            if (bindItem[MEASURE_NAMES]) {
                domain.push(mnd);
            } else {
                var metadata = rawData.metadata(bindItem)[0];
                var data = utils.parseData(rawData, bindItem, parsedData);
                if (metadata.domain) {
                    domain.push(getDistinctValues(metadata.domain));
                } else {
                    domain.push(getDistinctValues(data));
                }
            }
        }
        //TODO: domainSet seems unnecessary.
        var domainSet = groupDomain(domain);
        if (!TypeUtils.isArray(domainSet)) {
            return [];
        }
        if (parserOption && parserOption.isTimeStacked) {
            var timeDomain = domainSet[0].value;
            var timeList = [];
            if (timeDomain) {
                for(var prop in timeDomain) {
                    if (timeDomain.hasOwnProperty(prop)) {
                        timeList.push(prop);
                    }
                }
                if (timeList.length > 0) {
                    ArrayUtils.stableSort(timeList, function(a, b) {
                        return (parseInt(a) - parseInt(b));
                    });
                }
                for (i = 0; i < timeList.length; i++) {
                    timeDomain[timeList[i]] = i;
                }
            }
        }
        //start to sort
        var allArray = [];
        for (i = 0, len = indexArray.length; i < len; i++) {
            var index = 0;
            var val = indexArray[i],
                dimValue;
            for (var j = 0, length = domainSet.length; j < length; j++) {
                dimValue = getDimensionValue(val[j]);
                index += domainSet[j].multiplier * domainSet[j].value[dimValue];
            }
            if (index > -1) {
                allArray.push({idx:index, val:val});
            }
        }
        allArray.sort(function(a, b){
            return (a.idx - b.idx); 
        });
        var returnArray = allArray.map(function(e) {
            return e.val;
        });
        return returnArray;
    };

    // a internal property sorter for every dimensions in metadata.field
    // sorter: type is Object, defaultValue is null
    // the structure of sorter:
    // { 
    //    bDescending: {boolean} (optional)  // default: false,
    //    fnComparator: {function} (optional) // default: defaultSortComparator, similar to Array.sort
    // } 
    // When sort and group both work, sort is based on group Result.    
    var orderBySorter = function(indexArray, rawData, bindingInfo, mnd) {
        var i, len;
        var sorters = getSorter(rawData), hasSorter = false;
        for (i = 0; i < bindingInfo.length; i++ ){
            if (sorters[bindingInfo[i]]){
                hasSorter = true;
            }
        }
        if (!hasSorter){
            return indexArray;
        }
        var mndMap = {};
        if (mnd && mnd.length > 0){
            for (i = 0; i < mnd.length; i++){
                mndMap[mnd[i]] = i;
            }
        }
        return ArrayUtils.stableSort(indexArray, function(valA, valB){
            var diff = 0;
            // 1) For MND binding, we canât set 'sorter' for MND, but conside MND is in order
            // 2) Sort order from outside to inside is according to binding order
            //  eg. binding order is Year, Country, Product, sort order is Year, Country, Product
            for (i = 0, len = bindingInfo.length; i < len; ++i){
                var bindItem = bindingInfo[i];
                if (bindItem[MEASURE_NAMES]) {
                    diff = mndMap[valA[i]] - mndMap[valB[i]];
                } else {
                    var sorter = sorters[bindItem];
                    if (sorter){
                        var fnComparator = sorter.fnComparator || defaultSortComparator;
                        var bDescending = sorter.bDescending;
                        diff = fnComparator(valA[i], valB[i]);
                        diff = bDescending ? -1 * diff : diff;
                    }
                }
                if (diff !== 0){
                    return diff;
                }
            }
            return diff;
        });
    };

    function integerDivide(a, b){
        return Math.floor(a / b);
    }

    function extendNode(node, row, i) {
        // add a row to tree
        node.order = node.order || [];
        if (i === row.length) {
            node.order.push(row);
            node.isLeaf = true;
            return;
        }

        var val = getDimensionValue(row[i]);
        node.map = node.map || {};
        var index;
        if (val == null) {
            // No Value case
            if (node.noValueMap == null) {
                node.noValueMap = node.order.length;
                node.order.push({});
            }
            index = node.noValueMap;
        } else {
            if (node.map[val] == null) {
                node.map[val] = node.order.length;
                node.order.push({});
            }
            index = node.map[val];
        }
        extendNode(node.order[index], row, ++i);
    }

    function flattenNode(node, arr) {
        // export tree to flattened array result
        for (var i = 0; i < node.order.length; ++i) {
            if (node.isLeaf) {
                Array.prototype.push.apply(arr, node.order);
                return;
            }
            flattenNode(node.order[i], arr);
        }
    }

    function groupBy(arr) {
        // loop data records to generate tree according to relative order
        var tree = {};
        arr.forEach(function(row) {
            extendNode(tree, row, 0);
        });
        var retArr = [];
        flattenNode(tree, retArr);
        return retArr;
    }

    function defaultSortComparator(valA, valB) {
        var a = (valA && valA[DataUtils.DIMENSION_VALUE]) || valA, 
            b = (valB && valB[DataUtils.DIMENSION_VALUE]) || valB;
		if (a == b) {
			return 0;
		}
		if (b == null) {
			return -1;
		}
		if (a == null) {
			return 1;
		}
		if (typeof a == "string" && typeof b == "string") {
			return a.localeCompare(b);
		}
		if (a < b) {
			return -1;
		}
		if (a > b) {
			return 1;
		}
		return 0;
    }

    function getSorter(rawData){
        var i, j, sorters = {};
        var fields =  rawData._FlatTableD._dataset.metadata.fields;
        if (TypeUtils.isExist(fields)){
            fields.forEach(function(field){
                if (field.id && field.sorter){
                    var sorter = {};
                    var bDescending = field.sorter.bDescending;
                    var fnComparator = field.sorter.fnComparator;
                    if (bDescending && typeof bDescending === "boolean" ){
                        sorter.bDescending = bDescending;
                    } else {
                        sorter.bDescending = false;
                    }
                    if (fnComparator && TypeUtils.isFunction(fnComparator)){
                        sorter.fnComparator = fnComparator;
                    }
                    sorters[field.id] = sorter;
                }
            });
        }
        return sorters;
    }
   
    var groupResult = function(array, mndInfo, rawData, bindingInfo, 
        parsedData, multiDimensionIndex, parserOption) {
        if (!array || !array.length) {
            return [];
        }
        var mnd = mndInfo.items;
        var mndLength = mnd.length;
        var hasMND = mndLength > 0;
        var mndPosition = mndInfo.position;
        var bindingInfoLength = bindingInfo.length;
        var rowLength = array.length / bindingInfoLength;
        var maxIndex = hasMND ? rowLength / mndLength : rowLength;
        var dataCache = {};
        var returnArray = [];
        var i, j;
        // TODO: need a better name for this flag!
        var respectDataOrder = mndInfo.respectOrder;
        var groupOption = mndInfo.groupOption;
        var flag = respectDataOrder &&
                mndPosition > -1 &&
                mndPosition === bindingInfoLength - 1 &&
                bindingInfoLength !== 1;

        for(i = 0; i < rowLength; ++i){
            var rowIndex = i * bindingInfoLength;
            // generate a key for multiple dimensions
            var cacheKey = '';
            // Even if there's only one dimension, still add the "," as a prefix to the cache key,
            // so that it can distinguish with the reserved names in object
            for(j = 0; j < bindingInfoLength; ++j){
                cacheKey += "," + String(getDimensionValue(array[rowIndex + j]));
            }
            var cachedItem = dataCache[cacheKey];
            if (cachedItem == null) {
                cachedItem = dataCache[cacheKey] = returnArray.length;
                var arrayItem = array.slice(rowIndex, rowIndex + bindingInfoLength);
                returnArray.push(arrayItem);
                arrayItem.reference = [];
                arrayItem.mndIndex = flag ?
                        mnd[i % mndLength] :
                        (hasMND ? mnd[integerDivide(i, maxIndex)] : null);
            }
            var dataIndex = flag ?
                integerDivide(i, mndLength) :
                i % maxIndex;
            returnArray[cachedItem].reference.push(dataIndex);
        }

        if (returnArray[0] && returnArray[0].length > 0) {
            if (!respectDataOrder) {
                // 1) groupData = true, respectOrderInGroup = false, sort by each dimension's own distinct order
                // 2) 'domain' set by user, sort by domain's order
                returnArray = 
                sortByDomain(returnArray, rawData, bindingInfo, mndInfo.globalMND, parsedData, parserOption);
            } else if (groupOption.groupData && groupOption.respectOrderInGroup) {
                // groupData = true, respectOrderInGroup = true, group data while repecting relative order
                returnArray = groupBy(returnArray);
            }
            // When both sorter and legend.order is set, legend.order has higher priority.
            if((groupOption.bindingName !== "color" && groupOption.bindingName !== "shape") || 
                !groupOption.legendOrder){
                returnArray = orderBySorter(returnArray, rawData, bindingInfo, mnd);
            }
            
        }
        // If not passing multiDimensionIndex, meaning it will not be used in handleMeasure
        if(multiDimensionIndex){
            var dimensionIndex = [];
            var returnArrayLength = returnArray.length;
            for(i = 0; i < returnArrayLength; ++i){
                var ref = returnArray[i].reference;
                var refLength = ref.length;
                for(j = 0; j < refLength; ++j){
                    var k = ref[j];
                    dimensionIndex[k] = dimensionIndex[k] || [];
                    dimensionIndex[k].push(i);
                }
            }
            var dimensionIndexLength = dimensionIndex.length;
            for(i = 0; i < dimensionIndexLength; ++i){
                var dimIndex = dimensionIndex[i];
                if(!dimIndex){
                    continue;
                }
                multiDimensionIndex[i] = multiDimensionIndex[i] || [];
                multiDimensionIndex[i].push(dimIndex);
            }
            multiDimensionIndex.levels = multiDimensionIndex.levels || 0;
            multiDimensionIndex.levels++;
        }

        return returnArray;
    };

    //Follow the sequence of the feeding definition, data[][][][]
    function createMeasureMultiDimensionTable(measureArray, bindingInfo, mnd, multiDimensionIndex, options){
        var enableDuplicated = options.enableDuplicated;
        var isBullet = options.isBullet;
        var multiArray = [];
        var dimensionLength = multiDimensionIndex && multiDimensionIndex.levels;
        var rowLength = measureArray.length;
        var i;
        var getPosition = function(dimensionIndex, i, j){
            var v = dimensionIndex[i];
            return v[j] ? v[j] : v[0];
        };
        var fillMeasureArray = function(dimensionIndex, length, rowMeasure, value){
            for(var j = 0; j < length; ++j){
                if (dimensionIndex.length >= dimensionLength) {
                    var tmpValue = multiArray;
                    for (var k = 0; k < dimensionLength - 1; k++) {
                        var pos = getPosition(dimensionIndex, k, j);
                        tmpValue = tmpValue[pos] = tmpValue[pos] || [];
                    }
                    var lastPos = getPosition(dimensionIndex, k, j);
                    if (TypeUtils.isExist(lastPos)) {
                        var v = (value === null && rowMeasure[j] != null? rowMeasure[j] : value);
                        if (enableDuplicated) {
                            tmpValue[lastPos] = tmpValue[lastPos] || [];
                            tmpValue[lastPos].push(v);
                        } else {
                            if (tmpValue[lastPos] == null) {
                                //keep zero value
                                tmpValue[lastPos] = v;
                            }
                        }
                    }
                }
            }
        };

        if (dimensionLength) {
            for (i = 0; i < rowLength; i++) {
                var dimensionIndex = multiDimensionIndex[i];
                if (TypeUtils.isExist(dimensionIndex)) {
                    var rowMeasure = measureArray[i];
                    var length = rowMeasure.length;
                    var value = null;
                    if (length !== mnd.length || options.buildContextId) {
                        if(isBullet){
                            value = rowMeasure.slice();
                        }else{
                            value = rowMeasure[length - 1];
                        }
                        length = mnd.length ? mnd.length : 1;
                    }
                    fillMeasureArray(dimensionIndex, length, rowMeasure, value);
                }
            }
        } else {
            for (i = 0; i < rowLength; i++) {
                multiArray[i] = measureArray[i].slice();
            }
        }
        return multiArray;

    }

    utils.buildMetaData = function(rawData, bindingInfo, MND) {
        return bindingInfo.map(function(bindingInfoItem){
            if (MND && bindingInfoItem[MEASURE_NAMES]) {
                return {
                    'id': MEASURE_NAMES,
                    'type': TYPENAME_DIMENSION,
                    'values': MND.map(function(mndIndex) {
                        var metadata = rawData.metadata(mndIndex)[0];
                        return {
                            'id': metadata.id,
                            'name': metadata.name
                        };
                    })
                };
            } else {
                var showInTooltip = false;
                if(bindingInfoItem.id){
                    showInTooltip = !! bindingInfoItem.showInTooltip;
                    bindingInfoItem = bindingInfoItem.id;
                }
                
                var metadata = rawData.metadata(bindingInfoItem)[0];
                if (bindingInfoItem === CONTEXT_ID_NAME) {
                    return {
                        'id': metadata.id,
                        'name': metadata.name
                    };
                } else {

                    var result = {
                        'id': metadata.id,
                        'name': metadata.name,
                        'type': metadata.semanticType,
                        'dataType': metadata.dataType
                    };
                    if(showInTooltip){
                        result.showInTooltip = true;
                    }
                    if (metadata.formatString) {
                        result.formatString = metadata.formatString;
                    }
                    if (metadata.hasOwnProperty("max")) {
                        result.max = metadata.max;
                    }
                    if (metadata.hasOwnProperty("min")) {
                        result.min = metadata.min;
                    }
                    if (metadata[Constants.FIELD.INRESULT]) {
                        result.hidden = true;
                    }
                    if (metadata[Constants.FIELD.UNIT]) {
                        result.unit = metadata[Constants.FIELD.UNIT];
                    }
                    return result;
                }
            }
        });
    };
    
    utils.getArrayLength = function(seriesBinds) {
        var arrayLength = [];
        for (var i = 0; i < seriesBinds.length; i++){
            arrayLength.push(seriesBinds[i].rowArray.length);
        }
        return arrayLength;
    };
    
    utils.generateNum = function(arrayLength, numberArray) {
        var num = 0;
        for (var i = 0, iLen = numberArray.length; i < iLen; i++) {
            var factor = 1;
            for (var j = i + 1, jLen = arrayLength.length; j < jLen; j++) {
                factor *= arrayLength[j];
            }
            num += numberArray[i] * factor;
        }
        return num;
    };

    utils.dpInitializer = function (trellis){
        return function (){
            return trellis ? {
                    trellisRow: trellis.trellisRow,
                    trellisColumn: trellis.trellisColumn
                } : {};
        };
    };

    utils.sumByCategory = function(array) {
        var results = [], item, i, j, len1, len2;
        var total = 0;
        for (i = 0, len1 = array.length; i < len1; i++) {
            var sum = 0;
            item = array[i];
            if (TypeUtils.isArray(item)) {
                for (j = 0, len2 = item.length; j < len2; j++) {
                    if (TypeUtils.isArray(item[j]) || !TypeUtils.isNumber(item[j])) {
                        continue;
                    }
                    var value = +item[j];
                    if (sum === 0) {
                        sum = value;
                    } else if (sum < 0 && value > 0) {
                        sum = value;
                    } else if (sum * value > 0) {
                        sum += value;
                    }
                }
            } else {
                sum = +item;
            }
            results[i] = sum;
        }
        return results;
    };

    utils.generateSeriesGetter = function (getSeriesFn){
        return function(rawData, dimensions, measures, bindingResults, bindings, 
                bindingDefinition, options) {
            var roleMap = extractBindingDefinition(bindingDefinition);
            var rowDimension = bindingResults[roleMap[CONST_ROW]];
            var columnDimension = bindingResults[roleMap[CONST_COLUMN]];
            var rowLength = rowDimension ? rowDimension.rowArray.length : 0;
            var columnLength = columnDimension ? columnDimension.rowArray.length : 0;
    
            if (rowLength === 0 && columnLength === 0) {
                var playDimension = bindingResults[roleMap[CONST_FRAME]];
                var playLength = playDimension ? playDimension.rowArray.length : 0;
                if (playLength === 0) {
                    getSeriesFn(rawData, dimensions, measures, bindingResults, 
                        undefined, options, bindingDefinition);
                } else {
                    getPlayBindingSeries(getSeriesFn, rawData, dimensions, measures,
                        bindingResults, bindings, bindingDefinition, playDimension, playLength, options);
                }
            } else {
                getTrellisBindingSeries(getSeriesFn, rawData, dimensions, measures, bindingResults, bindings,
                    bindingDefinition, rowDimension, columnDimension, rowLength, columnLength);
            }
        };
    };

    utils.parseData = function(rawData, metadataId, parsedData) {
        var data;
        if (TypeUtils.isExist(parsedData)) {
            data = parsedData[metadataId];
        }
        if (!TypeUtils.isExist(data)) {
            data = rawData.dataInFields([metadataId]);
            for (var i in data) {
                if (data.hasOwnProperty(i)) {
                    data[i] = data[i].data[0];
                    if (data[i] === undefined){
                        data[i] = null;
                    }
                }
            }
        }
        return data;
    };

    utils.getMetadata = function(data) {
        return data._FlatTableD._dataset.metadata;
    };

    utils.getData = function(rawData, bindings, parsedData, parserOption, bindingName) {
        var i, j, length, item;
        if (!parsedData && TypeUtils.isExist(bindings)) {
            var bindSource = [];
            for (i = 0; i < bindings.length; i++) {
                for (j = 0; j < bindings[i].source.length; j++) {
                    if (TypeUtils.isString(bindings[i].source[j])) {
                        bindSource.push(bindings[i].source[j]);
                    }
                }
            }
            parsedData = rawData._FlatTableD.columnDataInFields(bindSource).data;

            if (FiscalUtil.isFiscal(rawData)) {
                //we should remove all illegal fiscal data for fiscal charts.
                var illegalArray = [];
                for (i in parsedData) {
                    if (parsedData.hasOwnProperty(i)) {
                        var timeUnitType = rawData._FlatTableD.getMetadata(i)[0].timeUnitType;
                        if (timeUnitType && timeUnitType.indexOf(Constants.FISCAL.UNITTYPE_PREFIX) === 0) {
                            for (j = parsedData[i].length - 1; j >= 0; j--) {
                                var pValue = FiscalUtil.fiscalToQuantity(parsedData[i][j], parserOption.fiscalObj);
                                if (pValue == null || isNaN(pValue)) {
                                    illegalArray.push(j);
                                }
                            }
                            break;
                        }
                    }
                }
                for (i = 0; i < illegalArray.length; i++) {
                    for (var prop in parsedData) {
                        if (parsedData.hasOwnProperty(prop)) {
                            parsedData[prop].splice(illegalArray[i], 1);
                        }
                    }
                }
            }

            for (i in parsedData) {
                if (parsedData.hasOwnProperty(i)) {
                    var dataType = rawData._FlatTableD.getMetadata(i)[0].dataType;
                    var parser = RawDataParserFactory.get(dataType, parserOption, bindingName);

                    var oneColumn = parsedData[i];
                    length = oneColumn.length;
                    for (j = 0; j < length; j++) {
                        item = oneColumn[j];
                        if(item !== null){
                            oneColumn[j] = parser.parse(item);
                        }
                    }
                }
            }
        }
        return parsedData;
    };

    utils.handleDimension = function(rawData, bindingInfo, mnd, groupOption, parsedData, 
        multiDimensionIndex, parserOption) {
        if (!bindingInfo){
            throw "flat table need fieldsName as it's bindingInfo";
        }
        var length = bindingInfo.length;
        var categoryArray = [];
        var hasMND = false;
        var MNDPosition = -1;
        var MNDItems = [];
        var i, j;
        var respectOrder = (!groupOption.groupData || groupOption.respectOrderInGroup);
        for (i = 0; i < length; i++) {
            var bindItem = bindingInfo[i];
            if (bindItem[MEASURE_NAMES]) {
                hasMND = true;
                MNDPosition = i;
                MNDItems = mnd;
            } else {
                var metadata = rawData.metadata(bindItem)[0];
                if (metadata.semanticType !== TYPENAME_DIMENSION) {
                    throw "semantic type not match";
                }
                var data = utils.parseData(rawData, bindItem, parsedData);
                var dataVolume = data.length;
                if(!categoryArray.length){
                    categoryArray.length = length * data.length;
                }
                for (j = 0; j < dataVolume; j++) {
                    categoryArray[j * length + i] = data[j];
                }
                if (metadata.domain) {
                    respectOrder = false;//When domain is set, respectOrder should be false.
                }
            }
        }
        var mndInfo = {
            globalMND: mnd,
            items: MNDItems,
            position: MNDPosition,
            respectOrder: respectOrder,
            groupOption: groupOption
        };
        if (hasMND) {
            if (categoryArray.length > 0) {
                categoryArray = handleMND(categoryArray, mndInfo, length);
            } else {
                //TODO: add API to get flatTable size.
                var rowLength = rawData._FlatTableD._data.length;
                for (i = 0; i < rowLength; i++) {
                    MNDItems.forEach(function(value, index) {
                        categoryArray[index * rowLength + i] = value;
                    });
                }
            }
        }
        var groupedResult = groupResult(categoryArray, mndInfo,
            rawData, bindingInfo, parsedData, multiDimensionIndex, parserOption);

        return groupedResult;
    };

    utils.handleContinuousDimension = function(rawData, bindingInfo, measureNamesDimension, parsedData) {
        if (!bindingInfo) {
            throw "flat table need fieldsName as it's bindingInfo";
        }
            
        var length = bindingInfo.length;
        for (var i = 0; i < length; i++) {
            var bindItem = bindingInfo[i];
            var metadata = rawData.metadata(bindItem)[0];
            if (metadata.semanticType !== TYPENAME_DIMENSION) {
                throw "semantic type not match";
            }
            var data = utils.parseData(rawData, bindItem, parsedData);
            return data.map(function(e){
                return [e];
            });
        }
    };

    utils.handleMeasure = function(rawData, bindingInfo, mnd, parsedData, multiDimensionIndex, options) {
        if (bindingInfo) {
            var length = bindingInfo.length;
            var measureArray = [];
            for (var i = 0; i < length; i++) {
                var data = utils.parseData(rawData, bindingInfo[i], parsedData);
                if(!measureArray.length){
                    measureArray.length = data.length;
                }
                for (var j = data.length; j--;) {
                    measureArray[j] = measureArray[j] || [];
                    measureArray[j][i] = data[j];
                }
            }
            var multiArray = createMeasureMultiDimensionTable(measureArray, bindingInfo, mnd,
                    multiDimensionIndex, options);
            var result = {
                measureArray: measureArray,
                multiArray: multiArray
            };

            if (multiDimensionIndex && multiDimensionIndex.length && multiDimensionIndex.levels &&
                !options.enableDuplicated) {
                result.measureArray = uniqMeasure(measureArray, multiDimensionIndex);
            }

            //in some special charts, we need to calculator measures and update result
            if (options && options.funMeasuresCalculator) {
                options.funMeasuresCalculator(options, result);
            }
            return result;
        } else {
            throw "flat table need fieldsName as it's bindingInfo";
        }
    };

    function combineMsrArrays(a, b) {
        return a.map(function(v, i) {
            return TypeUtils.isExist(v) ? v : b[i];
        });
    }

    function uniqMeasure(msrArr, multiDimIndices) {
        var uniqMsrs = [],
            uniqDims = {};
        for (var len = multiDimIndices.length, i = 0, key; i < len; i++) {
            if (!multiDimIndices[i]) {
                continue;
            }
            key = multiDimIndices[i].map(function(pos) {
                return pos.join(",");
            }).join(":");
            if (!uniqDims.hasOwnProperty(key)) {
                uniqMsrs.push(msrArr[i]);
                uniqDims[key] = uniqMsrs.length - 1;
            } else {
                var msrId = uniqDims[key];
                uniqMsrs[msrId] = combineMsrArrays(uniqMsrs[msrId], msrArr[i]);
            }
        }
        return uniqMsrs;
    }

    //TODO: only support 2d array, need to support cross join Nd array
    utils.generateIndexArray = function(inputArray) {
        var length = inputArray.length;
        if (length === 0) { //series is not bind
            return [0];
        }
        var arr = [];
        var i, j;
        for (i = 0; i < length; i++) {
            for (j = 0; j < inputArray[i]; j++) {
                arr[i] = arr[i] || [];
                arr[i].push(j);
            }
        }
        var index = 0;
        var resultArray = [];
        if (arr.length === 1) { //1d array
            for (i = 0; i < arr[0].length; i++) {
                resultArray[index] = resultArray[index] || [];
                resultArray[index].push(i);
                index++;
            }
            return resultArray;
        }
        if (arr.length && TypeUtils.isExist(arr[0])) {
            for (i = 0; i < arr[0].length; i++) {
                for (j = 0; j < arr[1].length; j++) {
                    resultArray[index] = resultArray[index] || [];
                    resultArray[index].push(i);
                    resultArray[index].push(j);
                    index++;
                }
            }
        }
        return resultArray;
    };
    
    utils.processSeriesContext = function(context, categoryNum, indexArray){
        var result;
        if (context && context.values) {
            var metas = context.metaData;
            result = [];
            
            var values = context.values;
            for(var tt = 0; tt < metas.length; ++tt){
                var meta = metas[tt];
                var temp = values[tt];
                if(temp){
                    if(categoryNum >= 0){
                        temp = temp[categoryNum];
                    }
                    for (var j = 0; temp && j < indexArray.length; j++) {
                        if (TypeUtils.isExist(temp[indexArray[j]])) {
                            temp = temp[indexArray[j]];
                        }
                    }
                }
                result.push(temp);
            }
        }
        return result;
    };


    
    utils.processYYSeriesContext = function(context, indexArray) {
        if (TypeUtils.isArray(indexArray)) {
            return utils.processSeriesContext(context, -1, indexArray);
        } else if (!context || !context.values) { // no context
            return undefined;
        } else {                                  // no series
            return context.metaData.map(function(meta, i) {
                var vals = context.values[i];
                return TypeUtils.isArray(vals) ? vals.map(function(v) {
                    return v[0];
                }) : vals;
            });
        }
    };
    
    utils.getAvailableCategories = function(measureBinds, seriesBinds) {
        var availableCategories = [];
        var arrayLength = this.getArrayLength(seriesBinds);
        var indexArray = this.generateIndexArray(arrayLength);
        
        if (measureBinds[0] && measureBinds[0].values) {
            measureBinds[0].values.forEach(function(values, categoryNum) {
                if (TypeUtils.isArray(values)) {
                    for (var index in values) {
                        if (values.hasOwnProperty(index)) {
                            index = parseInt(index);
                            availableCategories[index] = availableCategories[index] || [];
                            availableCategories[index].push(categoryNum);
                        }
                    }
                } else {
                    indexArray.forEach(function(v, index) {
                        availableCategories[index] = availableCategories[index] || [];
                        availableCategories[index].push(categoryNum);
                    });
                }
            });
        }

        return availableCategories;
    };

    return utils;
});

define('sap/viz/chart/chains/SeriesContext',[
    'sap/viz/framework/common/util/DataUtils'
], function(DataUtils) {
    return function(series, seriesMeta, seriesBinds, measureBinds){
        if(seriesMeta.length === 0){
            var noBinding = [];
            if(measureBinds && measureBinds.length === 1 && measureBinds[0] && 
                    measureBinds[0].metaData){
                noBinding = [{measureNames: measureBinds[0].metaData[0].id}];
            }
            return noBinding;
        } else{
            return series.map(function(serie){
                var sample, i = 0;
                while(i < serie.length && !serie[i]){
                    i++;
                }
                if(i >= serie.length){
                    return null;
                }
                sample = serie[i];
                return seriesMeta.reduce(function(ctx, key, idx) {
                        var metas = seriesBinds[idx].metaData,
                            vals = sample[key];
                        metas.forEach(function(meta, i) {
                            ctx[meta.id] = vals[i] && vals[i][DataUtils.DIMENSION_VALUE] || vals[i];
                        });
                        return ctx;
                    }, {});
            });
        }
    };
});
define('sap/viz/chart/chains/BaseChains',[
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/chains/ChainUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/framework/binding/BindingManager",
    'sap/viz/chart/chains/SeriesContext'
], function Setup(
    TypeUtils,
    ChainUtils,
    NumberUtils,
    ObjectUtils,
    ArrayUtils,
    BindingManager,
    SeriesContextFunc
) {

    var flatTableChains = {};

    var parsedData;
    var multiDimensionIndex;

    var resetState = function() {
        multiDimensionIndex = [];
        parsedData = null;
    };

    flatTableChains.defineSpec = function (series, measures, dimensions) {
        //for combinationEx and flexible stacked, spec is required.
        series.forEach(function (sr) {
            var mndKey, mndIdx, i;

            for (i = 0; i < measures.length; i++) {
                if (sr.measureMeta && sr.measureMeta.indexOf(measures[i]) > -1) {
                    mndKey = measures[i];
                    break;
                }
            }

            for (i = 0; i < dimensions.length; i++) {
                if (sr.seriesMeta &&
                    sr.seriesMeta[dimensions[i]] &&
                    sr.seriesMeta[dimensions[i]].hasOwnProperty("mndIndex")) {
                    mndIdx = sr.seriesMeta[dimensions[i]].mndIndex;
                    break;
                }
            }

            // series should conform its array interface as much as possible, so spec shall be non-enumerable
            Object.defineProperty(sr, "spec", {
                enumerable: false,
                value: {
                    mndKey: mndKey,
                    mndIdx: mndIdx
                }
            });
        });
    };

    var getBindingSeries = function(rawData, dimensions, measures, bindingResults, trellisInfo,
        options) {
        var series = [];

        var categoryMeta = "categoryAxis";
        var categoryBinds = bindingResults[categoryMeta];

        var seriesBinds = [],
            seriesMeta = [],
            measureBinds = [],
            measureMeta = [];
        if (categoryBinds) {

            var contextMeta = 'context';

            var allowEmptyMeasure = options && options.allowEmptyMeasure;

            dimensions.filter(function(d){
                return d !== categoryMeta;
            }).forEach(function(d){
                if (bindingResults[d]){
                    seriesBinds.push(bindingResults[d]);
                    seriesMeta.push(d);
                }
            });

            measures.forEach(function(m){
                if (bindingResults[m]){
                    measureBinds.push(bindingResults[m]);
                    measureMeta.push(m);
                }
            });

            var initDp = ChainUtils.dpInitializer(trellisInfo);

            var arrayLength = ChainUtils.getArrayLength(seriesBinds);
            var indexArray = ChainUtils.generateIndexArray(arrayLength);
            var dp, i, j, k, temp;

            var availableCategories = ChainUtils.getAvailableCategories(measureBinds, seriesBinds);
            var meta;
            for (i = 0; i < indexArray.length; i++) {
                series[i] = new Array(categoryBinds.rowArray.length);
                // we define measureMeta as an enumerable property in series
                // in order to config series settings in combinationEx when all series data is null
                Object.defineProperty(series[i], "measureMeta", {
                    enumerable: false,
                    value: measureMeta
                });
                if (!availableCategories[i]) {
                    continue;
                }
                // for (var categoryNum = 0, len = categoryBinds.rowArray.length; categoryNum < len; categoryNum++) {
                for (var categoryNumIndex = 0; categoryNumIndex < availableCategories[i].length; categoryNumIndex++) {
                    var categoryNum = availableCategories[i][categoryNumIndex];
                    dp = initDp();
                    var isExisted = true;
                    var seriesMetaValue = {};
                    for (j = 0; j < indexArray[i].length; j++) {
                        var tmpSeries = seriesBinds[j].rowArray[indexArray[i][j]];
                        if (tmpSeries.mndIndex) {
                            var mndIndex = tmpSeries.mndIndex;
                            meta = bindingResults[seriesMeta[j]].metaData;
                            var mndMeta = meta[tmpSeries.indexOf(mndIndex)];
                            if (mndMeta && mndMeta.values) {
                                var metaDataValues = mndMeta.values;
                                for (k = 0; k < metaDataValues.length; k++) {
                                    if (metaDataValues[k].id == mndIndex) {
                                        tmpSeries.mndIndex = k;
                                        break;
                                    }
                                }
                            }
                        }
                        var seriesMetaId = seriesMeta[j];
                        dp[seriesMetaId] = tmpSeries;
                        seriesMetaValue[seriesMetaId] = tmpSeries;
                    }
                    if (!series[i].seriesMeta) {
                        // we define seriesMeta as an enumerable property in series
                        // in order to config series settings in combinationEx when all series data is null
                        Object.defineProperty(series[i], "seriesMeta", {
                            enumerable: false,
                            value: seriesMetaValue
                        });
                    }
                    for (k = 0; k < measureBinds.length; k++) {
                        if (TypeUtils.isExist(measureBinds[k].values) &&
                            (TypeUtils.isExist(measureBinds[k].values[categoryNum]) ||
                            (measureBinds[k].metaData[0].type === "Dimension"))) {
                            temp = measureBinds[k].values[categoryNum];
                            for (j = 0; j < indexArray[i].length; j++) {
                                if(TypeUtils.isExist(temp[indexArray[i][j]]) || allowEmptyMeasure){
                                    temp = temp[indexArray[i][j]];
                                }
                            }
                            if (TypeUtils.isArray(temp)) {
                                isExisted = false;
                            } else {
                                dp[measureMeta[k]] = temp;
                            }
                        } else {
                            isExisted = false;
                        }
                    }
                    var context = ChainUtils.processSeriesContext(bindingResults.context, categoryNum, indexArray[i]);
                    if(context) {
                        dp.context = context;
                    }
                    var addition = ChainUtils.processSeriesContext(bindingResults.additionInfo,
                            categoryNum, indexArray[i]);
                    if(addition){
                        dp.addition = addition;
                    }


                    if (!isExisted) {
                        continue;
                    }
                    var seriesIndex = ChainUtils.generateNum(arrayLength, indexArray[i]);
                    series[seriesIndex] = series[seriesIndex] || [];
                    series[seriesIndex][categoryNum] = dp;
                }
            }
        }

        bindingResults.series = series.filter(function (e){
            return e;
        });

        bindingResults.seriesContext = SeriesContextFunc(series, seriesMeta, seriesBinds, measureBinds);

        if (options && options.isFlexibleStack) {
            flatTableChains.defineSpec(series, measures, dimensions);
        }
    };

    flatTableChains.GetBindingSeries = ChainUtils.generateSeriesGetter(getBindingSeries);

    flatTableChains.GetContext = function(rawData, context, duplicated, mnd) {
        if (context.length === 0) {
            return {
                values: [],
                metaData: []
            };
        }

        var values = [];
        for(var i = 0; i < context.length; ++i){
            var name = context[i].id || context[i];
            var results = ChainUtils.handleMeasure(rawData, [name], mnd,
                    parsedData, multiDimensionIndex, {enableDuplicated : duplicated, buildContextId: true});
            values.push(results.multiArray);
        }
        return {
            values:  values,
            metaData: ChainUtils.buildMetaData(rawData, context)
        };
    };

    function getDefByBindingId(bindingDefinition, bindingName){
        var def = null;
        if (bindingDefinition) {
            bindingDefinition.some(function(item) {
                if (item.id === bindingName) {
                    def = item;
                    return true;
                }
                return false;
            });
        }
        return def;
    }

    flatTableChains.GetDimensionsFromFlattable = function(rawData, fields, mnd, bindings,
        bindingDefinition, bindingName, groupOption, parserOption) {
        var metadata = ChainUtils.getMetadata(rawData).fields;
        parsedData = ChainUtils.getData(rawData, bindings, parsedData, parserOption, bindingName);
        for (var i = 0, iLen = fields.length; i < iLen; i++) {
            var field = fields[i];
            for (var j = 0, jLen = metadata.length; j < jLen; j++) {
                if (field.measureNames || field === metadata[j].id) {
                    var rowArray;
                    var def = getDefByBindingId(bindingDefinition, bindingName);
                    if (def && def.continuous &&
                        (!parserOption || (parserOption && !parserOption.isTimeStacked))){
                        rowArray = ChainUtils.handleContinuousDimension(rawData, fields, mnd, parsedData);
                    } else {
                        var options = {
                            isTimeStacked: bindingName === "timeAxis" &&
                            parserOption && parserOption.isTimeStacked
                        };
                        groupOption.bindingName = bindingName;
                        rowArray = ChainUtils.handleDimension(rawData, fields, mnd,
                            groupOption, parsedData, multiDimensionIndex, options);
                    }
                    return {
                        values: ArrayUtils.transpose(rowArray),
                        metaData: ChainUtils.buildMetaData(rawData, fields, mnd),
                        rowArray: rowArray
                    };
                }
            }
        }
    };

    flatTableChains.GetMeasuresFromFlattable = function(rawData, fields, mnd, bindings, duplicated,
        bindingName, needSum, parserOption) {
        var metadata = ChainUtils.getMetadata(rawData).fields;
        parsedData = ChainUtils.getData(rawData, bindings, parsedData, parserOption);
        var sortedData;
        if (parserOption && parserOption.isTimeWaterFall) {
            var mName = fields[0];
            if (mName) {
                var k, dateName = "Date";
                for (k = 0; k < bindings.length; k++) {
                    var binding = bindings[k];
                    if (binding.feed === "timeAxis") {
                        dateName = binding.source[0] || dateName;
                        break;
                    }
                }
                sortedData = parsedData[dateName].map(function(item, index) {
                    return {Date: item, Value: parsedData[mName][index]};
                });
                ArrayUtils.stableSort(sortedData, function(a, b) {
                    if (a.Date && b.Date) {
                        return a.Date.parsedValue - b.Date.parsedValue;
                    } else if (!a.Date) {
                        return -1;
                    } else if (!b.Date) {
                        return 1;
                    }
                });
                for (k = 0; k < sortedData.length; k++) {
                    parsedData[dateName][k] = sortedData[k].Date;
                    if (sortedData[k].Date) {
                        parsedData[mName][k] = sortedData[k].Value;
                    } else {
                        parsedData[mName][k] = null;
                    }
                }
            }
        }

        var timeArray, timeCompare;
        var isTimeStacked = (parserOption && parserOption.isTimeStacked);
        if (isTimeStacked) {
            timeArray = parserOption.timeAxis.values[0];
            timeCompare = function (a, b) {
                if (a.timeValue && b.timeValue) {
                    return a.timeValue - b.timeValue;
                } else if (!a.timeValue) {
                    return -1;
                } else if (!b.timeValue) {
                    return 1;
                }
            };
        }

        for (var i = 0, iLen = fields.length; i < iLen; i++) {
            for (var j = 0, jLen = metadata.length; j < jLen; j++) {
                if (fields[i] === metadata[j].id) {
                    if (!parserOption) {
                        parserOption = {};
                    }
                    parserOption.bindingName = bindingName;
                    parserOption.enableDuplicated = duplicated;
                    var returnArray = ChainUtils.handleMeasure(rawData, fields, mnd, parsedData,
                        multiDimensionIndex, parserOption);

                    var array = ArrayUtils.transpose(returnArray.measureArray);

                    var x = 0, xLen = array.length;
                    var domain = Array(xLen);
                    for (; x < xLen; ++x) {
                        var row = array[x];
                        var min = Infinity, max = -Infinity;
                        for (var y = 0, yLen = row.length; y < yLen; ++y) {
                            var ele = row[y];
                            if (ele == null){
                                continue;
                            }
                            ele = +ele;
                            min = Math.min(min, ele);
                            max = Math.max(max, ele);
                        }
                        domain[x] = [min, max];
                    }
                    //When mnd is not bound ,only first measure will be visible.
                    var metaData = ChainUtils.buildMetaData(rawData, fields);
                    if (!(mnd && mnd.length)) {
                        metaData = [metaData[metaData.length - 1]];
                        domain = [domain[domain.length - 1]];
                    }
                    var multiArray = returnArray.multiArray;
                    if (isTimeStacked) {
                        var sortedMultiArray = multiArray.map(function(item, index) {
                            return {array: item, timeValue: timeArray[index] && timeArray[index].parsedValue};
                        });
                        ArrayUtils.stableSort(sortedMultiArray, timeCompare);
                        multiArray = sortedMultiArray.map(function(item) {
                            return item.array;
                        });
                    }
                    if (domain.length) {
                        //isNaN(null) is false, but isNaN(undefined) is true.
                        metaData.forEach(function(md, idx) {
                            if (md.hasOwnProperty("min") && TypeUtils.isNumeric(md.min)) {
                                domain[idx][0] = md.min;
                            }
                            if (md.hasOwnProperty("max") && TypeUtils.isNumeric(md.max)) {
                                domain[idx][1] = md.max;
                            }
                        });
                    }
                    var result = {
                        values: multiArray,
                        range: domain,
                        metaData: metaData
                    };
                    if (needSum){
                        if(needSum === "NEED_ONLY_TOTAL_SUM"){
                            var hasPositive = result.values.some(function(value){
                                return value > 0;
                            });
                            result.totalSum = ArrayUtils.sum(result.values.filter(function(value){
                                return value > 0 || (!hasPositive);
                            }));
                        }else{
                            result.categorySum = ChainUtils.sumByCategory(multiArray);
                        }
                    }
                    return result;
                }
            }
        }
    };

    flatTableChains.OnBindingFinished = function() {
        resetState();
    };
    flatTableChains.OnBindingStart = function() {
        resetState();
    };

    flatTableChains.extend = function(type, defaultChains) {
        var chains = {};
        defaultChains.forEach(function(item) {
            chains[type + item] = flatTableChains[item];
        });

        Object.defineProperty(chains, "parsedData", {
            get: function() {
                return parsedData;
            },
            set: function(newValue) {
                parsedData = newValue;
            }
        });
        Object.defineProperty(chains, "multiDimensionIndex", {
            get: function() {
                return multiDimensionIndex;
            },
            set: function(newValue) {
                multiDimensionIndex = newValue;
            }
        });
        return chains;
    };
    BindingManager.registerChain('GetBindingSeries', flatTableChains.GetBindingSeries);
    return flatTableChains;
});

define('sap/viz/chart/chains/XYChains',[
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/framework/binding/BindingManager'
], function Setup(
    BaseChains,
    BindingManager
) {
    var xyChains = {};
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetMeasuresFromFlattable',
        'GetBindingSeries',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];
    xyChains = BaseChains.extend('xy', defaultChains);
    Object.keys(xyChains).forEach(function(key) {
        BindingManager.registerChain(key, xyChains[key]);
    });
    return xyChains;
});
define('sap/viz/chart/scales/FrameScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/BaseScale',
    'sap/viz/framework/common/util/ObjectUtils'
], function(
   oo,
   BaseScale,
   ObjectUtils)
   {

    /*
     * Used for shape scale
     */
    var FrameScale = function(domain, range) {
        FrameScale.superclass.constructor.apply(this, arguments);
        this.__className = "sap.viz.scale.FrameScale";
        this._name = null;
        this._type = "frame";
        this._initScale();
    };

    oo.extend(FrameScale, BaseScale);

    FrameScale.prototype._initScale = function() {
        this._scale = d3.scale.ordinal();
        var domain = [];
        for (var i = 0, len = this._domain.length; i < len; i++) {
            if (this._domain[i]) {
                domain.push(this._domain[i].v || this._domain[i]);
            } else {
                domain.push(this._domain[i]);
            }
        }
        this._scale.domain(domain).range(this._range);
        this._isReset = false;
    };

    FrameScale.prototype.getDomain = function() {
        this._ensureScaled();
        return this._domain;
    };

    FrameScale.prototype.getRange = function() {
        this._ensureScaled();
        return this._range;
    };

    FrameScale.prototype.scale = function(value) {
        var domain = this.getDomain();
        for (var i in domain) {
            if (ObjectUtils.deepEqual(domain[i], value)) {
                return this._scale(value ? (value.v || value) : value);
            }
        }
        //if value is not a member of scale domain, return the index of the first element
        return 0;
    };
    
    FrameScale.prototype._ensureScaled = function() {
        if (this._scale === undefined || this._isReset === true) {
            this._initScale();
        }
    };

    return FrameScale;
});
define(
        'sap/viz/chart/scales/FrameScaleProcessor',["sap/viz/chart/scales/FrameScale",
         'sap/viz/framework/scale/ScaleRepository'],
    function(FrameScale,
            ScaleRepository)
    {
    

        var frameScale = function(data, name, scaleMgr, propMgr, option) {
            option = option || {};
            var seriesType = option.seriesType, role = option.role;
            var domain = [];
            var range = [];

            if (data.values && data.values[0]) {
                for (var i = 0; i < data.values[0].length; i++) {
                    domain.push(data.values[0][i]);
                    range.push(i);
                }
            }

            scaleMgr.add(name, {
                serializable: true,
                defaultValue: {
                    "feed": name,
                    "type": "frame",
                    "currentValue": null,
                }
            });

            scaleMgr.add(name + ".domain", {
                serializable: true,
                readonly: true,
                defaultValue: domain,
            });

            var frameScale = new FrameScale(domain, range);


            return frameScale;
        };
        ScaleRepository["frameScale"] = frameScale;
       
        return frameScale;
    });
define('sap/viz/chart/dynamicScales/StackedDyScaleProcessor',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/scale/DynamicScaleRepository',
    "sap/viz/chart/dynamicScales/BaseDyScaleProcessor"

],function(
    oo,
    DynamicScaleRepository,
    BaseDyScaleProcessor
){

    function StackedDyScaleProcessor(type, propertyMgr, dataModel, runtime){
        StackedDyScaleProcessor.superclass.constructor.apply(this, arguments);
    }
    ["stacked_bar", "stacked_column", "dual_stacked_bar",
    "dual_stacked_column", "timeseries_stacked_column", "waterfall",
    "horizontal_waterfall","timeseries_waterfall", "stacked_waterfall",
    "horizontal_stacked_waterfall", "stacked_combination", "horizontal_stacked_combination",
    "dual_stacked_combination","dual_horizontal_stacked_combination", 
    "timeseries_stacked_combination", ]. forEach(function(type){
        DynamicScaleRepository[type] = StackedDyScaleProcessor;
    });

    oo.extend(StackedDyScaleProcessor, BaseDyScaleProcessor);

    StackedDyScaleProcessor.prototype.getMinMax = function(){
        var clean = this.cleanValue;
        var min = false, min2 = false;
        var isDual = !!this._scales.valueAxis2;
        this._dataModel._series.forEach(function(ss){
            var inValueAxis2 = isDual && ss.measureMeta &&
                               ss.measureMeta.indexOf("valueAxis2") > -1;
            ss.forEach(function(dp){
                if(!dp){
                    return;
                }
                var v  = clean(this.getValue(dp));
                if(inValueAxis2){
                    min2 = min2 === false? v: min2;
                    min2 = Math.min(min2, v);
                }else{
                    min = min === false? v: min;
                    min = Math.min(min, v);
                }

            }, this);
        }, this);


        var domain = this._scales[this._mainValue].getAutoDomain().map(clean);
        var result = {  minTable: [Math.max(min, 0)],
                        maxTable: [Math.max.apply(null, domain)] };

        if(isDual){
            domain = this._scales.valueAxis2.getAutoDomain().map(clean);
            result.minTable2 = [Math.max(min2, 0)];
            result.maxTable2 = [Math.max.apply(null, domain)];
        }
        return result;
    };

    return StackedDyScaleProcessor;
});
define('sap/viz/chart/views/XYChartView',['sap/viz/framework/common/util/oo',
        'sap/viz/chart/views/ChartView',
        'sap/viz/chart/components/plotareas/XYPlotArea',
        'sap/viz/chart/components/legend/CombinationLegend',
        "sap/viz/chart/components/util/TextUtils",
        'sap/viz/framework/common/util/TypeUtils',
        'sap/viz/chart/components/legend/LineLegend',
        'sap/viz/framework/binding/bindingValidationUtil',
        'sap/viz/framework/chartmodel/ContextBuilder',
        'sap/viz/chart/chains/XYChains',
        "sap/viz/chart/scales/FrameScaleProcessor",
        "sap/viz/chart/dynamicScales/StackedDyScaleProcessor"
    ],
    function Setup(oo, ChartView, PlotArea, CombinationLegend, TextUtils,
        TypeUtils, LineLegend, bindingValidationUtil, ContextBuilder) {
    


        var XYChartView = function(runtime, option) {
            XYChartView.superclass.constructor.apply(this, arguments);
            this._supportLazyRender = true;
            this.setValueAxisIndex(option.bindings);
            runtime.statusManager().add("plotArea.series", {
                get: this._getSeriesSettings.bind(this)
            });
        };

        oo.extend(XYChartView, ChartView);

        XYChartView.prototype._getSeriesSettings = function() {
            if (!this._data) {
                return null;
            }
            return this._data.series.map(function(sr) {
                return this._getSingleSeriesSetting(sr);
            }.bind(this));
        };

        XYChartView.prototype._getSingleSeriesSetting = function(sr) {
            // do not use sr.settings directly as it contains other attributes which must not be exposed
            if (!sr.seriesMeta) {
                return null;
            }
            var settings = {
                dataContext: ContextBuilder.buildBasic(this._data, sr.seriesMeta, null, null, {})
            };

            if (this.isLine()) {
                settings.type = "line";
            } else if (this.isBar()) {
                settings.type = "bar";
            } else if (this._renderType.match(/area/)) {
                settings.type = "area";
            }

            if (this._renderType.match(/area|stacked/)) {
                settings.stack = "stacked";
            }

            return settings;
        };

        XYChartView.prototype.setSize = function() {
            if (this._plotArea && this._plotArea.setRoughSize) {
                this._plotArea.setRoughSize.apply(this._plotArea, arguments);
            }
            XYChartView.superclass.setSize.apply(this, arguments);
        };

        XYChartView.prototype._getDataItems = function() {
            var dataItems = ["valueAxis", "categoryAxis", "color", "dataFrame", "series",
             "trellisRow", "trellisColumn", "seriesContext"];
            if (this._valueAxisIndex === "valueAxis2") {
                dataItems[0] = "valueAxis2";
                dataItems[2] = "color2";
            }
            return dataItems;
        };

        XYChartView.prototype._createPlotContainer = function(isTrellis) {
      
            this._plotArea = new PlotArea(this.runtime(), {
                renderType: this._renderType,
                valueAxisIndex: this._valueAxisIndex
            });

            this._plotArea.setRoughSize(this._size);

            this.setChild("main", this._plotArea, {
                priority: 3
            });
        };

        XYChartView.prototype.isCombination = function() {
            return this._renderType.indexOf("combination") !== -1;
        };

        XYChartView.prototype.isLine = function() {
            return this._renderType.indexOf("line") !== -1;
        };

        XYChartView.prototype._getLegendDefinition = function() {
            if (this.isCombination()) {
                return [CombinationLegend];
            } else if(this.isLine()){
                return [LineLegend];
            } else {
                return XYChartView.superclass._getLegendDefinition.apply(this, arguments);
            }
        };
        
     

        XYChartView.prototype.isBar = function() {
            return this._renderType.search(/bar|column/) !== -1;
        };

        XYChartView.prototype._getLegendInitOptions = function() {
            var noFillSupport = this._renderType.search(/area/) === -1;
            if (this.isBar()) {
                return [{
                    defaultMarkerShape: "squareWithRadius",
                    noFillSupport:noFillSupport
                }];
            } else {
                return [{noFillSupport:noFillSupport}];
            }
        };

        XYChartView.prototype.calculatePaddingInPX = function(prop){
            var paddings = XYChartView.superclass.calculatePaddingInPX.apply(this, arguments);
            var isHorizontal = false;
            var plotArea = this._plotArea;
            if(plotArea){
                var horizontal = plotArea._isHorizontal;
                if(TypeUtils.isFunction(horizontal)){
                    isHorizontal = plotArea._isHorizontal();
                }else if(horizontal === true){ 
                    isHorizontal = true;
                }
            }
            if((prop.get("title.visible") === false) && !isHorizontal &&
                (prop.get("valueAxis.visible") === true)){
                //If padding with pixel less than value axis label hegiht / 2 and 
                //title is invisible, add half value label's height 
                //to avoid cut the latest value axis label.  
                this.changePaddingTop(prop, paddings);
            }
            return paddings;
        };

        XYChartView.prototype.setData = function(data, bindings) {
            this.setValueAxisIndex(bindings);
            XYChartView.superclass.setData.apply(this, arguments);
        };

        XYChartView.prototype.setValueAxisIndex = function(bindings) {
            this._valueAxisIndex = bindingValidationUtil.getValueAxisBindings(bindings)[0];
            var oppositeValueAxis = (this._valueAxisIndex === "valueAxis") ? "valueAxis2" : "valueAxis";
            this.runtime().zoneManager().remove("tempFeedingZone." + oppositeValueAxis);
            this.runtime().zoneManager().remove("tempPropertyZone." + oppositeValueAxis);
        };

        return XYChartView;
    });

define('sap/viz/chart/metadata/bindings/XYBindings',[], function Setup() {

    var feeds = [{
        "id": "dataFrame",
        "name": "IDS_DATA_FRAME",
        "type": "Dimension",
        "min": 0,
        "max": 1,
        "acceptMND": false,
        "role": "frame.data"
    }, {
        "id": "trellisColumn",
        "name": "IDS_TRELLIS_COLUMN",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "trellis.columnCategory",
    }, {
        "id": "trellisRow",
        "name": "IDS_TRELLIS_ROW",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "trellis.rowCategory"
    }, {
        "id": "categoryAxis",
        "name": "IDS_CATEGORY_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "layout.category"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }];

    return feeds;
});
define('sap/viz/chart/components/plots/DataHandler',[], function Setup() {
    var Handler = function() {

    };

    Handler.prototype.reset = function() {};

    Handler.prototype.getBase = function(index, value) {
        return 0;
    };

    Handler.prototype.add = function(index, value) {
        return value;
    };

    Handler.prototype.destroy = function() {
    };

    var PercentageHandler = function() {

    };

    PercentageHandler.prototype.reset = function(length) {
        this._sum = [];
    };

    PercentageHandler.prototype.getBase = function(index, value) {
        if (this._sum[index] == null) {
            this._sum[index] = 0;
        }
        return this._sum[index];
    };

    PercentageHandler.prototype.add = function(index, value) {
        if (this._sum[index] === 0) {
            this._sum[index] = value;
        } else if (this._sum[index] < 0 && value > 0) {
            this._sum[index] = value;
        } else if (this._sum[index] * value > 0) {
            this._sum[index] += value;
        }
        return this._sum[index];
    };

    PercentageHandler.prototype.destroy = function() {
        this._sum = null;
    };

    var StackedHandler = function() {
        this._stackedBase = [];
    };

    StackedHandler.prototype.destroy = function() {
        this._sum = null;
        this._stackedBase = null;
    };

    StackedHandler.prototype.reset = function() {
        this._sum = [];
        this._stackedBase = [];
    };

    StackedHandler.prototype.getBase = function(index, value, series) {
        if (this._sum[index] == null) {
            this._sum[index] = 0;
        }
        if (this._stackedBase[index] && this._stackedBase[index][series] != null) {
            return this._stackedBase[index][series];
        } else {
            return this._sum[index];
        }
    };

    StackedHandler.prototype.add = function(index, value, series) {
        if (this._stackedBase[index] == null) {
            this._stackedBase[index] = [];
        }
        if (this._stackedBase[index][series] == null) {
            this._stackedBase[index][series] = this._sum[index];
            return this._sum[index] += value;
        } else {
            return this._stackedBase[index][series] + value;
        }
    };

    var SignSensitiveHandler = function() {
        this._stackedBase = [];
    };

    SignSensitiveHandler.prototype.reset = function(length) {
        this._positiveSum = [];
        this._negativeSum = [];
        this._stackedBase = [];
    };

    SignSensitiveHandler.prototype.destroy = function() {
        this._positiveSum = null;
        this._negativeSum = null;
        this._stackedBase = null;
    };

    SignSensitiveHandler.prototype.getBase = function(index, value, series) {
        if (this._positiveSum[index] == null) {
            this._positiveSum[index] = 0;
        }
        if (this._negativeSum[index] == null) {
            this._negativeSum[index] = 0;
        }
        if (this._stackedBase[index] && this._stackedBase[index][series] != null) {
            return this._stackedBase[index][series];
        } else {
            if (value >= 0) {
                return this._positiveSum[index];
            } else {
                return this._negativeSum[index];
            }
        }
    };

    SignSensitiveHandler.prototype.add = function(index, value, series) {
        if (this._stackedBase[index] == null) {
            this._stackedBase[index] = [];
        }
        if (this._stackedBase[index][series] == null) {
            if (value >= 0) {
                this._stackedBase[index][series] = this._positiveSum[index];
                return this._positiveSum[index] += value;
            } else {
                this._stackedBase[index][series] = this._negativeSum[index];
                return this._negativeSum[index] += value;
            }
        } else {
            return this._stackedBase[index][series] + value;
        }
    };

    var PercentageStackHandler = function() {
        this._stackedBase = [];
    };

    PercentageStackHandler.prototype.reset = function(length) {
        this._sum = [];
        this._stackedBase = [];
    };

    PercentageStackHandler.prototype.getBase = function(index, value, series) {
        if (this._sum[index] == null) {
            this._sum[index] = 0;
        }
        if (this._stackedBase[index] && this._stackedBase[index][series] != null) {
            return this._stackedBase[index][series];
        } else {
            return this._sum[index];
        }
    };

    PercentageStackHandler.prototype.add = function(index, value, series) {
        if (this._stackedBase[index] == null) {
            this._stackedBase[index] = [];
        }
        if (this._stackedBase[index][series] == null) {
            this._stackedBase[index][series] = this._sum[index];
            if (this._sum[index] === 0) {
                this._sum[index] = value;
            } else if (this._sum[index] < 0 && value > 0) {
                this._sum[index] = value;
            } else if (this._sum[index] * value > 0) {
                this._sum[index] += value;
            }
            return this._sum[index];
        } else {
            return this._stackedBase[index][series] + value;
        }
    };

    PercentageStackHandler.prototype.destroy = function() {
        this._sum = null;
        this._stackedBase = null;
    };

    var WTFHandler = function() {
        this._sum = [];
        this._base = [];
        this._addHistory = {};
    };

    WTFHandler.prototype.destroy = function() {
        this._sum = null;
        this._base = null;
        this._addHistory = null;
    };

    WTFHandler.prototype.reset = function(length) {
        this._sum = [];
        this._base = [];
        this._addHistory = {};
    };

    WTFHandler.prototype.getBase = function(index, value) {
        if (this._base[index] == null) {
            this._base[index] = value;
            this._sum[index] = value;
        }
        return this._base[index];
    };

    WTFHandler.prototype.add = function(index, value) {
        var key = index + "-" + value;
        if(!this._addHistory[key]){  //only add once
            this._sum[index] += value;
            this._addHistory[key] = true;
        }
        return this._sum[index];
    };

    var STKWTFHandler = function() {

    };

    STKWTFHandler.prototype.destroy = function() {
        this._sum = null;
    };

    STKWTFHandler.prototype.reset = function(length) {
        this._sum = [];
    };

    STKWTFHandler.prototype.getBase = function(index, value) {
        if (this._sum[index] == null) {
            this._sum[index] = value;
        }
        return this._sum[index];
    };

    STKWTFHandler.prototype.add = function(index, value) {
        return this._sum[index] += value;
    };


    return {
        getHandler: function() {
            return new Handler();
        },
        getStackHandler: function(signSensitive, isPercentage) {
            if (signSensitive) {
                return new SignSensitiveHandler();
            } else if (isPercentage) {
                return new PercentageHandler();
            } else {
                return new StackedHandler();
            }
        },
        getPercentageStackHandler: function() {
            return new PercentageStackHandler();
        },
        getWTFHandler: function() {
            return new WTFHandler();
        },
        getSTKWTFHandler: function() {
            return new STKWTFHandler();
        },

    };
});
define('sap/viz/chart/components/plots/SeriesIterator',[], function() {

    function createIterator(length, type) {
        var iterator;

        switch (type) {
        case "reverse":
            iterator = {
                current: length,
                hasNext: function() {
                    return this.current > 0;
                },
                next: function() {
                    return --this.current;
                },
                index: function() {
                    return this.current;
                }
            };
            break;

        case "reverse_with_series":
            iterator = {
                current: length,
                hasNext: function() {
                    return this.current > 0;
                },
                next: function() {
                    return --this.current;
                },
                index: function() {
                    return length - this.current - 1;
                }
            };
            break;

        default:
            iterator =  {
                limit: length,
                current: -1,
                hasNext: function() {
                    return this.current < this.limit - 1;
                },
                next: function() {
                    return ++this.current;
                },
                index: function() {
                    return this.current;
                }
            };
            break;
        }

        return iterator;
    }

    return {
        create: createIterator
    };

});
define('sap/viz/chart/components/plots/model/DataPointInfo',[
    
],
function(){
    var DataPoint = function(seriesIndex, itemIndex, rawData, id){
        this._seriesIndex = seriesIndex;
        this._itemIndex = itemIndex;
        this._rawData = rawData;
        this._id = id;
        this._node = null;
        this._position = null;
        this._isVisible = true;
        this._refNode = null;
    };
    
    DataPoint.prototype.getSeriesIndex = function() {
        return this._seriesIndex;
    };
    
    DataPoint.prototype.getItemIndex = function() {
        return this._itemIndex;
    };
    
    DataPoint.prototype.getRawData = function() {
        return this._rawData;
    };
    
    DataPoint.prototype.setRawData = function(rawData) {
        this._rawData = rawData;
        return this;
    };
    
    DataPoint.prototype.getId = function() {
        return this._id;
    };
    
    DataPoint.prototype.init = function(config, dataId, data, dataPointId, onlyOneMndIndex){
        this._config = config;
        this._dataId = dataId;
        this._data = data;
        this._dataPointId = dataPointId;
        this._onlyOneMndIndex = onlyOneMndIndex;
    };
    
    DataPoint.prototype.reset = function(){
        this._position = null;
        this._config = null;
        this._dataId = null;
        this._data = null;
        this._dataPointId = null;
    };

    DataPoint.prototype.getOnlyOneMndIndex = function(){
        return this._onlyOneMndIndex;
    };
    
    DataPoint.prototype.getConfig = function() {
        return this._config;
    };
    DataPoint.prototype.setConfig = function(cfg){
        this._config = cfg;
    };
    
    DataPoint.prototype.getDataId = function() {
        return this._dataId;
    };
    
    DataPoint.prototype.getData = function() {
        return this._data;
    };
    DataPoint.prototype.setData = function(data){
        this._data = data;
    };
    
    DataPoint.prototype.getDataPointId = function() {
        return this._dataPointId;
    };
    
    DataPoint.prototype.getContext = function() {
        return this._config.ctx;
    };
    
    DataPoint.prototype.getAdditionCtx = function(){
        return this._config.additionCtx;
    };
    
    DataPoint.prototype.getPosition = function() {
        return this._position;
    };
    
    DataPoint.prototype.getNode = function() {
        return this._node;
    };
    
    DataPoint.prototype.setNode = function(node) {
        this._node = node;
        return this;
    };

    DataPoint.prototype.getRefNode = function() {
        return this._refNode;
    };
    
    DataPoint.prototype.setRefNode = function(node) {
        this._refNode = node;
        return this;
    };

    DataPoint.prototype.setPosition = function(position) {
        this._position = position;
        return this;
    };

    DataPoint.prototype.setVisible = function (_){
        this._isVisible = _;
        return this;
    };

    DataPoint.prototype.isVisible = function (){
        return this._isVisible;
    };

    return DataPoint;
});

define('sap/viz/chart/components/plots/model/Series',[
    
],function(){
    var Series = function(){
        this._datapoints = [];
        this._context = null;
    };
    
    var prot = Series.prototype;

    prot.setDataPoint = function(index, datapoint){
        this._datapoints[index] = datapoint;
        return this;
    };

    prot.getDataPoint = function(index){
        return this._datapoints[index];
    };
    
    prot.setLength = function(length){
        this._datapoints.length = length;
        return this;
    };

    prot.getDataPoints = function(){
        return this._datapoints;
    };
    
    prot.setContext = function(_){
        this._context = _;
        return this;
    };

    prot.getContext = function(){
        return this._context;
    };

    return Series;
});

define('sap/viz/chart/components/renderers/ReferenceLineRenderer',['sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/chart/components/util/StyleUtils",
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/util/NameColorUtils',
    "sap/viz/framework/common/util/DataGraphics"
], function (SVG, TextUtils, Constants, StyleUtils, TypeUtils,
    FiscalUtil,
    NameColorUtils,
    DataGraphics) {

    var ReferenceLineRenderer = {};

    var PADDING = Constants.REFERENCE_LINE.LABEL_PADDING;
    var MIN_LABEL_WIDTH = 30;
    var STROKE_DASH = Constants.REF_LINE_DASH_TYPE_ARRAY;
    var LINE_OPACITY = 0.8;
    var TEXT_WIDTH_LIMIT = 180;
    var LABEL_RADIUS = 1;
    var CSS_CLASS_REFERENCE_LINE_GROUP = "v-referenceline-group";
    var CLASS_REFERENCE_LINE_LABELS_GROUP = "v-referenceline-labels-group";
    ReferenceLineRenderer.TEXT_PADDING = PADDING;

    ReferenceLineRenderer._combineConfig = function (currentSetting, options) {
        var defaultStyle = options.defaultStyle;

        var config = {};

        config.strokeColor = currentSetting.color ? currentSetting.color : defaultStyle.color;

        config.lineType = currentSetting.type ? currentSetting.type : defaultStyle.type;

        config.strokeWidth = currentSetting.size ? currentSetting.size : defaultStyle.size;

        if (config.strokeWidth < 1 || config.strokeWidth > 7) {
            config.strokeWidth = 1;
        }

        // label
        config.label = {};
        config.label.background = defaultStyle.label.background;

        config = this._checkLabelVisible(currentSetting, config);

        if(config.label.visible === false){
            return config;
        }
        var labelStyle = defaultStyle.label;
        
        config = this._getLabelStyle(config, currentSetting, labelStyle);
        //for background, we use plotArea.referenceLine.line.valueAxis.label.background
        if (currentSetting.label && currentSetting.label.background) {
            config.label.background = currentSetting.label.background;
        }

        config.label.visible = true;
        config.label.text = currentSetting.label.text;
        config.lineOpacity = LINE_OPACITY;

        config.label.fontSize = TextUtils.validateFontStyle(config.label.fontSize);
        // label.textSize
        config.label.textSize = TextUtils.fastMeasure(config.label.text, config.label.fontSize,
            config.label.fontWeight,
            config.label.fontFamily);

        //convert color for UI5 parameters
        config.strokeColor = NameColorUtils.convertColor(config.strokeColor);
        config.label.background = NameColorUtils.convertColor(config.label.background);
        config.label.color = NameColorUtils.convertColor(config.label.color);

        //to use default property if it is invalid.
        if (!TypeUtils.isExist(config.strokeColor) || !config.strokeColor.length) {
            config.strokeColor = defaultStyle.color;
        }
        if (!TypeUtils.isExist(config.label.background) || !config.label.background.length) {
            config.label.background = defaultStyle.label.background;
        }
        if (!TypeUtils.isExist(config.label.color) || !config.label.color.length) {
            config.label.color = defaultStyle.label.color;
        }

        if (options.props && options.props.realSize) {
            config.realWidth = options.props.realSize.width;
            config.realHeight = options.props.realSize.height;
        }
        return config;
    };

    ReferenceLineRenderer._checkLabelVisible = function (currentSetting, config) {
        if (currentSetting.label == null || currentSetting.label.visible === false || currentSetting.label.text ==
            null) {
            config.label.visible = false;
        }
        return config;
    };

    ReferenceLineRenderer._getLabelStyle = function (config, currentSetting, labelStyle) {
        for (var key in labelStyle) {
            if (labelStyle.hasOwnProperty(key)) {
                if (currentSetting.label.style && currentSetting.label.style.hasOwnProperty(key)) {
                    config.label[key] = currentSetting.label.style[key];
                    continue;
                }
                config.label[key] = labelStyle[key];
            }
        }
        return config;
    };

    ReferenceLineRenderer._drawReferenceLine = function (config, key, parent, pos,
        isHorizontal, width, height) {

        var currentLineGroup = SVG.create("g", parent);
        currentLineGroup.setAttribute("class", "v-referenceline v-referenceline-" + key);

        var currentLine = SVG.create("line", currentLineGroup);
        var rect = SVG.create("rect", currentLineGroup);

        currentLine.setAttribute("stroke", config.strokeColor);
        currentLine.setAttribute("stroke-width", config.strokeWidth);
        currentLine.setAttribute("shape-rendering", "crispEdges");

        if (Constants.GRIDLINE_TYPE.DASHED === config.lineType ||
            Constants.GRIDLINE_TYPE.DOTTED === config.lineType) {
            currentLine.setAttribute("stroke-dasharray", STROKE_DASH);
        } else if (Constants.GRIDLINE_TYPE.INCISED === config.lineType) {
            currentLine.setAttribute("stroke", "#ffffff");
        }

        var xyPosition;
        if (isNaN(config.strokeWidth)) {
            xyPosition = "-" + parseFloat(config.strokeWidth.slice(0, -2)) / 2 + "px";
        }
        else {
            xyPosition = "-" + config.strokeWidth / 2;
        }
        currentLine.setAttribute("opacity", config.lineOpacity);
        rect.setAttribute("fill", "transparent");
        currentLine.setAttribute("x1", 0);
        currentLine.setAttribute("y2", 0);

        if (isHorizontal) {
            currentLine.setAttribute("y1", 0);
            currentLine.setAttribute("x2", width);
            rect.setAttribute("y", xyPosition);
            rect.setAttribute("height", config.strokeWidth);
            rect.setAttribute("width", width);
        } else {
            currentLine.setAttribute("y1", height);
            currentLine.setAttribute("x2", 0);
            rect.setAttribute("x", xyPosition);
            rect.setAttribute("width", config.strokeWidth);
            rect.setAttribute("height", height);
        }
    };

    ReferenceLineRenderer._buildLabelObj = function (options) {
        var config = options.combinedConfig;
        var labelTextGroup = SVG.create("g", options.labelsGroupDOM);
        labelTextGroup.setAttribute("class", "v-referenceline-label v-referenceline-label-" + options.key);
        labelTextGroup.setAttribute("fill",
            config.label.color ? config.label.color : config.axisColor);
        labelTextGroup.setAttribute("font-size", config.label.fontSize);
        labelTextGroup.setAttribute("font-weight", config.label.fontWeight);
        labelTextGroup.setAttribute("font-family", config.label.fontFamily);
        labelTextGroup.setAttribute("font-style", config.label.fontStyle);

        var textSize = config.label.textSize;
        var textWidth = textSize.width;
        var ellipsisWidth;
        if (textWidth > TEXT_WIDTH_LIMIT) {
            textWidth = TEXT_WIDTH_LIMIT;
            ellipsisWidth = TEXT_WIDTH_LIMIT;
        }

        //for some ellipsis cases, we have to adjust rect X because of realLength.
        var adjustXForEllipsis = false;
        var rect = SVG.create("rect", labelTextGroup);
        rect.setAttribute("rx", LABEL_RADIUS);
        rect.setAttribute("ry", LABEL_RADIUS);
        rect.setAttribute("fill", config.label.background);

        var rectObj = {};
        rectObj.width = textWidth + 2 * PADDING;
        rectObj.height = textSize.height + PADDING;
        rectObj.x = 0;
        rectObj.y = 0;

        //for horizontal case, we need one candidateRect.
        var candidateRect;

        var text = SVG.create("text", labelTextGroup);
        text.textContent = config.label.text;
        text.setAttribute("text-anchor", config.textAnchor);

        if (!options.isHorizontal) {
            var widthPos = options.pos * options.width;
            if (options.axisLayout[options.key] === "bottom") { // make label close to its axis
                rectObj.y = options.height - rectObj.height - 1;
            } else {
                rectObj.y = 1;
            }
            if (widthPos + textWidth + PADDING * 2 + 1 <= options.width) {
                rectObj.x = 1;
            } else if (widthPos - textWidth - 1 >= PADDING * 2) {
                adjustXForEllipsis = true;
                rectObj.x = (-textWidth - PADDING * 2 - 1);
            } else {
                ellipsisWidth = options.width - widthPos - PADDING * 2 - 1;
                if (ellipsisWidth >= MIN_LABEL_WIDTH) {
                    rectObj.x = 1;
                } else {
                    ellipsisWidth = widthPos - PADDING * 2 - 1;
                    if (ellipsisWidth >= MIN_LABEL_WIDTH) {
                        adjustXForEllipsis = true;
                        rectObj.x = (-ellipsisWidth - PADDING * 2 - 1);
                    } else {
                        adjustXForEllipsis = true;
                        ellipsisWidth = options.width - widthPos - PADDING * 2 - 1;
                        rectObj.x = 1;
                    }
                }
                ellipsisWidth = Math.max(ellipsisWidth, 2 * PADDING);
                ellipsisWidth = Math.min(ellipsisWidth, TEXT_WIDTH_LIMIT);
            }
        } else {
            candidateRect = {};
            if (options.axisLayout[options.key] === "right") { // make label close to its axis
                adjustXForEllipsis = true;
                rectObj.x = Math.max((options.width - rectObj.width), 0);
            } else {
                rectObj.x = 0;
            }

            var actualHeight = options.height;
            if (options.combinedConfig.realHeight) {
                actualHeight = options.combinedConfig.realHeight;
            }
            var heightPos = (1 - options.pos) * actualHeight;
            if (heightPos >= (actualHeight - rectObj.height / 2 + 1)) {
                rectObj.y = (-rectObj.height + 1);
            } else if (heightPos >= (rectObj.height / 2)) {
                rectObj.y = (-(rectObj.height / 2));
            }
            else {
                rectObj.y = -1;
            }

            if (textSize.width + PADDING * 2 > options.width) {
                ellipsisWidth = Math.min(options.width - PADDING * 2, TEXT_WIDTH_LIMIT);
            }
        }

        if (ellipsisWidth != null) {
            var cssString = StyleUtils.convertToCss(config.label);
            var textObj = TextUtils.ellipsis(config.label.text,
                text, ellipsisWidth, cssString, config.ellipsisOptions);

            var textRealLength = textObj.realLength;
            if (adjustXForEllipsis) {
                rectObj.x += (ellipsisWidth - textRealLength);
            }
            rectObj.width = (textRealLength + PADDING * 2);

            if (!TypeUtils.isNonEmptyString(textObj.text)) {
                d3.select(labelTextGroup).remove();
                labelTextGroup = null;
            }
        }
        if (!options.isHorizontal) {
            rectObj.x += options.initPos;
            rectObj.initPosX = options.initPos;
        }
        else {
            rectObj.y += options.initPos;
            rectObj.initPosY = options.initPos;
        }

        var labelObj;
        if (labelTextGroup) {
            labelObj = {};
            labelObj.DOM = labelTextGroup;
            labelObj.rect = rectObj;
            if (candidateRect) {
                if (rectObj.x === 0) {
                    candidateRect.x = options.width - rectObj.width;
                }
                else {
                    candidateRect.x = 0;
                }
                candidateRect.y = rectObj.y;
                candidateRect.width = rectObj.width;
                candidateRect.height = rectObj.height;
                labelObj.candidateRect = candidateRect;
            }
        }

        return labelObj;
    };

    ReferenceLineRenderer._layoutAndUpdateLabelDOM = function (options, labelObj) {
        if (labelObj) {
            //update x and y
            if (options && options.plotInstance) {
                //renderResult will be used to build ReferenceLineItem.
                var layoutOptions = {};
                layoutOptions.isHorizontal = options.isHorizontal;
                layoutOptions.width = options.width;
                layoutOptions.height = options.height;
                layoutOptions.candidateRect = labelObj.candidateRect;
                options.plotInstance.getReferenceLines().smartLayoutReferenceLineLabel(labelObj.rect, layoutOptions);
            }

            var textSize = options.combinedConfig.label.textSize;
            var rectDOM = labelObj.DOM.querySelector("rect");
            var textDOM = labelObj.DOM.querySelector("text");

            rectDOM.setAttribute("width", labelObj.rect.width);
            rectDOM.setAttribute("height", labelObj.rect.height);

            var initX = labelObj.rect.initPosX;
            var initY = labelObj.rect.initPosY;
            if (!TypeUtils.isExist(initX)) {
                initX = 0;
            }
            if (!TypeUtils.isExist(initY)) {
                initY = 0;
            }

            rectDOM.setAttribute("x", labelObj.rect.x - initX);
            textDOM.setAttribute("x", labelObj.rect.x - initX + PADDING);
            rectDOM.setAttribute("y", labelObj.rect.y - initY);
            textDOM.setAttribute("y", labelObj.rect.y - initY + PADDING / 2 - textSize.y);

            labelObj.DOM.setAttribute("transform", "translate(" + initX + ", " + initY + ")");

            //one of the poses is undefined
            DataGraphics.setData(labelObj.DOM, {
                initPosX: labelObj.rect.initPosX,
                initPosY: labelObj.rect.initPosY
            });
        }
    };

    ReferenceLineRenderer._drawLabel = function (options) {
        var labelObj = this._buildLabelObj(options);
        //update DOM
        this._layoutAndUpdateLabelDOM(options, labelObj);
        return labelObj;
    };

    // utility
    ReferenceLineRenderer._searchXYAxisHandler = function (xHandlers, yHandlers, key) {

        var axisHandler = this._searchAxisHandler(xHandlers, key);

        if (axisHandler) {
            return {
                handler: axisHandler,
                isHorizontal: false
            };
        }

        axisHandler = this._searchAxisHandler(yHandlers, key);

        if (axisHandler) {
            return {
                handler: axisHandler,
                isHorizontal: true
            };
        }
        return null;
    };

    ReferenceLineRenderer._searchAxisHandler = function (handlers, key) {

        for (var i = 0; i < handlers.length; i++) {

            if (handlers[i].id === key && handlers[i].continuous) {
                return handlers[i]._scale;
            }
        }
        return null;
    };

    ReferenceLineRenderer._calculatePosition = function(isPercentage, axis, configValue){
        // calculate reference line location
        var value = axis.handler.normalizeValue(configValue);
        var pos = isPercentage ? value : axis.handler.scale(value);
        return pos;
    };

    function getValueAxisLayout(xHandlers, yHandlers) {
        var layout = {};

        var xNames = xHandlers.filter(function (h) {
            return h.type === "value";
        }).map(function (h) {
            return h.id;
        }).sort();

        var yNames = yHandlers.filter(function (h) {
            return h.type === "value";
        }).map(function (h) {
            return h.id;
        }).sort();

        if(xNames.length === 2 && yNames.length === 0){
             // dual bar charts
            layout[xNames[0]] = "top";
            layout[xNames[1]] = "bottom";
        }else if(xNames.length === 0 && yNames.length === 2){
            // dual column charts
            layout[yNames[0]] = "left";
            layout[yNames[1]] = "right";
        }else{
            if (xNames[0]) {
                layout[xNames[0]] = "top";
            }
            if (yNames[0]) {
                //for single value charts, we change reference title to 
                //right align
                layout[yNames[0]] = "right";
            }
        }
        return layout;
    }

    ReferenceLineRenderer._isInvisiblePosition = function (pos) {
        return (pos < 0 || pos > 1);
    };

    ReferenceLineRenderer._renderSub = function (options) {
        var renderResult;
        var axisLayout = getValueAxisLayout(options.xHandlers, options.yHandlers);
        for (var i = 0; i < options.lineStyles[options.key].length; i++) {
            renderResult = {};
            var config = options.lineStyles[options.key][i];

            if (config.visible === false) {
                continue;
            }

            if (config.value == null || isNaN(config.value) || config.value === "") {
                continue;
            }

            // obtain target axis
            var axis = this._searchXYAxisHandler(options.xHandlers, options.yHandlers,
                options.key);

            if (axis == null) {
                continue;
            }

            // calculate reference line location
            var pos = this._calculatePosition(options.isPercentage, axis, config.value);

            if (this._isInvisiblePosition(pos, config)) {
                continue;
            }

            // combine with default style
            var combinedConfig = this._combineConfig(config, options, axis);

            combinedConfig.axisColor = options.props[options.key + 'Color'];
            combinedConfig.textAnchor = options.props.textAnchor;
            combinedConfig.ellipsisOptions = options.props.ellipsisOptions;
            combinedConfig.xOffset = (options.props.offset && options.props.offset.x) || 0;

            var referenceLineG = SVG.create("g", options.labelsGroupDOM, true);
            referenceLineG.setAttribute("class", axis.isHorizontal ?
                "v-referenceline-horizontal" : "v-referenceline-vertical");
            var initPos = axis.isHorizontal ? (1 - pos) * options.height : pos * options.width;
            referenceLineG.setAttribute("transform", axis.isHorizontal ?
                "translate(" + 0 + ", " + initPos + ")" :
                "translate(" + initPos + ", " + 0 + ")");
            var dataObj = {
                value: Number(config.value),
                id: i
            };
            if (axis.isHorizontal) {
                dataObj.initPosY = initPos;
            }
            else {
                dataObj.initPosX = initPos;
            }
            DataGraphics.setData(referenceLineG, dataObj);

            // draw reference line
            this._drawReferenceLine(combinedConfig, options.key, referenceLineG, pos, axis.isHorizontal,
                options.width, options.height);

            // draw label
            if (combinedConfig.label.visible) {
                var labelOptions = {};
                labelOptions.combinedConfig = combinedConfig;
                labelOptions.key = options.key;
                labelOptions.referenceLineG = referenceLineG;
                labelOptions.pos = pos;
                labelOptions.initPos = initPos;
                labelOptions.labelsGroupDOM = options.labelsGroupDOM;
                labelOptions.isHorizontal = axis.isHorizontal;
                labelOptions.width = options.width;
                labelOptions.height = options.height;
                labelOptions.axisLayout = axisLayout;
                labelOptions.plotInstance = options.plotInstance;

                var labelObj = this._drawLabel(labelOptions);
                if (labelObj) {
                    renderResult.labelRect = labelObj.rect;
                    if (options && options.plotInstance && renderResult.labelRect) {
                        //renderResult will be used to build ReferenceLineItem.
                        options.plotInstance.getReferenceLines().addReferenceLineItem(renderResult);
                    }
                }
            }
        }
    };

    ReferenceLineRenderer.render = function (options) {
        if (options.props.referenceLine == null) {
            return;
        }

        if (options && options.plotInstance) {
            options.plotInstance.getReferenceLines().cleanReferenceLineItems();
        }

        var referenceLine = options.props.referenceLine;
        var defaultStyle = referenceLine.defaultStyle;
        var lineStyles = referenceLine.line;

        var isFiscal = false;
        if (lineStyles && lineStyles.timeAxis) {
            if (options.dataModel && options.dataModel._rawData) {
                isFiscal = FiscalUtil.isFiscal(options.dataModel._rawData);
            }
            lineStyles.timeAxis.forEach(function (s) {
                if (isFiscal) {
                    s.value = FiscalUtil.fiscalToQuantity(s.value, options.originalProps);
                }
                else {
                    s.value = new Date(s.value);
                }
            });
        }

        var referenceLineGroup = options.selection.querySelector("." + CSS_CLASS_REFERENCE_LINE_GROUP);
        if (!referenceLineGroup) {
            referenceLineGroup = SVG.create("g", options.selection);
            referenceLineGroup.setAttribute("class", CSS_CLASS_REFERENCE_LINE_GROUP);

            if (options.clipPath) {
                referenceLineGroup.setAttribute("clip-path", "url(#" + 
                    options.clipPath.getAttribute('id') + ")");
            }
        } else {
            var child = null;
            while ((child = referenceLineGroup.firstChild) != null) {
                referenceLineGroup.removeChild(child);
            }
        }

        var labelsGroupDOM = SVG.create("g", referenceLineGroup);
        labelsGroupDOM.setAttribute("class", CLASS_REFERENCE_LINE_LABELS_GROUP);

        options.lineStyles = lineStyles;
        options.defaultStyle = defaultStyle;
        options.referenceLineGroup = referenceLineGroup;
        options.labelsGroupDOM = labelsGroupDOM;
        for (var key in lineStyles) {
            if (lineStyles.hasOwnProperty(key)) {
                options.key = key;
                this._renderSub(options);
            }
        }
    };

    return ReferenceLineRenderer;

});

define('sap/viz/chart/components/referencelines/BaseReferenceLines',[
    "sap/viz/framework/common/util/ObjectUtils",
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/UIComponent',
    "sap/viz/framework/common/util/Constants"
], function (ObjectUtils,
    oo,
    UIComponent,
    Constants) {
    var PADDING = Constants.REFERENCE_LINE.LABEL_PADDING;

    var BaseReferenceLines = function(runtime) {
        BaseReferenceLines.superclass.constructor.apply(this, arguments);
        this._referenceLineItems = [];
    };

    oo.extend(BaseReferenceLines, UIComponent);

    BaseReferenceLines.prototype.destroy = function() {
        this._referenceLineItems = null;
    };

    BaseReferenceLines.prototype.addReferenceLineItem = function (renderResult) {
        //to build and push one ReferenceLineItem according to renderResult
        var referenceLineItem = ObjectUtils.clone(renderResult);
        this._referenceLineItems.push(referenceLineItem);
        return referenceLineItem;
    };

    BaseReferenceLines.prototype.cleanReferenceLineItems = function () {
        this._referenceLineItems = [];
    };

    BaseReferenceLines.prototype._labelOverlapFactor = function (newLabelRect) {
        var i;
        var allIntersectionArea = 0;
        var allExistingLabelArea = 0;
        var newRectX1 = newLabelRect.x - PADDING;
        var newRectX2 = newLabelRect.x + newLabelRect.width + PADDING;
        var newRectY1 = newLabelRect.y - PADDING;
        var newRectY2 = newLabelRect.y + newLabelRect.height + PADDING;

        var targetLabelRect;
        var targetRectX1;
        var targetRectX2; 
        var targetRectY1; 
        var targetRectY2; 

        var interRectX1;
        var interRectX2;
        var interRectY1;
        var interRectY2;
        for (i = 0; (this._referenceLineItems && i < this._referenceLineItems.length); i++) {
            targetLabelRect = this._referenceLineItems[i].labelRect;
            targetRectX1 = targetLabelRect.x - PADDING;
            targetRectX2 = targetLabelRect.x + targetLabelRect.width + PADDING;
            targetRectY1 = targetLabelRect.y - PADDING;
            targetRectY2 = targetLabelRect.y + targetLabelRect.height + PADDING;
            allExistingLabelArea += (targetRectX2 - targetRectX1) * (targetRectY2 - targetRectY1);

            interRectX1 = Math.max(newRectX1, targetRectX1);
            interRectX2 = Math.min(newRectX2, targetRectX2);
            interRectY1 = Math.max(newRectY1, targetRectY1);
            interRectY2 = Math.min(newRectY2, targetRectY2);
            if ((interRectX2 > interRectX1) && (interRectY2 > interRectY1)) {
                allIntersectionArea += (interRectX2 - interRectX1) * (interRectY2 - interRectY1);
            }
        }

        var overlapFactor = 0;
        if (allExistingLabelArea > 0) {
            overlapFactor = allIntersectionArea / allExistingLabelArea;
        }
        return overlapFactor;
    };

    BaseReferenceLines.prototype.smartLayoutReferenceLineLabel = function (newLabelRect, layoutOptions) {
        //to adjust X and Y in newLabelRect
        var newFactor;
        if (!layoutOptions.isHorizontal) {
            //for this case, we have to "slide" label to find a best location. Y will be changed, but not x.
            var y;
            var minOverlapFactor = Number.MAX_VALUE;
            var lastGoodY = newLabelRect.y;

            newFactor = Number.MAX_VALUE;            
            for (y = newLabelRect.y; (newFactor && y <= (layoutOptions.height - newLabelRect.height));
                y++) {
                newLabelRect.y = y;
                newFactor = this._labelOverlapFactor(newLabelRect);
                //if newFactor is 0, it means we find the best.
                if (newFactor < minOverlapFactor) {
                    //acceptable
                    minOverlapFactor = newFactor;
                    lastGoodY = y;
                }
            }
            newLabelRect.y = lastGoodY;
        }
        else if (layoutOptions.candidateRect) {
            //for horizontal case, we just need to try the candidate location
            newFactor = this._labelOverlapFactor(newLabelRect);
            var candidateFactor = this._labelOverlapFactor(layoutOptions.candidateRect);
            if (newFactor && candidateFactor < newFactor) {
                newLabelRect.x = layoutOptions.candidateRect.x;
                newLabelRect.y = layoutOptions.candidateRect.y;
            }
        }
    };

    return BaseReferenceLines;
});

define('sap/viz/chart/components/referencelines/DualReferenceLines',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/referencelines/BaseReferenceLines',
], function (oo,
    BaseReferenceLines) {

    var DualReferenceLines = function(runtime) {
        DualReferenceLines.superclass.constructor.apply(this, arguments);
    };

    oo.extend(DualReferenceLines, BaseReferenceLines);

    DualReferenceLines.prototype.smartLayoutReferenceLineLabel = function (newLabelRect, layoutOptions) {
        //dual reference line labels does not need smart layout.
    };

    return DualReferenceLines;
});

define('sap/viz/chart/components/util/ZoomUtil',['sap/viz/framework/common/util/TypeUtils', 
       'sap/viz/framework/common/util/FiscalUtil',
       'sap/viz/framework/common/util/Constants',
    ], function Setup(TypeUtils, 
    FiscalUtil,
    Constants){

    return {
        isZoomRangeValid: function(zoomStart, zoomEnd, domain){
            if (TypeUtils.isExist(zoomStart)) {//new Date(null) return current date
                zoomStart = new Date(zoomStart).getTime();
            }
            zoomStart = parseInt(zoomStart);

            if (TypeUtils.isExist(zoomEnd)) {
                zoomEnd = new Date(zoomEnd).getTime();
            }
            zoomEnd = parseInt(zoomEnd);

            if(!isNaN(zoomStart) || !isNaN(zoomEnd)){
                if (isNaN(zoomStart)) {
                    zoomStart = domain[0];
                }
                if (isNaN(zoomEnd)) {
                    zoomEnd = domain[1];
                }
                return !(zoomStart > domain[1] || zoomEnd < domain[0] || zoomStart >= zoomEnd);
            }
            return false;
        },
        getZoomRange: function(props, domain, hasCategory){
            function handle(dd){
                if( dd === Constants.PLOTAREA.FIRST_DATAPOINT ){
                    return domain[0];
                }else if( dd === Constants.PLOTAREA.LAST_DATAPOINT ){
                    return domain[1];
                }else if(!!dd && hasCategory){
                    return dd.categoryAxis;
                }else{
                    return dd;
                }
            }

            var start, end,
                isInteractive = !props.get('interaction.noninteractiveMode');
            if (isInteractive) {
                start = props.get('plotArea.window.start');
                end = props.get('plotArea.window.end');

                var values = FiscalUtil.startEndConvertor(start, end, props);
                start = handle(values.start);
                end = handle(values.end);
            } 
            return [start, end];
        },
        isRangeIncomplete: function(range){
            //only one of them is null
            if(!TypeUtils.isExist(range)){
                return false;
            }

            var e1 = TypeUtils.isExist(range[0]);
            var e2 = TypeUtils.isExist(range[1]);
            return ( e1 && !e2 ) || ( !e1 && e2);     
        }
    };
});

define('sap/viz/chart/components/plots/BasePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/UIComponent',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/plots/SeriesIterator',
    'sap/viz/chart/components/plots/model/DataPointInfo',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/chart/components/Background",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/renderers/ReferenceLineRenderer',
    'sap/viz/chart/components/referencelines/BaseReferenceLines',
    'sap/viz/chart/components/referencelines/DualReferenceLines',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/chart/components/container/utils/xyTransformUtils",
    "sap/viz/framework/interaction/utils/PlotZoomUtils",
    "sap/viz/chart/components/util/ZoomUtil",
    "sap/viz/chart/components/util/ColorUtil"
], function Setup(
    oo,
    ObjectUtils,
    UIComponent,
    DataHandler,
    SeriesIterator,
    DataPointInfo,
    Series,
    DataLabels,
    Constants,
    DataPointUtils,
    NameColorUtils,
    Background,
    DataGraphics,
    DOM,
    SVG,
    referenceLineRenderer,
    BaseReferenceLines,
    DualReferenceLines,
    TypeUtils,
    xyTransformUtils,
    PlotZoomUtils,
    ZoomUtil,
    ColorUtil
) {
    var CSSCLASS = Constants.CSS.CLASS;

    /**
     * To initialize plot object.
     *
     * @name BasePlot
     * @constructor
     */
    var BasePlot = function(runtime, options) {
        BasePlot.superclass.constructor.apply(this, arguments);

        this._options = options || {};
        this._isInTrellis = this._options.inTrellis;

        this._needApplyChanges = false;
        //subclass will over this flag
        this._dataHandler = this._getDataHandler();
        this._dataPointRenderer = undefined; //please overwrite with default renderer in sub classes
        this._seriesRenderer = this._getSeriesRenderer();
        this._randomSuffix = ObjectUtils.guid();

        this._xHandlers = this._getXHandlers();
        this._yHandlers = this._getYHandlers();

        this._dataLabels = this._getDataLabels(this._name + '.dataLabel', runtime);
        this._referenceLines = this._getReferenceLines(runtime);

        this._semanticMgr = this.runtime().semanticManager();
        this._semanticMgr.bindDataPointProperty(this._name + ".dataPointStyle", this._name + ".dataPointStyleMode");
        this._semanticMgr.bindSeriesStyleProperty(this._name + ".seriesStyle");

        this._effectManager = this.runtime().effectManager();

        this._background = new Background(runtime, {
            name: 'background',
            properties: this._properties
        });

        this._selection = null;
        this._parent_trellis = null;
        this._exposeMoreEvents("reRenderComplete");
        // Offset for scroll.
        this._offset = {
            x: 0,
            y: 0
        };

        this._strokeProp = this._properties.origin.get('plotArea.dataPoint.stroke');
        this._graphicModel = this.runtime().graphicModel();
        if (this._graphicModel) {
            this._graphicModel.registerExposedModule('plot');
        }
        this._dataPointClasses = [CSSCLASS.DATAPOINT, CSSCLASS.MORPHABLEDATAPOINT, CSSCLASS.DATAPOINTDEFAULT];
        this.runtime().statusManager().add("plotArea.window");
    };

    oo.extend(BasePlot, UIComponent);

    BasePlot.prototype._getXHandlers = function() {
        return [];
    };

    BasePlot.prototype._getYHandlers = function() {
        return [];
    };

    BasePlot.prototype._getDataHandler = function() {
        return {
            "valueAxis": DataHandler.getHandler()
        };
    };

    BasePlot.prototype._getSeriesRenderer = function() {};

    BasePlot.prototype._getDataLabels = function(name, runtime) {
        return new DataLabels(runtime, {
            name: name
        });
    };

    BasePlot.prototype._getReferenceLines = function (runtime) {
        var referenceLinesInstance;
        if (this._options && this._options.isDualValueAxis) {
            referenceLinesInstance = new DualReferenceLines(runtime);
        }
        else {
            referenceLinesInstance = new BaseReferenceLines(runtime);
        }
        return referenceLinesInstance;
    };

    BasePlot.prototype.getReferenceLines = function () {
        return this._referenceLines;
    };

    BasePlot.prototype.setData = function(data) {
        BasePlot.superclass.setData.apply(this, arguments);
        if(this._dataLabels){
            this._dataLabels.setData(data);
        }
        this._needApplyChanges = true;
        //After base plot is render, record plot windows status.
        this._recordPlotWindow();
    };

    BasePlot.prototype.setSize = function(size) {
        BasePlot.superclass.setSize.apply(this, arguments);
        this._background.setSize(size);
        if(this._dataLabels){
            this._dataLabels.setSize(size);
        }
        this._needApplyChanges = true;
    };

    BasePlot.prototype.getRealSize = function() {
        return {
            width: this._realSize.width,
            height: this._realSize.height
        };
    };

    function getCategoryIndexRange(data, category) {
        if (!category) {
            return [];
        }
        var cateAxis = data.categoryAxis;
        var domains = cateAxis.scale.getDomain();
        var meta = cateAxis.metaData;
        // get valid values from category. For example meta ['Year', 'Country']
        // input category {'Year': '2001', "Product": 'car'}, values will be ['2001']
        var values = [];
        for (var i = 0; i < meta.length; ++i) {
            if (category.hasOwnProperty(meta[i].id)) {
                values.push(category[meta[i].id]);
            } else {
                break;
            }
        }
        var indexes = [];
        //var bFound = false;
        var j = 0,
            k = 0;
        var lastMetaIndex = -1;
        var firstIndex = 0;
        var lastIndex = 0;

        //Find the first valid category index.
        if (values.length) {
            for (; j < domains.length; ++j) {
                for (k = 0; k < values.length; ++k) {
                    if (domains[j][k] != values[k]) {
                        break;
                    }
                }
                if (k > 0) {

                    if (k > lastMetaIndex + 1) {
                        lastMetaIndex = k - 1;
                        firstIndex = j;
                    }
                    if (k === lastMetaIndex + 1) {
                        lastIndex = j;
                    }
                }
            }
        }

        // Find the last valid category index.
        if (lastMetaIndex >= 0) {
            indexes.push(firstIndex);
            indexes.push(lastIndex);

        }

        return indexes;
    }

    BasePlot.prototype._getCategoryRange = function(categoryCount) {
        if(! this._data.categoryAxis){
            return null;
        }

        var lastDP = this._data.categoryAxis.scale.getDomain().length - 1;
        var baseDomain = [0, lastDP];

        var range = ZoomUtil.getZoomRange(this._properties.origin, baseDomain, true);
        var minCategory = range[0];
        var maxCategory = range[1];
        //when BOTH NUlL
        if (!TypeUtils.isExist(minCategory) && !TypeUtils.isExist(maxCategory)) {
            return null;
        }

        var result = [0, lastDP];
        var startRange = TypeUtils.isNumber(minCategory)?
                            [minCategory, minCategory] : getCategoryIndexRange(this._data, minCategory);
        var endRange =TypeUtils.isNumber(maxCategory)?
                            [maxCategory, maxCategory] : getCategoryIndexRange(this._data, maxCategory);

        if (startRange.length > 0 && endRange.length > 0) {
            result[0] = Math.min(startRange[0], endRange[0]);
            result[1] = Math.max(startRange[1], endRange[1]);
        } else if (startRange.length > 0) {
            result[0] = startRange[0];
            result[1] = null;
        } else if (endRange.length > 0) {
            result[0] = null;
            result[1] = endRange[1];
        }
        return result;
    };

    BasePlot.prototype._getTimeRange = function(){
        function handlePropInput(dd){
            var result = dd;
            if (TypeUtils.isExist(result)) {
                result = new Date(result).getTime();
                result = parseInt(result);
            }
            return result;
        }

        if(! this._data.timeAxis){
            return null;
        }

        var domain = this._data.timeAxis.scale.getDomain();
        var props = this._properties.origin;
        var range = ZoomUtil.getZoomRange(props, domain);
        var start = handlePropInput(range[0]);
        var end = handlePropInput(range[1]);
        return [start, end];
    };

    BasePlot.prototype._isRangeIncomplete = function(range){
        return ZoomUtil.isRangeIncomplete(range);
    };

    BasePlot.prototype._fillRange = function(ranges){
        if(!TypeUtils.isExist(ranges[0])){
            ranges[0] = 0;
        }

        if(!TypeUtils.isExist(ranges[1])){
            var lastDP = this._data.categoryAxis.scale.getDomain().length - 1;
            ranges[1] = lastDP;
        }
        return ranges;
    };

    BasePlot.prototype._shiftOffsetForIncompleteRange = function(ranges, categoryCount){
        var realsize = this.isHorizontal() ? this._realSize.height  : this._realSize.width ;
        var size = this.isHorizontal() ?  this._size.height: this._size.width;
        var categoryWidth = realsize / categoryCount;
        var offset;
        if(!TypeUtils.isNumber(ranges[0])){
            offset = -(ranges[1] +1)*  categoryWidth + size;
        }else{
            offset = -ranges[0] *  categoryWidth;
        }

        if(offset > 0 ||  -offset + size > realsize){
            //invalid offset
            //scroll right too much, such that even before than start point
            //scroll left too much, such that even ahead than last point
            this._fillRange(ranges);
            return false;
        }else{
            if(this.isHorizontal()){
                this._offset.y = offset;
            }else{
                this._offset.x = offset;
            }
            return true;
        }
    };

    BasePlot.prototype.destroy = function() {
        BasePlot.superclass.destroy.call(this);
        this._properties = null;
        this._options = null;
        this._needApplyChanges = null;
        if (this._dataHandler) {
            for (var key in this._dataHandler) {
                if (this._dataHandler.hasOwnProperty(key)) {
                    if (this._dataHandler[key]) {
                        this._dataHandler[key].destroy();
                    }
                    delete this._dataHandler[key];
                }
            }
        }

        this._dataHandler = null;
        this._dataPointRenderer = null;
        this._seriesRenderer = null;
        this._randomSuffix = null;

        if (this._xHandlers) {
            this._xHandlers.forEach(function(handler) {
                handler.destroy();
            });
        }
        this._xHandlers = null;

        if (this._yHandlers) {
            this._yHandlers.forEach(function(handler) {
                handler.destroy();
            });
        }
        this._yHandlers = null;

        if (this._dataLabels && this._dataLabels.destroy) {
            this._dataLabels.destroy();
        }
        this._dataLabels = null;

        if (this._referenceLines && this._referenceLines.destroy) {
            this._referenceLines.destroy();
        }
        this._referenceLines = null;

        this._background = null;

        if (this._selection) {
            this._selection.remove();
        }
        this._selection = null;
        if (this._parent_trellis) {
            this._parent_trellis.remove();
        }
        this._parent_trellis = null;
        this._series = [];
        this._customMarkerRenderer = null;

        this._semanticMgr = null;
        this._strokeProp = null;
        this._effectManager = null;
        this._plotDpParentNode = null;
    };

    BasePlot.prototype._updateBackgroundColor = function(){
        if (this._isInTrellis) {
            //Currently, no plotarea background color for each cell in properties,
            //so set color=transparent always.

            //Doesn't support drawing plotarea border for each cell,
            //so set hasBorder=false to disable it.
            this._background.setData({
                'color': 'transparent',
                'hasBorder': false
            });
        } else {
            //this color will override background property
            this._background.setData(null);
        }
    };

    /**
     * To render element.
     */
    BasePlot.prototype.render = function (selection, additionalInfo, semanticDisplayStyleRules) {
        this._selection = selection;
        if (this._needApplyChanges) {
            this._applyChanges();
            this._needApplyChanges = false;
        }
        this._drawingEffect = this._properties.get('drawingEffect');
        this._preRender();

        var selectionNode = selection.node();
        this._EmptyDOM(selectionNode);

        this._updateBackgroundColor();
        this._background.render(selection);
        var node = this._createMainNode(selectionNode);
        if (!this._isInTrellis) {
            var transformStr = "translate(" + (this._offset.x) + ", " +
                (this._offset.y) + ")";
            for (var key in node) {
                if (node.hasOwnProperty(key)) {
                    node[key].setAttribute("transform", transformStr);
                }
            }
        }
        this._plotDpParentNode = d3.select(node.plotMainNode);
        this._drawGridlines(this._plotDpParentNode);

        this._semanticMgr.beginSession();
        this._drawDatapoints(this._getDpParentNode(), additionalInfo, semanticDisplayStyleRules);
        this._semanticMgr.endSession();
    };

    BasePlot.prototype._EmptyDOM = function(selectionNode) {
        DOM.empty(selectionNode);
    };

    BasePlot.prototype._preRender = function() {
        this._customMarkerRenderer = this._properties.get("markerRenderer");
        this._series = [];
    };

    BasePlot.prototype._postRender = function(dataPointG) {
        this._drawReferenceLine();
    };

    BasePlot.prototype._recordPlotWindow = function() {
        var win = this._properties.get("window");
        win = win && (win.start || win.end) ? win : null;
        this.runtime().statusManager().set("plotArea.window", win);
    };

    BasePlot.prototype.getReferenceLineRenderer = function () {
        //may be overwritten
        return referenceLineRenderer;
    };

    BasePlot.prototype._drawReferenceLine = function(offset) {
        var referenceLine = ObjectUtils.extend(true, {}, this._properties.get('referenceLine'));
        var defaultDefaultStyle = this._properties.getDefault('referenceLine');
        if (referenceLine && referenceLine.defaultStyle) {
            //to set back to default if it is invalid.
            if (!TypeUtils.isExist(referenceLine.defaultStyle.color) ||
                !referenceLine.defaultStyle.color.length) {
                referenceLine.defaultStyle.color = defaultDefaultStyle.defaultStyle.color;
            }
            if (!TypeUtils.isExist(referenceLine.defaultStyle.label.background) ||
                !referenceLine.defaultStyle.label.background.length) {
                referenceLine.defaultStyle.label.background =
                    defaultDefaultStyle.defaultStyle.label.background;
            }
            if (!TypeUtils.isExist(referenceLine.defaultStyle.label.color) ||
                !referenceLine.defaultStyle.label.color.length) {
                referenceLine.defaultStyle.label.color =
                    defaultDefaultStyle.defaultStyle.label.color;
            }
        }
        var referenceLineRenderer = this.getReferenceLineRenderer();
        if (null == referenceLine || !referenceLineRenderer) {
            return;
        }
        var refOffset = ObjectUtils.extend(true, {}, this._offset, offset);
        var props = {
            referenceLine: referenceLine,
            offset: refOffset,
            realSize: this._realSize
        };
        var properties = this._properties.origin;
        var lines = referenceLine.line;
        for (var key in lines) {
            if (lines.hasOwnProperty(key)) {
                props[key + 'Color'] = properties.get(key + '.color');
            }
        }

        props.textAnchor = null;
        if (this.runtime) {
            var envManager = this.runtime().envManager();
            if (envManager) {
                props.textAnchor = envManager.textAnchor();
            }
            props.ellipsisOptions = {};
            props.ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());
            props.ellipsisOptions.needRealLength = true;
        }

        var options = {};
        options.dataModel = this._runtime && this._runtime._interaction &&
            this._runtime._interaction._service && this._runtime._interaction._service.getDataModel();
        options.xHandlers = this._xHandlers;
        options.yHandlers = this._yHandlers;
        options.props = props;
        options.width = this._size.width;
        options.height = this._size.height;
        options.selection = this._getDpPlotNode();
        options.isPercentage = (this._data._seriesType === 'percentage');
        options.originalProps = properties;
        //plotInstance is optional. It is required if the plot need to smart layout
        //reference labels.
        options.plotInstance = this;
        options.clipPath = this.clipPath;
        referenceLineRenderer.render(options);
    };

    BasePlot.prototype._getDpPlotNode = function(){
        if (this._selection) {
            return this._selection.node();
        }
    };

    BasePlot.prototype._getDpParentNode = function(){
        return this._plotDpParentNode;
    };

    BasePlot.prototype._repositionReferenceLine = function() {
        if (!this._selection) {
            return;
        }
        var container = this._getDpPlotNode(),
            linesAndLabels = container.querySelectorAll(
                ".v-referenceline-horizontal,.v-referenceline-vertical,.v-referenceline-label"),
            i;

        var scale = this.runtime().statusManager().get("plot.transform.scale"),
            trans = this.runtime().statusManager().get("plot.transform.translate");
        for (i = 0; i < linesAndLabels.length; i++) {
            xyTransformUtils.adjustXYTranslate(linesAndLabels[i], scale, trans);
        }
    };

    BasePlot.prototype._drawDataLabels = function(parent, dataShapesGroupNode) {
        this._dataLabels.setDataShapesGroupNode(dataShapesGroupNode);
        this._dataLabels.setRealSize(this._realSize);
        this._parent_trellis = parent;
        var dataLabels = this._dataLabels;
        if (!this._isInTrellis) {
            var dataPoints = parent.selectAll('.' + Constants.CSS.CLASS.DATAPOINT)[0];
            dataLabels.render(parent, dataPoints);
        }
    };

    BasePlot.prototype.drawTrellisDataLabels = function(cellPadding, cellSize) {
        if (!this._parent_trellis || !this._dataLabels) {
            return;
        }
        var dataLabels = this._dataLabels;
        dataLabels.setTrellisCell(cellPadding, cellSize);
        var dataPoints = this._parent_trellis.selectAll('.' + Constants.CSS.CLASS.DATAPOINT)[0];
        dataLabels.render(this._parent_trellis, dataPoints);
    };

    BasePlot.prototype._createMainNode = function(selection) {
        
        var width = this._size.width,
            height = this._size.height;
        var clipPath, clipPathId;
        var enableClipPath = !this._options.disableClipPath;
        if (enableClipPath) {
            clipPath = SVG.create("clipPath", selection);
            clipPathId = "plot_main_clipPath_" + this._randomSuffix;
            clipPath.setAttribute("id", clipPathId);
            var rect = SVG.create("rect", clipPath);
            var scale = this._runtime._statusMgr.get('plot.transform.scale');
            this._setClipPathAttribute(rect, width, height, scale, this._data);
            this.clipPath = clipPath;
        }
        var plotEventLayer = SVG.create("rect", selection);
        plotEventLayer.setAttribute("class", "v-plot-bound v-bound " + PlotZoomUtils.ZOOM_CONTAINER_CLASS);
        plotEventLayer.setAttribute("width", width);
        plotEventLayer.setAttribute("height", height);
        plotEventLayer.setAttribute("fill", "transparent");

        // Add a wrapper node to main node, so that scrolling can be done within it.
        var wrapper = SVG.create("g", selection);
        var mainNode = SVG.create("g", wrapper);
        mainNode.setAttribute("class", "v-plot-main");
        mainNode.setAttribute('role', 'list');
        if (enableClipPath && !this._notNeedClippath) {
            wrapper.setAttribute("clip-path", "url(#" + clipPathId + ")");
        }
        return {plotMainNode: mainNode};
    };

    BasePlot.prototype._setClipPathAttribute = function(rect, width, height, scale, data) {
        var clipRect = this._getClipPathAttribute(width, height, scale, data);
        for (var name in clipRect) {
            if (clipRect.hasOwnProperty(name)) {
                rect.setAttribute(name, clipRect[name]);
            }
        }
    };

    BasePlot.prototype._getClipPathAttribute = function(width, height) {
        var ADJUST_SIZE = 0.5; //to make sure the first and last gridline will not be cut by clippath
        return {
            y: -1,
            width: width + 1,
            height: height + 1 + ADJUST_SIZE
        };
    };

    BasePlot.prototype._applyChanges = function() {
        var size = this._realSize;
        //for trellis chart, the trellisSeriesLength exists
        var seriesCount = this._data.trellisSeriesLength ? this._data.trellisSeriesLength : this._data.series.length;
        this._initXHandler(this._xHandlers, this._data, size.width, seriesCount);
        this._initYHandler(this._yHandlers, this._data, size.height, seriesCount);
    };

    BasePlot.prototype._initXHandler = function(handlers, data, range, seriesCount) {
        initHandler(handlers, data, range, seriesCount);
    };

    BasePlot.prototype._initYHandler = function(handlers, data, range, seriesCount) {
        initHandler(handlers, data, range, seriesCount);
    };

    function initHandler(handlers, data, range, seriesCount) {
        var scale = null;
        for (var i = 0, len = handlers.length; i < len; i++) {
            var id = handlers[i].id;
            var currentData = data[id];

            if (currentData == null || currentData.scale == null) {
                continue;
            }

            scale = currentData.scale;
            handlers[i].init(scale, seriesCount, range);
        }
    }

    BasePlot.prototype._drawGridlines = function(parent) {};

    BasePlot.prototype._getSeries = function() {
        return this._data.series;
    };

    BasePlot.prototype._buildLegendTextData = function(series) {
        //bar and dual_bar may need to show legend data in data label
        return [];
    };

    BasePlot.prototype._getOnlyOneMndIndex = function(seriesItem, colorDataArray) {
        //we need to remove onlyOneMndIndex color text
        return -1;
    };

    BasePlot.prototype.createSeriesIterator = function(len) {
        return SeriesIterator.create(len);
    };



    BasePlot.prototype._drawDatapoints = function(parent) {
        var series = this._getSeries();
        var seiresLength = series.length;
        if (this._seriesRenderer) {
            this._seriesRenderer.init(seiresLength);
        }

        for (var dhID in this._dataHandler) {
            if (this._dataHandler[dhID].reset) {
                this._dataHandler[dhID].reset();
            }
        }
        var currentId;
        var countId = 0;

        var onlyOneMndIndex = -1;

        if (this._properties.get("dataLabel.visible")) {
            var colorDataArray = this._buildLegendTextData(series);
            if (seiresLength > 0) {
                onlyOneMndIndex = this._getOnlyOneMndIndex(series[0], colorDataArray);
            }
        }
        var seriesIndex;
        var itemIndex;

        //variables used in loops
        var seriesItem;
        var data;
        var position;
        var dpConfig;
        var dpData;
        var dataPoint;
        var iterator = this.createSeriesIterator(seiresLength);

        while (iterator.hasNext()) {
            seriesIndex = iterator.next();
            seriesItem = series[seriesIndex];
            if (!seriesItem) {
                continue;
            }
            this._series[seriesIndex] = new Series();
            for (itemIndex = 0; itemIndex < seriesItem.length; itemIndex++) {
                data = seriesItem[itemIndex];
                if (!data) {
                    continue;
                }

                position = this._getPosition(seriesIndex, itemIndex, data);
                if (!position) {
                    continue;
                }

                currentId = countId++;
                dpConfig = this._buildWrapperConfig(data, position, data.dp.context());
                dpData = this._buildData(dpConfig);
                dataPoint = this._createDataPoint(seriesIndex, itemIndex, dpConfig, dpData, position,
                        currentId, data, onlyOneMndIndex);
                this._series[seriesIndex].setDataPoint(itemIndex, dataPoint);
            }
        }

        var dataPointG = SVG.create("g");
        dataPointG.setAttribute("class", CSSCLASS.DATAPOINT_GROUP);
        this._showDataPoints(dataPointG);

        if (this._seriesRenderer) {
            this._seriesRenderer.render(dataPointG);
        }
        this._postRender(dataPointG);
        parent.node().appendChild(dataPointG);
        if(this._dataLabels) {
            this._drawDataLabels(parent, dataPointG);
        }
    };

    BasePlot.prototype._preShowDataPoints = function() {};

    BasePlot.prototype._showDataPoints = function(dataPointG) {
        this._preShowDataPoints();
        var newDataPoints = [];
        var hasSeries = false;

        var seriesIndex;
        var itemIndex;

        var seriesModel;
        var dpRenderer;
        var dataPoints;
        var hasDataPoint;
        var dataPointModel;
        var dpNode;

        var seriesLength = this._series.length;
        var dataPointsLength;
        for (seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {
            seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }
            dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
            dataPoints = seriesModel.getDataPoints();
            hasDataPoint = false;
            dataPointsLength = dataPoints.length;
            for (itemIndex = 0; itemIndex < dataPointsLength; itemIndex++) {
                dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }
                hasDataPoint = true;
                dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                dataPointModel.setNode(dpNode);
                if (dpNode) {
                    newDataPoints.push(dpNode);
                }

                if (this._seriesRenderer) {
                    this._seriesRenderer.addDataPoint(seriesIndex, itemIndex, dataPointModel.getConfig(),
                        dataPointModel.getPosition(), dpNode);
                } else {
                    if (dpNode) {
                        dataPointG.appendChild(dpNode);
                    }
                }

                if (dpNode) {
                    seriesModel.setDataPoint(itemIndex, null);
                }
            }
            if (!hasDataPoint) {
                this._series[seriesIndex] = null;
            } else {
                hasSeries = true;
            }
        }
        if (!hasSeries) {
            this._series = [];
        }
        return newDataPoints;

    };

    BasePlot.prototype._setOffset = function(offset) {
        if (!offset) {
            return;
        }
        if (offset.hasOwnProperty("x") && offset.x != null) {
            this._offset.x = offset.x;
        }
        if (offset.hasOwnProperty("y") && offset.y != null) {
            this._offset.y = offset.y;
        }
    };

    BasePlot.prototype.getOffset = function(offset) {
        return {
            x: this._offset.x,
            y: this._offset.y
        };
    };

    BasePlot.prototype.scroll = function(offset) {
        this._setOffset(offset);
        if (!this._selection) {
            return;
        }
        this._applyScroll();
        this._repositionReferenceLine();
    };


    BasePlot.prototype._applyScroll = function() {
        if(!this._selection){
            return;
        }
        var dataPointG = this._getDpPlotNode().querySelector("." + CSSCLASS.DATAPOINT_GROUP);
        var newDataPoints = this._showDataPoints(dataPointG);

        if (this._seriesRenderer) {
            this._seriesRenderer.update();
        }

        if(this._dataLabels){
            this._dataLabels.render(this._getDpParentNode(), newDataPoints);
        }

        if (!this._isInTrellis) {
            var transformStr = "translate(" + (this._offset.x) + ", " +
                (this._offset.y) + ")";
            this._selection.select("g.v-plot-main").node()
                .setAttribute("transform", transformStr);
        }

        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };

    BasePlot.prototype.getSeries = function() {
        return this._series;
    };

    BasePlot.prototype._isEmptySeries = function(sr) {
        for(var ii = 0; ii < sr.length; ii++){
            if(!!sr[ii]){
                return false;
            }
        }
        return true;
    };

    BasePlot.prototype._getAxisPosition = function(handlers, seriesIndex, itemIndex, data, shape) {
        var dataHandler = this._dataHandler;
        var scaleOption = {
            index: itemIndex,
            seriesIndex: seriesIndex,
            shape: shape
        };

        for (var i = 0, length = handlers.length; i < length; i++) {
            var handler = handlers[i];
            if (data.hasOwnProperty(handler.id)) {
                scaleOption.dataHandler = dataHandler[handler.id];
                return handler.scale(data[handler.id], scaleOption);
            }
        }
        //if value does not exist, use index. for categoryAxis
        scaleOption.rawData = data;
        scaleOption.dataHandler = null;
        return handlers[0].scale(null, scaleOption);
    };

    BasePlot.prototype._getXPosition = function(seriesIndex, itemIndex, data) {
        return this._getAxisPosition(this._xHandlers, seriesIndex, itemIndex, data);
    };

    BasePlot.prototype._getYPosition = function(seriesIndex, itemIndex, data) {
        return this._getAxisPosition(this._yHandlers, seriesIndex, itemIndex, data);
    };

    BasePlot.prototype.getDataPointPosition = function(seriesIndex, itemIndex) {
        var data = this._data.series[seriesIndex][itemIndex];
        return this._getPosition(seriesIndex, itemIndex, data);
    };

    BasePlot.prototype._getPosition = function(seriesIndex, itemIndex, data) {
        var xResult = this._getXPosition(seriesIndex, itemIndex, data);
        var yResult = this._getYPosition(seriesIndex, itemIndex, data);
        if(isNaN(xResult[0]) || isNaN(xResult[1]) || isNaN(yResult[0]) || isNaN(yResult[1])){
            return null;
        }
        return {
            x: xResult[0],
            width: xResult[1],
            y: yResult[0],
            height: yResult[1]
        };
    };
    var BGCOLORPROPS = [ "plotArea.grid.background.color",
                         "plotArea.background.color",
                         "general.background.color"];

    BasePlot.prototype._getBackgroundColor = function(){
        var propMgr = this.runtime().propertyManager();
        var strokeColor = "plotArea.dataPoint.stroke.color";
        var strokeVisible = "plotArea.dataPoint.stroke.visible";
        var result =  ColorUtil.getBgColor(propMgr,
            propMgr.get(strokeVisible) ? BGCOLORPROPS.concat(strokeColor) : BGCOLORPROPS);
        return NameColorUtils.convertColor(result);
    };

    BasePlot.prototype._buildWrapperConfig = function(data, position, context, option) {
        option = option || {};

        var config = this._buildConfig(data, position, context);
        var additionCtx = data.dp && data.dp.additionCtx();
        config.additionCtx = additionCtx;
        if (this._strokeProp && this._strokeProp.visible && config.graphic) {
            config.graphic.stroke = config.graphic.stroke||this._strokeProp.color;
            config.graphic.strokeWidth = config.graphic.strokeWidth || 1;
        }

        if(option.seriesStyle){
            if(option.seriesStyle.dpPattern){
                config.graphic.pattern = option.seriesStyle.dpPattern;
            }
            if(option.seriesStyle.color){
                config.graphic.fill = option.seriesStyle.color;
            }
        }

        config.graphic.bgColor =  this._getBackgroundColor();

        //we should fetch legend text as well, write as a function
        if (!data.isNullValue) {
            context = context || data.dp.context();
        }

        // Ignore semantic color when dataPoint is unhighlight
        if (config.isMatchedHighlightContext === false) {
            option.disableSemantic = true;
        }

        config = this._getFillColorConfig(config, context, option, data);

        if (data.dp){
            config.dataId = data.dp.id;
            data.dp._isSemantic = config.matchSemantic;
        }
        config.rawData = data;

        if (data.trellisRow || data.trellisColumn){
            config.trellisInfo = {
                trellisRow: data.trellisRow,
                trellisColumn: data.trellisColumn
            };
        }

        return config;
    };

    BasePlot.prototype._doColorMapOnConfig = function(config){
        if (config.graphic) {
            if (config.graphic.fill) {
                config.graphic.fill = NameColorUtils.convertColor(config.graphic.fill);
            }
            if (config.graphic.color) {
                config.graphic.color = NameColorUtils.convertColor(config.graphic.color);
            }
            if(config.graphic.borderColor) {
                config.graphic.borderColor = NameColorUtils.convertColor(config.graphic.borderColor);
            }
        }
        if (config.data && config.data.color) {
            config.data.color = NameColorUtils.convertColor(config.data.color);
        }
    };

    BasePlot.prototype._getFillColorConfig = function(config, context, options, data) {
        var additionCtx =  (data && !data.isNullValue) ? data.dp.additionCtx() : {};
        var result = options.disableSemantic ? null :
        this._semanticMgr.analyzeDataPoint("color", context, true, additionCtx);
        var hasDPColorStyle = true;
        if (result == null || (result.properties == null) ||
            !(this._semanticMgr.hasDataPointColorStyle() ||
                this._semanticMgr.hasDataPointLineStyle())) {
            this._doColorMapOnConfig(config);
            hasDPColorStyle = false;
        }

        if (hasDPColorStyle) {
            if (result.properties.hasOwnProperty("color")) {
                var color = NameColorUtils.convertColor(result.properties.color||
                            this._semanticMgr._propMgr.get("plotArea.defaultOthersStyle.color"));
                if (config.graphic) {
                    if(config.graphic.hasOwnProperty("fill")) {
                        config.graphic.fill = color;
                    }
                    if(config.graphic.hasOwnProperty("color")) {
                        config.graphic.color = color;
                    }
                }
                if (config.data && config.data.color) {
                    config.data.color = color;
                }

                config.isOthers = result.isOthers;
                config.useDefaultOtherName  = result.useDefaultOtherName;
                config.displayName = result.displayName;
                config.matchSemantic = true;
            }

            if (result.properties.stroke) {
                config.graphic.stroke = result.properties.stroke;
            }
            if (result.properties.strokeWidth) {
                config.graphic.strokeWidth = result.properties.strokeWidth;
            }
        }

        config = this._getPatternConfig(config, context, options, additionCtx);
        return config;
    };

    BasePlot.prototype._getColor = function(data) {
        var color = null;
        if (this._data.color2 && data.color2) {
            color = this._data.color2.scale.scale(data.color2);
        } else if (this._data.color) {
            color = this._data.color.scale.scale(data.color);
        } else if (this._data.color2) {
            color = this._data.color2.scale.scale();
        }
        return color;
    };

    BasePlot.prototype._buildConfig = function(data, position, context) {
        var color = this._getColor(data);

        var graphic = {
            width: position.width,
            height: position.height,
            drawingEffect: this._drawingEffect,
            fill: color,
            opacity: 1
        };

        return {
            graphic: graphic,
            data: {
                color: color,
                width: position.width,
                height: position.height,
                translate: [position.x, position.y]
            },
            ctx: context,
            effectManager: this._effectManager
        };
    };

    BasePlot.prototype._createDataPoint = function(seriesIndex, itemIndex, dpConfig, dpData, position,
            currentId, data, onlyOneMndIndex) {
        var dataPoint = new DataPointInfo(-1, -1, null, -1);
        dataPoint.init(dpConfig, currentId, dpData, data && data.dp && data.dp.id ? data.dp.id
                : Constants.NULL_VALUE, onlyOneMndIndex);
        dataPoint.setPosition(position);
        dataPoint.setRawData(data);
        return dataPoint;
    };

    BasePlot.prototype._applyDataPointRenderer = function(dpRenderer, dpConfig) {
        return dpRenderer(dpConfig, this._dataPointRenderer.expose);
    };

    var DATAPOINT_CLASS = Constants.CSS.CLASS.DATAPOINT + ' ' +
            Constants.CSS.CLASS.MORPHABLEDATAPOINT + ' ' + Constants.CSS.CLASS.DATAPOINTDEFAULT;

    BasePlot.prototype._additionalExtraData = function (extraData) {
    };

    BasePlot.prototype._drawDataPoint = function(dpRenderer, dataPoint) {

        var dataPointG = SVG.create("g");
        DataPointUtils.setDataId(dataPointG, dataPoint.getDataId());
        DataPointUtils.setDataPointId(dataPointG, dataPoint.getDataPointId());
        DataGraphics.setContext(dataPointG, dataPoint.getContext());

        var extraData = dataPoint.getData();
        extraData.seriesIndex = dataPoint.getSeriesIndex();
        extraData.itemIndex = dataPoint.getItemIndex();
        this._additionalExtraData(extraData);

        DataGraphics.setData(dataPointG, extraData);

        var additionCtx = dataPoint.getAdditionCtx();
        DataGraphics.setAdditionCtx(dataPointG, additionCtx);

        dataPointG.setAttribute("class", this._dataPointClasses.join(' '));
        var position = dataPoint.getPosition();
        if (TypeUtils.isExist(position.x) && TypeUtils.isExist(position.y)) {
            dataPointG.setAttribute("transform", 'translate(' + position.x + ', ' + position.y + ')');
        }

        var dpConfig = dataPoint.getConfig();
        var node = this._renderNode(dpRenderer, dpConfig, dataPointG, extraData);
        var shadowNode = this._drawShadowNode(dpConfig.graphic, dataPointG, node, extraData, dpRenderer);
        return dataPointG;
    };

    BasePlot.prototype._isSupportNoFill = function (){
        return false;
    };

    BasePlot.prototype._drawShadowNode = function (graphic, dataPointG, node, extraData, dpRenderer){
        var shadowNode;
        dpRenderer = dpRenderer || this._dataPointRenderer;
        if (this._isSupportNoFill() && graphic.pattern === "noFill") {
            var clonedGraphic = ObjectUtils.clone(graphic);
            delete clonedGraphic.bgColor;
            delete clonedGraphic.drawingEffect;
            delete clonedGraphic.pattern;
            clonedGraphic.fill = "transparent";
            shadowNode = dpRenderer({graphic: clonedGraphic});
            if (shadowNode) {
                dataPointG.appendChild(shadowNode);
            }
        }
        node = shadowNode || node;
        if(node){
            var strokeWidth = node.getAttribute("stroke-width");
            if (strokeWidth) {
                extraData.strokeWidth = parseInt(strokeWidth);
            }
        }

        return shadowNode;
    };

    BasePlot.prototype._renderNode = function(dpRender, dpConfig, dataPointG, extraData){
        var node = this._applyDataPointRenderer(dpRender, dpConfig);
        if (!node && this._dataPointRenderer) {
            node = this._dataPointRenderer(dpConfig);
        }
        dataPointG.appendChild(node);

        //Save pattern's URL
        if(dpConfig.graphic && dpConfig.graphic.pattern){
            if(dpConfig.graphic.pattern === 'noFill'){
                extraData.pattern = 'noFill';
            }else{
                extraData.patternFill = node.getAttribute('fill');
            }
        }
        return node;
    };

    BasePlot.prototype._appendDataPointClass = function(className) {
        this._dataPointClasses.push(className);
    };

    BasePlot.prototype._buildData = function(dpConfig) {
        var data = {
            color: dpConfig.graphic.fill,
            trellisInfo: dpConfig.trellisInfo
        };
        if (this._semanticMgr.isUseSemanticPattern()) {
            data.pattern = dpConfig.graphic.pattern;
            if (dpConfig.ctx) {
                data.isNegative = (dpConfig.ctx[dpConfig.ctx.measureNames] < 0) ? true : false;
            }
        }
        return data;
    };

    BasePlot.prototype._getDataPointRenderer = function(seriesIndex) {
        return this._customMarkerRenderer || this._dataPointRenderer;
    };

    BasePlot.prototype.isBigDataMode = function() {
        return false;
    };

    BasePlot.prototype.getAxisBinding = function() {

        var binding = {};

        if (this._xHandlers) {

            binding.horizontal = this._xHandlers.map(function(handler) {
                return handler.id;
            });
        }

        if (this._yHandlers) {
            binding.vertical = this._yHandlers.map(function(handler) {
                return handler.id;
            });
        }

        return binding;
    };

    BasePlot.prototype.mappingDataPointInfo = function(id) {
        return {};
    };

    BasePlot.prototype.getRemainingPlotOffset = function(start, offset) {
        var realSize = this.getRealSize();
        var plotSize = this.getSize();
        var remainingOffset = {};
        var startPos = start ? (start.x || start.y || 0) : 0;

        if (this.isHorizontal()) {
            remainingOffset.y = (realSize.height - plotSize.height + startPos) * (-offset);
            return {y: remainingOffset.y + startPos};
        } else {
            remainingOffset.x = (realSize.width - plotSize.width + startPos) * (-offset);
            return {x: remainingOffset.x + startPos};
        }
    };

    BasePlot.prototype._getPatternConfig = function(config, context, options, additionCtx) {
        if (!options.disableSemantic && this._useSemanticPattern()) {
            var result = this._semanticMgr.analyzeDataPoint("pattern", context, true, additionCtx);
            if (result && result.properties && result.properties.pattern) {
                if(this._isSupportNoFill() || result.properties.pattern !== 'noFill'){
                    config.graphic.pattern = result.properties.pattern;
                }
                if (config.ctx[config.ctx.measureNames] < 0) {
                    config.graphic.isNegative = true;
                } else {
                    config.graphic.isNegative = false;
                }
            }
        }
        return config;
    };

    BasePlot.prototype._useSemanticPattern = function() {
        return this._semanticMgr.isUseSemanticPattern() && this._semanticMgr.hasDataPointStyle();
    };

    BasePlot.prototype.getSeriesIndex = function(dp){
        return dp._addr[1];
    };

    return BasePlot;
});

define('sap/viz/chart/components/plots/BarWidthUtils',['sap/viz/framework/common/util/NumberUtils'], function(NumberUtils){
    
    var utils = {};
    var DEFAULT_INNERGROUPSPACING = 0.125;
    var DEFAULT_GROUPSPACING = 1;
    utils.getBarInfo = function(seriesCount, options) {
        var STEP = 1;
        var result = {};
        if(options.hasOwnProperty("barWidth")){
            result.barWidth = options.barWidth;
            if(seriesCount === 1){
                result.itemWidth = result.barWidth;
                result.gap = (STEP - result.barWidth) / 2;
            }else{
                result.itemWidth = result.barWidth * (1 + options.innerGroupSpacing);
                result.gap = (STEP -  result.itemWidth * (seriesCount - 1) - result.barWidth) / 2;
            }
        }else  if(seriesCount === 1){
           
            result.barWidth = STEP / (seriesCount + options.barSpacing);
            result.gap = result.barWidth * options.barSpacing / 2;
            result.itemWidth = result.barWidth; 
        }else{
            result.barWidth = STEP / ( seriesCount  + options.innerGroupSpacing * (seriesCount - 1) +
                    options.groupSpacing);
            result.gap = result.barWidth * options.groupSpacing / 2;
            result.itemWidth = result.barWidth * (1 + options.innerGroupSpacing);
        }
        return result;
    };
    
    utils.getBarProperties = function(props, isFlexibleStack) {
        var innerGroupSpacing = DEFAULT_INNERGROUPSPACING;
        var groupSpacing = DEFAULT_GROUPSPACING;
        if (!isFlexibleStack) {
            innerGroupSpacing = parseFloat(props.get("plotArea.gap.innerGroupSpacing"));
            if (NumberUtils.isNoValue(innerGroupSpacing) || innerGroupSpacing < 0) {
                innerGroupSpacing = props.getDefault("plotArea.gap.innerGroupSpacing") || 0;
            }
            groupSpacing = parseFloat(props.get("plotArea.gap.groupSpacing"));
            if (NumberUtils.isNoValue(groupSpacing) || groupSpacing < 0) {
                groupSpacing = props.getDefault("plotArea.gap.groupSpacing") || 0;
            }
        }

        var barSpacing = parseFloat(props.get("plotArea.gap.barSpacing"));
        if(NumberUtils.isNoValue(barSpacing) || barSpacing < 0){
            barSpacing = props.getDefault("plotArea.gap.barSpacing") || 0;
        }
        
        return {
            innerGroupSpacing: innerGroupSpacing,
            groupSpacing: groupSpacing,
            barSpacing: barSpacing,
            forBar : true
        };
    };
    
    return utils;
            
    
});
define('sap/viz/chart/components/plots/ItemScaleHandler',['sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/ObjectUtils', 'sap/viz/chart/components/plots/BarWidthUtils'],
    function Setup(oo, ObjectUtils, BarWidthUtils) {
    function getSpreadItemScale(seriesCount, options) {
        var result = [];
        var barInfo = BarWidthUtils.getBarInfo(seriesCount, options);
        for (var i = 0; i < seriesCount; i++) {
            result[i] = [barInfo.gap + i * barInfo.itemWidth, 
                         barInfo.gap + i * barInfo.itemWidth + barInfo.barWidth];
        }
        return result;
    }

    var ItemScale = function(options) {
        this._result = [];
        this._options = options || {};
    };

    ItemScale.prototype.updateOptions = function(options) {
        ObjectUtils.extend(true, this._options, options);
    };

    ItemScale.prototype.init = function(seriesCount) {
        var result = this._result = [];
        var step = 1;
        var itemRange;
        if(!this._options.hasOwnProperty("barSpacing")){
            itemRange = [step * 0.25, step * 0.75];
            if(this._options && this._options.hasOwnProperty("barWidth")) {
                var halfBarWidth = this._options.barWidth / 2;
                itemRange = [step * (0.5 - halfBarWidth), step * (0.5 + halfBarWidth)];
            } 
       
        }else{
            itemRange = getSpreadItemScale(1, this._options)[0];
           
        }
        for (var i = 0; i < seriesCount; i++) {
            result[i] = itemRange;
        }
    };

    ItemScale.prototype.get = function(seriesIndex) {
        return this._result[seriesIndex];
    };

    ItemScale.prototype.updateOptions = function(options) {
        ObjectUtils.extend(true, this._options, options);
    };

    var SpreadItemScale = function(options) {
        SpreadItemScale.superclass.constructor.apply(this, arguments);
        this._options = options || {
            forBar: true
        };
    };

    oo.extend(SpreadItemScale, ItemScale);

    SpreadItemScale.prototype.init = function(seriesCount) {
        if(this._options.isMekkoCategoryAxis){
            this._result = [];
            for (var j = 0; j < seriesCount; j++) {
                this._result[j] = [0.0, 1.0];
            }
        } else if (!this._options.forBar) {
            this._result = [];
            for (var i = 0; i < seriesCount; i++) {
                this._result[i] = [i / seriesCount, (i + 1) / seriesCount];
            }
        } else {
            this._result = getSpreadItemScale(seriesCount, this._options);
        }
    };

    SpreadItemScale.prototype.get = function(seriesIndex) {
        return this._result[seriesIndex];
    };

    var MultiItemsScale = function(options) {
        MultiItemsScale.superclass.constructor.apply(this, arguments);
        this._items = options.valueAxis;
    };

    oo.extend(MultiItemsScale, ItemScale);

    MultiItemsScale.prototype.init = function(seriesCount) {
        this._result = getSpreadItemScale(this._items.length, this._options);
    };

    MultiItemsScale.prototype.get = function(seriesIndex, rawData) {
        for (var i = 0; i < this._items.length; i++) {
            if (rawData && rawData.hasOwnProperty(this._items[i])) {
                return this._result[i];
            }
        }
    };
    
    MultiItemsScale.prototype.updateItems = function(items){
        this._items = items;
    };

    return {
        /**
         * get Item scale for category
         * @param {Boolean} isSpread
         * @param {Boolean} options.forBar
         * @param {Array} options.valueAxis set value axis if isSpread is false. for dual stacked chart.
         */
        get: function(isSpread, options) {
            if(options && options.isMekkoCategoryAxis){
                return new SpreadItemScale(options);
            }else if (isSpread) {
                return new SpreadItemScale(options);
            } else if (options && options.valueAxis) {
                return new MultiItemsScale(options);
            } else {
                return new ItemScale(options);
            }
        },
        extend: function(subClass) {
            var baseScale = ItemScale;
            oo.extend(subClass, baseScale);

            return subClass;
        }
    };
});
define('sap/viz/chart/components/plots/ScaleHandler',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DataUtils'
], function Setup(
    oo,
    TimeUtil,
    TypeUtils,
    DataUtils
) {
    /**
     * options : {
     *     isHorizontal : true|false,
     *     alignment : top|left|center|right,
     *     itemScaleHandler : func
     * }
     */
    var ScaleHandler = function(id, options) {
        this.id = id;
        this._options = options || {
            isHorizontal: true
        };
    };
    
    var LINE = "line";

    ScaleHandler.prototype.init = function(scale, seriesCount, range) {
        this._scale = scale;
        this._range = range;
    };

    ScaleHandler.prototype.scale = function(value, index) {
        return this._scale(value);
    };
    
    ScaleHandler.prototype.destroy = function() {
        this.id = null;
        this._options = null;
        
        this._range = null;
        this._scale = null;
        this.type = null;
    };

    var CategoryScaleHandler = function(id, options) {
        CategoryScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "category";
    };
    oo.extend(CategoryScaleHandler, ScaleHandler);

    CategoryScaleHandler.prototype.init = function(categoryScale, seriesCount) {
        CategoryScaleHandler.superclass.init.apply(this, arguments);
        if (!categoryScale) {
            this._scaleByIndex = null;
            return;
        }
        var domain = categoryScale.getDomain();
        var scale = categoryScale.scale.bind(categoryScale);
        this._scaleByIndex = [];
        for (var i = 0; i < domain.length; i++) {
            this._scaleByIndex[i] = scale(domain[i]);
        }
        this._options.itemScaleHandler.init(seriesCount);
    };

    CategoryScaleHandler.prototype.destroy = function() {
        CategoryScaleHandler.superclass.destroy.call(this);
        this._scaleByIndex = null;
    };
    
    CategoryScaleHandler.prototype.scale = function(value, options) {
        var index = options.index,
            seriesIndex = options.seriesIndex;
        var range = this._scaleByIndex && this._scaleByIndex[index] ? this._scaleByIndex[index] : [0, 1];
        var itemRange = this._options.itemScaleHandler.get(seriesIndex, options.rawData) || [0, 1];
        var step = range[1] - range[0];
        var distance = step * (itemRange[1] - itemRange[0]) * this._range;
        var start = (range[0] + step * itemRange[0]) * this._range;
        if (this._options.alignment === "center") {
            return [start + distance / 2, 0];
        } else {
            return [start, distance];
        }
    };

    var PolarScaleHandler = function(id, options) {
        PolarScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "polar";
    };
    oo.extend(PolarScaleHandler, CategoryScaleHandler);

    PolarScaleHandler.prototype.scale = function(value, options) {
        var index = options.index,
            seriesIndex = options.seriesIndex;
        var range = this._scaleByIndex ? this._scaleByIndex[index] : [0, 1];
        return [Math.PI * 2 * range[0], 0];
    };

    PolarScaleHandler.prototype.categorySum = function(value, options) {
        return this._scaleByIndex.length;
    };

    var ValueScaleHandler = function(id, options) {
        ValueScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "value";
        this.continuous = true;
    };
    oo.extend(ValueScaleHandler, ScaleHandler);

    ValueScaleHandler.prototype.scale = function(value, options) {
        value = +value;
        var index = options.index,
            seriesIndex = options.seriesIndex,
            dataHandler = options.dataHandler;
        var start = this._scale.scale(dataHandler ? dataHandler.getBase(index, value, seriesIndex) : 0);
        var newValue = dataHandler ? dataHandler.add(index, value, seriesIndex) : value;
        var end = this._scale.scale(newValue);
        var distance = (end - start) * this._range;
        if (this._options.isHorizontal) {
            if (this._options.alignment === "right") {
                return [end * this._range, distance];
            } else {
                return [start * this._range, distance];
            }
        } else {
            return [(1 - end) * this._range, distance];
        }
    };

    var PerfectValueScaleHandler = function(id, options) {
        PerfectValueScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "value";
        this.continuous = true;
    };
    oo.extend(PerfectValueScaleHandler, ScaleHandler);

    PerfectValueScaleHandler.prototype.scale = function(value, options) {
        var index = options.index,
            seriesIndex = options.seriesIndex,
            dataHandler = options.dataHandler;
        var start, newValue, end, distance;
        var min, max, autoDomain, domain, domainFixed, range;
        value = +value;
        autoDomain = this._scale.getAutoDomain();
        domain = this._scale.getDomain();
        domainFixed = this._scale.getDomainFixed();
        range = this._scale.getRange();
        min = domainFixed[0] ? domain[0] : autoDomain[0];
        max = domainFixed[1] ? domain[1] : autoDomain[1];
        if (min >= max) {
            min = autoDomain[0];
            max = autoDomain[1];
        }
        if (value < min) {
            start = range[0];
        } else if (value > max) {
            start = range[1];
        }
        else {
            start = this._scale.scale(dataHandler ? dataHandler.getBase(index, value, seriesIndex) : 0);
        }
        newValue = dataHandler ? dataHandler.add(index, value, seriesIndex) : value;
        if (newValue > max) {
            end = range[1];
        } else if (newValue < min) {
            end = range[0];
        }
        else {
            end = this._scale.scale(newValue);
        }
        distance = (end - start) * this._range;
        if (this._options.isHorizontal) {
            if (this._options.alignment === "right") {
                return [end * this._range, distance];
            } else {
                return [start * this._range, distance];
            }
        } else {
            return [(1 - end) * this._range, distance];
        }
    };

    var TimeScaleHandler = function(id, options) {
        TimeScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "time";
    };

    oo.extend(TimeScaleHandler, ValueScaleHandler);

    TimeScaleHandler.prototype.scale = function(value, options) {
        var index = options.index,
            dataHandler = options.dataHandler;
        var newValue = dataHandler ? dataHandler.add(index, value) : value;
        var middle = this._scale.scale(newValue);

        return [middle * this._range, 0];
    };

    var TimeCategoryScaleHandler = function(id, options) {
        TimeCategoryScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "time";
        this._barWidth = null;
        this._innerSpace = null;
        this._columnCount = null;
        this._isSingleBar = options.forSingleBar;
    };

    oo.extend(TimeCategoryScaleHandler, ValueScaleHandler);

    TimeCategoryScaleHandler.prototype.scale = function(value, options) {
        var index = options.index,
            dataHandler = options.dataHandler;
        var handlerOptions = this._options;
        var minLevel = handlerOptions.minTimeLevel;
        var utc = handlerOptions.showAsUTC;
        var newValue = dataHandler ? dataHandler.add(index, value) : value;
        var middle = this._scale.scale(newValue);
        var position;   
        if (this._isSingleBar) {
            position = this._barWidth / 2;
        } else {
            position = (this._columnCount * this._barWidth + (this._columnCount - 1) * this._innerSpace) / 2 -
                options.seriesIndex * (this._barWidth + this._innerSpace);
        }
        return [(middle - (options.shape === LINE ? 0 : position)) *
            this._range, this._barWidth * this._range
        ];
    };

    TimeCategoryScaleHandler.prototype.updateBarWidth = function(barWidth, innerSpace, count) {
        this._barWidth = barWidth;
        this._innerSpace = innerSpace;
        this._columnCount = count;
    };

    var WTFScaleHandler = function(id, options) {
        ValueScaleHandler.superclass.constructor.apply(this, arguments);
        this.type = "value";
        this.continuous = true;
    };
    oo.extend(WTFScaleHandler, ScaleHandler);

    WTFScaleHandler.prototype.scale = function(data, options) {
        var index = options.index,
            seriesIndex = options.seriesIndex,
            dataHandler = options.dataHandler;
        var value = +data.value;
        var total = data.total;
        var base = data.base;
        var start = this._scale.scale(dataHandler ? dataHandler.getBase(index, base, seriesIndex) : base);
        var newValue = dataHandler ? dataHandler.add(index, value, seriesIndex) : value;
        var end = this._scale.scale(dataHandler? newValue : total);
        var distance = (end - start) * this._range;
        if (this._options.isHorizontal) {
            if (this._options.alignment === "right") {
                return [end * this._range, distance];
            } else {
                return [start * this._range, distance];
            }
        } else {
            return [(1-end) * this._range, distance];
        }
    };
    
    return {
        getCategoryScaleHandler: function(id, options) {
            return new CategoryScaleHandler(id, options);
        },
        getValueScaleHandler: function(id, options) {
            return new ValueScaleHandler(id, options);
        },
        getTimeScaleHandler: function(id, options) {
            if (options.forBar){
                return new TimeCategoryScaleHandler(id, options);
            } else {
                return new TimeScaleHandler(id, options);
            }
        },
        getPolarScaleHandler: function(id, options) {
            return new PolarScaleHandler(id, options);
        },
        getPerfectValueScaleHandler: function(id, options) {
            return new PerfectValueScaleHandler(id, options);
        },
        getWTFScaleHandler: function(id, options) {
            return new WTFScaleHandler(id, options);
        },
        extend: function(subClass) {
            var baseScale = ScaleHandler;
            oo.extend(subClass, baseScale);
            return subClass;
        }
    };
});

define('sap/viz/chart/components/renderers/BarRenderer',[ "sap/viz/framework/common/util/SVG",
    'sap/viz/framework/common/util/DataGraphics',
    "sap/viz/chart/components/util/DrawUtil",
    'sap/viz/framework/common/util/Constants'
], function(SVG, DataGraphics, DrawUtil, Constants) {
    var MIN_FILL_SIZE = 2;
    var barRenderer = function(config) {
        var node;
        var graphic = config.graphic;
        var width = graphic.width < 1 && graphic.width !== 0 ? 1 : graphic.width;
        var height = graphic.height < 1 && graphic.height !== 0 ? 1 : graphic.height;
        var fill = graphic.fill;

        if (graphic.pattern === "noFill" && config.path) {
            node = SVG.create("path");
            node.setAttribute("d", config.path);
            node.setAttribute("stroke-width",
                isNaN(graphic.pathStrokeWidth) ? 3 : graphic.pathStrokeWidth);
            node.setAttribute("fill", graphic.bgColor);
            node.setAttribute("stroke", graphic.fill);
        } else {
            node = SVG.create("rect");
            if (config.effectManager) {
                fill = config.effectManager.register({
                    drawingEffect : graphic.drawingEffect,
                    fillColor : graphic.fill,
                    patternEffect: graphic.pattern,
                    isNegative: graphic.isNegative,
                    direction : config.horizontal ? 'vertical' : 'horizontal'
                });
            }
            node.setAttribute("width", width);
            node.setAttribute("height", height);
            node.setAttribute("fill", fill);
            if(graphic.shapeRendering) {
                node.setAttribute('shape-rendering', graphic.shapeRendering);
            } 
            if(graphic.stroke) {
                var minSize = config.twoDirection ? Math.min(height, width) :(config.horizontal ? height : width);
                var strokeWidth = minSize > graphic.strokeWidth + MIN_FILL_SIZE ?
                        graphic.strokeWidth : minSize - MIN_FILL_SIZE;
                if(strokeWidth >= 1){
                    node.setAttribute('stroke', graphic.stroke);
                    node.setAttribute('stroke-width', graphic.strokeWidth);
                }
            }           
        }

        DataGraphics.setCustomizationInfo(node, {'defaultRenderer' : true});
        return node;
    };

    barRenderer.update = function(node, config) {
        var graphic = config.graphic;
        var width = graphic.width < 1 && graphic.width !== 0 ? 1 : graphic.width;
        var height = graphic.height < 1 && graphic.height !== 0 ? 1 : graphic.height;
        var size = {
            width: width,
            height: height,
            minSize: config.twoDirection ? Math.min(height, width) :(config.horizontal ? height : width)
        };
        DrawUtil.barUpdate(node, config, size);
    };

    barRenderer.expose = {
        renderer: barRenderer,
        update: barRenderer.update
    };

    return barRenderer;
});

define('sap/viz/chart/components/renderers/GridlineRenderer',[
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/scales/ValueScaleUtil",
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/common/util/DataGraphics"
], function(NumberUtils, Constants, ValueScaleUtil, SVG, DataGraphics) {

    var GRIDLINE_GROUP_CLASS_NAME = Constants.CSS.CLASS.GRIDLINE_GROUP;
    var GRIDLINE_CLASS_NAME = Constants.CSS.CLASS.GRIDLINE;
    var INCISED_GRIDLINE_CLASS_NAME = Constants.CSS.CLASS.GRIDLINE_INCISED;
    var INCISED_GRIDLINE_COLOR = "#ffffff";
    var CLASS_ZEROLINE_GROUP = Constants.CSS.CLASS.ZERO_LINE_GROUP;
    var CLASS_ZEROLINE = "v-zeroline";
    var MAIN_LINE = "v-gridline-mainline";
    var INCISED_LINE = "v-gridline-incisedline";

    var ret = {};

    ret.drawZeroLine = function(selection, width, height, scale, properties, direction, defaultColor, outofPlot) {
        //selection.select("." + CLASS_ZEROLINE).remove();
        var node;
        var highlight = properties.get("gridline.zeroLine.highlight");
        if (!highlight) {
            return;
        }
        var ticks = ValueScaleUtil.getTicks(scale);
        //if not grid line below zero line, do not draw
        var zeroIdx = ticks.indexOf(0);
        if (zeroIdx < 1) {
            node = selection.select("." + CLASS_ZEROLINE_GROUP);
            if (!node.empty()) {
                node.remove();
            }
            return;
        }
        var color = properties.get("gridline.zeroLine.color") || defaultColor;
        color = color || properties.origin.get("categoryAxis.color");

        node = selection.select("." + CLASS_ZEROLINE_GROUP);
        var g, line;
        if (!node.node()){
            node = selection.append("g").attr("class", CLASS_ZEROLINE_GROUP)
            .style('pointer-events','none');
        }
        g = node.select("." + CLASS_ZEROLINE);
        if(!g.node()) {
            g = node.append("g").attr("class", CLASS_ZEROLINE);
            line = g.append("line");
        } else {
            line = g.select("line");
        }
        node.attr("stroke", color)
            .attr("stroke-width", properties.get("gridline.size") || 1)
            .attr("shape-rendering", "crispEdges");
        if (properties.get("gridline.type") === Constants.GRIDLINE_TYPE.DASHED ||
            properties.get("gridline.type") === Constants.GRIDLINE_TYPE.DOTTED){
            node.attr("stroke-dasharray", Constants.DASH_TYPE_ARRAY);
        } else {
            node.node().removeAttribute("stroke-dasharray");
        }
        var clipPath = selection.node().getElementsByTagName('clipPath');
        if(clipPath && clipPath.length > 0) {
            var clipPathId = clipPath[0].getAttribute('id');
            node.attr("clip-path", "url(#" + clipPathId + ")");
        }
        var x1, x2, y1, y2;
        var pos = NumberUtils.preciseSimple(scale.scale(0));
        var dataObj = {};
        if (direction === Constants.DIRECTION.HORIZONTAL) {
            x1 = 0;
            x2 = NumberUtils.preciseSimple(width);
            y1 = y2 = !outofPlot ? pos : 0;
            if(outofPlot) {
                g.attr("transform", "translate(" + 0 + ", " + pos + ")"); 
            }
            dataObj.initPosY = pos;
        } else {
            y1 = 0;
            y2 = NumberUtils.preciseSimple(height);
            x1 = x2 = !outofPlot ? pos : 0;
            if(outofPlot) {
                g.attr("transform", "translate(" + pos + ", " + 0 + ")"); 
            }
            dataObj.initPosX = pos;
        }
        line.attr('x1', x1)
            .attr('x2', x2)
            .attr('y1', y1)
            .attr('y2', y2);
        if(outofPlot) {
            DataGraphics.setData(g.node(), dataObj);
        }        
    };

    ret.drawValueGridline = function(selection, width, height, scale, props, direction) {
        var node = selection.select("." + GRIDLINE_GROUP_CLASS_NAME);
        if (props.get('visible')) {
            var stroke = props.get('color');
            var strokeWidth = props.get('size');
            var valueTicks = ValueScaleUtil.getTicks(scale);
            var ticks = ValueScaleUtil.getTicksPosition(valueTicks, scale);
            var i = 0;
            var length = ticks.length;
            var x1s = [];
            var y1s = [];
            var x2s = [];
            var y2s = [];
            switch (direction) {
                case Constants.DIRECTION.HORIZONTAL:
                    for (; i < length; ++i) {
                        x1s[i] = 0;
                        y1s[i] = ticks[i];
                        x2s[i] = NumberUtils.preciseSimple(width);
                        y2s[i] = ticks[i];
                    }
                    break;
                case Constants.DIRECTION.VERTICAL:
                    for (; i < length; ++i) {
                        x1s[i] = ticks[i];
                        y1s[i] = 0;
                        x2s[i] = ticks[i];
                        y2s[i] = NumberUtils.preciseSimple(height);
                    }
                    break;
            }
            if (!node.node()) {
                node = selection.append("g").attr("class", GRIDLINE_GROUP_CLASS_NAME);
            }
            var gridlines = node.selectAll("." + GRIDLINE_CLASS_NAME).data(valueTicks);
            gridlines.enter().append("g");
            gridlines.exit().remove();

            var unhighlightAxis = props.get('zeroLine.unhighlightAxis');
            var isTopDown = props.origin.get("valueAxis.layout.direction") === "topDown";
            gridlines.each(function(d, i) {
                this.setAttribute("class", GRIDLINE_CLASS_NAME);
                this.setAttribute("stroke", stroke);
                this.setAttribute("stroke-width", strokeWidth);
                this.setAttribute("shape-rendering", "crispEdges");
                var line = this.querySelector("line." + MAIN_LINE);
                if (!line) {
                    line = SVG.create("line");
                    line.setAttribute("class", MAIN_LINE);
                    this.appendChild(line);
                }
                line.setAttribute("x1", x1s[i]);
                line.setAttribute("y1", y1s[i]);
                line.setAttribute("x2", x2s[i]);
                line.setAttribute("y2", y2s[i]);

                // Unhighlight axis if necessary.
                if ((!isTopDown && i === 0 || isTopDown && i === length -1) && d !== 0 && unhighlightAxis === false) {
                    line.setAttribute("stroke-opacity", 0);
                }
            });
            var type = props.get('type');
            if (type === Constants.GRIDLINE_TYPE.DASHED || type === Constants.GRIDLINE_TYPE.DOTTED) {
                gridlines.attr("stroke-dasharray", Constants.DASH_TYPE_ARRAY);
            }
            if (type === Constants.GRIDLINE_TYPE.INCISED) {
                switch (direction) {
                    case Constants.DIRECTION.HORIZONTAL:
                        gridlines.each(function(d, i) {
                            var line = this.querySelector("line." + INCISED_LINE);
                            if (!line) {
                                line = SVG.create("line");
                                line.setAttribute("class", INCISED_LINE);
                                this.appendChild(line);
                            }
                            line.setAttribute("stroke", INCISED_GRIDLINE_COLOR);
                            line.setAttribute("x1", x1s[i]);
                            line.setAttribute("y1", y1s[i] + 1);
                            line.setAttribute("x2", x2s[i]);
                            line.setAttribute("y2", y2s[i] + 1);
                        });
                        break;
                    case Constants.DIRECTION.VERTICAL:
                        gridlines.each(function(d, i) {
                            var line = this.querySelector("line." + INCISED_LINE);
                            if (!line) {
                                line = SVG.create("line");
                                line.setAttribute("class", INCISED_LINE);
                                this.appendChild(line);
                            }
                            line.setAttribute("stroke", INCISED_GRIDLINE_COLOR);
                            line.setAttribute("x1", x1s[i] - 1);
                            line.setAttribute("y1", y1s[i]);
                            line.setAttribute("x2", x2s[i] - 1);
                            line.setAttribute("y2", y2s[i]);
                        });
                        break;
                }
            }
        } else {
            node.remove();
        }
    };
    
    ret.drawRadarGridLine = function(selection, center, branchAngle, scale, props) {
        if (!props.visible) {
            return;
        }
        var node = selection.select("." + GRIDLINE_GROUP_CLASS_NAME);
        if (!node.node()) {
            node = selection.append("g").attr("class", GRIDLINE_GROUP_CLASS_NAME);
        }
        var stroke = props.color;
        var strokeWidth = props.size;
        var ticks = getTicks(scale);
        function convertPolarPosition(center, angle, distance) {
            if(distance === 0) {
                return;
            }
            var offsetX = distance * Math.sin(angle);
            var offsetY = distance * Math.cos(angle);
            return {
                x : center.x - offsetX,
                y : center.y - offsetY
            };
        }
        for(var i = 0; i < ticks.length; i ++) {
            if(ticks[i] === 0) {
                continue;
            }
            var branchGridLine = SVG.create("g");
            var position = [];
            for(var j = 0; j < branchAngle.length; j ++) {
                var line = SVG.create("line");
                line.setAttribute("class", INCISED_LINE);
                line.setAttribute("stroke", stroke);
                line.setAttribute("stroke-width", strokeWidth);
                var start = j === 0 ? convertPolarPosition(center, branchAngle[branchAngle.length - 1], ticks[i]) :
                    position[j - 1];
                var end = convertPolarPosition(center, branchAngle[j], ticks[i]);
                position.push(end);
                line.setAttribute("x1", start.x);
                line.setAttribute("y1", start.y);
                line.setAttribute("x2", end.x);
                line.setAttribute("y2", end.y);
                branchGridLine.appendChild(line);
            }
            node.node().appendChild(branchGridLine);
        }
    };

    function getTicks(scale) {
        var ticks = ValueScaleUtil.getTicks(scale);
        return ValueScaleUtil.getTicksPosition(ticks, scale);
    }

    return ret;
});

define('sap/viz/chart/components/plots/BaseColumnPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/chart/scales/ValueScale',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/model/DataPointInfo',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/chart/components/renderers/BarRenderer',
    'sap/viz/chart/components/renderers/GridlineRenderer',
    'sap/viz/framework/common/util/DataGraphics',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/components/plots/BarWidthUtils',
    'sap/viz/framework/common/util/NumberUtils',
    "sap/viz/chart/components/container/utils/xyTransformUtils",
    "sap/viz/framework/chartmodel/ContextBuilder",
    "sap/viz/chart/components/util/DrawUtil"
], function Setup(
    oo,
    SVG,
    DOM,
    ValueScale,
    Constants,
    BasePlot,
    DataHandler,
    ItemScaleHandler,
    ScaleHandler,
    DataPointInfo,
    Series,
    BarRenderer,
    GridlineRenderer,
    DataGraphics,
    DataPointUtils,
    UADetector,
    ObjectUtils,
    DataUtils,
    TypeUtils,
    BarWidthUtils,
    NumberUtils,
    xyTransformUtils,
    ContextBuilder,
    DrawUtil

) {
    var CLASS_NEGATIVEDATAPOINT = "negative-datapoint";
    var trellisColumnSize = {
        desktop : {
            minWidth : 8,
            maxWidth : 100
        },
        mobile : {
            minWidth : 8,
            maxWidth : 100
        }
    };
    var MIN_FILL_SIZE = Constants.MIN_FILL_SIZE;

    /**
     * To initialize BaseColumnPlot object.
     *
     * @name BaseColumnPlot
     * @constructor
     */
    var BaseColumnPlot = function(runtime, options) {
        options = options || {
            isHorizontal: false
        };
        this._valueAxisIndex = options.valueAxisIndex || "valueAxis";
        BaseColumnPlot.superclass.constructor.apply(this, arguments);
        this._dataPointRenderer = BarRenderer;
        this._flipNegativeShape = true; //if need to flip shapes of negative value
        this._drawZeroLineBeforeDatapoints = true;
        this._isBigData = false;
    };

    oo.extend(BaseColumnPlot, BasePlot);

    BaseColumnPlot.prototype._getBarProperties = function(){
        if (!this._barInfoProperties) {
            this._barInfoProperties = BarWidthUtils.getBarProperties(this._properties.origin);
        }
        return this._barInfoProperties;
    };
    
    BaseColumnPlot.prototype.destroy = function() {
        BaseColumnPlot.superclass.destroy.call(this);
        if (this._categoryScaleHandler) {
            this._categoryScaleHandler.destroy();
        }
        this._categoryScaleHandler = null;

        if (this._gridlineScale) {
            this._gridlineScale.destroy();
        }
        this._gridlineScale = null;
        this._dataPointRenderer = null;
        this._flipNegativeShape = null;
        this._drawZeroLineBeforeDatapoints = null;
        this._options = null;
        this._isBigData = null;
    };

    BaseColumnPlot.prototype.isBigDataMode = function() {
        return this._isBigData;
    };

    BaseColumnPlot.prototype.setVisibleWindow = function(size, position){
        this._windowSize = size;
        this._positionInWindow = position;
        this._applyScroll();
    };

    BaseColumnPlot.prototype._getDataPointRange = function(dataPoints, range){
        var min = range.min;
        var max = range.max;
        var posProp = this.isHorizontal() ? "y" : "x";
        var position;
        if(dataPoints[min] && min > 0){
            position = this._getDataPointPosition(dataPoints[min]);
            if(position[posProp] >= -this._offset[posProp]){
                --min;
            }
        }
        while(min > 0 && !dataPoints[min]){
            --min;
        }
       
        if(max < dataPoints.length - 1 && dataPoints[max]){
            position = this._getDataPointPosition(dataPoints[max]);
            if(position[posProp] <  this._visibleBound[posProp]){
                ++max;
            }
        }
        while(max < dataPoints.length - 1 && !dataPoints[max]){
            ++max;
        }
        return {
            min : min,
            max : max
        };

    };
    
    BaseColumnPlot.prototype._getColorData = function() {
        return this._data.color;
    };

    BaseColumnPlot.prototype._getColor2Data = function() {
        return this._data.color2;
    };

    BaseColumnPlot.prototype._buildLegendTextData = function(series) {
        //bar and dual_bar may need to show legend data in data label
        //build color legent text data
        var seiresLength = series.length;
        var colorDataArray = [];
        var seriesIndex;
        var seriesItem;
        for (seriesIndex = 0; seriesIndex < seiresLength; seriesIndex++) {
            seriesItem = series[seriesIndex];
            var colorItemIndex;
            for(colorItemIndex = 0; colorItemIndex < seriesItem.length; colorItemIndex++) {
                if(seriesItem[colorItemIndex]) {
                    if(seriesItem[colorItemIndex].color) {
                        colorDataArray.push(seriesItem[colorItemIndex].color);
                    }
                    else {
                        colorDataArray.push(seriesItem[colorItemIndex].color2);
                    }
                    //the series should have the same color
                    break;
                }
            }
        }
        return colorDataArray;
    };


    BaseColumnPlot.prototype._getOnlyOneMndIndex = function(seriesItem, colorDataArray) {
        var onlyOneMndIndex = -1;
        //the function is for legend text feature. Now the feature does not support Trellis.
        if(!this._options.inTrellis) {
            //we need to remove onlyOneMndIndex color text
            var colorMetaData;

            if(seriesItem.length > 0 && seriesItem[0].color) {
                colorMetaData = this._getColorData();
            }
            else if(seriesItem.length > 0){
                colorMetaData = this._getColor2Data();
            }

            if(colorMetaData) {
                onlyOneMndIndex = DataUtils.checkMndStatus(colorMetaData.metaData, colorDataArray).mndIndex;
            }
        }
        return onlyOneMndIndex;
    };

    BaseColumnPlot.prototype._getMaxVisibleSize = function(){
        var visibleSize = this._windowSize || this._size;
        return {
            width: visibleSize.width,
            height: visibleSize.height
        };
    };
    BaseColumnPlot.prototype._preShowDataPoints = function() {
        BaseColumnPlot.superclass._preShowDataPoints.apply(this, arguments);
        var offset = this._offset;
        var offsetX = offset.hasOwnProperty("x") ? offset.x : 0;
        var offsetY = offset.hasOwnProperty("y") ? offset.y : 0;
        if (this._positionInWindow) {
            offsetX += this._positionInWindow.hasOwnProperty("x") ? this._positionInWindow.x : 0;
            offsetY += this._positionInWindow.hasOwnProperty("y") ? this._positionInWindow.y : 0;
        }
        var maxSize = this._getMaxVisibleSize();
        this._visibleBound = {
            x : maxSize.width - offsetX,
            y : maxSize.height - offsetY
        };
    };

    BaseColumnPlot.prototype._drawDataPoint = function(dpRenderer, dataPoint) {
        var config = dataPoint.getConfig();
        var dp = BaseColumnPlot.superclass._drawDataPoint.apply(this, arguments);
        this._updateStrokeWidth(dp);
        if (this._flipNegativeShape) {
            var dpConfig = dataPoint.getConfig();
            if(dpConfig.ctx){
                var negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
                if (negative) { //flip
                    this._addNegativeClass(dp, dpConfig);
                }
            }
        }
        return dp;
    };
    BaseColumnPlot.prototype._addNegativeClass = function(dp, dpConfig) {
        var g = document.createElementNS('http://www.w3.org/2000/svg', "g");
        for(var i = 0, len = dp.childNodes.length; i < len; ++i){
            g.appendChild(dp.childNodes[0]);
        }
        /*
         * To fix bug BITSDC1-4723, we need to set the bar width/height to be 1
         * if less then 1px
         */
        g.setAttribute("class", CLASS_NEGATIVEDATAPOINT);
        this._updateNegativeDatapoint(dpConfig, g);
        dp.appendChild(g);
    };
    
    BaseColumnPlot.prototype._generateMarkerPath = function (){
        var markerProps = this._markerPropName && this._properties.get(this._markerPropName);
        if (markerProps) {
            var r = markerProps.size / 2;
            this._markerD = DrawUtil.createMarkerData({
                type : this._getMarkerShape(),
                rx : r,
                ry : r,
                borderWidth : 2
            });
            // "noFill" inner marker path data
            this._markerShadow = DrawUtil.createMarkerData({
                type : this._getMarkerShape(),
                rx : r + 0.8,
                ry : r + 0.8,
                borderWidth : 1,
                innerBorder: true
            });
        }
    };

    BaseColumnPlot.prototype._updateNegativeDatapoint = function(dpConfig, dataPoint) {
        var transform;
        if (this.isHorizontal()) {
            transform = "translate(" +
                (dpConfig.graphic.width > 1 ? dpConfig.graphic.width : 1) + ",0)scale(-1, 1)";
        } else {
            transform = "translate(0," +
                (dpConfig.graphic.height > 1 ? dpConfig.graphic.height : 1) + ")scale(1, -1)";
        }

        dataPoint.setAttribute("transform", transform);
    };
    BaseColumnPlot.prototype.isHorizontal = function() {
        return (this._options.isHorizontal === true);
    };

    BaseColumnPlot.prototype._getPreferredSizeProperties = function(propertyName){
        var props = this._properties;
        return props.get(propertyName);
    };

    BaseColumnPlot.prototype._getValueScaleHandlers = function(isHorizontal) {
        if (this._options.isDualValueAxis) {
            return [ScaleHandler.getValueScaleHandler("valueAxis", {
                isHorizontal: isHorizontal
            }), ScaleHandler.getValueScaleHandler("valueAxis2", {
                isHorizontal: isHorizontal
            })];
        } else {
            return [ScaleHandler.getValueScaleHandler(this._valueAxisIndex, {
                isHorizontal: isHorizontal
            })];
        }
    };

    BaseColumnPlot.prototype._getCategoryScaleHandlers = function(isHorizontal) {
        this._categoryScaleHandler = ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: isHorizontal,
            itemScaleHandler: ItemScaleHandler.get(true, this._getBarProperties())
        });
        return [this._categoryScaleHandler];
    };

    BaseColumnPlot.prototype._getXHandlers = function() {
        if (this.isHorizontal()) {
            return this._getValueScaleHandlers(true);
        } else {
            return this._getCategoryScaleHandlers(true);
        }
    };

    BaseColumnPlot.prototype._getYHandlers = function() {
        if (this.isHorizontal()) {
            return this._getCategoryScaleHandlers(false);
        } else {
            return this._getValueScaleHandlers(false);
        }
    };

    BaseColumnPlot.prototype._getDataHandler = function() {
        if (this._options.isDualValueAxis) {
            return {
                "valueAxis": DataHandler.getHandler(),
                "valueAxis2": DataHandler.getHandler()
            };
        } else {
            var ret = {};
            ret[this._valueAxisIndex] = DataHandler.getHandler();
            return ret;
        }
    };

    BaseColumnPlot.prototype._getDefaultZeroLineColor = function() {
        return this._properties.origin.get("categoryAxis.color");
    };

    BaseColumnPlot.prototype._postRender = function(dataPointG) {
        if (!this._drawZeroLineBeforeDatapoints && this._gridlineScale) {
            var isHorizontal = this.isHorizontal();
            var direction = isHorizontal ? Constants.DIRECTION.VERTICAL : Constants.DIRECTION.HORIZONTAL;
            GridlineRenderer.drawZeroLine(this._selection, this._size.width, this._size.height,
                                          this._gridlineScale, this._properties, direction,
                                          this._getDefaultZeroLineColor(), true);
        }
        BaseColumnPlot.superclass._postRender.apply(this, arguments);
    };

    function getFirstDataPoint(dataPoints){
        var index = -1;
        for(var i=0; i<dataPoints.length; i++){
            if(dataPoints[i]){
                index = i;
                break;
            }
        }
        return index;
    }

    function getLastDataPoint(dataPoints){
        var index = -1;
        for(var i=dataPoints.length-1; i >=0; i--){
            if(dataPoints[i]){
                index = i;
                break;
            }
        }
        return index;
    }

    BaseColumnPlot.prototype._resetDataPoints = function(){
        for (var dhID in this._dataHandler) {
            if (this._dataHandler[dhID].reset) {
                this._dataHandler[dhID].reset();
            }
        }
        if(!this._series || this._series.length===0){
            return;
        }
        for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
            var seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }
            var dataPoints = seriesModel.getDataPoints();
            this._hideDataPoints(dataPoints, {min:0, max: dataPoints.length-1});
            for (var itemIndex = 0; itemIndex < dataPoints.length; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (dataPointModel) {
                    dataPointModel.reset();
                }
            }
        }
    };

    BaseColumnPlot.prototype._getDataPointPosition = function(dataPointModel){
        var position = dataPointModel.getPosition();
        if(!position){
            position = this._getPosition(dataPointModel.getSeriesIndex(), dataPointModel.getItemIndex(),
                dataPointModel.getRawData());
            dataPointModel.setPosition(position);
        }
        return position;
    };

    BaseColumnPlot.prototype._needLazyRender = function(){
        if (!!this._options.inTrellis){
            return true;
        }
        var size = this._size;
        var realSize = this._realSize;
        return this.isHorizontal() ? size.height < realSize.height : size.width < realSize.width;
    };
    
   
   
    BaseColumnPlot.prototype._getVisibleRange = function(dataPoints){
        var cateCount = this._getCategoryCount();
        if(!this._needLazyRender()){
            return {
                min: 0,
                max: cateCount
            };
        }
        var isHorizontal = this.isHorizontal();
        var posProp = isHorizontal ? "y" : "x";
        var offsets = this._offset[posProp];
        var visibleBound = this._visibleBound;
        var sizeProp = isHorizontal ? 'height' : 'width';

        var cateWidth = this._realSize[sizeProp] / cateCount;
        var first = Math.floor(Math.abs(offsets / cateWidth));
        var last = Math.floor(Math.abs(visibleBound[posProp])/ cateWidth);
        return  {
            min:  first ,
            max:  last 
        };
    };
    
    BaseColumnPlot.prototype._initSeries = function(){
        var series = this._getSeries();
        var seiresLength = series.length;  
        var currentId;
        var countId = 0;
        if (this._seriesRenderer) {
            this._seriesRenderer.init(seiresLength);
        }
        for (var seriesIndex = 0; seriesIndex < seiresLength; seriesIndex++) {
            //...each series
            var seriesItem = series[seriesIndex];
            if (!seriesItem) {
                continue;
            }

            //set each data point
            var seriesSize = seriesItem.length, color = null;
            for (var itemIndex = 0; itemIndex < seriesSize; ++itemIndex) {
                var data = seriesItem[itemIndex];
                if (!data) {
                    continue;
                }

                //FIXME: Use raw data id here instead of an inner id.
                currentId = countId++;
                this._series[seriesIndex] = this._series[seriesIndex] || new Series();
                var dataPoint = this._series[seriesIndex].getDataPoint(itemIndex);
                if(dataPoint){
                    dataPoint.reset();
                    dataPoint.setRawData(data);
                } else {
                    dataPoint = new DataPointInfo(seriesIndex, itemIndex, data, currentId);
                    this._series[seriesIndex].setDataPoint(itemIndex, dataPoint);
                }
            }
            if(this._series[seriesIndex]){
                this._series[seriesIndex].setLength(seriesSize);
            }
        }
        this._series.length = seiresLength;
    };

    BaseColumnPlot.prototype._drawDatapoints = function(parent) {
     

        this._initSeries(); 

        for (var dhID in this._dataHandler) {
            if (this._dataHandler[dhID].reset) {
                this._dataHandler[dhID].reset();
            }
        }

        this._drawingEffect = this._properties.get('drawingEffect');
     

        var dataPointG = parent.node().querySelector("."+Constants.CSS.CLASS.DATAPOINT_GROUP);
        if (!dataPointG){
            dataPointG = SVG.create("g");
            dataPointG.setAttribute("class", Constants.CSS.CLASS.DATAPOINT_GROUP);
            parent.node().appendChild(dataPointG);
        } else {
            d3.select(dataPointG).selectAll("*").remove();
        }

        //set up anything, time to render!!
        this._showDataPoints(dataPointG);
        if(this._seriesRenderer){
            this._seriesRenderer.render(dataPointG);
        }

        this._postRender(dataPointG);
        this._drawDataLabels(parent, dataPointG);
    };

    BaseColumnPlot.prototype._isSupportNoFill = function (){
        return true;
    };
    
   
    var PATTERNVALS = ["noFill", "solid"];
    BaseColumnPlot.prototype.getSeriesDPStyle = function(seriesIndex, context, isLine) {
        
        var semanticMgr = this._semanticMgr;
        context = context || ContextBuilder.buildSeriesLineContext(this._data, seriesIndex);
        var semanticProps = semanticMgr.analyzeSeriesStyle(context, "dataPoint");
        var dpPattern = semanticProps && semanticProps.dataPoint && semanticProps.dataPoint.pattern;
        if(isLine && PATTERNVALS.indexOf(dpPattern) === -1){
            dpPattern = null;
        }
        if(!this._isSupportNoFill() && dpPattern === 'noFill'){
            dpPattern = null;
        }
        return {
            dpPattern:dpPattern,
            color : semanticProps && semanticProps.dataPoint && semanticProps.dataPoint.color
        };
    };

    BaseColumnPlot.prototype._hideNode = function(dataPoints, index) {
        var dataPointModel = dataPoints[index];
        var node = dataPointModel && dataPointModel.getNode();
        if(node ){
            DOM.remove(node);
            dataPointModel.setNode(null);
        }
    };

    BaseColumnPlot.prototype._columnOutOfRange = function(dataPoints, visibleRange) {
        var i;
        for(i=0; i<visibleRange.min; i++){
            this._hideNode(dataPoints, i);
        }
        for(i=visibleRange.max +1; i<dataPoints.length; i++){
            this._hideNode(dataPoints, i);
        }
    };

    BaseColumnPlot.prototype._hideDataPoints = function(dataPoints, visibleRange){
        if (!visibleRange){
            //if not specify range, hide all.
            var dpLen = dataPoints.length;
            visibleRange = {
                min: dpLen,
                max: dpLen
            };
        }
        this._columnOutOfRange(dataPoints, visibleRange);
    };

    BaseColumnPlot.prototype._generatePath = function(size) {
        var points = [];
        //When path stroke width is 3, it is 1.5. If storke width is 2, it is 1.
        var strokePadding = 1.5;
        if (this.isHorizontal()) {
            if (size.width === 0) {
                strokePadding = 0;
            }
            points.push([0, strokePadding]);
            points.push([size.width-strokePadding, strokePadding]);
            points.push([size.width-strokePadding, size.height-strokePadding]);
            points.push([0, size.height-strokePadding]);
        } else {
            if (size.height === 0) {
                strokePadding = 0;
            }
            points.push([strokePadding, size.height]);
            points.push([strokePadding, strokePadding]);
            points.push([size.width-strokePadding, strokePadding]);
            points.push([size.width-strokePadding, size.height]);
        }
        return SVG.generatePath({points : points});       
    };

    BaseColumnPlot.prototype._pathStrokeWidth = function(context) {
        //Now path stroke width is 3 for noFill pattern, 
        //but it should be 0 when bar height or width is 0.
        if (context && context[context.measureNames] === 0) {
            return 0;
        }
        return 3;
    };

    BaseColumnPlot.prototype._isSupportBarPathGenerator = function () {
        //for all combination and flexible stacks, it is true
        return false;
    };

    BaseColumnPlot.prototype._showDataPoints = function(dataPointG) {
        this._preShowDataPoints();
        var newDataPoints = [];
        this._dataPointContext = [];
        if(this._seriesRenderer){
            this._seriesRenderer.resetDataPoints();
        }
        
        var mndIndex;
        if(this._data.color && this._data.color.metaData && !this._data.color2){
            var result = DataUtils.checkMndStatus(this._data.color.metaData , this._data.color.rowArray);
            if(result.isOnlyOneMndValue){
                mndIndex = result.mndIndex;
            }
        }
        var seriesIter = this.createSeriesIterator(this._series.length);
        var range = this._getVisibleRange();
        
        while (seriesIter.hasNext()) {
            var seriesIndex = seriesIter.next();
            var seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }
            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
            var dataPoints = seriesModel.getDataPoints();
            var curRange = this._getDataPointRange(dataPoints, range);
            this._hideDataPoints(dataPoints, curRange);
            var seriesStyle = this.getSeriesDPStyle(seriesIndex);
            for (var itemIndex = curRange.min; itemIndex <= curRange.max; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }
                var position = this._getDataPointPosition(dataPointModel);
                if (!position) {
                    continue;
                }
                var data = dataPointModel.getRawData();
                var dp = data.dp;
                var itemChanged = false;
                var dpConfig = dataPointModel.getConfig();
                if(!dpConfig){
                    itemChanged = true;
                    var ctx = dp && dp.context() ? dp.context() : Constants.NULL_VALUE;
                    var seriesType = this._seriesType && this._seriesType[seriesIndex];
                    var options = {itemIndex: itemIndex, seriesType: seriesType, seriesStyle: seriesStyle};
                    dpConfig = this._buildWrapperConfig(data, position, ctx, options);
                    if (dpConfig.graphic.pattern === "noFill") {
                        if (this._isSupportBarPathGenerator() && seriesType === "bar") {
                            dpConfig.path = this._generatePath(dpConfig.graphic);
                        }
                    }
                }
                this._dataPointContext.push(dpConfig);
                var dpData = dataPointModel.getData();
                if(!dpData){
                    itemChanged = true;
                    var currentId = dataPointModel.getId();
                    dpData = this._buildData(dpConfig);
                    dataPointModel.init(dpConfig, currentId, dpData,
                        dp && dp.id ? dp.id : Constants.NULL_VALUE, mndIndex);
                }

                var dpNode = dataPointModel.getNode();
                if(dpNode){
                    if(itemChanged){
                        this._updateDatapoint(dpNode, dpRenderer, dpConfig, position);
                        newDataPoints.push(dpNode);
                    }
                } else {
                    dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                    dataPointModel.setNode(dpNode);
                    if (dpNode) {
                        newDataPoints.push(dpNode);
                    }
                }
                // when update, we need update strokeWidth, since strokeWidth will change
                this._updateStrokeWidth(dpNode);
                
                if(this._seriesRenderer){
                    this._seriesRenderer.addDataPoint(seriesIter.index(), itemIndex, dpConfig, position, dpNode);
                } else if(!dpNode.parentNode){
                    dataPointG.appendChild(dpNode);
                }
            }
        }
        return newDataPoints;
    };

    BaseColumnPlot.prototype.zoom = function() {
        this.update();
    };

    BaseColumnPlot.prototype.update = function(offset) {
        this._applyChanges();
        this._dataLabels.setSize(this._realSize);
        if(this._selection){
            var selection = this._selection.select(".v-plot-main");

            this._drawGridlines(selection);
            this._updateDatapoints(this._getDpParentNode());
            this._drawReferenceLine(offset);
            this._repositionReferenceLine();
            this._repositionZeroline();
        }
    };
    
    BaseColumnPlot.prototype._updateStrokeWidth = function(dpNode){
        if(!dpNode){
            return;
        }
        var extra_data = DataGraphics.getData(dpNode);
        var rect = dpNode.querySelector("rect");
        if(rect){
            extra_data["strokeWidth"] = rect.getAttribute("stroke-width") || 0;
            DataGraphics.setData(dpNode, extra_data);
        }
    };

    BaseColumnPlot.prototype._updateDatapoints = function(parent) {
        this._resetDataPoints();
        var dataPointG = parent.select("." + Constants.CSS.CLASS.DATAPOINT_GROUP).node();
        var dataPoints = this._showDataPoints(dataPointG);
        if(this._seriesRenderer){
            this._seriesRenderer.update(dataPointG);
        }
        this._dataLabels.updatePosition(parent, dataPoints);
    };

    BaseColumnPlot.prototype._updateDatapoint = function(dataPointG, dpRenderer, dpConfig,
        position) {
        if (dataPointG && dpRenderer.update && TypeUtils.isFunction(dpRenderer.update)) {
            dpRenderer.update(dataPointG, dpConfig, this._dataPointRenderer.expose);
        }

        if (dataPointG && position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            dataPointG.setAttribute("transform", 'translate(' + position.x + ', ' + position.y +
                ')');
        }

        var negative = null;

        if (dpConfig.ctx) {
            negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
        } else {
            // when lazy context build
            var dataModel = this._data.rawData.dataModel;

            var dp = dataModel.getDataPoint(dpConfig.dataId);

            var context = dp.context();

            negative = context[context.measureNames] < 0;
        }
        if (negative) {
            var negativeDatapoint = dataPointG.querySelector("." + CLASS_NEGATIVEDATAPOINT);
            if (negativeDatapoint) {
                this._updateNegativeDatapoint(dpConfig, negativeDatapoint);
            }
        }
    };

    BaseColumnPlot.prototype._drawGridlines = function(parent) {
        var size = this._realSize;
        var isHorizontal = this.isHorizontal();
        var direction = isHorizontal ? Constants.DIRECTION.VERTICAL : Constants.DIRECTION.HORIZONTAL;
        var props = this._properties.proxy('gridline');
        var range = isHorizontal ? [0, size.width] : [size.height, 0];
        var scale = this._gridlineScale = this._getGridLineScale(range);

        GridlineRenderer.drawValueGridline(parent, size.width, size.height, scale, props, direction);
        var syncValueAxis = this._properties.origin.get('interaction.syncValueAxis');
        if (this._drawZeroLineBeforeDatapoints || syncValueAxis) {
            GridlineRenderer.drawZeroLine(this._drawZeroLineBeforeDatapoints ? parent : this._selection, 
                size.width, size.height, this._gridlineScale,
                this._properties, direction, this._getDefaultZeroLineColor(), !this._drawZeroLineBeforeDatapoints);
        }
    };

    BaseColumnPlot.prototype._getGridLineScale = function(range) {

        var axisKey = this._valueAxisIndex;

        if (this._options.isDualValueAxis &&
            this._data.valueAxis.tickHint < this._data.valueAxis2.tickHint) {
            axisKey = "valueAxis2";
        }
        var valueAxis = this._data[axisKey];
        var scale = new ValueScale(valueAxis.scale.getDomain(), range);
        scale.setTickHint(valueAxis.tickHint);

        scale.setAllowDecimals(valueAxis.scale.getAllowDecimals());

        return scale;
    };

    BaseColumnPlot.prototype._getPosition = function(seriesIndex, itemIndex, data) {
        var position = BaseColumnPlot.superclass._getPosition.apply(this, arguments);
        this._adjustPosition(position, seriesIndex);
        return position;
    };
    BaseColumnPlot.prototype._adjustPosition = function(position, seriesIndex) {
        /*
         * Waterfall and StackedColumn chart will keep the old behavior and move up/left the negative columns/bars 
         * 0.5px from the zero line so these two subclasses will overwritte this function.
         */
        var horizontal = this.isHorizontal(), offset = 0;
        if (horizontal) {
            if(position.width < 0){
                if(position.width > -MIN_FILL_SIZE) {
                    position.width = MIN_FILL_SIZE;
                }else {
                    position.width = Math.abs(position.width);
                }
                position.x -= position.width;
            } else if(position.width > 0 && position.width < MIN_FILL_SIZE){
                position.width = MIN_FILL_SIZE;
            }
        } else {
            if(position.height < 0) {
                if(position.height > -MIN_FILL_SIZE) {
                    offset = MIN_FILL_SIZE - Math.abs(position.height);
                    position.height = MIN_FILL_SIZE;
                }else {
                    position.height = Math.abs(position.height);
                }
                position.y -= position.height - offset;
            }
            else if(position.height > 0 && position.height < MIN_FILL_SIZE) {
                offset = MIN_FILL_SIZE - position.height;
                position.height = MIN_FILL_SIZE;
                position.y -= offset;
            }
        }
    };

    BaseColumnPlot.prototype._buildConfig = function(data, position, context) {
        var config = BaseColumnPlot.superclass._buildConfig.apply(this, arguments);
        config.horizontal = this.isHorizontal();

        return config;
    };

    BaseColumnPlot.prototype._getColumnCount = function() {
        return this._data.series.length;
    };

    BaseColumnPlot.prototype._getColumnWidth = function(columnCount, categoryCount,
        isHorizontal) {
        var step = 1;
        var categoryWidth = isHorizontal ?
            (this._size.height / categoryCount) :
            (this._size.width / categoryCount);
        var barInfo = BarWidthUtils.getBarInfo(columnCount, this._getBarProperties());
        return  categoryWidth * barInfo.barWidth;
    };

    BaseColumnPlot.prototype._updateRealSize = function(columnCount, categoryCount, columnWidth, isHorizontal) {
        var size = this.getRealSizeByFixedDPSize(columnWidth, columnCount, categoryCount);
        this._realSize[isHorizontal ? 'height' : 'width'] = size;
    };

    BaseColumnPlot.prototype._getCategoryCount = function() {
        var cateAxis = this._data.categoryAxis;
        return cateAxis ? cateAxis.scale.getDomain().length : 1;
    };

    BaseColumnPlot.prototype.getPreferredSize = function() {
        var props = this._properties;
        var inTrellis = !!this._options.inTrellis;
        var isHorizontal = this.isHorizontal();
        var categoryCount = this._getCategoryCount();
        var ranges = this._getCategoryRange() || this._getTimeRange();
        var columnCount = this._getColumnCount();
        this._showSrollbar = false;
        var maxWidth = this._getPreferredSizeProperties("dataPointSize.max") || 
            props.getDefault("dataPointSize.max");
        var categoryWidth, barWidth;

        var isTimeChart = !!this._data.timeAxis;
        var isInterative = !props.origin.get("interaction.noninteractiveMode");
        var isRangeIncompleteFn = this._isRangeIncomplete;
        function useFullRangeAlgo(){
            return !isTimeChart && ranges && !isRangeIncompleteFn(ranges) && isInterative;
        }

        if (!useFullRangeAlgo()) {
            var columnWidth = this._getColumnWidth(columnCount, categoryCount, isHorizontal);
            var trellisSize = UADetector.isMobile() ? trellisColumnSize.mobile : trellisColumnSize.desktop;
            var minWidth = inTrellis ? trellisSize.minWidth : 
                (this._getPreferredSizeProperties("dataPointSize.min") || props.getDefault("dataPointSize.min"));
            maxWidth = inTrellis ? trellisSize.maxWidth : maxWidth;
            if(!inTrellis && minWidth > maxWidth) {
                maxWidth = props.getDefault("dataPointSize.max");
                minWidth = props.getDefault("dataPointSize.min");
            }

            var minWidthChanged = false;
            if (columnWidth < minWidth && isInterative) {
                //if users disable Interative, barWidth does not apply minWidth. It is for "thumbnail" mode.
                minWidthChanged = true;
                columnWidth = minWidth;
            } else if (columnWidth > maxWidth) {
                columnWidth = maxWidth;
                this._updateBarWidth(maxWidth);
            }

            if (minWidthChanged && 
                    (inTrellis || 
                        isRangeIncompleteFn(ranges) || 
                        this._getPreferredSizeProperties('isFixedDataPointSize') )) {
                this._updateRealSize(columnCount, categoryCount, columnWidth, isHorizontal);
            }
            //time implement _shiftOffsetForIncompleteRange as empty function
            if(isRangeIncompleteFn(ranges) && 
                this._shiftOffsetForIncompleteRange(ranges, categoryCount)){
                return this.getRealSize();
            }
        }   

        if(useFullRangeAlgo()){
            var visibleCategoryCount = ranges[1] - ranges[0] + 1;
            var width = this._getColumnWidth(columnCount, visibleCategoryCount, isHorizontal);
            var overviewWidth = this._getColumnWidth(columnCount, categoryCount, isHorizontal);
            if(width > maxWidth){
                width = maxWidth;
                if(overviewWidth < maxWidth){
                    this._updateRealSize(columnCount, categoryCount, width, isHorizontal);
                    // calculate max visible category numbers
                    var maxVisibleCount;
                    if(isHorizontal){
                        maxVisibleCount = this._size.height / this._realSize['height'] * categoryCount;
                    }else{
                        maxVisibleCount = this._size.width / this._realSize['width'] * categoryCount;
                    }
                    // set start position fitting in poltArea
                    if(maxVisibleCount > categoryCount - ranges[0]){
                        ranges[0] = categoryCount - maxVisibleCount;
                    }
                }else{
                    categoryWidth = isHorizontal? this._size.height/categoryCount : this._size.width/categoryCount;
                    barWidth = width / categoryWidth;
                    this._categoryScaleHandler._options.itemScaleHandler.updateOptions({
                        'barWidth' : barWidth
                    });
                    ranges[0] = 0;
                }
            }else{
                if(isHorizontal){
                    this._realSize['height'] = this._size.height * categoryCount / visibleCategoryCount;
                }else{
                    this._realSize['width'] = this._size.width * categoryCount / visibleCategoryCount;
                }
            }
            if(isHorizontal){
                this._offset['y'] = -ranges[0] / categoryCount * this._realSize['height'];
            }else{
                this._offset['x'] = -ranges[0] / categoryCount * this._realSize['width'];
            }
        } 

        return this.getRealSize();
    };

    BaseColumnPlot.prototype._updateBarWidth = function(maxWidth) {
        var categoryCount = this._getCategoryCount();
        var isHorizontal = this.isHorizontal();
        var categoryWidth = isHorizontal? this._size.height/categoryCount : this._size.width/categoryCount;
        var barWidth = maxWidth / categoryWidth;
        this._categoryScaleHandler._options.itemScaleHandler.updateOptions({
            'barWidth' : barWidth
        });
    };

    BaseColumnPlot.prototype._buildWrapperConfig = function(data, position, context, options) {
        var config = BaseColumnPlot.superclass._buildWrapperConfig.apply(this, arguments);
        var graphic = config.graphic;
        if((graphic.width < 1 || graphic.height < 1) &&
                graphic.width !== 0 && graphic.height !== 0) {
            graphic.shapeRendering = 'crispEdges';
        }
        return config;
    };
    
    BaseColumnPlot.prototype._getDataRange = function( rangeStart, rangeEnd){
        var categoryAxis = this._data.categoryAxis;
        var result = {displayValues : {start: rangeStart, end:rangeEnd}};
        if(categoryAxis){
            var domain = categoryAxis.scale.getDomain();
            var meta = categoryAxis.metaData;
            var start  = Math.floor(rangeStart * domain.length / 100);
            var end   =  Math.ceil(rangeEnd * domain.length/ 100);
            var cData = [];
            for(var i = start; i < end; ++i){
               
                var element = {};
                for(var j = 0; j < meta.length; ++j){
                    element[meta[j].id] = domain[i][j];
                }
                cData[i-start] = element;
            } 
            var convertFunc = DataUtils.getDisplayTextsConverter(meta);
            var startValue = convertFunc(domain[start])[0];
            var endValue = convertFunc(domain[end - 1])[0];
            result = {displayValues : {start: startValue, end:endValue}, data : cData};
        }  

        return result;
        
    };

    BaseColumnPlot.prototype.getRealSizeByFixedDPSize = function(dpSize, nColumn, nCategory) {
        nColumn = nColumn || this._getColumnCount();
        nCategory = nCategory || this._getCategoryCount();
        var barInfo = BarWidthUtils.getBarInfo(nColumn, this._getBarProperties());
        return dpSize * nCategory / barInfo.barWidth;
    };

    BaseColumnPlot.prototype._repositionZeroline = function() {
        if (!this._selection) {
            return;
        }
        var zlns = this._selection.node().querySelectorAll(".v-zeroline"),
            scale = this.runtime().statusManager().get("plot.transform.scale"),
            trans = this.runtime().statusManager().get("plot.transform.translate");
        for(var i = 0; i < zlns.length; i++) {
            xyTransformUtils.adjustXYTranslate(zlns[i], scale, trans);
        }
    };

    BaseColumnPlot.prototype.scroll = function() {
        this._semanticMgr.beginSession();
        BaseColumnPlot.superclass.scroll.apply(this, arguments);
        this._repositionZeroline();
        this._semanticMgr.endSession();
    };

    BaseColumnPlot.prototype._getDpPlotNode = function(){
        if (this._selection) {
            return this._dpPlotNode || this._selection.node();
        }
    };

    BaseColumnPlot.prototype._getDpParentNode = function(){
        return this._dpParentNode || this._plotDpParentNode;
    };
    
    BaseColumnPlot.prototype._getMarkerShape = function() {
        var shape = this._properties.get("marker.shape") ||
            this._properties.get("line.marker.shape");
        if(Constants.LINE_MARKER_SHAPE.indexOf(shape) === -1) {
            shape = this._properties.getDefault("marker.shape") ||
                this._properties.getDefault("line.marker.shape");
        }
        return shape;
    };
    
    BaseColumnPlot.prototype._getLegendMarkerShape = function() {
        var shape = this._properties.origin.get("legend.marker.shape");
        if(Constants.LEGEND_MARKER_SHAPE.indexOf(shape) === -1) {
            shape = this._properties.origin.getDefault("legend.marker.shape");
        }
        return shape;
    };

    return BaseColumnPlot;
});

define('sap/viz/chart/components/datalabels/ColumnDataLabels',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/framework/common/util/Constants'
], function(
    oo,
    DOM,
    DataGraphics,
    DataLabels,
    Constants
    ) {
    var ColumnDataLabels = function(ctx, options) {
        ColumnDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = "outside";
    };

    oo.extend(ColumnDataLabels, DataLabels);
    ColumnDataLabels.prototype.labelOffset = Constants.DATALABEL.VERTICAL_LABEL_OFFSET;

    ColumnDataLabels.prototype.allowIntersectionCheck = function() {
        return false;
    };

    ColumnDataLabels.prototype.hideConditional = function(dataLabelInfos, allDataPoints) {
        var i;
        var dataPointBoxes = new Array(allDataPoints.length);
        for (i = 0; i < allDataPoints.length; i++) {
            dataPointBoxes[i] = allDataPoints[i].getBoundingClientRect();
        }

        for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
            var dataLabelinfo = dataLabelInfos[i];

            var dataLabelNode = dataLabelinfo.node;
            var dataLabelBBox = dataLabelNode.getBoundingClientRect();
            var dataPointNode = dataLabelinfo.dataPoint;
            var dataLabelLocation = DataGraphics.getData(dataPointNode).dataLabelLocation;
            if(dataLabelLocation === "inside") {
                if( ((dataLabelBBox.width - (2 * this.labelOffset)) > dataPointBoxes[i].width) ||
                    (dataLabelBBox.height > dataPointBoxes[i].height)) {
                    //remove the dataLabel
                
                    DOM.remove(dataLabelNode);
                    dataLabelInfos.splice(i, 1);
                    continue;
                }
            }

            if (!this.allowIntersectionCheck(dataPointNode)) {
                var iIndex = this.indexOfDataLabelIntersectDataPoints(dataLabelBBox, dataPointBoxes,
                                                                      allDataPoints, dataPointNode);

                if (iIndex !== -1 ) {
                    DOM.remove(dataLabelNode);
                    dataLabelInfos.splice(i, 1);
                }
            }
        }
        return ColumnDataLabels.superclass.hideConditional.apply(this, arguments);
    };

    

    ColumnDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox, 
                                                                config, node) {
        this._labelPosition = this._properties.get('position') ||
        this._properties.getDefault('position');
        //add 1px padding to avoid datalabel background overlapped with datapoint
        var PADDING = 1;
        var exData;
        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;
        
        x = (nodeX + shapeBBox.width / 2) - (labelBBox.x + labelBBox.width / 2);
        if(config.val === 0){
            y = nodeY - (labelBBox.y + labelBBox.height) + this.labelOffset;
            if( y + labelBBox.y < 0){
                y = nodeY - labelBBox.y - this.labelOffset;
            }
            
        }else if(this._labelPosition === "inside"){
            if(config.val >=0){
                y = nodeY + labelBBox.height  +
                (labelBBox.y + labelBBox.height / 2) - this.labelOffset;
            }else{
                y = nodeY + shapeBBox.height + this.labelOffset - (labelBBox.y + labelBBox.height);
            }
           
        }else{
            if(config.val >= 0) {
                if (this._labelPosition === 'outsideFirst') {
                    y = nodeY - (labelBBox.y + labelBBox.height) - PADDING;
                    if (y < labelBBox.height) {
                        y = nodeY + labelBBox.height  +
                        (labelBBox.y + labelBBox.height / 2) - this.labelOffset;
                        exData = DataGraphics.getData(node);
                        exData.dataLabelLocation = "inside";
                        DataGraphics.setData(node, exData);
                    }
                } else {
                    y = nodeY - (labelBBox.y + labelBBox.height);
                    if(y + labelBBox.y + this.labelOffset >= 0) {
                        y = y + this.labelOffset;
                    }else if(y + labelBBox.y >= 0){
                        y = -labelBBox.y;
                    }
                }
            }
            else {
                if (this._labelPosition === 'outsideFirst') {
                    y = nodeY + shapeBBox.height - labelBBox.y + PADDING;
                    if (y > config.plotSize.height) {
                        y = nodeY + shapeBBox.height - labelBBox.height - labelBBox.y + this.labelOffset;
                        exData = DataGraphics.getData(node);
                        exData.dataLabelLocation = "inside";
                        DataGraphics.setData(node, exData);
                    }
                } else {
                    y = nodeY + shapeBBox.height - labelBBox.y;
                    if(y + labelBBox.height + labelBBox.y - this.labelOffset <= config.plotSize.height) {
                        y = y - this.labelOffset;
                    } else if(y + labelBBox.height + labelBBox.y <= config.plotSize.height) {
                        y = config.plotSize.height;
                    }
                }
            }
            
        }
        return [x, y];
    };

    ColumnDataLabels.prototype._processDataLabelRendererConfig = function(config, node) {
        ColumnDataLabels.superclass._processDataLabelRendererConfig.apply(this, arguments);
        var mark = this._getMarkFromNode(node), size;
        if (mark && config.dataPointWidth === 0 && config.dataPointHeight === 0) {
            size = this._getDataLabelSizeFromMark(mark);
            if (size) {
                config.dataPointWidth = size.width;
                config.dataPointHeight = size.height;
            }
        }
    };

    ColumnDataLabels.prototype._getMarkFromNode = function(node) {
        // by default get the rect size
        if (!node) {
            return null;
        }
        var mark = d3.select(node).select('rect:first-child');
        return mark.empty() ? null : mark.node();
    };

    return ColumnDataLabels;
});

define('sap/viz/chart/components/renderers/SeriesRenderer',[
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/TypeUtils'
], function Setup(SVG, TypeUtils) {

    //this is a wrapper.IT has the render and update functions, and it holds the series data
    //series render may not be the best name for this class
    var SeriesRenderer = function(itemRenderFn, itemUpdateFn) {
        this._renderFn = itemRenderFn;
        this._updateFn = itemUpdateFn;
    };

    SeriesRenderer.prototype.init = function(seiresCount) {
        this._series = [];
        this._seriesGroup = [];
        for (var i = 0; i < seiresCount; i++) {
            this._seriesGroup[i] = SVG.create("g");
        }
    };

    SeriesRenderer.prototype.resetDataPoints = function(){
        this._series = [];
    };

    SeriesRenderer.prototype.addDataPoint = function(seriesIndex, categoryIndex, dpConfig, position, dataPoint) {

        if (dataPoint) {
            this._seriesGroup[seriesIndex].appendChild(dataPoint);
        }

        this._series[seriesIndex] = this._series[seriesIndex] || [];
        this._series[seriesIndex][categoryIndex] = {
            position: position,
            dpConfig: dpConfig,
            dataPoint: dataPoint
        };
    };

    SeriesRenderer.prototype.updateDataPoint = function (seriesIndex, categoryIndex, dpConfig, position, dataPoint){
        if(!this._series[seriesIndex]){
            this._series[seriesIndex] = [];
        }
        var seriesInfo = this._series[seriesIndex][categoryIndex];
        if(!seriesInfo){
            seriesInfo = this._series[seriesIndex][categoryIndex] = {};
        }
        seriesInfo.position = position;
        seriesInfo.dpConfig = dpConfig;
        seriesInfo.dataPoint = dataPoint;
    };

    SeriesRenderer.prototype.render = function(parent, gIndexes) {
        var seriesOrder = [], series, seriesGroup;
        for (var i = 0; i < this._seriesGroup.length; i++) {
            seriesGroup = this._seriesGroup[i];
            if(seriesGroup && !(gIndexes && gIndexes.indexOf(i) < 0)){
                series = this._series[i] || [];
                var order = this._renderSeries(seriesGroup, series, i);
                if(TypeUtils.isNaN(order)){
                    order = 0;
                }
                seriesOrder[order] = seriesOrder[order] || [];
                seriesOrder[order].push(seriesGroup);
            }
        }
        for(var n = 0; n < seriesOrder.length; n++){
            var group = seriesOrder[n];
            if(!group || !group.length){
                continue;
            }
            for(var m = 0; m < group.length; m++){
                parent.appendChild(group[m]);
            }
        }
    };

    SeriesRenderer.prototype.update = function(parent){
        for (var i = 0; i < this._seriesGroup.length; i++) {
            if(this._series[i]){
                this._updateSeries(this._seriesGroup[i], this._series[i], i);
            }
        }
    };

    SeriesRenderer.prototype._updateSeries = function (seriesG, data, seriesIndex){
        if (this._updateFn && data && data.length){
            this._updateFn(seriesG, data, seriesIndex);
        }
    };

    SeriesRenderer.prototype._renderSeries = function(seriesG, data, seriesIndex) {
        if (this._renderFn && data && data.length) {
            return this._renderFn(seriesG, data, seriesIndex);
        }
        return 0;
    };

    return SeriesRenderer;
});
define('sap/viz/chart/components/renderers/LineRenderer',[
    "sap/viz/framework/common/util/SVG"
], function(
    SVG
) {
    var LineRenderGetter = function() {
        var LineRender = function(config) {

            var graphic = config.graphic;

            var path = SVG.create("path");

            path.setAttribute("d", SVG.generatePath(config));
            path.setAttribute("fill", "none");
            path.setAttribute("stroke-linejoin", "round");
            path.setAttribute("stroke", graphic.color);
            path.setAttribute("stroke-width", graphic.width);
            if (graphic.dash){
                path.setAttribute("stroke-dasharray", graphic.dash);
            }
            if(graphic.linecap){
                path.setAttribute("stroke-linecap", graphic.linecap);
            }
            return path;
        };

        LineRender.update = function(node, config) {
            node.setAttribute("d", SVG.generatePath(config));
            if (config.graphic) {
                var graphic = config.graphic;
                if (graphic.color) {
                    node.setAttribute("stroke", graphic.color);
                }
                if (graphic.width) {
                    node.setAttribute("stroke-width", graphic.width);
                }
                if (graphic.dash) {
                    node.setAttribute("stroke-dasharray", graphic.dash);
                } else {
                    node.removeAttribute("stroke-dasharray");
                }
                if(graphic.linecap){
                    node.setAttribute("stroke-linecap", graphic.linecap);
                }else{
                    node.removeAttribute("stroke-linecap");
                }
            }
        };

        LineRender.prepare = function(config) {
            // align with smoothLineRenderer since we pass this to customRenderer
            return config;
        };

        LineRender.expose = {
            renderer: LineRender,
            prepare: LineRender.prepare,
            update: LineRender.update
        };

        return LineRender;
    };

    // Just to keep with SmoothLineRender.
    return LineRenderGetter;
});
define('sap/viz/chart/components/util/BarSeriesUtil',[
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/renderers/LineRenderer',
    'sap/viz/chart/components/util/SeriesUtil'
], function(
    DataGraphics,
    DOM,
    TypeUtils,
    Constants,
    NameColorUtils,
    LineRenderer,
    SeriesUtil
) {

    var defaultStraightLineRender = LineRenderer();

    var convertColor = NameColorUtils.convertColor;

    var CSS_CLASS = Constants.CSS.CLASS;
    
    var LINE_TYPE = Constants.LINE_TYPE; 

    function prepareBarSeriesConfig(config, isHorizontal){
        config.graphic = {
            color: config.color,
            width: 1,
            opacity: 1
        };
        delete config.color;
        config.isHorizontal = isHorizontal;
    }

    function renderBarSeries(lineRender, config, isHide, seriesG) {
        var lineTag = lineRender(config);
        lineTag.setAttribute("class", CSS_CLASS.BAR_SERIES_PATH);
        DataGraphics.setData(lineTag, config.graphic);
        if (isHide) {
            lineTag.setAttribute("display", "none");
        } else {
            lineTag.removeAttribute("display");
        }
        seriesG.insertBefore(lineTag, seriesG.firstChild);
    }

 

    function generateBarSeriesCandidates(data, isHorizontal, semanticMgr, effectMgr) {
        var candidates = [];
        var candidate = {
            points: []
        };
        var dataItem, dpConfig, lastColor, currentColor;
        var length = data.length;
        for (var n = 0; n < length; n++) {
            dataItem = data[n];
            if (!dataItem || !dataItem.position) {
                continue;
            }
            dpConfig = dataItem.dpConfig;

            currentColor = effectMgr.register({
                fillColor: SeriesUtil.parseSemanticColor(dpConfig, semanticMgr)
            });
            if (candidate.points.length !== 0 && lastColor !== currentColor) {
                candidate.color = lastColor;
                candidates.push(candidate);
                candidate = {
                    points: []
                };
            }
            SeriesUtil.addRectSeriesPathPoints(candidate.points, dataItem, !!dpConfig.negative,
                isHorizontal);
            lastColor = currentColor;
        }
        if (candidate.points.length > 0) {
            candidate.color = lastColor;
            candidates.push(candidate);
        }
        return candidates;
    }

    var utils = {

        drawBarSeries: function(seriesG, data, semanticMgr, effectMgr, isHorizontal, isHide) {
            if (semanticMgr.hasDataPointColorStyle()) {
                // In case affecting standard performance case, using different code to judge semantic case.
                var candidates = generateBarSeriesCandidates(data, isHorizontal, semanticMgr, effectMgr);
                candidates.forEach(function(config) {
                    prepareBarSeriesConfig(config, isHorizontal);
                    renderBarSeries(defaultStraightLineRender, config, isHide, seriesG);
                });
            } else {
                var points = [];
                var n, currentOpacity, currentColor, dataItem, dpConfig, graphicConfig;
                var length = data.length;

                for (n = 0; n < length; n++) {
                    dataItem = data[n];
                    if (!dataItem || !dataItem.position) {
                        continue;
                    }
                    dpConfig = dataItem.dpConfig;
                    graphicConfig = dpConfig.graphic;
                    SeriesUtil.addRectSeriesPathPoints(points, dataItem, !!dpConfig.negative, isHorizontal);

                    if (!currentColor) {
                        currentColor = effectMgr.register({
                            fillColor: graphicConfig.fill
                        });
                        currentOpacity = graphicConfig.opacity;
                    }
                }
                var config = {
                    graphic: {
                        color: currentColor,
                        width: 1,
                        opacity: currentOpacity
                    },
                    points: points,
                    isHorizontal: isHorizontal
                };
                renderBarSeries(defaultStraightLineRender, config, isHide, seriesG);
            }
        },
        updateBarSeries: function(seriesG, data, semanticMgr, effectMgr, isHorizontal, isHide) {
            var lineTags = seriesG.querySelectorAll("path." + CSS_CLASS.BAR_SERIES_PATH);
            if (isHide) {
                [].forEach.call(lineTags, function(lineTag) {
                    lineTag.setAttribute("display", "none");
                });
                return;
            }
            var n;
            var length = data.length;
            if (semanticMgr.hasDataPointColorStyle()) {
                // In case affecting standard performance case, using different code to judge semantic case.
                var candidates = generateBarSeriesCandidates(data, isHorizontal, semanticMgr, effectMgr);
                var lineTag;
                candidates.forEach(function(config, i) {
                    prepareBarSeriesConfig(config, isHorizontal);
                    lineTag = lineTags[i];
                    if (lineTag) {
                        defaultStraightLineRender.update(lineTag, config);
                        DataGraphics.setData(lineTag, config.graphic);
                        lineTag.removeAttribute("display");
                    } else {
                        renderBarSeries(defaultStraightLineRender, config, isHide, seriesG);
                    }
                });
                for (n = candidates.length; n < lineTags.length; ++n) {
                    DOM.remove(lineTags[n]);
                }
            } else {
                var dataItem;
                var points = [];
                for (n = 0; n < length; n++) {
                    dataItem = data[n];
                    if (!dataItem || !dataItem.position) {
                        continue;
                    }
                    SeriesUtil.addRectSeriesPathPoints(points, dataItem, !!dataItem.dpConfig.negative,
                        isHorizontal);
                }

                var config = {
                    points: points,
                    isHorizontal: isHorizontal
                };
                defaultStraightLineRender.update(lineTags[0], config);
                lineTags[0].removeAttribute("display");
            }
        }
    };
    return utils;
});

define('sap/viz/chart/components/decorator/Decorator',[],function(){
    var Decorator = function (){
        this._decos = {};
    };

    Decorator.prototype.decorate = function(cls){
        var decos = this._decos;
        for (var key in decos){
            if (decos.hasOwnProperty(key)){
                cls.prototype[key] = decos[key];
            }
        }
    };

    return Decorator;
});
define('sap/viz/chart/components/util/HitTestUtils',[], function() {
    var HitTestUtils = {};

    HitTestUtils.inRange = function(value, min, max) {
        return value >= min && value <= max;
    };

    var inRange = HitTestUtils.inRange;

    HitTestUtils.isInCircle = function(pointOne, pointTwo, radius) {
        var distance = Math.sqrt(
            Math.pow(pointOne[0] - pointTwo[0], 2) +
            Math.pow(pointOne[1] - pointTwo[1], 2)
        );
        return radius >= distance;
    };

    function isInRect(point, startPoint, width, height) {
        return inRange(point[0], startPoint[0], (startPoint[0] + width)) &&
            inRange(point[1], startPoint[1], (startPoint[1] + height));
    }

    HitTestUtils.isInRect = isInRect;

    HitTestUtils.isInRectWithRatio = function(point, startPoint, ratio) {
        var x = startPoint.x;
        var y = startPoint.y;
        var width = Math.ceil(startPoint.width);
        var height = Math.ceil(startPoint.height);
        if (ratio != 1){
            x *= ratio;
            y *= ratio;
            width *= ratio;
            height *= ratio;
        }
        return isInRect([point.left, point.top], [x, y], width, height);
    };

    return HitTestUtils;
});

define('sap/viz/chart/components/decorator/BaseHitTestDecorator',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/decorator/Decorator',
    'sap/viz/chart/components/util/HitTestUtils'
], function(
    oo,
    Decorator,
    HitTestUtils
) {
    var inRange = HitTestUtils.inRange;
    var BaseHitTestDecorator = function() {
        BaseHitTestDecorator.superclass.constructor.apply(this, arguments);
        this._decos.hitTest = function(cord) {
            //empty as interface
        };

        this._decos.hitTestForRangeSelection = function(cord){
            if(!cord.hasOwnProperty("start") && !cord.hasOwnProperty("end")){
                return null;
            }
            
            //in range selection, we treat each dp as a point, no matter its size
            var bound = this._data.valueAxis.scale._domain;
            var bound2 = this._data.valueAxis2 && this._data.valueAxis2.scale._domain;

            var result;
            var datas = this._dataPointContext;
            result = datas.filter(function(e) {
                var timeValue = e.rawData.timeAxis[0].parsedValue || e.rawData.timeAxis[0].value;
                if(!inRange(timeValue, cord["start"], cord["end"])){
                    return false;
                }

                var value;
                if(e.rawData.hasOwnProperty("valueAxis2")){
                    value = e.rawData.valueAxis2;
                    return  inRange(value, bound2[0], bound2[1]);
                }else{
                    value = e.rawData.valueAxis;
                    return  inRange(value, bound[0], bound[1]);

                }
            });
            return result.map(function(e){return (e.dataId).toString();});
        };
    };

    oo.extend(BaseHitTestDecorator, Decorator);
    return BaseHitTestDecorator;
});
define('sap/viz/chart/components/decorator/HitTestRectDecorator',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/chart/components/util/BoundingBoxUtils",
    'sap/viz/chart/components/decorator/BaseHitTestDecorator',
    'sap/viz/chart/components/util/HitTestUtils'
], function(
    oo,
    BoundingBoxUtils,
    BaseHitTestDecorator,
    HitTestUtils
) {
    var isInRectWithRatio = HitTestUtils.isInRectWithRatio;

    var HitTestRectDecorator = function() {
        HitTestRectDecorator.superclass.constructor.apply(this, arguments);
        this._decos.hitTest = function(coord) {
            var datas = this._dataPointContext;
            var result;
            //Calculate a ratio in case user set a css transform especially scale on root chart div
            var plotBound = this._selection.select(".v-plot-bound").node();
            var ratio = plotBound.getBoundingClientRect().width / plotBound.getBBox().width;

            if (coord.hasOwnProperty("width") && coord.hasOwnProperty("height")) {
                var size = this.getSize();
                var offset = this._offset;
                var startXRange = -offset.x;
                var startYRange = -offset.y;
                coord.left = coord.left + startXRange;
                coord.top = coord.top + startYRange;
                var plotWidth = size.width;
                var plotHeight = size.height;
                if (ratio != 1){
                    plotWidth *= ratio;
                    plotHeight *= ratio;
                    // when big data with scroll bar, also need re-calculate startX/Y with ratio
                    startXRange *= ratio;
                    startYRange *= ratio;
                }
                var plotRect = {
                    left: startXRange,
                    top: startYRange,
                    width:plotWidth,
                    height:plotHeight
                };

                if(!BoundingBoxUtils.intersects(plotRect, coord)){
                    //if the selection happen outside the plotarea, do nothing
                    return [];
                }

                //the lassor range only work inside plotarea
                coord = BoundingBoxUtils.intersection(plotRect, coord);

                result = datas.filter(function(e) {
                    var position = e.position;
                    var p = {
                        left: position.x,
                        top: position.y,
                        width: position.width,
                        height: position.height
                    };
                    if (ratio != 1){
                        p.left *= ratio;
                        p.top *= ratio;
                        p.width *= ratio;
                        p.height *= ratio;
                    }
                    return BoundingBoxUtils.intersects(p, plotRect) &&
                        BoundingBoxUtils.intersects(p, coord);
                });
            } else {
                result = datas.filter(function(e) {
                    return isInRectWithRatio(coord, e.position, ratio);
                });
            }
            return result;
        };
    };

    oo.extend(HitTestRectDecorator, BaseHitTestDecorator);

    return HitTestRectDecorator;
});
define('sap/viz/chart/components/accessibility/BaseDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/chart/components/util/SeriesUtil",
    "sap/viz/chart/components/accessibility/ChartComponentNavigator"
], function (oo, ObjectUtils, SeriesUtil, ChartComponentNavigator) {

    function BaseDataPointNavigator(options) {
        BaseDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._dataModel = options.dataModel;
        this._sortedDataPointsByDirection = [];
        this._series = options.series ?
            options.series : (options.dataModel ? options.dataModel.series() : null);
        this._propMgr = options.propertyManager;
        this._isDual = options.isDual;
        this._isPercentage = options.isPercentage;
        this._seriesTypeLookup = [];
        this._isTimeColumn = options.isTimeColumn;
        this._isTimeWaterfall = options.isTimeWaterfall;
        this._isTimeBullet = options.isTimeBullet;
    }

    oo.extend(BaseDataPointNavigator, ChartComponentNavigator);

    var prot = BaseDataPointNavigator.prototype;

    prot.destroy = function () {
        BaseDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._dataModel = null;
        this._sortedDataPointsByDirection = [];
        this._series = null;
        this._propMgr = null;
        this._renderType = null;
        this._isDual = null;
        this._isPercentage = null;
        this._seriesTypeLookup = null;
    };

    prot.locate = function (address) {
        var result = this._series;
        for (var i = address.length - 1; result && i >= 0; --i) {
            result = result[address[i]];
        }
        return result || null;
    };

    prot.address = function (id) {
        return this._dataModel.getDataPoint(id).address();
    };

    prot.getDataPoint = function (id) {
        return this._dataModel ? this._dataModel.getDataPoint(id) : null;
    };

    prot.getColumn = function (columnIndex) {
        return this._dataModel.getDataPoints(columnIndex);
    };

    prot.getRow = function (rowIndex) {
        return this._dataModel.getDataPoints(null, rowIndex);
    };

    prot.getPrevDataPointInSeries = function (id) {
        return this.getDataPoint(id).prev();
    };

    prot.getNextDataPointInSeries = function (id) {
        return this.getDataPoint(id).next();
    };

    prot.getFirstStartPoint = function () {
        if (this._series && this._series.length) {
            //all category should have same number
            var categoryNum = this._series[0].length;
            for (var l = 0; l < this._series.length; l++) {
                if (this._series[l].length > categoryNum) {
                    categoryNum = this._series[l].length;
                }
            }
            for (var i = 0; i < categoryNum; i++) {
                for (var j = 0; j < this._series.length; j++) {
                    if (this._series[j][i]) {
                        return this._series[j][i].dp;
                    }
                }
            }
        } else {
            return null;
        }
    };

    prot.dataPointValueSortInCategory = function (columnIndex) {
        this._sortedDataPointsByDirection[columnIndex] = this.getColumn(columnIndex);
        var that = this;
        this._sortedDataPointsByDirection[columnIndex].sort(function (a, b) {
            var aDp = that.locate(a.address());
            var bDp = that.locate(b.address());
            return aDp.valueAxis - bDp.valueAxis;
        });
    };

    prot._getSeriesType = function (dp) {
        var orignalDp = this.locate(dp.address());

        if (!this._dataShapes) {
            var propKey = "dataShape.primaryAxis";
            var isSecondAxis = orignalDp && !orignalDp.hasOwnProperty("valueAxis");
            if (isSecondAxis) {
                propKey = "dataShape.secondaryAxis";
            }
            this._dataShapes = this._propMgr.get("plotArea." + propKey);

            //last solution
            if (!this._dataShapes) {
                this._dataShapes = isSecondAxis ? ["line", "line", "line"] : ["bar", "line", "line"];
            }
        }
        return SeriesUtil.getSeriesType(orignalDp, this._dataShapes, this._renderType);
    };

    prot._setupSeriesTypeTable = function () {
        if (this._series) {
            for (var i = 0; i < this._series.length; i++) {
                var j = 0;
                while (!this._series[i][j] && j < this._series[i].length) {
                    j++;
                }
                if (this._series[i][j]) {
                    this._seriesTypeLookup[i] = this._getSeriesType(this._series[i][j].dp);
                } else {
                    this._seriesTypeLookup[i] = undefined;
                }
            }
        }
    };

    prot._getMaxCategoryNum = function () {
        var max = 0;
        for (var i = 0; i < this._series.length; i++) {
            if (this._series[i] && this._series[i].length > max) {
                max = this._series[i].length;
            }
        }
        return max;
    };

    prot._getFirstPointBySeries = function (seriesIndex) {
        if (this._series && seriesIndex > -1 && seriesIndex < this._series.length) {
            if (this._series[seriesIndex]) {
                for (var i = 0; i < this._series[seriesIndex].length; i++) {
                    if (this._series[seriesIndex][i]) {
                        return this._series[seriesIndex][i].dp;
                    }
                }
            }
        }
        return null;
    };

    prot._prevSeriesFirstPoint = function (id) {
        var dp = this.getDataPoint(id);
        if (dp) {
            var seriesIndex = dp.address()[1];
            while ((--seriesIndex) > -1 &&
            !(dp = this._getFirstPointBySeries(seriesIndex))) {
            }
        }
        return dp;
    };

    prot._nextSeriesFirstPoint = function (id) {
        var dp = this.getDataPoint(id);
        if (dp) {
            var seriesIndex = dp.address()[1];
            var seriesLen = this._series.length;
            while ((++seriesIndex) < seriesLen &&
            !(dp = this._getFirstPointBySeries(seriesIndex))) {
            }
        }
        return dp;
    };

    prot.leftSeries = function (id) {
        return this._prevSeriesFirstPoint(id);
    };

    prot.rightSeries = function (id) {
        return this._nextSeriesFirstPoint(id);
    };

    prot.upSeries = function (id) {
        return this._prevSeriesFirstPoint(id);
    };

    prot.downSeries = function (id) {
        return this._nextSeriesFirstPoint(id);
    };


    return BaseDataPointNavigator;
});

define('sap/viz/chart/components/accessibility/ColumnDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator"
], function(oo, 
            TypeUtils,
            ArrayUtils, 
            BaseDataPointNavigator) {

    function ColumnDataPointNavigator() {
        ColumnDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._allDataPoints = [];
        this._allDataPointsReverse = []; // Only for timeseries_waterfall
        this._setupDataPointsMap(); 
    }

    oo.extend(ColumnDataPointNavigator, BaseDataPointNavigator);

    var prot = ColumnDataPointNavigator.prototype;

    prot._setupDataPointsMap = function() {
        if (this._series && this._propMgr.get("interaction.enableKeyboard")) {
            this._allDataPoints = [];
            this._allDataPointsReverse = [];
        
            if (!this._isTimeColumn  && !this._isTimeWaterfall) {
                var categoryNum = this._getMaxCategoryNum();
                for (var categoryIndex = 0; categoryIndex < categoryNum; categoryIndex++) {
                    for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
                        var curVal = this._series[seriesIndex][categoryIndex];
                        if (curVal && (curVal.valueAxis != null || curVal.valueAxis2 != null)) {
                            this._allDataPoints.push(curVal.dp);
                        }
                    }
                }
            }else {
                var timeList;
                var dataPoints = this._dataModel.getDataPoints();
                var timeAxis = this._dataModel.timeAxis();
                if (dataPoints.length > 0 && timeAxis) {
                    timeList = timeAxis.rowArray.map(function(item) {return item[0] ? item[0].parsedValue : null;});
                    timeList = timeList.filter(function(item) {return item;});
                    timeList = ArrayUtils.unique(timeList).sort(function(a, b){
                        return a - b;
                    });

                    var rangeIndex = this._dataModel._rangeIndex;
                    var selectByTimeAxisGroup = this._propMgr.get("interaction.selectByTimeAxisGroup");
                    var len = rangeIndex && rangeIndex.length > 0 ? rangeIndex.length + 1 : timeList.length;

                    var timeTable = {};
                    dataPoints.forEach(function(item) {
                        var ctx = item.context();
                        if (item._model &&
                            item._model.timeAxis &&
                            item._model.timeAxis.metaData) {
                            var prop = item._model.timeAxis.metaData[0].id + ".parsedValue";
                            var ts = ctx[prop];
                            if (TypeUtils.isExist(ts)) {
                                timeTable[ts] = timeTable[ts] || [];
                                timeTable[ts].push(item);
                            }
                        }
                    });

                    for (var i = rangeIndex[0] || 0; i < len; i++) {
                        var group = timeTable[timeList[i]];
                        if(group && group.length > 0) {
                            this._allDataPoints = this._allDataPoints.concat(
                                selectByTimeAxisGroup ? group[group.length - 1] : group);
                            this._allDataPointsReverse = this._allDataPointsReverse.concat(
                                selectByTimeAxisGroup ? group[0] : group);
                        }
                    }
                }
            }
        }
    };

    prot.getFirstStartPoint = function() {
        return this._allDataPoints[0];
    };

    prot.destroy = function() {
        ColumnDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._allDataPoints = null;
    };

    prot.left = function(id) {
        return this.getPrevDataPoint(id);
    };

    prot.right = function(id) {
        return this.getNextDataPoint(id);
    };

    prot.up = function(id) {
        return this.getPrevDataPoint(id);
    };

    prot.down = function(id) {
        return this.getNextDataPoint(id);
    };

    prot.getNextDataPoint = function(id) {
        var selectByTimeAxisGroup = this._propMgr.get("interaction.selectByTimeAxisGroup");
        var dp = this.getDataPoint(id);
        var nextDp = null, nextIndex;
        if(selectByTimeAxisGroup) {
            nextIndex = this._allDataPoints.indexOf(dp);
            if(nextIndex === -1) {
                nextIndex = this._allDataPointsReverse.indexOf(dp);
            }
            nextIndex++;
        }else {
            nextIndex = this._allDataPoints.indexOf(dp) + 1;
        }
        if (nextIndex < this._allDataPoints.length) {
            nextDp = this._allDataPoints[nextIndex];
        }
        return nextDp;
    };

    prot.getPrevDataPoint = function(id) {
        var selectByTimeAxisGroup = this._propMgr.get("interaction.selectByTimeAxisGroup");
        var dp = this.getDataPoint(id);
        var prevDp = null, prevIndex;
        if(selectByTimeAxisGroup) {
            prevIndex = this._allDataPointsReverse.indexOf(dp);
            if(prevIndex === -1) {
                prevIndex = this._allDataPoints.indexOf(dp);
            }
            prevIndex--;
        }else {
            prevIndex = this._allDataPoints.indexOf(dp) - 1;
        }
        
        if (prevIndex > -1) {
            if(selectByTimeAxisGroup) {
                prevDp = this._allDataPointsReverse[prevIndex];
            }else {
                prevDp = this._allDataPoints[prevIndex];
            } 
        }
        return prevDp;
    };

    return ColumnDataPointNavigator;
});

define('sap/viz/chart/components/trendline/mixin/columnPlot',[
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/trendline/Trendline",
], function(
    SVG,
    ObjectUtils,
    Trendline
) {

    function pathify(coordinates) {
        var d = "M" + coordinates.pop().join(",");
        // Line requires only two defining points
        d += "L" + coordinates.shift().join(",");
        return d;
    }
    function ColumnPlotTrendLine (){ 
        this._trendlines = null;
    }
    var prot = ColumnPlotTrendLine.prototype;
    prot._getTrendLineContainer = function(trendlineG, container){
        container.appendChild(trendlineG);
    };
    prot.renderTrendlines = function(selection){
        if(!selection) {
            return;
        }
        var dataPointStyleMode = this._properties.get("dataPointStyleMode"),
            dataPointStyle = this._properties.get("dataPointStyle");
        if(dataPointStyle && dataPointStyleMode && dataPointStyleMode === "override"){
            return;
        }
        var seriesId = 0,
            trendlinesCfg = this._trendlineCfg(),
            container = selection.select(".v-plot-main").node(),
            g = container.querySelector(".v-trendline-group"),
            path,
            trendlineStyle;
        this._getTrendLines(this._data); 
        if (!trendlinesCfg || !this._trendlines || trendlinesCfg.length === 0) {
            return null;
        }

        if (g) {
            g.parentNode.removeChild(g);
        }
        g = SVG.create("g");
        g.setAttribute("class", "v-trendline-group");
        this._getTrendLineContainer(g, container);
        for(var index = 0, len =trendlinesCfg.length; index < len ;index++){
            trendlineStyle = trendlinesCfg[index];
            var line = this._trendlines[index];
            if(!trendlineStyle || !line || !line.raw || !line.fx){
                continue;
            }
            var pathValue = this._drawTrendlineForSeries(line, this._swapXY(line));
            if(pathValue){
                path = SVG.create("path");
                path.setAttribute("fill", "none");
                path.setAttribute("d", pathValue);
                Object.keys(trendlineStyle.style).forEach(function(att) {
                    path.setAttribute(att, trendlineStyle.style[att]);
                });
                g.appendChild(path);
            }
        }
        return g;
    };

    // Plot a trendline for a given series using. 
    prot._drawTrendlineForSeries = function(trendline, swapXY) {
        var series = trendline.series,
            seriesId = trendline.seriesId,
            posFns = this._val2PosFns(seriesId, series, swapXY),
            rasterized = this._rasterizeTrendData(trendline, swapXY),
            fx = Trendline.calculate(rasterized.slice(0,trendline.raw.length -trendline.forecast));
        trendline.rasterizedData = rasterized;
        var range = this._getTrendlineRange(trendline, swapXY),
            coordinates = [],
            valPosBound;
        if(this._visibleBound){
            valPosBound = swapXY ? [-1*this._offset.y, this._visibleBound.y]: 
                [-1*this._offset.x, this._visibleBound.x];
        }else{
            valPosBound = swapXY ? [-1*this._offset.y, this._realSize.height] : 
                [-1*this._offset.x, this._realSize.width];
        }
        for (var i = range.start; range.start !== range.end && i <= range.end; i += range.step) {
            var posX = posFns.x(i);
            var posY = posFns.y(fx(i));
            // Clip trendline using computed value against bound
            if(posX <= valPosBound[1] && posX >= valPosBound[0]){
                coordinates.push([posX, posY]);
            }
        }
        if(!coordinates || coordinates.length < 2){
            return null;
        }
        return pathify(!swapXY ? coordinates : coordinates.map(function(pt) {
            return pt.reverse();
        }));
    };

    prot._getTrendlineRange = function(trendline, swapXY) {
        var data = trendline.rasterizedData;
        return {
            start: data[0].x,
            end: data[data.length - 1].x,
            step: 1
        };
    };
    
    prot._swapXY = function() {
        return this.isHorizontal();
    };
    
    prot._val2PosFns= function(seriesId, series, swapXY) {
        var key = Trendline.Utils.seriesAxisId(series),
            valueScale = this._xHandlers.concat(this._yHandlers).filter(function(s) {
                return s.id === key;
            })[0],
            w = this._realSize.width,
            h = this._realSize.height;
        return {
            x: function(val) {
                return val;
            },
            y: swapXY ? function(val) {
                var percentage = valueScale._scale.scale(val);
                return percentage * w;
            } : function(val) {
                var percentage = valueScale._scale.scale(val);
                return (1 - percentage) * h;
            }
        };
    };

    prot._rasterizeTrendData = function(trendline, swapXY) {
        var categorySize = swapXY ? this._realSize.height : this._realSize.width,
            scale = (swapXY ? this._yHandlers[0] : this._xHandlers[0])._scaleByIndex;
        var oriLen = trendline.raw.length - trendline.forecast;
        var scaleStep;
        return trendline.raw.map(function(d, i) {
            if(i < oriLen){
                var pos = scale[d.x - 1];
                return {
                    x: categorySize * (pos[0] + (pos[1] - pos[0]) / 2),
                    y: d.y
                };
            } else {
                var forecastStart = scale[scale.length - trendline.forecast] || forecastStart;
                scaleStep = scaleStep ? scaleStep : (forecastStart[1]- forecastStart[0]);
                return {
                    x: categorySize * ((trendline.forecast - 1 + 1/2) * scaleStep + forecastStart[0]),
                    y: d.y
                };
            }
        }, this);
    };
    prot._getTrendLines = function(data){
        var dataPointStyleMode = this._properties.get("dataPointStyleMode"),
            dataPointStyle = this._properties.get("dataPointStyle");
        if(dataPointStyle && dataPointStyleMode&& dataPointStyleMode === "override"){
            return;
        }
        if(!this._trendlines){
            var props = this._properties.get("trendLine"),
                dataPoint = this._properties.get("dataPoint"),
                timeLevel = this.runtime().statusManager().get('timeLevels');
            this._trendlines = Trendline.Parser.basic(props, data, dataPoint, timeLevel);
        }
    };

    prot._trendlineValueDomain = function(data) {
        var domains = {
            valueAxis: [],
            valueAxis2: []
        };
        this._getTrendLines(data);
        if(!this._trendlines){
            return [];
        }
        domains = this._trendlines.reduce(function(domains, tl) {
            if(!tl || !tl.raw || !tl.fx){
                return domains;
            }
            var series = tl.series,
                key = Trendline.Utils.seriesAxisId(series),
                dom = Trendline.domainPerTrendline(tl.fx, tl.raw),
                aggregate = domains[key].concat(dom);
            domains[key] = [Math.min.apply(null, aggregate), Math.max.apply(null, aggregate)];
            return domains;
        }, domains);

        if (domains.valueAxis.length === 0) {
            delete domains.valueAxis;
        }
        if (domains.valueAxis2.length === 0) {
            delete domains.valueAxis2;
        }

        return domains;
    };

    prot._trendlineCfg = function() {
        var data = this._data,
            props = this._properties.get("trendLine"),
            seriesStyle = this._properties.get("seriesStyle");
        return Trendline.Parser.color(props, data, seriesStyle, this._effectManager);
    };

    prot._expandTrendlineXRange = function(dimension){
        Trendline.expandCategoryDomain(dimension, this._trendlines, this.runtime().statusManager());
    };

    prot.zoom = function(selection) {
        this.renderTrendlines(this._selection);
    };
    
    prot.render = function(selection) {
        this.renderTrendlines(selection);
    };

    function after(theirs, ours) {
        return function() {
            var result = theirs.apply(this, arguments);
            ours.apply(this, arguments);
            return result;
        };
    }
    
    prot.inject = function(receiver, resolveStrategy){
        resolveStrategy = resolveStrategy || this.defaultResolveStrategy;
        for(var prop in this){
            if(receiver[prop] && this.defaultResolveStrategy[prop]){
                var resolve = resolveStrategy[prop];
                if (!resolve) {
                    throw new Error("Mixin conflict: no resolve strategy");
                }
                var resolved = resolve(receiver[prop], this[prop]);
                if (!resolved) {
                    throw new Error("Mixin conflict: strategy not able to resolve it");
                }
                receiver[prop] = resolved;
            }else {
                receiver[prop] = this[prop];
            }
        }

    };
    prot.defaultResolveStrategy = {
        zoom: after,
        render: after
    };
    return ColumnPlotTrendLine;
});

define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForBar',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/ChartTypeUtils",
    'sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/behavior/config/ContextualDataUtil',
    "sap/viz/framework/interaction/BehaviorManager"
], function(
    Constants,
    TypeUtils,
    HighlightHelper,
    DataGraphics,
    ChartTypeUtils,
    DPBhvrHdlr,
    ObjectUtils,
    DataPointUtils,
    ContextualDataUtil,
    BehaviorManager
) {
    var barTypeSupportBigData = [
        "info/bar", "info/column",
        "info/dual_bar", "info/dual_column",
        "info/timeseries_column", "info/timeseries_stacked_column",
        "info/timeseries_100_stacked_column", "info/timeseries_waterfall"
    ];

    var timeCombTypes = ["info/timeseries_combination",
                         "info/dual_timeseries_combination", "info/timeseries_stacked_combination"];

    var barTypeSupportBigDataWithTimeComb = barTypeSupportBigData.concat(timeCombTypes);

    //the types without time combination
    var barType2 = [
        "info/stacked_bar", "info/stacked_column",
        "info/dual_stacked_bar", "info/dual_stacked_column",
        "info/100_stacked_bar", "info/100_stacked_column",
        "info/100_dual_stacked_bar", "info/100_dual_stacked_column",
        "info/mekko", "info/horizontal_mekko",
        "info/100_mekko", "info/100_horizontal_mekko",
        "info/waterfall", "info/horizontal_waterfall",
        "info/stacked_waterfall", "info/horizontal_stacked_waterfall",
        "info/heatmap"
    ].concat(barTypeSupportBigData);
    barType2 = ChartTypeUtils.addTrellisType(barType2);

    var barType = barType2.concat(timeCombTypes);

    barType = ChartTypeUtils.addTrellisType(barType);
    barTypeSupportBigData = ChartTypeUtils.addTrellisType(barTypeSupportBigData);
    var CSS_CLASS = Constants.CSS.CLASS;

    var DP_LAYER = "datapoint";
    var DL_LAYER = "dataline";

    var timeColumnType = ["info/timeseries_column", "info/timeseries_stacked_column",
        "info/timeseries_100_stacked_column", "info/timeseries_waterfall"];

    var bar = [{
        "id": "selectDataPoint_bar",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes":barType2,
        },
        "handler": function(event, service) {
            if (service.isBigDataMode() ) {
                DPBhvrHdlr.selectOnBarDuringBigData(event, service);
            } else {
                DPBhvrHdlr.selectOnBarOnNormalMode(event, service);
            }
        }
    }, {
        "id": "deselectDataPoint_bar",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": barType2
        },
        "handler": function(event, service) {
            if (service.isBigDataMode()) {
                return;
            }
            service.fireEvent(event, true);
            var props = service.getProperties();
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            var isMarkerRendererExist = TypeUtils.isExist(props.get('plotArea.markerRenderer'));
            elements.forEach(function(e) {
                var width = 1;
                if(event.data.isAnyOtherSelected) {
                    prop = props.get('interaction.deselected');
                }else{
                    prop = props.get('plotArea.dataPoint');
                    width = DataGraphics.getData(e).strokeWidth;
                }
                HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, width);
                HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
            });
        }
    }, {
        "id": "hoverOnDataPoint_bar",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": barType2
        },
        "handler": function(event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                DPBhvrHdlr.highlightOnBarDuringBigData(event, service);
            }
            else {
                DPBhvrHdlr.hoverEffectDuringNormalMode(event, service);
            }
        }
    }, {
        "id": "unhoverOnDataPoint_bar",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": barType2
        },
        "handler": function (event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                DPBhvrHdlr.unhighlightOnBarDuringBigData(event, service);
            } else {
                DPBhvrHdlr.unhoverEffectDuringNormalMode(event, service);
            }
        }
    },{
        "id": "clearPlot_bar",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": barType2
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            service._getDecorationLayer().clear();
            var gray = event.data.isGray;
            var rangeSelection = event.data.rangeSelection;
            var bUseRange = rangeSelection && rangeSelection !== "clear";
            var props = service.getProperties();
            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if (mainNode == null || mainNode.length === 0) {
                DPBhvrHdlr.cleanBar(event, service);
                return;
            }
            var prop;
            var isMarkerRendererExist = TypeUtils.isExist(props.get('plotArea.markerRenderer'));
            mainNode.forEach(function(e) {
                var width = 1;
                if(gray || bUseRange) {
                    prop = props.get('interaction.deselected');
                    if (bUseRange) {
                        prop = ObjectUtils.extend(true, {}, prop);
                        prop.opacity = 1;
                    }
                }else{
                    prop = props.get('plotArea.dataPoint');
                    width = DataGraphics.getData(e).strokeWidth;
                }
                var extraData = DataGraphics.getData(e);
                HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 
                    TypeUtils.isExist(width) ? width : 1, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
            });
        }
    }, {
        "id": "clearPlot_timeseries_column",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": timeColumnType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            if (!event.data.rangeSelection) {
                service._getDecorationLayer().clear();
                service._getActionLayer().clear();
            }
        }
    }, {
        "id": "hover_on_plot_bar",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": barTypeSupportBigData,
            "targets": "v-m-plot"
        },
        "handler": function(event, service){
            DPBhvrHdlr.hoverOnBarDuringBigData(event, service);
        }
    }, {
        "id": "hover_on_non_plot_bar",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": barTypeSupportBigDataWithTimeComb,
            "excludeTargets": "v-m-plot"
        },
        "handler": function(event, service) {
            if (!service.isBigDataMode()) {
                return;
            }
            service.setStatus("hoveringOnPlotEvent", null);
            var actionLayer = service._getActionLayer();
            actionLayer.clear(DP_LAYER);
            service._getDecorationLayer().clear(DP_LAYER);

            service.fireEvent("hideTooltipHoverOnPlot", {
                mode: "infoMode"
            });
        }
    },{
        "id": "hover_range_selection_bar",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeColumnType,
            "targets": "v-m-action-layerrange"
        },
        "handler": function(event, service) {
            DPBhvrHdlr.showDetailForRangeSelectionWhenHover(event, service);
        }
    }, {
        "id": "click_on_time_comb_during_big_data",
        "triggerEvent": {
            "name": "click",
            "supportedChartTypes": timeCombTypes,
            "excludeTargets": HighlightHelper.getDeselAllExTargets(),
        },
        "handler": function(event, service){
            DPBhvrHdlr.clickOnCombDuringBigData(event, service);
        }
    }, {
        "id": "hover_on_plot_time_during_big_data",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeCombTypes,
            "targets": "v-m-plot"
        },
        "handler": function(event, service){
            if (service.getStatus("rangeSelection")) {
                return;
            }
            DPBhvrHdlr.hoverOnCombDuringBigData(event, service);
        }
    }, {
        "id": "click_on_non_selection_bar",
        "triggerEvent": {
            "name": "click",
            "supportedChartTypes": barType,//barTypeSupportBigData,
            "excludeTargets": HighlightHelper.getDeselAllExTargets(),
        },
        "handler": function(event, service){
            // For time combination chart in big data mode, we process in "click_on_time_comb_during_big_data" already
            if (service.isBigDataMode() && timeCombTypes.indexOf(service._getChartType()) > -1 ) {
                return;
            }

            if(!service.getProperties().get("interaction.enableDeselectAll")){
                return;
            }

            if(barTypeSupportBigDataWithTimeComb.indexOf(service._getChartType()) > -1){
                DPBhvrHdlr.clickOnBarDuringBigData(event, service);
            }else{
                service.fireEvent(event, true);
            }
        }
    }, {
        "id": "update_range_selection_effect_bar",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "down",
            "supportedChartTypes": timeColumnType
        },
        "handler": function(event, service) {
            DPBhvrHdlr.updateRangeEffect(event, service);
        }
    }, {
        "id": "recover_range_selection_effect_bar",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "up",
            "supportedChartTypes": timeColumnType
        },
        "handler": function(event, service) {
            DPBhvrHdlr.recoverRangeEffect(event, service);
        }
    }];
    BehaviorManager.registerAll(bar);
    return bar;

});

define('sap/viz/chart/components/plots/ColumnPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/plots/BaseColumnPlot',
    'sap/viz/chart/components/datalabels/ColumnDataLabels',
    'sap/viz/chart/components/datalabels/BarDataLabels',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/framework/chartmodel/ContextBuilder',
    "sap/viz/framework/common/util/NameColorUtils",
    'sap/viz/chart/components/util/BarSeriesUtil',
    'sap/viz/chart/components/decorator/HitTestRectDecorator',
    'sap/viz/chart/components/plots/XYPlotFactory',
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/ColumnDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    'sap/viz/chart/components/trendline/mixin/columnPlot',
    "sap/viz/chart/behavior/config/DataPointBehaviorConfigForBar"
], function (
    oo,
    Constants,
    ObjectUtils,
    DataGraphics,
    TypeUtils,
    DataUtils,
    BaseColumnPlot,
    ColumnDataLabels,
    BarDataLabels,
    SeriesRenderer,
    ContextBuilder,
    NameColorUtils,
    SeriesUtil,
    HitTestDecorator,
    XYPlotFactory,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants,
    ColumnPlotTrendLine
) {
    var CSSCLASS = Constants.CSS.CLASS;

    /**
     * To initialize ColumnPlot object.
     *
     * @name ColumnPlot
     * @constructor
     */
    var ColumnPlot = function (runtime, options) {
        ColumnPlot.superclass.constructor.apply(this, arguments);
        this._drawZeroLineBeforeDatapoints = false;
        this._dataPointContext = [];
        this._idMap = {};//it's a map from data id to drawing sequence order(data point id).
        this._semanticMgr.setUseSemanticPattern(true);
    };

    oo.extend(ColumnPlot, BaseColumnPlot);

    ColumnPlot.prototype._getDataLabels = function (name, runtime) {
        if (this.isHorizontal()) {
            return new BarDataLabels(runtime, {
                name: name
            });
        } else {
            return new ColumnDataLabels(runtime, {
                name: name
            });
        }
    };

    ColumnPlot.prototype.destroy = function () {
        ColumnPlot.superclass.destroy.call(this);
        this._drawZeroLineBeforeDatapoints = null;
    };

    ColumnPlot.prototype.mappingDataPointInfo = function(id) {
        var dpInfo = this._dataPointContext[id];
        
        return dpInfo;
    };
    ColumnPlot.prototype._attachColorData = function (dp, data, onlyOneMndIndex, dpConfig) {
        if (this.isHorizontal() && this._properties.get("dataLabel.visible")) {
            var exData = DataGraphics.getData(dp);
            if (!exData) {
                exData = {};
            }

            if (dpConfig && dpConfig.displayName !== undefined ) {
                exData.colorLegendData = [];
                exData.colorLegendData.push(dpConfig.displayName);
            } else {

                if (data.color || data.color2) {
                    exData.colorLegendData = ObjectUtils.clone(data.color || data.color2);

                    var get = function (model, field) {
                        return TypeUtils.isFunction(model[field]) ? model[field]() : model[field];
                    };

                    var mateDataFlag = "color";
                    if (data.color2) {
                        mateDataFlag = "color2";
                    }
                    var colorMetaData = get(this._data, mateDataFlag).metaData;

                    //we need to change id to name                
                    var fakeColorDomain = [];
                    fakeColorDomain.push(ObjectUtils.clone(exData.colorLegendData));
                    var domainNamesArray = DataUtils.getDomainArray(fakeColorDomain, colorMetaData);
                    if (domainNamesArray.length > 0 && domainNamesArray && domainNamesArray[0]) {
                        exData.colorLegendData = domainNamesArray[0];
                    }

                    if (onlyOneMndIndex >= 0) {
                        if (exData.colorLegendData.length > 1) {
                            exData.colorLegendData.splice(onlyOneMndIndex, 1);
                        }
                    }

                    //we need to change obj in colorLegendData to string
                    if (exData.colorLegendData) {
                        var displayTextsConverter = DataUtils.getDisplayTextsConverter(colorMetaData);
                        exData.colorLegendData = displayTextsConverter(exData.colorLegendData);
                    }
                }
            }

            DataGraphics.setData(dp, exData);
        }
    };

    ColumnPlot.prototype.isBigDataMode = function() {
        var dpCount = this._getDpCount();
        var allowBigData = this._properties.get('dataPoint.savingMode');
        var chartSize = this.isHorizontal() ? this._realSize.height: this._realSize.width;
        return allowBigData && dpCount > 0 && (chartSize / dpCount) < 1;
    };

    ColumnPlot.prototype._preShowDataPoints = function(parent) {
        var semanticMgr = this.runtime().semanticManager();
        this._isBigData = this.isBigDataMode();
        if (this._isBigData){
            var seriesIter = this.createSeriesIterator(this._series.length);
            while (seriesIter.hasNext()) {
                var seriesIndex = seriesIter.next();
                var seriesModel = this._series[seriesIndex];
                if (!seriesModel) {
                    continue;
                }
                var dataPoints = seriesModel.getDataPoints();
                this._hideDataPoints(dataPoints);
            }
        }
        return ColumnPlot.superclass._preShowDataPoints.apply(this, arguments);
    };
    
    ColumnPlot.prototype._getDpCount = function(){
        var series = this._getSeries();
        var dpCount = 0;
        series.forEach(function(e) {
            dpCount += e.length;
        });
        return dpCount;
    };

    ColumnPlot.prototype._applyScroll = function() {

        ColumnPlot.superclass._applyScroll.apply(this, arguments);
        this.renderTrendlines(this._selection);

    };
    

    ColumnPlot.prototype._updateDatapoints = function(parent) {
        this._resetDataPoints();
        var dataPointG = parent.select("." + Constants.CSS.CLASS.DATAPOINT_GROUP).node();
        var dataPoints = this._showDataPoints(dataPointG);
        this._dataLabels.updatePosition(parent, dataPoints);
    };

    ColumnPlot.prototype._showDataPoints = function(dataPointG) {
        this._preShowDataPoints();
        var newDataPoints = [];
        this._dataPointContext = [];
        var effectMgr = this.runtime().effectManager();
        if(this._seriesRenderer){
            this._seriesRenderer.resetDataPoints();
        }

        var needLazyRender = this._needLazyRender();
        var seriesIter = this.createSeriesIterator(this._series.length);
        var options = {
            color: null,
            drawingEffect: this._properties.get('drawingEffect')
        };

           // The default invalidity value is 'break'
        var allowBreakLine = Constants.DATAPOINT_INVALIDITY_SUPPORTED.indexOf(
                this._properties.get('dataPoint.invalidity')) <= 0;
        var range = this._getVisibleRange();
        while (seriesIter.hasNext()) {
        //each series 
            var seriesIndex = seriesIter.next();
            var seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }
            //choose the render based on the series. so will allow to draw line or column, etc
            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
            var dataPoints = seriesModel.getDataPoints();
            var curRange = this._getDataPointRange(dataPoints, range);
            if(needLazyRender){

                this._hideDataPoints(dataPoints, curRange);
            }
            var color = null;

            var isLine = this._getDataShape && this._getDataShape(seriesIndex) === "line";
            var isBar = this._getDataShape && this._getDataShape(seriesIndex) === "bar";
            var seriesStyle = this.getSeriesDPStyle(seriesIndex);

            //each data point
            for (var itemIndex = curRange.min; itemIndex <= curRange.max; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }

                var position = this._getDataPointPosition(dataPointModel);
                if (!position) {
                    continue;
                }
                var data = dataPointModel.getRawData();
                if(isBar && data && 
                    (!data.hasOwnProperty("valueAxis") || !TypeUtils.isExist(data.valueAxis) )){
                    continue;
                }

                var itemChanged = false;
                var currentId = dataPointModel.getId();
                var dpNode = null;
                var dpConfig = dataPointModel.getConfig();

                if(allowBreakLine && data.dp.ignore && isLine){
                    // Insert a null position for series renderer to break the line
                    position = null;
                    //Even data point is ignored, still need carry on its color to series util for line renderer
                    if (!dpConfig) {
                        dpConfig = {
                            graphic: {
                                fill: color,
                            }
                        };
                    }
                }else{
                    if(!dpConfig){
                        if (!color) {
                            color = this._getColor(data);
                        }
                        options.color = color;
                        options.seriesStyle = seriesStyle;
                        itemChanged = true;
                        dpConfig = this._buildWrapperConfig(data, position, null, options);

                        dpConfig.seriesIndex = seriesIndex;
                        dpConfig.seqId = currentId;
                        dpConfig.position = position;
                        if (dpConfig.graphic.pattern === "noFill") {
                            dpConfig.path = this._generatePath(dpConfig.graphic);
                            dpConfig.graphic.pathStrokeWidth = this._pathStrokeWidth(dpConfig.ctx);
                        }
                    }
                    this._dataPointContext[data.dp.id] = dpConfig;

                    //set up each dpNode and data Point
                    this._idMap[data.dp.id] = currentId;

                    //decide if draw the dataPoint
                    if(!this._isBigData) {
                        var dpData = dataPointModel.getData();
                        if(!dpData){
                            itemChanged = true;


                            dpData = this._buildData(dpConfig);
                            dataPointModel.init(dpConfig, currentId, dpData,
                                data.dp && data.dp.id ? data.dp.id : Constants.NULL_VALUE);
                        }

                        dpNode = dataPointModel.getNode();
                        if(dpNode){
                            if(itemChanged){
                                if (dpConfig.graphic.pattern === "noFill") {
                                    dpConfig.path = this._generatePath(dpConfig.graphic);
                                    dpConfig.graphic.pathStrokeWidth = this._pathStrokeWidth(dpConfig.ctx);
                                }
                                this._updateDatapoint(dpNode, dpRenderer, dpConfig, position);
                                newDataPoints.push(dpNode);
                            }
                        } else {
                            dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                            dataPointModel.setNode(dpNode);
                            if (dpNode) {
                                newDataPoints.push(dpNode);
                            }
                        }
                    }
                        
                    this._updateStrokeWidth(dpNode);
                   
                    //add to the render, will be rendered later
                    if (this._seriesRenderer) {
                        this._seriesRenderer.addDataPoint(seriesIndex, itemIndex, dpConfig, position, dpNode);
                    } else if(!dpNode.parentNode){
                        dataPointG.appendChild(dpNode);
                    }
                }
            }
        }
        return newDataPoints;
    };

    function getValue(rawData){
        if (rawData.valueAxis != null){
            return rawData.valueAxis;
        } else if (rawData.valueAxis2){
            return rawData.valueAxis2;
        } else {
            return 0;
        }
    }

    ColumnPlot.prototype._buildWrapperConfig = function(data, position, context, options) {
        var ctx;
        if (this._isBigData && context == null) {
            var transparent = data.transparent || 0;
            var w = position.width;
            var h = position.height;
            var c = NameColorUtils.convertColor(options.color);
            var result =  {
                graphic: {
                    width: w,
                    height: h,
                    drawingEffect: this._drawingEffect || options.drawingEffect ||
                        this._properties.get('drawingEffect'),
                    fill: (options && options.seriesStyle && options.seriesStyle.color) ? 
                        NameColorUtils.convertColor(options.seriesStyle.color) : c,
                    opacity: 1 - transparent
                },
                data: {
                    color: c,
                    width: w,
                    height: h,
                    translate: [position.x, position.y]
                },
                effectManager: this._effectManager,
                rawData: data,
                negative: getValue(data) < 0,
                horizontal : this.isHorizontal(),
                dataId: data.dp.id
            };
            //generare context is expensive, and is only used by combination chart
            if(this._isCombination){
                ctx = data.dp && data.dp.context() ? data.dp.context() : Constants.NULL_VALUE;
                result.ctx = ctx;
            }
            return result;
        } else {
            ctx = data.dp && data.dp.context() ? data.dp.context() : Constants.NULL_VALUE;
            var config =
                ColumnPlot.superclass._buildWrapperConfig.call(this, data, position, ctx, options);
            return config;
        }
    };

    ColumnPlot.prototype._drawDataPoint = function (dpRenderer, dataPoint) {
        var dp = ColumnPlot.superclass._drawDataPoint.apply(this, arguments);
        //add color legend data to datapoint
        this._attachColorData(dp, dataPoint.getRawData(), dataPoint.getOnlyOneMndIndex(), dataPoint.getConfig());

        return dp;
    };

    ColumnPlot.prototype._getSeriesRenderer = function() {
        //column chart will draw column as a path not matter what. This is the key to the saving mode
        return new SeriesRenderer(this._drawBarSeries.bind(this), this._updateBarSeries.bind(this));
    };

    ColumnPlot.prototype._drawBarSeries = function(seriesG, data, seriesIndex) {
        SeriesUtil.drawBarSeries(seriesG, data, this._semanticMgr, 
            this._effectManager, this.isHorizontal(), !this._isBigData);
    };

    ColumnPlot.prototype._updateBarSeries = function(seriesG, data, seriesIndex) {
        SeriesUtil.updateBarSeries(seriesG, data, this._semanticMgr, 
            this._effectManager, this.isHorizontal(), !this._isBigData);
    };

    (new HitTestDecorator()).decorate(ColumnPlot);
    
    XYPlotFactory.registerClazz("column", ColumnPlot);
    XYPlotFactory.registerClazz("bar", ColumnPlot);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.COLUMN, DataPointNavigator);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.WATERFALL, DataPointNavigator);
    
    (new ColumnPlotTrendLine()).inject(ColumnPlot.prototype);
    return ColumnPlot;
});

define('sap/viz/chart/components/datalabels/StackedDataLabels',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/GeometryUtils',
    'sap/viz/chart/components/util/ColorUtil',
    'sap/viz/framework/common/util/NumberUtils'
], function(
    oo,
    DOM,
    DataGraphics,
    DataLabels,
    Constants,
    TypeUtils,
    SVG,
    DataPointUtils,
    GeometryUtils,
    ColorUtil,
    NumberUtils
    ) {
    var StackedDataLabels = function (ctx, options) {
        this._isFlexibleStack = options.isFlexibleStack;
        StackedDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = "inside";
        this._totalLabels = [];
        this._stackIndexs = [];
        this._plotSelection = null;
        this._gridlineScale = null;
    };
    
    var DATA_LABEL_CLASS = Constants.CSS.CLASS.DATALABEL + " " + Constants.CSS.CLASS.MORPHABLELABEL,
    DATA_LABELS_GROUP_CLASS = Constants.CSS.CLASS.DATALABEL_GROUP_TOTAL,
    DATA_LABELS_GROUP_TAG = "g";

    oo.extend(StackedDataLabels, DataLabels);
    
    function defaultRenderer(config) {
        var text = config.gNode.querySelector("text");
        if (!text){
            text = SVG.create("text");
            config.gNode.appendChild(text);
        }
        text.textContent = config.text;
        return text;
    }

    defaultRenderer.expose = {
        renderer: defaultRenderer
    };

    StackedDataLabels.prototype.setTrellisCell = function (cellPadding, cellSize) {
        StackedDataLabels.superclass.setTrellisCell.apply(this, arguments);
        //trellis is not flexible
        this._isFlexibleStack = false;
    };

    StackedDataLabels.prototype.setSeriesSettings = function (seriesGroups, seriesType) {
        if (this._isFlexibleStack) {
            //flexible stack 
            this._seriesGroups = seriesGroups.reduce(function (srToGrp, srGrp) {
                srGrp.series.forEach(function (srIdx) {
                    srToGrp[srIdx] = srGrp;
                });
                return srToGrp;
            }, []);
            this._seriesType = seriesType;
        }
    };
    
    StackedDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition,
            labelBBox, config, node) {
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;
        var positionResult = [];

        if (labelPosition === "up" || labelPosition === "down" ||
            labelPosition === "inside") {
            positionResult[0] = (nodeX + shapeBBox.width / 2) -
                (labelBBox.x + labelBBox.width / 2);
            if (labelPosition !== "inside") {
                positionResult[1] = nodeY - (labelBBox.y + labelBBox.height) - 
                    Constants.DATALABEL.VERTICAL_TOTAL_LABEL_PADDING ;
                if ((config.val === 0 && (positionResult[1] + labelBBox.y < 0)) || 
                    (labelPosition === "down")) {
                    positionResult[1] = nodeY - labelBBox.y + shapeBBox.height + 
                        Constants.DATALABEL.VERTICAL_TOTAL_LABEL_PADDING;
                }
            }
        }

        if (labelPosition === "left" || labelPosition === "right" ||
            labelPosition === "inside") {
            positionResult[1] = (nodeY + shapeBBox.height / 2) -
                (labelBBox.y + labelBBox.height / 2);
            if (labelPosition !== "inside") {
                positionResult[0] = nodeX - labelBBox.x + shapeBBox.width + 
                    Constants.DATALABEL.HORIZONTAL_TOTAL_LABEL_PADDING;
                if ((positionResult[0] > this._size.width && config.val === 0) || 
                    (labelPosition === "left")) {
                    positionResult[0] = nodeX - (labelBBox.x + labelBBox.width) - 
                        Constants.DATALABEL.HORIZONTAL_TOTAL_LABEL_PADDING;
                }
            }
        }

        

        if(this._options.allowMicroAdjust && config.zeroLineAdjust){
            var zeroLinePosition =  this._gridlineScale.scale(0);
            var y = positionResult[1];
            var height = labelBBox.height;
            var top = y - height;
            var val = config.val;
            if(TypeUtils.isNumber(zeroLinePosition) && 
                    top < zeroLinePosition && y > zeroLinePosition){  //cut off by zero line
                if(val >= 0){
                    positionResult[1] = zeroLinePosition ;
                }else{
                    positionResult[1] = zeroLinePosition + height;
                }
            }
        }

        return positionResult;
    };
    
    StackedDataLabels.prototype._getCategorySum = function (stack) {
        var range;
        if (this._isFlexibleStack) {
            //for flexible stack, we build the range because flexible stack is a array. 
            range = [0, 0];
            for (var i = 0; i < stack.length; i++) {
                var ctx = DataGraphics.getContext(stack[i]);
                var value = +ctx[ctx.measureNames];
                if (value >= 0) {
                    range[1] += value;
                } else {
                    range[0] += value;
                }
            }
        } else {
            range = DataGraphics.getData(stack).range;
        }
        return range;
    };
    
    StackedDataLabels.prototype.updatePosition = function(selection, dataPoints) {
        var parentNodeDOM = selection.node();
        this._allStacksNodes = parentNodeDOM.querySelectorAll("." + Constants.CSS.CLASS.STACK);
        // When updating position, data-id for stacked total will always changed, so we delete all 
        // stacked node and redraw
        this._renderStackTotal(selection, this._allStacksNodes);
        
        StackedDataLabels.superclass.updatePosition.apply(this, arguments);
    };
    
    StackedDataLabels.prototype.render = function(selection, dataPoints) {
        this._removeExtraNodes(selection);
        this._plotSelection = selection;
        dataPoints =  dataPoints || DataPointUtils.findAll(this._dataShapesGroupNode) || [];
        var filteredDataPoints = this._beforeRender(dataPoints);
        this._render(selection, filteredDataPoints);
        if (this._isFlexibleStack) {
            this._allStacksNodes = this.getAllFlexibleStacks(dataPoints);
        } else {
            this._allStacksNodes = selection.node().querySelectorAll("." + Constants.CSS.CLASS.STACK);
        }
        this._renderStackTotal(selection, this._allStacksNodes);
        this._afterRender(selection);
      
    }; 

    var getFlexibleStackRefNode = function (stackItems, labelIdx) {
        //the function gets the "first" or "last" node for flexible stack
        var refNode = stackItems[0];
        var refIndex = Infinity;
        for (var i = 0; i < stackItems.length; i++) {
            var ctx = DataGraphics.getContext(stackItems[i]);
            var value = ctx[ctx.measureNames];
            var nodeData = DataGraphics.getData(stackItems[i]);
            if ( ((labelIdx > 0 && value < 0) || (labelIdx <= 0 && value >= 0)) &&
                nodeData.seriesIndex < refIndex) {
                refIndex = nodeData.seriesIndex;
                refNode = stackItems[i];
            }
        }
        return refNode;
    };

    StackedDataLabels.prototype.getAllFlexibleStacks = function (dataPoints) {
        if (!(dataPoints && dataPoints.length)) {
            dataPoints = DataPointUtils.findAll(this._dataShapesGroupNode) || [];
        }
        var allStacksMap = [];
        var allStacksArray = [];
        for (var i = 0; i < dataPoints.length; i++) {
            var flexibleStackId = DataGraphics.getData(dataPoints[i]).flexibleStackId;
            if (flexibleStackId) {
                if (!allStacksMap[flexibleStackId]) {
                    allStacksMap[flexibleStackId] = [];
                    allStacksArray.push(allStacksMap[flexibleStackId]);
                }
                allStacksMap[flexibleStackId].push(dataPoints[i]);
            }
        }
        return allStacksArray;
    };
  

    StackedDataLabels.prototype._renderStackTotal = function(selection, stacks) {
        var parentNodeDOM = selection.node();
        var props = this._properties;

        var showTotalLabel = props.get('showTotal');
        this._totalLabels = [];
        this._stackIndexs = [];

        var dynamicScale = this._runtime.statusManager().get("dynamicScale");
        
        if (showTotalLabel) {
            var len, i;
            var dataLabelsGroup = parentNodeDOM.querySelector("." + DATA_LABELS_GROUP_CLASS);
            if(!dataLabelsGroup){
                dataLabelsGroup = SVG.create(DATA_LABELS_GROUP_TAG, parentNodeDOM);
                dataLabelsGroup.setAttribute("class", DATA_LABELS_GROUP_CLASS);    
                var textAnchor = null;
                var envManager = this.runtime().envManager();
                if (envManager) {
                    textAnchor = envManager.textAnchor();
                }
                dataLabelsGroup.setAttribute("text-anchor", textAnchor);  
                var dataLabelStyle = this._getStyle();
                for (var j in dataLabelStyle) {
                    if (dataLabelStyle.hasOwnProperty(j)) {
                        dataLabelsGroup.setAttribute(j, dataLabelStyle[j]);
                    }
                }
            }else{
                var stackNodes = dataLabelsGroup.querySelectorAll("." + Constants.CSS.CLASS.DATALABEL);
                len = stackNodes.length;
                while(len){
                    dataLabelsGroup.removeChild(stackNodes[len - 1]);
                    --len;
                }
            }


            
            var labelRenderer = props.get('renderer') || defaultRenderer;
          
            
            var formatPatterns = props.get('formatString');
            
            for (i = 0, len = stacks.length; i < len; i++) {
                var stack = stacks[i];
                var dps;
                if (this._isFlexibleStack) {
                    dps = stack;
                } else {
                    dps = stack.querySelectorAll("." + Constants.CSS.CLASS.DATAPOINT);
                }
                var dp = dps[dps.length - 1];
                var dataPointId = DataPointUtils.getDataPointId(dp);
                var dataLabelText, formatPattern = formatPatterns, config;

                var measureName, metaDataFormat;

                if (this._data && this._data.valueAxis && this._data.valueAxis.metaData) {
                    measureName = this._data.valueAxis.metaData[0].id;
                    metaDataFormat = this._data.valueAxis.metaData[0].formatString;
                }

                formatPattern = formatPattern ? formatPattern : metaDataFormat;
                
                var drawLabel = function (dataLabelInfo, labelIdx) {
                    var stackRefNode = stack;
                    if (this._isFlexibleStack) {
                        //for flexible stack, "stack" is an arry, so we have to find the target 
                        //DOM node for data label.
                        stackRefNode = getFlexibleStackRefNode(stack, labelIdx);
                    }

                    dataLabelText = this._buildDataLabelText(formatPattern, dataLabelInfo, null,
                        false);
                    if(dataLabelText === null || dataLabelText === undefined){
                        return;
                    }
                    if(TypeUtils.isExist(dataLabelText) && dataLabelText && dataLabelText.text) {
                        //dataLabelText is a object. Use string and record formattedValue.
                        dataLabelInfo.formattedValue = dataLabelText.formattedValue;
                        dataLabelText = dataLabelText.text;
                    }                    
                    
                    var dataId = i + '-' + labelIdx;

                    var dataLabelGroup = SVG.create("g", dataLabelsGroup); 
                    DataPointUtils.setDataStackId(dataLabelGroup, dataId);
                    DataPointUtils.setDataId(dataLabelGroup, dataId);
                    DataGraphics.setData(dataLabelGroup, {
                        "id": dataId
                    });
                    
                   
                    DataGraphics.setContext(dataLabelGroup, {val: dataLabelInfo.value});
                    dataLabelGroup.setAttribute("class", DATA_LABEL_CLASS);
                    config = this._getConfigForRender(dataLabelInfo, dataLabelText, dataLabelStyle, stackRefNode, dp);
                    config.gNode = dataLabelGroup;
                    this._processDataLabelRendererConfig(config, dataLabelInfo.value !== 0 ? stackRefNode : dp);

                    var labelContentNode = labelRenderer(config, defaultRenderer.expose) || defaultRenderer(config);
                    if (labelContentNode) {
                        if (this.getDataLabelDefaultPosition){
                            this.getDataLabelDefaultPosition(dataLabelInfo.value !== 0 ? stackRefNode : dp);
                        }
                        var labelBBox = GeometryUtils.getBBox(dataLabelGroup);
                        var ctm = dataLabelInfo.value !== 0 ? SVG.getTransformToElement(stackRefNode, parentNodeDOM) :
                            SVG.getTransformToElement(dp, parentNodeDOM);
                        var position = null;
                        if(dataLabelInfo.value >= 0 ){
                            position = this._horizontal ? "right" : "up";
                        }else{
                            position = this._horizontal ? "left" : "down";
                        }
                        var labelTranslate = this._computeDataLabelTranslate(dataLabelInfo.value !== 0 ?
                            stackRefNode : dp, ctm, position, labelBBox, config);

                        if (!labelTranslate) {
                            dataLabelGroup.removeChild(labelContentNode);
                            return;
                        }
                        var x = labelTranslate[0];
                        var y = labelTranslate[1];
                        
                        dataLabelGroup.setAttribute("transform", "translate(" + x + "," + y + ")");
                        this._totalLabels.push(dataLabelGroup);
                        this._stackIndexs.push({
                            id: dataId,
                            value: dataLabelInfo.value,
                            labelTranslate: labelTranslate,
                            labelBBox: labelBBox
                        });
                    }
                };
                
                var range = this._getCategorySum(stack);
                if(range[1] > 0 || (range[1] === 0 && range[0] === 0)) {
                    drawLabel.call(this, {
                            key : measureName,
                            value : NumberUtils.preciseSimple(range[1]),
                            dynamicScale: dynamicScale
                        }, 0);                    
                }
                if(range[0] < 0 ) {
                    drawLabel.call(this, {
                            key : measureName,
                            value : NumberUtils.preciseSimple(range[0]),
                            dynamicScale: dynamicScale
                        }, 1);                    
                }
            }
        }
    };

    StackedDataLabels.prototype._getConfigForRender = function (dataLabelInfo, dataLabelText, 
                                                                dataLabelStyle, stack, dp) {
        var config = { val: dataLabelInfo.value,
                       text: dataLabelText,
                       info: dataLabelInfo,
                       styles: dataLabelStyle,
                       horizontal: this._horizontal,
                       // both _processDataLabelRendererConfig and _fixBBoxWhenInvisible need dpBBox,
                       // so calculate it for only one time here
                       dpBBox: GeometryUtils.getBBox(dataLabelInfo.value !== 0 ? stack : dp),
                       isTotalDataLabel: true 
                    };
        return config;
    };

    //we do not move dataLabel because of bound here. Because of BITSDC1-7704,
    //dataLabel position moving should be executed out of hiding logical.

    StackedDataLabels.prototype.hideConditional = function (dataLabelInfos, allDataPoints) {
        var i, dataLabelNode, dataPointNode, dataLabelinfo;
        var overlapBehavior = this._properties.get("overlapBehavior");
        if(overlapBehavior !== "hideOverlappedLabels"){
            for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
                dataLabelinfo = dataLabelInfos[i];
                dataLabelNode = dataLabelinfo.node;
                dataPointNode = dataLabelinfo.dataPoint;
                if (this.isDataLabelOutOfDataPoint(dataLabelNode, dataLabelinfo) && 
                    (!dataPointNode || DataGraphics.getData(dataPointNode).type != "line")) {
                    DOM.remove(dataLabelNode);
                    dataLabelInfos.splice(i, 1);
                }
            } 
        }

        var totalDataLabelInfos;
        if (this._totalLabels.length) {
            totalDataLabelInfos = [];
            var dataPointBoxes = new Array(this._allStacksNodes.length);
            for (i = 0; i < this._allStacksNodes.length; i++) {
                dataPointBoxes[i] = GeometryUtils.getBoundingClientRect(this._allStacksNodes[i]);
            }

            for (i = (this._totalLabels.length - 1); i >= 0; i--) {
                var stackId = this._stackIndexs[i].id;
                var stack = this._allStacksNodes[stackId.split('-')[0]];

                dataLabelNode = DataPointUtils.findByDataStackIds(this._totalLabels, stackId)[0];
                if(dataLabelNode){
                    var dataLabelBBox = dataLabelNode.getBoundingClientRect();
                    // first, hide it if it's overlapped the datapoints.
                    var iIndex = this.indexOfDataLabelIntersectDataPoints(dataLabelBBox, dataPointBoxes, 
                            this._allStacksNodes, stack);
                    if (iIndex !== -1) {
                        DOM.remove(dataLabelNode);
                        this._totalLabels.splice(i, 1);
                        this._stackIndexs.splice(i, 1);
                    } else {
                        var dataLabelValue = this._stackIndexs[i].value;
                        var labelTranslate = this._stackIndexs[i].labelTranslate;
                        var labelBBox = this._stackIndexs[i].labelBBox;

                        var config = {val: dataLabelValue};
                        if(labelTranslate){
                            var dataLabelInfoConfig = {
                                info:{value: dataLabelValue},
                                node: dataLabelNode,
                                left: labelTranslate[0] + labelBBox.x,
                                right: labelTranslate[0] + labelBBox.x + labelBBox.width,
                                top: labelTranslate[1] + labelBBox.y,
                                bottom: labelTranslate[1] + labelBBox.y + labelBBox.height
                            };
                            totalDataLabelInfos.push(dataLabelInfoConfig);
                        }
                    }
                }
            }
            if(totalDataLabelInfos) {
                //check whether the datalabels are overlapped with each other
                StackedDataLabels.superclass.hideConditional.call(this, totalDataLabelInfos);
            }
        }

        StackedDataLabels.superclass.hideConditional.apply(this, arguments);
        if(totalDataLabelInfos) {
            this.detectAndRemoveOverlappedDataLabel(dataLabelInfos.concat(totalDataLabelInfos));
        }
    };
    
    StackedDataLabels.prototype.updateColor = function(dataLabelInfos, backgroundColor) {
        StackedDataLabels.superclass.updateColor.apply(this, arguments);
        var dataLabelColor = this._properties.get('style.color');
        for (var i = 0; i < this._totalLabels.length; i++) {
            var stackId = this._stackIndexs[i].id;            
            var dataLabelNode = DataPointUtils.findByDataStackIds(this._totalLabels, stackId)[0];
            if(dataLabelNode) {
                var color = dataLabelColor;
                if(!color){                   
                    color = ColorUtil.getDataLabelColor(backgroundColor);
                }
                var fill = this.runtime().effectManager().register({
                    fillColor: color
                });
                dataLabelNode.setAttribute("fill", fill);
            }
        }
    };

    StackedDataLabels.prototype.drawZero = function (dataPoint) {
        //(!dataPoint && this._isFlexibleStack) means flexible stack labels
        return (!dataPoint || null === DataPointUtils.getDataPointId(dataPoint));
    };
    
    StackedDataLabels.prototype.destroy = function() {
        StackedDataLabels.superclass.destroy.call(this);
        this._labelPosition = null;
        this._totalLabels = null;
        this._stackIndexs = null;
        this._plotSelection = null;
        this._gridlineScale = null;
    };

    return StackedDataLabels;
});

define('sap/viz/chart/components/renderers/StackedBarRenderer',[ "sap/viz/framework/common/util/SVG", 
    'sap/viz/framework/common/util/DataGraphics',
    "sap/viz/chart/components/util/DrawUtil"
    ], function(SVG, DataGraphics, DrawUtil) {
    var MIN_FILL_SIZE = 2;
    var barRenderer = function(config) {
        var node, fill;
        var graphic = config.graphic;
        var bTinyValue = (graphic.width < 1 || graphic.height < 1) && 
            (graphic.width !== 0 && graphic.height !== 0);
        var width = graphic.width < 1 && graphic.width !== 0 ? 1 : graphic.width;
        var height = graphic.height < 1 && graphic.height !== 0 ? 1 : graphic.height;

        if (graphic.pattern === "noFill" && config.path) {
            node = SVG.create("path");
            node.setAttribute("d", config.path);
            node.setAttribute("stroke-width",
                isNaN(graphic.pathStrokeWidth) ? 3 : graphic.pathStrokeWidth);
            node.setAttribute("fill", graphic.bgColor);
            node.setAttribute("stroke", graphic.fill);
        } else {
            node = SVG.create("rect");
            node.setAttribute("width", width);
            node.setAttribute("height", height);
            fill = graphic.fill;
            if (config.effectManager) {

                fill = config.effectManager.register({
                    drawingEffect : graphic.drawingEffect,
                    fillColor : graphic.fill,
                    patternEffect: graphic.pattern,
                    direction : config.horizontal ? 'vertical' : 'horizontal'
                });
            }
            node.setAttribute("fill", fill);
            node.setAttribute('shape-rendering', 'crispEdges');
            if(graphic.stroke) {
                var minSize =  config.horizontal ? height : width;
                var strokeWidth = minSize > graphic.strokeWidth + MIN_FILL_SIZE ?
                        graphic.strokeWidth : minSize - MIN_FILL_SIZE;
                if(strokeWidth >= 1){
                    node.setAttribute('stroke', graphic.stroke);
                    node.setAttribute('stroke-width', graphic.strokeWidth);
                }
            }            
        }
        var data = DataGraphics.getData(node) || {};
        data.bTinyValue = bTinyValue;
        DataGraphics.setData(node, data);
        DataGraphics.setCustomizationInfo(node, {'defaultRenderer' : true});
        return node;
    };

    barRenderer.update = function(node, config) {
        var graphic = config.graphic;
        var width = graphic.width < 1 && graphic.width !== 0 ? 1 : graphic.width;
        var height = graphic.height < 1 && graphic.height !== 0 ? 1 : graphic.height;
        var size = {
            width: width,
            height: height,
            minSize: config.horizontal ? height : width
        };
        DrawUtil.barUpdate(node, config, size);
    };

    barRenderer.expose = {
        renderer: barRenderer,
        update: barRenderer.update
    };

    return barRenderer;
});
define('sap/viz/chart/components/accessibility/StackedColumnDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator"
], function(oo, TypeUtils, BaseDataPointNavigator) {


    function StackedColumnDataPointNavigator(options) {
        StackedColumnDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._allNegativeValueInCategory = [];
        this._negativeValueAxis1 = [];
        this._negativeValueAxis2 = [];

        this._stackItemsUpDownOrder = [];
        this._isSupportNaturalUpDown = (!this._isPercentage && !this._isDual &&
            this._isVerticalRender && options && !options.isTimeseries &&
            !options.isCombination);
    }

    oo.extend(StackedColumnDataPointNavigator, BaseDataPointNavigator);

    var prot = StackedColumnDataPointNavigator.prototype;

    prot.buildUpDownOrder = function () {
        if (this._series && this._isSupportNaturalUpDown) {
            //we calculate category number, and then build this._stackItemsUpDownOrder[iCategory] for each category
            var categoryNumber = 0;
            var i;
            var iCategory;
            for (i = 0; i < this._series.length; i++) {
                categoryNumber = Math.max(categoryNumber, this._series[i].length);
            }

            var isAllValueNegative = {};
            for (iCategory = 0; iCategory < categoryNumber; ++iCategory) {
                isAllValueNegative[iCategory] = true;
                for (i = 0; i < this._series.length; ++i) {
                    if (this._series[i][iCategory]) {
                        var msr = this._series[i][iCategory].valueAxis;
                        if (msr > 0) {
                            isAllValueNegative[iCategory] = false;
                            break;
                        }
                    }
                }
            }

            for (iCategory = 0; iCategory < categoryNumber; iCategory++) {
                this._stackItemsUpDownOrder[iCategory] = [];

                //this._stackItemsUpDownOrder[iCategory] is an arrry like
                //[7, 6, 5, 4, 3, 2, 1, 0], it saved SeriesIndexs which is indicator of up and down.
                var flexbleStacks = [];
                var currentFlexibleGroupNames = [];
                var flexibleGroupIndex;
                for (i = 0; i < this._series.length; i++) {
                    //even if no this._series[i][iCategory], we have to build currentFlexibleGroupNames
                    //to record current flexible group name
                    flexibleGroupIndex = 0;
                    if (this._series[i].settings) {
                        var itemGroupName = this._series[i].settings.group;
                        flexibleGroupIndex = currentFlexibleGroupNames.indexOf(itemGroupName);
                        if (flexibleGroupIndex < 0) {
                            currentFlexibleGroupNames.push(itemGroupName);
                            flexibleGroupIndex = currentFlexibleGroupNames.length - 1;
                        }
                    }
                    if (this._series[i][iCategory]) {
                        var flexibleStackItem = {};
                        //original index
                        flexibleStackItem.i = i;

                        //negative values are below positive ones
                        var dp = this._series[i][iCategory].dp;
                        if (dp) {
                            var dpData = dp.context();
                            if (isAllValueNegative[iCategory]) {
                                flexibleStackItem.isNegative = (dpData[dpData.measureNames] > 0 ? 0 : 1);
                            } else {
                                flexibleStackItem.isNegative = (dpData[dpData.measureNames] >= 0 ? 0 : 1);
                            }
                            flexibleStackItem.seriesLocation = dp.address()[1];
                            if (flexibleStackItem.isNegative > 0) {
                                flexibleStackItem.seriesLocation = -flexibleStackItem.seriesLocation;
                            }
                            flexibleStackItem.flexibleGroupIndex = flexibleGroupIndex;
                            flexbleStacks.push(flexibleStackItem);
                        }

                    }
                }

                flexbleStacks.sort(function (aItem, bItem) {
                    var flexibleGroupIndexDelta = aItem.flexibleGroupIndex - bItem.flexibleGroupIndex;
                    var isNegativeDelta = aItem.isNegative - bItem.isNegative;
                    var seriesLocationDelta = aItem.seriesLocation - bItem.seriesLocation;
                    //the order is priority
                    return flexibleGroupIndexDelta || isNegativeDelta || seriesLocationDelta;
                });

                for (i = 0; i < flexbleStacks.length; i++) {
                    this._stackItemsUpDownOrder[iCategory].push(flexbleStacks[i].i);
                }
            }
        }
    };

    prot.init = function () {
        this.buildUpDownOrder();
        if (this._series && this._isPercentage) {
            var categoryNum = this._getMaxCategoryNum();
            for (var categoryIndex = 0; categoryIndex < categoryNum; categoryIndex++) {
                var negativeNum1 = 0;
                var negativeNum2 = 0;
                var valueAxis1Num = 0;
                var valueAxis2Num = 0;
                for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
                    if (this._series[seriesIndex][categoryIndex]) {
                        if (this._series[seriesIndex][categoryIndex].valueAxis) {
                            valueAxis1Num++;
                            if (this._series[seriesIndex][categoryIndex].valueAxis < 0) {
                                negativeNum1++;
                            }
                        }
                        if (this._isDual && this._series[seriesIndex][categoryIndex].valueAxis2) {
                            valueAxis2Num++;
                            if (this._series[seriesIndex][categoryIndex].valueAxis2 < 0) {
                                negativeNum2++;
                            }
                        }
                    }
                }
                if (negativeNum1 === valueAxis1Num) {
                    this._negativeValueAxis1[categoryIndex] = true;
                } else {
                    this._negativeValueAxis1[categoryIndex] = false;
                }

                if (this._isDual) {
                    if (negativeNum2 === valueAxis2Num) {
                        this._negativeValueAxis2[categoryIndex] = true;
                    } else {
                        this._negativeValueAxis2[categoryIndex] = false;
                    }
                }
            }
        }
    };

    prot.destroy = function () {
        StackedColumnDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._allNegativeValueInCategory = null;
        this._negativeValueAxis1 = null;
        this._negativeValueAxis2 = null;
        this._stackItemsUpDownOrder = null;
    };

    prot.left = function (id) {
        return this._isVerticalRender ?
            this._getPrevDataPointInSeries(id) : this._getNextDataPointInStack(id);
    };

    prot.right = function (id) {
        return this._isVerticalRender ?
            this._getNextDataPointInSeries(id) : this._getPrevDataPointInStack(id);
    };

    prot.up = function (id) {
        return this._isVerticalRender ?
            this._getPrevDataPointInStack(id) : this._getPrevDataPointInSeries(id);
    };

    prot.down = function (id) {
        return this._isVerticalRender ?
            this._getNextDataPointInStack(id) : this._getNextDataPointInSeries(id);
    };

    prot._getPrevDataPointInSeries = function (id) {
        var prevDp = this._prevNonNullDPInSeries(id);
        if (this._isPercentage) {
            while (prevDp &&
                ((!this._negativeValueAxis1[prevDp.address()[0]] &&
                    this.locate(prevDp.address()).valueAxis < 0) ||
                    (this._isDual && !this._negativeValueAxis2[prevDp.address()[0]] &&
                        this.locate(prevDp.address()).valueAxis2 < 0))) {
                prevDp = this._prevNonNullDPInSeries(prevDp.id);
                if (!prevDp) {
                    break;
                }
            }
        }
        return prevDp;
    };

    prot._getNextDataPointInSeries = function (id) {
        var nextDp = this._nextNonNullDPInSeries(id);
        if (this._isPercentage) {
            while (nextDp &&
                ((!this._negativeValueAxis1[nextDp.address()[0]] &&
                    this.locate(nextDp.address()).valueAxis < 0) ||
                    (this._isDual && !this._negativeValueAxis2[nextDp.address()[0]] &&
                        this.locate(nextDp.address()).valueAxis2 < 0))) {
                nextDp = this._nextNonNullDPInSeries(nextDp.id);
                if (!nextDp) {
                    break;
                }
            }
        }
        return nextDp;
    };


    prot.getUpDownIndexInStack = function (index, iCategory, upDownDelta) {
        var targetIndex;
        if (this._isSupportNaturalUpDown) {
            var currentStackOrder = this._stackItemsUpDownOrder[iCategory];
            targetIndex = currentStackOrder[Math.min(Math.max(currentStackOrder.indexOf(index) +
                upDownDelta, 0), currentStackOrder.length - 1)];
        } else {
            targetIndex = index + upDownDelta;
        }
        return targetIndex;
    };

    prot._getNextDataPointInStack = function (id) {
        var dp = this.getDataPoint(id);
        var nextDp = null;
        var originalDp = null;
        var stackNum = this._series.length;
        if (dp) {
            var address = dp.address();
            if (address[1] !== stackNum - 1 || this._isSupportNaturalUpDown) {
                nextDp = this._downNonNullDPInSeries(dp.id);
                if (nextDp && this._isPercentage) {
                    originalDp = this.locate(nextDp.address());
                    if ((originalDp.valueAxis && !this._negativeValueAxis1[address[0]]) ||
                        (originalDp.valueAxis2 && !this._negativeValueAxis2[address[0]])) {
                        var dpValue = null;
                        while (nextDp && nextDp.address()[1] < stackNum) {
                            originalDp = this.locate(nextDp.address());
                            dpValue = originalDp.valueAxis || originalDp.valueAxis2;
                            if (dpValue < 0) {
                                nextDp = this._downNonNullDPInSeries(nextDp.id);
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
        }
        return nextDp;
    };

    prot._getPrevDataPointInStack = function (id) {
        var dp = this.getDataPoint(id);
        var prevDp = null;
        var originalDp = null;
        if (dp) {
            var address = dp.address();
            if (address[1] !== 0 || this._isSupportNaturalUpDown) {
                prevDp = this._upNonNullDPInSeries(dp.id);
                if (prevDp && this._isPercentage) {
                    originalDp = this.locate(prevDp.address());
                    if ((originalDp.valueAxis && !this._negativeValueAxis1[address[0]]) ||
                        (originalDp.valueAxis2 && !this._negativeValueAxis2[address[0]])) {
                        var dpValue = null;
                        while (prevDp && prevDp.address()[1] > -1) {
                            originalDp = this.locate(prevDp.address());
                            dpValue = originalDp.valueAxis || originalDp.valueAxis2;
                            if (dpValue < 0) {
                                prevDp = this._upNonNullDPInSeries(prevDp.id);
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
        }
        return prevDp;
    };

    prot.getFirstStartPoint = function () {
        if (!this._isPercentage) {
            return StackedColumnDataPointNavigator.superclass.getFirstStartPoint.apply(this, arguments);
        }
        if (this._series) {
            for (var i = 0; i < this._series[i].length; i++) {
                for (var j = 0; i < this._series.length; j++) {
                    if (this._series[j][i]) {
                        if (this._isDual) {
                            if (!this._negativeValueAxis1[i] &&
                                this._series[j][i].valueAxis < 0) {
                                continue;
                            }

                            if (this._isDual &&
                                !this._negativeValueAxis2[i] &&
                                this._series[j][i].valueAxis2 < 0) {
                                continue;
                            }

                            return this._series[j][i].dp;
                        } else {
                            if (!this._negativeValueAxis1[i] &&
                                this._series[j][i].valueAxis < 0) {
                                continue;
                            } else {
                                return this._series[j][i].dp;
                            }
                        }
                    }
                }
            }
        } else {
            return null;
        }
    };

    prot._isMeaningful = function(dp) {
        return dp && (TypeUtils.isExist(dp.valueAxis) || TypeUtils.isExist(dp.valueAxis2));
    };

    prot._downNonNullDPInSeries = function (id) {
        var currentDp = this.getDataPoint(id);
        var dpAddress = currentDp.address();
        var seriesDelta = dpAddress[0];
        var seriesLen = this._series.length;
        var nextSeriesIndex = this.getUpDownIndexInStack(dpAddress[1], seriesDelta, 1);
        var dp = null;
        if (nextSeriesIndex > seriesLen) {
            return dp;
        }
        while (nextSeriesIndex < seriesLen) {
            if (this._series[nextSeriesIndex]) {
                dp = this._series[nextSeriesIndex][seriesDelta];
                if (this._isMeaningful(dp)) {
                    return dp.dp;
                }
            }
            nextSeriesIndex = this.getUpDownIndexInStack(nextSeriesIndex, seriesDelta, 1);
        }
        return dp;
    };

    prot._upNonNullDPInSeries = function (id) {
        var currentDp = this.getDataPoint(id);
        var dpAddress = currentDp.address();
        var seriesDelta = dpAddress[0];
        var prevSeriesIndex = this.getUpDownIndexInStack(dpAddress[1], seriesDelta, -1);
        var dp = null;
        if (prevSeriesIndex < 0) {
            return dp;
        }
        while (prevSeriesIndex > -1) {
            if (this._series[prevSeriesIndex]) {
                dp = this._series[prevSeriesIndex][seriesDelta];
                if (this._isMeaningful(dp)) {
                    return dp.dp;
                }
            }
            prevSeriesIndex = this.getUpDownIndexInStack(prevSeriesIndex, seriesDelta, -1);
        }
        return dp;
    };

    prot._nextNonNullDPInSeries = function (id) {
        var currentDp = this.getDataPoint(id);
        var dpAddress = currentDp.address();
        var stackNum = this._series[dpAddress[1]].length;
        var nextDpIndex = dpAddress[0] + 1;
        if (nextDpIndex > stackNum) {
            return null;
        }
        var dp = this._series[dpAddress[1]][nextDpIndex];
        while (!this._isMeaningful(dp) && nextDpIndex < stackNum) {
            dp = this._series[dpAddress[1]][nextDpIndex];
            nextDpIndex++;
        }
        return this._isMeaningful(dp) ? dp.dp : null;
    };

    prot._prevNonNullDPInSeries = function (id) {
        var currentDp = this.getDataPoint(id);
        var dpAddress = currentDp.address();
        var prevDpIndex = dpAddress[0] - 1;
        if (prevDpIndex < 0) {
            return null;
        }
        var dp = this._series[dpAddress[1]][prevDpIndex];
        while (!this._isMeaningful(dp) && prevDpIndex > -1) {
            dp = this._series[dpAddress[1]][prevDpIndex];
            prevDpIndex--;
        }
        return this._isMeaningful(dp) ? dp.dp : null;
    };

    prot._getFirstPointBySeries = function (seriesIndex) {
        if (this._series && seriesIndex > -1 && seriesIndex < this._series.length) {
            if (this._series[seriesIndex]) {
                for (var i = 0; i < this._series[seriesIndex].length; i++) {
                    if (this._series[seriesIndex][i]) {
                        if (this._isPercentage) {
                            if (!this._negativeValueAxis1[i] &&
                                this._series[seriesIndex][i].valueAxis < 0) {
                                continue;
                            }

                            if (this._isDual &&
                                !this._negativeValueAxis2[i] &&
                                this._series[seriesIndex][i].valueAxis2 < 0) {
                                continue;
                            }
                        }
                        return this._series[seriesIndex][i].dp;
                    }
                }
            }
        }
        return null;
    };

    return StackedColumnDataPointNavigator;
});

define('sap/viz/chart/components/plots/StackedPlotHelper',[],
    function()
    {
        var helper = {};
        helper.getVisibleRange = function(instance, BaseClass){
            var range =  BaseClass.prototype._getVisibleRange.apply(instance, arguments);
            if(range){
                var series = instance._series;
                var seriesLength = series.length;
                var rRange;
                for (var seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {
                    var seriesItem = series[seriesIndex];
                    if (!seriesItem) {
                        continue;
                    }
                    var dataPoints = seriesItem.getDataPoints();
                    var curRange = instance._getDataPointRange(dataPoints, range);
                    rRange = rRange || curRange;
                    rRange.min = Math.min(rRange.min, curRange.min);
                    rRange.max = Math.max(rRange.max, curRange.max);
                }
                range = rRange;
            }
            return range;
        }; 
       
        return helper;
    }
);
define('sap/viz/chart/components/plots/ComboExDataHandler',[
    "sap/viz/chart/components/plots/DataHandler"
], function(
    DataHandler
) {
    function ComboExDataHandler(seriesGroup) {
        this._handlers = seriesGroup.reduce(function(handlers, srGroup) {
            var signSensitive = srGroup.type === "area" ? false : true;
            var dataHandler = DataHandler.getStackHandler(signSensitive);
            srGroup.series.forEach(function(seriesIdx) {
                handlers[seriesIdx] = dataHandler;
            });
            return handlers;
        }, []);
    }

    ComboExDataHandler.prototype.add = function(index, value, series) {
        return this._handlers[series].add(index, value, series);
    };

    ComboExDataHandler.prototype.getBase = function(index, value, series) {
        return this._handlers[series].getBase(index, value, series);
    };

    ComboExDataHandler.prototype.reset = function() {
        this._handlers.forEach(function(handler) {
            handler.reset();
        });
    };

    ComboExDataHandler.prototype.destroy = function() {
        this._handlers.forEach(function(handler) {
            handler.destroy();
        });
    };

    return ComboExDataHandler;
});

define('sap/viz/chart/components/renderers/AreaSeriesRenderer',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/renderers/SeriesRenderer'
], function Setup(
    oo,
    SVG,
    TypeUtils,
    DataGraphics,
    Constants,
    SeriesRenderer
) {

    var CSS_CLASS = Constants.CSS.CLASS;

    var AreaSeriesRenderer = function(itemRenderer, itemUpdater) {
        AreaSeriesRenderer.superclass.constructor.apply(this, arguments);
    };

    oo.extend(AreaSeriesRenderer, SeriesRenderer);

    AreaSeriesRenderer.prototype.init = function(seiresCount) {
        this._series = [];
        this._seriesGroup = [];
        var sGroup;
        for (var i = 0; i < seiresCount; i++) {
            sGroup = this._seriesGroup[i] = SVG.create("g");
            sGroup.setAttribute("class", CSS_CLASS.AREA_POINT);
        }
        sGroup = this._areaGroup = SVG.create("g");
        sGroup.setAttribute("class", CSS_CLASS.AREA_GROUP);
        sGroup = this._refLineGroup = SVG.create("g");
        sGroup.setAttribute("class", CSS_CLASS.AREA_REF_LINE_GROUP);

    };

    AreaSeriesRenderer.prototype.addDataPoint = function(sIdx/*seriesIndex*/, cIdx/*categoryIndex*/, 
        dpConfig, position, dataPoint, dataPointRefLine) {

        if (dataPoint) {
            this._seriesGroup[sIdx].appendChild(dataPoint);
        }

        if (dataPointRefLine){
            this._refLineGroup.appendChild(dataPointRefLine);
        }
        this._series[sIdx] = this._series[sIdx] || [];
        this._series[sIdx][cIdx] = {
            position: position,
            dpConfig: dpConfig,
            dataPoint: dataPoint,
            dataPointRefLine: dataPointRefLine
        };
    };

    AreaSeriesRenderer.prototype.addDataPointRefLine = function(sIdx, cIdx, node){
        if (!node || !this._series[sIdx]){
            return;
        }
        var seriesInfo = this._series[sIdx][cIdx];
        if(!seriesInfo){
            return;
        }
        this._refLineGroup.appendChild(node);
        seriesInfo.dataPointRefLine = node;
    };

    AreaSeriesRenderer.prototype.render = function(parent) {
        var areaGroup = this._areaGroup;
        var refLineGroup = this._refLineGroup;
        var dataPointGroup = SVG.create("g");
        for (var i = 0; i < this._seriesGroup.length; i++) {
            if(this._series[i]){
                this._renderSeries(areaGroup, this._series[i], i);
                dataPointGroup.appendChild(this._seriesGroup[i]);
            }
        }
        dataPointGroup.setAttribute("class", CSS_CLASS.AREA_POINT_GROUP);
        parent.appendChild(areaGroup);
        parent.appendChild(refLineGroup);
        parent.appendChild(dataPointGroup);
    };

    AreaSeriesRenderer.prototype.update = function(parent){
        for (var i = 0; i < this._seriesGroup.length; i++) {
            if(this._series[i]){
                this._updateSeries(this._areaGroup, this._series[i], i);
            }
        }
    };

    return AreaSeriesRenderer;
});
define('sap/viz/chart/components/renderers/ComboExSeriesRenderer',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/renderers/SeriesRenderer",
    "sap/viz/chart/components/renderers/AreaSeriesRenderer"
], function(
    oo,
    SeriesRenderer,
    AreaSeriesRenderer
) {
    var TYPE_PRIORITY = ["line", "bar", "area"];

    function ComboExSeriesRenderer(renderFn, updateFn) {

        this.seriesRenderers = {
            "bar": new SeriesRenderer(renderFn, updateFn),
            "line": new SeriesRenderer(renderFn, updateFn),
            "area": new AreaSeriesRenderer(renderFn, updateFn)
        };
        // order is important since area needs to be rendered at the bottom
        this._renderers = TYPE_PRIORITY.slice().reverse().map(function(type) {
            return this.seriesRenderers[type];
        }, this);
        this._seriesType = [];
    }

    /** type of each series */
    ComboExSeriesRenderer.prototype.setSeriesSettings = function(seriesGroups, seriesType) {
        this._seriesGroupInfo = seriesGroups;
        this._seriesType = seriesType;
        this._typeIndexes = [[],[],[]];
        var size = TYPE_PRIORITY.length - 1;
        for(var i = 0; i < seriesType.length; ++i){
            this._typeIndexes[size - TYPE_PRIORITY.indexOf(seriesType[i])].push(i);
        }
    };

    /** series of the same stack group need to be rendered in reversed order to get the overlapping right */
    ComboExSeriesRenderer.prototype._seriesGroupOrder = function() {
        var groupedByType = this._seriesGroupInfo.reduce(function(grouped, srg) {
            if (!grouped[srg.type]) {
                grouped[srg.type] = [];
            }

            grouped[srg.type].push(srg.series);

            return grouped;
        }, {});

        return TYPE_PRIORITY.reduce(function(order, type) {
            if (groupedByType[type]) {
                groupedByType[type].forEach(function(series) {
                    order = order.concat(series.slice().reverse());
                });
            }
            return order;
        }, []);
    };

    ComboExSeriesRenderer.prototype._sortStackedSeries = function(type) {
        var order = this._seriesGroupOrder();

        var renderer = this.seriesRenderers[type];

        var series = renderer._series,
            seriesGroup = renderer._seriesGroup,
            availableSlots = series.reduce(function(slots, sr, i) {
                return sr ? slots.concat(i) : slots;
            }, []);

        var sorted = availableSlots.slice().sort(function(a, b) {
            return order.indexOf(a) - order.indexOf(b);
        }).reduce(function(sorted, srIdx, i) {
            var slot = availableSlots[i];
            sorted.series[slot] = series[srIdx];
            sorted.seriesGroup[slot] = seriesGroup[srIdx];
            return sorted;
        }, {
            series: [],
            seriesGroup: []
        });

        renderer._series = sorted.series;
        renderer._seriesGroup = sorted.seriesGroup;
    };

    ComboExSeriesRenderer.prototype.getSeriesRenderer = function(seriesIndex) {
        return this.seriesRenderers[this._seriesType[seriesIndex]];
    };

    ComboExSeriesRenderer.prototype._doAll = function(fnName, args) {
        var typeIndexes = this._typeIndexes;
        this._renderers.forEach(function(renderer, i) {
            renderer[fnName].apply(renderer, [].slice.call(args).concat([typeIndexes[i]]));
        });
    };

    ComboExSeriesRenderer.prototype.addDataPointRefLine = function(sIdx, cIdx, refLineNode) {
        this.seriesRenderers.area.addDataPointRefLine(sIdx, cIdx, refLineNode);
    };

    // ============ overrides ============

    ComboExSeriesRenderer.prototype.init = function(nSeries) {
        this._doAll("init", arguments);
    };

    ComboExSeriesRenderer.prototype.resetDataPoints = function() {
        this._doAll("resetDataPoints", arguments);
    };

    ComboExSeriesRenderer.prototype.render = function(parent) {
        this._sortStackedSeries("bar");
        this._doAll("render", arguments);
    };

    ComboExSeriesRenderer.prototype.update = function(parent) {
        this._doAll("update", arguments);
    };

    ComboExSeriesRenderer.prototype.addDataPoint = function(seriesIndex, categoryIndex, dpConfig, position, dataPoint) {
        this.getSeriesRenderer(seriesIndex).addDataPoint(seriesIndex, categoryIndex, dpConfig, position, dataPoint);
    };

    ComboExSeriesRenderer.prototype.updateDataPoint = function(seriesIndex, categoryIndex, dpConfig, position) {
        this.getSeriesRenderer(seriesIndex).updateDataPoint(seriesIndex, categoryIndex, dpConfig, position);
    };

    oo.extend(ComboExSeriesRenderer, SeriesRenderer);

    return ComboExSeriesRenderer;
});

define('sap/viz/chart/components/plots/StackedColumnPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/ColumnPlot',
    'sap/viz/chart/components/plots/BaseColumnPlot',
    'sap/viz/chart/components/plots/DataHandler',
    "sap/viz/chart/components/plots/SeriesIterator",
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/BarWidthUtils',
    'sap/viz/chart/components/datalabels/StackedDataLabels',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/SVG',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/chart/components/renderers/StackedBarRenderer',
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/components/plots/XYPlotFactory",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/StackedColumnDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    'sap/viz/chart/components/plots/StackedPlotHelper',
    "sap/viz/chart/components/plots/ComboExDataHandler",
    "sap/viz/chart/components/renderers/ComboExSeriesRenderer"

], function Setup(
    oo,
    ColumnPlot,
    BaseColumnPlot,
    DataHandler,
    SeriesIterator,
    ItemScaleHandler,
    ScaleHandler,
    BarWidthUtils,
    StackedDataLabels,
    Constants,
    SVG, 
    DataPointUtils, 
    DataGraphics, 
    StackedBarRenderer, 
    ObjectUtils, 
    DOM,
    XYPlotFactory,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants,
    StackedPlotHelper,
    ComboExDataHandler,
    ComboExSeriesRenderer
) {

    /**
     * To initialize StackedColumnPlot object.
     *
     * @name StackedColumnPlot
     * @constructor
     */
    var StackedColumnPlot = function (runtime, options) {
        this._isFlexibleStack = (runtime.propertyManager().origin.get("plotArea.series") &&
            options && !options.inTrellis && !options.isDualValueAxis &&
            !options.isHorizontal && options.isSupportFlexibleStack);
        StackedColumnPlot.superclass.constructor.apply(this, arguments);

        this._dataPointRenderer = StackedBarRenderer;
        this._initCategoryAxis(ScaleHandler, ItemScaleHandler);
    };

    oo.extend(StackedColumnPlot, ColumnPlot);

    var BAR_TYPE = 1;

    StackedColumnPlot.prototype._initCategoryAxis = function (ScaleHandler, ItemScaleHandler) {
        if (this._isFlexibleStack) {
            this._seriesType = [];
            this._barCategoryAxis = ScaleHandler.getCategoryScaleHandler("categoryAxis", {
                isHorizontal: false,
                itemScaleHandler: ItemScaleHandler.get(true, this._getBarProperties())
            });
            this._categoryScaleHandler = this._barCategoryAxis;
        }
    };

    StackedColumnPlot.prototype._getXPosition = function (seriesIdx, itemIdx, data) {
        if (this._isFlexibleStack) {
            return this._getAxisPosition([this._barCategoryAxis], this._barGroupIndices[seriesIdx], itemIdx, data);
        }
        else {
            return StackedColumnPlot.superclass._getXPosition.apply(this, arguments);
        }
    };

    StackedColumnPlot.prototype._renderSeries = function (seriesG, data, seriesIndex, isUpdate) {
        if (this._isFlexibleStack) {
            return BAR_TYPE;
        }
    };

    StackedColumnPlot.prototype._updateSeries = function (seriesG, data, seriesIndex, isUpdate) {
        if (this._isFlexibleStack) {
            return BAR_TYPE;
        }
    };

    StackedColumnPlot.prototype._buildDataHandler = function (id) {
        if (this._isFlexibleStack) {
            return new ComboExDataHandler(this._seriesGroups.filter(function (srg) {
                return srg.mndKey === id;
            }));
        }
    };

    StackedColumnPlot.prototype._applyScroll = function () {
        return ColumnPlot.superclass._applyScroll.apply(this, arguments);
    };
    /**
     * Get data point position by data point address (series index and item index)
     */
    StackedColumnPlot.prototype.getDataPointPosition = function (seriesIndex, itemIndex, isResetDataPoints) {
        if (this._isFlexibleStack) {
            //regular stacked chart uses reversed index.
            var dpPosition = StackedColumnPlot.superclass.getDataPointPosition.apply(this, arguments);
            if (isResetDataPoints) {
                //for first invisible data point, we have to reset data handler and positions here,
                //because flexible stacks use internel structures to record
                //"dirty" data point positions and data handler states.
                this._resetDataPoints();
            }
            return dpPosition;
        } else {
            var series = this._getSeries();
            var data;
            if (series.length) {
                seriesIndex = series.length - seriesIndex - 1;
                data = series[seriesIndex][itemIndex];
            }
            return this._getPosition(seriesIndex, itemIndex, data);
        }
    };

    StackedColumnPlot.prototype.getSeriesIndex = function(dp){
        return this._series.length - dp._addr[1] - 1;
    };

    StackedColumnPlot.prototype._getDataHandler = function() {
        if (this._options.isDualValueAxis) {
            return {
                "valueAxis": DataHandler.getStackHandler(true),
                "valueAxis2": DataHandler.getStackHandler(true)
            };
        } else {
            return {
                "valueAxis": DataHandler.getStackHandler(true)
            };
        }
    };
    StackedColumnPlot.prototype._getCategoryScaleHandlers = function(isHorizontal) {
        this._categoryScaleHandler = ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: isHorizontal,
            itemScaleHandler: this._getItemScaleHandler()
        });

        return [this._categoryScaleHandler];
    };

    StackedColumnPlot.prototype._getBarProperties = function () {
        if (!this._barInfoProperties) {
            this._barInfoProperties = BarWidthUtils.getBarProperties(this._properties.origin,
                this._isFlexibleStack);
        }
        return this._barInfoProperties;
    };

    StackedColumnPlot.prototype._getItemScaleHandler = function() {
        var result;
        var options = this._getBarProperties();
        if (this._options.isDualValueAxis) {
            options.valueAxis = ["valueAxis", "valueAxis2"];
            result = ItemScaleHandler.get(false, options);
            delete options.valueAxis;
        }else {
            result = ItemScaleHandler.get(false, options);
        }

        this._itemScaleHandler = result;
        return result;
    };

    StackedColumnPlot.prototype._applyChanges = function(){
        if(this._options.isDualValueAxis && !(this._data.color.scale.getDomain().length &&
        this._data.color2.scale.getDomain().length)) {
            this._getBarProperties().barSpacing = 1;
            this._itemScaleHandler.updateItems( this._data.color2.scale.getDomain().length ?
                    ["valueAxis2"] :["valueAxis"]);
        }
        StackedColumnPlot.superclass._applyChanges.apply(this, arguments);
        this._initBarCategoryAxis();
    };

    StackedColumnPlot.prototype._initBarCategoryAxis = function () {
        if (this._isFlexibleStack) {
            var barCount = this._getColumnCount();
            var scale = this._data["categoryAxis"].scale;
            if (barCount) {
                var range = this.isHorizontal() ? this._realSize.height : this._realSize.width;
                this._barCategoryAxis.init(scale, barCount, range);
            }
        }
    };

    StackedColumnPlot.prototype._getDataLabels = function(name, runtime) {
        return new StackedDataLabels(runtime, {
            name: name,
            horizontal: this.isHorizontal(),
            allowMicroAdjust: !this.isHorizontal(),
            isFlexibleStack: this._isFlexibleStack
        });
    };

    StackedColumnPlot.prototype._getSeries = function () {
        if (this._isFlexibleStack) {
            return StackedColumnPlot.superclass._getSeries.apply(this, arguments);
        }
        else {
            if (this._data.series) {
                return this._data.series.slice().reverse();
            } else {
                return [];
            }
        }
    };

    StackedColumnPlot.prototype._attachMarkManager = function () {
        if (this._isFlexibleStack) {
            if (!this._data) {
                return;
            }

            var markManager = this.runtime().markManager();
            var markers = this._isInTrellis ? (markManager._shapes || []) : [];
            markManager.lock();
            markManager.setMode("series");
            var shapeTable = {
                line: this._getMarkerShape(),
                bar: this._getLegendMarkerShape(),
                area: "circle"
            };

            var vIndex1 = 0, vIndex2 = 0;

            this._getSeries().forEach(function (sr) {
                var isValueAxis1 = sr.spec.mndKey === "valueAxis";
                var mndKeyId = isValueAxis1 ? 0 : 1;
                var index = isValueAxis1 ? vIndex1 : vIndex2;
                if (isValueAxis1) {
                    vIndex1++;
                } else {
                    vIndex2++;
                }

                markers[mndKeyId] = markers[mndKeyId] || [];

                if (!!markers[mndKeyId][index] ||
                    (this._isInTrellis && this._isEmptySeries(sr))) {
                    //skip empty series in trellis
                    return;
                }

                markers[mndKeyId][index] = {
                    marker: shapeTable[sr.settings.type],
                    type: sr.settings.type
                };
            }, this);

            markManager.setMarkers(markers);
        }
    };

    StackedColumnPlot.prototype._getColumnCount = function () {
        if (this._isFlexibleStack) {
            return this._seriesGroups.length;
        }
        else {
            return this._options.isDualValueAxis && this._data.color.scale.getDomain().length &&
                this._data.color2.scale.getDomain().length ? 2 : 1;
        }
    };

    function series2Groups(series) {
        if (!series.length) {
            return [];
        }
        var categories = [], category, s;
        for (var i = 0, l = series.length; i < l; i++) {
            s = series [i];
            for (var j = 0; j < s.length; j++) {
                category = categories[j] = categories[j] || [];
                category.push(s[j]);
            }
        }
        return category;
    }

    StackedColumnPlot.prototype._needValidEmptyAxisData = function() {
        return false;
    };

    StackedColumnPlot.prototype._buildData = function(dpConfig) {
        var data = StackedColumnPlot.superclass._buildData.apply(this, arguments);
        data.isNegative = undefined;
        return data;
    };



    StackedColumnPlot.prototype._generatePath = function (size, options) {
        if (this._isFlexibleStack) {
            return StackedColumnPlot.superclass._generatePath.apply(this, arguments);
        } else {
            var points = [];
            var isClose = options.isClose;
            var isNegative = options.isNegative;
            var isPercent = this._isPercent;
            var strokePadding = 1.5;
            var xPos = size.width - strokePadding, yPos = size.height - strokePadding;
            if (xPos <= 0) {
                xPos = 1;
            }
            if (yPos <= 0) {
                yPos = 1;
            }
            if (options.isZero) {
                strokePadding = 0;
            }
            if (this.isHorizontal()) {
                if (options.isZero) {
                    xPos = 0;
                }
                if (isClose) {
                    points.push([strokePadding, strokePadding]);
                    points.push([xPos, strokePadding]);
                    points.push([xPos, yPos]);
                    points.push([strokePadding, yPos]);
                    points.push([strokePadding, 0]);
                } else {
                    if (isNegative && !isPercent) {
                        points.push([size.width, strokePadding]);
                        points.push([strokePadding, strokePadding]);
                        points.push([strokePadding, yPos]);
                        points.push([size.width, yPos]);
                    } else {
                        points.push([0, strokePadding]);
                        points.push([xPos, strokePadding]);
                        points.push([xPos, yPos]);
                        points.push([0, yPos]);
                    }
                }
            } else {
                if (options.isZero) {
                    yPos = 0;
                }
                if (isClose) {
                    points.push([strokePadding, yPos]);
                    points.push([strokePadding, strokePadding]);
                    points.push([xPos, strokePadding]);
                    points.push([xPos, yPos]);
                    points.push([0, yPos]);
                } else {
                    if (isNegative && !isPercent) {
                        points.push([strokePadding, 1]);
                        points.push([strokePadding, yPos]);
                        points.push([xPos, yPos]);
                        points.push([xPos, 1]);
                    } else {
                        points.push([strokePadding, size.height]);
                        points.push([strokePadding, strokePadding]);
                        points.push([xPos, strokePadding]);
                        points.push([xPos, size.height]);
                    }
                }
            }
            return SVG.generatePath({ points: points });
        }
    };

    StackedColumnPlot.prototype._pushDataPointContext = function() {
    };

    StackedColumnPlot.prototype._getVisibleRange = function () {
        if (this._isFlexibleStack) {
            return StackedColumnPlot.superclass._getVisibleRange.apply(this, arguments);
        } else {
            return StackedPlotHelper.getVisibleRange(this, ColumnPlot);
        }
    };

    StackedColumnPlot.prototype._isSupportBarPathGenerator = function () {
        return this._isFlexibleStack;
    };

    StackedColumnPlot.prototype.setData = function (data) {
        StackedColumnPlot.superclass.setData.call(this, data);

        if (this._isFlexibleStack) {
            if (this._fixSeriesForMulti) {
                this._fixSeriesForMulti.call(this, data.series.filter(function (sr) {
                    return sr.settings.type === "area";
                }));
            }
            this._configSeries();
            this._dataHandler = {
                valueAxis: this._buildDataHandler("valueAxis"),
                valueAxis2: this._buildDataHandler("valueAxis2")
            };
            this._seriesRenderer.setSeriesSettings(this._seriesGroups, this._seriesType);
            this._dataLabels.setSeriesSettings(this._seriesGroups, this._seriesType);
            this._attachMarkManager();
        }
    };

    StackedColumnPlot.prototype._configSeries = function () {
        if (this._isFlexibleStack) {
            var series = this._getSeries();
            var plot = this;

            this._seriesGroups = series.reduce(function (grps, sr, i) {
                var groupKey = sr.settings.group;
                if (!grps[groupKey]) {
                    grps[groupKey] = {
                        type: sr.settings.type,
                        mndKey: sr.spec.mndKey,
                        series: []
                    };
                }
                grps[groupKey].series.push(i);

                // _seriesType is used by CombinationPlot for data label and other purpose
                plot._seriesType[i] = sr.settings.type;

                return grps;
            }, {});

            this._seriesGroups = Object.keys(this._seriesGroups).map(function (groupKey) {
                return this._seriesGroups[groupKey];
            }, this);

            this._barGroupIndices = this._seriesGroups.filter(function (srGrp) {
                return srGrp.type === "bar";
            }).reduce(function (indices, srGrp, i) {
                srGrp.series.forEach(function (srIdx) {
                    indices[srIdx] = i;
                });
                return indices;
            }, []);
        }
    };

    StackedColumnPlot.prototype.createSeriesIterator = function (len) {
        if (this._isFlexibleStack) {
            return SeriesIterator.create(len, "reverse");
        }
        else {
            return StackedColumnPlot.superclass.createSeriesIterator.apply(this, arguments);
        }
    };

    StackedColumnPlot.prototype._showDataPoints = function (dataPointG, options) {
        var dataPointsToShow;
        if (this._isFlexibleStack) {
            //comboex uses BaseColumnPlot _showDataPoints
            dataPointsToShow = BaseColumnPlot.prototype._showDataPoints.apply(this, arguments);
        }
        else {
            this._preShowDataPoints();
            var inValidEmptyAxisData = this._needValidEmptyAxisData();
            dataPointsToShow = [];
            var series = this._series;
            var seriesLength = series.length;

            var categories = [], category;
            var needLazyRender = this._needLazyRender();
            // For stacked chart, we should render one category as a whole
            var range = this._getVisibleRange();
            var seriesIndex, seriesItem;


            for (seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {

                seriesItem = series[seriesIndex];
                var seriesStyle = this.getSeriesDPStyle(seriesLength - seriesIndex - 1);
                if (!seriesItem) {
                    continue;
                }
                var dataPoints = seriesItem.getDataPoints();
                if (needLazyRender) {
                    this._hideDataPoints(dataPoints, range);
                }
                var valAxisName = null;
                var start = (range && range.min || 0);
                var end = (range && range.max) || dataPoints.length;
                for (var itemIndex = start; itemIndex <= end; itemIndex++) {
                    var dataPointModel = dataPoints[itemIndex];
                    if (!dataPointModel) {
                        continue;
                    }
                    var data = dataPointModel.getRawData();
                    if (inValidEmptyAxisData === true) {
                        var emptyOfValueAxis = data.valueAxis === undefined || data.valueAxis === null;
                        var emtyOfValueAxis2 = data.valueAxis2 === undefined || data.valueAxis2 === null;
                        if (emptyOfValueAxis && emtyOfValueAxis2) {
                            continue;
                        }
                    }

                    var position = this._getPosition(seriesIndex, itemIndex, data);
                    if (!position) {
                        continue;
                    }

                    var currentId = dataPointModel.getId();
                    var dpConfig = dataPointModel.getConfig();
                    if (!dpConfig) {
                        dpConfig =
                            this._buildWrapperConfig(data, position, data.dp.context(), { seriesStyle: seriesStyle });
                        dataPointModel.setConfig(dpConfig);
                    }
                    this._pushDataPointContext(dpConfig);
                    if (!valAxisName) {
                        valAxisName = data.hasOwnProperty("valueAxis2") ? "valueAxis2" : "valueAxis";
                    }
                    categories[itemIndex] = categories[itemIndex] || {};
                    category = categories[itemIndex][valAxisName] = categories[itemIndex][valAxisName] || {
                        configs: [],
                        positions: [],
                        currentIds: [],
                        dataPoints: [],
                        dataModels: [],
                        data: []
                    };
                    var dpNode = DataPointUtils.find(dataPointG, currentId);
                    if (!category.node && dpNode) {

                        var categoryNode = dpNode;
                        while ((categoryNode = categoryNode.parentNode) &&
                            !DOM.hasClass(categoryNode, Constants.CSS.CLASS.STACK)) { }
                        category.node = categoryNode;

                    }
                    var dpData = dataPointModel.getData();
                    if (!dpData) {
                        dpData = this._buildData(dpConfig);
                    }
                    category.data.push(dpData);
                    category.configs.push(dpConfig);
                    category.dataPoints.push(data.dp);
                    category.positions.push(position);
                    category.currentIds.push(currentId);
                    category.dataModels.push(dataPointModel);
                }
            }
            this._removeEmptyStacks(dataPointG);
            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            for (var i = 0; i < categories.length; i++) {
                var currentCategory = categories[i];
                for (var axis in currentCategory) {
                    if (currentCategory.hasOwnProperty(axis)) {
                        category = currentCategory[axis];
                        if (!category) {
                            continue;
                        }
                        var cp = this._drawCategory(category, dpRenderer, dataPointsToShow);
                        if (cp) {
                            dataPointG.appendChild(cp);
                        }

                    }
                }
            }
        }
        this._dataLabels._gridlineScale = this._gridlineScale;
        return dataPointsToShow;
    };

    StackedColumnPlot.prototype._removeEmptyStacks = function(dataPointG){
        var stacks = [].slice.call(dataPointG.querySelectorAll("." + Constants.CSS.CLASS.STACK));
        stacks.forEach(function(node){
            if(!node.childNodes.length){
                dataPointG.removeChild(node);
            }
        });

    };


    function updateConfigs(configs) {
        var firstPositive = -1, firstNegative = -1;
        for (var i = 0; i < configs.length; i++) {
            var config = configs[i];
            config.isClose = true;
            config.isZero = false;
            if (config.ctx[config.ctx.measureNames] > 0) {
                if (firstPositive === -1) {
                    firstPositive = i;
                    config.isClose = false;
                }
            } else if (config.ctx[config.ctx.measureNames] < 0) {
                if (firstNegative === -1) {
                    firstNegative = i;
                    config.isClose = false;
                }
            } else {
                config.isZero = true;
            }
            if ((i + 1 < configs.length) &&
                ((config.rawData.hasOwnProperty("valueAxis") &&
                    configs[i+1].rawData.hasOwnProperty("valueAxis2")) ||
                (config.rawData.hasOwnProperty("valueAxis2") &&
                    configs[i+1].rawData.hasOwnProperty("valueAxis")))) {
                firstPositive = -1;
                firstNegative = -1;
            }
        }
    }

    // addrs is ONLY specified for stackedCombinaitonPlot customization.
    StackedColumnPlot.prototype._drawCategory = function(category, cpRenderer, newDataPoints) {
        var categoryG = category.node;
        var configs = category.configs;
        var data = category.data;
        var positions = category.positions;
        var currentIds = category.currentIds;
        var dataPoints = category.dataPoints;
        var dataModels = category.dataModels;
        var updateOnly = !!categoryG;
        var node;
        var config, position, ctx, stackWidth, stackHeight, x0, y0, x1, y1;
        var i;
        var isCustom = (cpRenderer !== this._dataPointRenderer && cpRenderer );
        var stackCtx = [], origGraphic, dataPointG;
        var extraData, value;
        stackCtx.range = [0, 0];
        if (!updateOnly) {
            categoryG = SVG.create("g");
            categoryG.setAttribute("class", Constants.CSS.CLASS.STACK);
        }
        if (isCustom) {
            for (i = 0; i < configs.length; i++) {
                config = configs[i];
                position = positions[i];
                if (i === 0) {
                    x0 = position.x;
                    y0 = position.y;
                    x1 = x0 + config.graphic.width;
                    y1 = y0 + config.graphic.height;
                } else {
                    if (config.horizontal) {
                        x0 = Math.min(x0, position.x);
                        x1 = Math.max(x1, position.x + config.graphic.width);
                    } else {
                        y0 = Math.min(y0, position.y);
                        y1 = Math.max(y1, position.y + config.graphic.height);
                    }
                }
            }
            stackWidth = x1 - x0;
            stackHeight = y1 - y0;

            for (i = 0; i < configs.length; i++) {
                config = configs[i];
                position = positions[i];
                origGraphic = ObjectUtils.extend({}, config.graphic);
                config.graphic.stackWidth = stackWidth;
                config.graphic.stackHeight = stackHeight;
                config.graphic.x = config.horizontal ? position.x - x0 : 0;
                config.graphic.y = config.horizontal ? 0 : position.y - y0;
                var defaultRendered = false;

                if (updateOnly) {
                    dataPointG = DataPointUtils.find(categoryG, currentIds[i]);
                    if (cpRenderer.update) {
                        cpRenderer.update(dataPointG, config, StackedBarRenderer.expose);
                    }

                } else {
                    node = cpRenderer(config, StackedBarRenderer.expose);
                    if (!node) {
                        node = this._dataPointRenderer(config, position);
                        defaultRendered = true;
                    }
                    dataPointG = SVG.create("g");
                    DataPointUtils.setDataId(dataPointG, currentIds[i]);
                    DataPointUtils.setDataPointId(dataPointG, dataPoints[i].id);
                    if(dataModels) {
                        dataModels[i].setNode(dataPointG);
                    }

                    ctx = config.ctx;
                    stackCtx.push(ctx);
                    DataGraphics.setContext(dataPointG, ctx);

                    value = ctx[ctx.measureNames];
                    if(value >= 0) {
                        stackCtx.range[1] += value;
                    } else {
                        stackCtx.range[0] += value;
                    }

                    extraData = data[i];
                    extraData.seriesIndex = dataPoints[i]._addr[1];
                    extraData.itemIndex = dataPoints[i]._addr[0];
                    DataGraphics.setData(dataPointG, extraData);

                    dataPointG.setAttribute("class", Constants.CSS.CLASS.DATAPOINT + ' ' +
                        Constants.CSS.CLASS.MORPHABLEDATAPOINT + ' ' + Constants.CSS.CLASS.DATAPOINTDEFAULT
                    );
                    dataPointG.appendChild(node);
                    categoryG.appendChild(dataPointG);
                    newDataPoints.push(dataPointG);
                }

                dataPointG.setAttribute("transform", 'translate(' + position.x + ', ' + position.y + ')');
                config.graphic = origGraphic;
                if( dataModels && dataModels[i] && !dataModels[i].getData()){
                    dataModels[i].init(config, currentIds[i], data[i],
                            dataPoints[i].id  ||  Constants.NULL_VALUE, null);
                }
            }

        } else {
            cpRenderer = this._dataPointRenderer;
            var clonedGraphic, shadowNode, cfg;
            updateConfigs.call(this, configs);
            for (i = 0; i < configs.length; i++) {
                clonedGraphic = undefined;
                shadowNode = undefined;
                config = configs[i];
                position = positions[i];
                cfg = {
                    isClose: config.isClose,
                    isNegative: config.ctx[config.ctx.measureNames] < 0,
                    isZero: config.isZero
                };
                if (updateOnly) {
                    dataPointG = DataPointUtils.find(categoryG, currentIds[i]);
                    if (cpRenderer.update) {
                        if (config.graphic.pattern === "noFill") {
                            config.path = this._generatePath(config.graphic, cfg);
                            if (config.isZero) {
                                config.graphic.pathStrokeWidth = 0;
                            } else {
                                config.graphic.pathStrokeWidth = 3;
                            }
                        }
                        cpRenderer.update(dataPointG, config);
                    }
                    if(dataModels && dataModels[i] && !dataModels[i].getData()){
                        newDataPoints.push(dataPointG);
                    }
                    this._updateStrokeWidth(dataPointG);
                } else {
                    if (config.graphic.pattern === "noFill") {
                        config.path = this._generatePath(config.graphic, cfg);
                        if (config.isZero) {
                            config.graphic.pathStrokeWidth = 0;
                        } else {
                            config.graphic.pathStrokeWidth = 3;
                        }
                        clonedGraphic = ObjectUtils.clone(config.graphic);
                        delete clonedGraphic.bgColor;
                        delete clonedGraphic.drawingEffect;
                        delete clonedGraphic.pattern;
                        clonedGraphic.fill = "transparent";
                    }
                    node = cpRenderer(config);
                    if (clonedGraphic) {
                        shadowNode = cpRenderer({graphic: clonedGraphic});
                    }

                    dataPointG = SVG.create("g");
                    DataPointUtils.setDataId(dataPointG, currentIds[i]);
                    DataPointUtils.setDataPointId(dataPointG, dataPoints[i].id);
                    if(dataModels){
                        dataModels[i].setNode(dataPointG);
                    }


                    ctx = config.ctx;
                    stackCtx.push(ctx);
                    DataGraphics.setContext(dataPointG, ctx);
                    DataGraphics.setAdditionCtx(dataPointG, config.additionCtx);

                    value = +ctx[ctx.measureNames];
                    if(value >= 0) {
                        stackCtx.range[1] += value;
                    } else {
                        stackCtx.range[0] += value;
                    }

                    extraData = data[i];
                    extraData.seriesIndex = dataPoints[i]._addr[1];
                    extraData.itemIndex = dataPoints[i]._addr[0];
                    extraData.strokeWidth = shadowNode ?
                        shadowNode.getAttribute("stroke-width") : node.getAttribute("stroke-width");

                    //Save pattern's URL
                    if(config.graphic && config.graphic.pattern){
                        if(config.graphic.pattern === 'noFill'){
                            extraData.pattern = 'noFill';
                        }else{
                            extraData.patternFill = node.getAttribute('fill');
                        }
                    }

                    DataGraphics.setData(dataPointG, extraData);

                    dataPointG.setAttribute("class", Constants.CSS.CLASS.DATAPOINT + ' ' +
                        Constants.CSS.CLASS.MORPHABLEDATAPOINT + ' ' + Constants.CSS.CLASS.DATAPOINTDEFAULT
                    );
                    dataPointG.appendChild(node);
                    if (shadowNode) {
                        dataPointG.appendChild(shadowNode);
                    }
                    categoryG.appendChild(dataPointG);
                    newDataPoints.push(dataPointG);

                }
                dataPointG.setAttribute("transform", 'translate(' + position.x + ', ' + position.y + ')');
                if(dataModels && dataModels[i] && !dataModels[i].getData()){
                    dataModels[i].init(config, currentIds[i], data[i],
                        dataPoints[i].id  ||  Constants.NULL_VALUE, null);
                }

            }
        }

        if (!updateOnly) {
            DataGraphics.setData(categoryG, stackCtx);
        }

        return categoryG;
    };

    /*
     * To fix bug BITSDC1-7944, PO changes the behavior for column chart.
     * StackedColumn chart overwrites this function to keep the old behavior and move up/left the negative columns/bars
     * 0.5px from the zero line.
     */
    StackedColumnPlot.prototype._adjustPosition = function(position, seriesIndex) {
        var horizontal = this.isHorizontal();
        if(horizontal && position.width < 0) {
            position.width = position.width > -1 ? 1 : Math.abs(position.width);
            position.x -= position.width + 0.5;
        }
        if (!horizontal && position.height < 0) {
            position.height = position.height > -1 ? 1 : Math.abs(position.height);
            position.y -= position.height + 0.5;
        }
    };

    StackedColumnPlot.prototype._additionalExtraData = function (extraData) {
        if (this._isFlexibleStack) {
            //build id for each "stack". extraData.itemIndex is category id, and this._barGroupIndices
            //means flexible stack order.
            extraData.flexibleStackId = (extraData.itemIndex).toString() +
                Constants.FLEXIBLE_STACK.ID_SEPARATOR +
                this._barGroupIndices[extraData.seriesIndex];
        }
    };

    StackedColumnPlot.prototype._getSeriesRenderer = function () {
        if (this._isFlexibleStack) {
            return new ComboExSeriesRenderer(this._renderSeries.bind(this), this._updateSeries.bind(this));
        }
    };

    XYPlotFactory.registerClazz("stacked_column", StackedColumnPlot);
    XYPlotFactory.registerClazz("stacked_bar", StackedColumnPlot);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,
            ChartConstants.STACKED_COLUMN, DataPointNavigator);
    return StackedColumnPlot;
});

define('sap/viz/chart/components/util/PercentageDataLabelUtil',[
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/TypeUtils'
],
    function Setup(DataPointUtils, UnitFormat, Constants, TypeUtils) {
        var PercentageDataLabelUtil = {
            getTypes : function(properties) {
                var type = properties.get('type');
                var result;
                if (type === 'valueAndPercentage' || type === 'valueAxisAndPercentage') {
                    result = ['value', 'percentage'];
                } else if (type === 'percentage') {
                    result = ['percentage'];
                } else {
                    //default type is "value"
                    result = ['value'];
                }
                return result;
            },
            mergeDataLabels : function(properties, formattedArray) {
                var type = properties.get('type');
                var dataLabelText;
                if(type === 'valueAndPercentage' || type === 'valueAxisAndPercentage') {
                    dataLabelText = formattedArray[1] ?
                        formattedArray[0] + " (" + formattedArray[1] + ")" : formattedArray[0];
                } else {
                    // default type is 'value'
                    dataLabelText = formattedArray[0];
                }
                return dataLabelText;
            },
            getDataLabelInfo : function(node, dataModel) {
                var ctx = DataPointUtils.getContextByDataModel(node, dataModel);
                return {
                    key: ctx.measureNames,
                    value: ctx[ctx.measureNames],
                    percentage: ctx.percentage
                };
            }
        };
        return PercentageDataLabelUtil;
    });
define('sap/viz/chart/components/datalabels/PercentageDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/datalabels/StackedDataLabels',
    'sap/viz/chart/components/util/PercentageDataLabelUtil'
], function(oo, DataLabels, StackedDataLabels, PercentageDataLabelUtil) {
    var PercentageDataLabels = function(ctx, options) {
        PercentageDataLabels.superclass.constructor.apply(this, arguments);
    };

    oo.extend(PercentageDataLabels, StackedDataLabels);
    
    PercentageDataLabels.prototype._getDataLabelInfo = function(node) {
        var dataModel = this._data && this._data.rawData && this._data.rawData.dataModel;
        return PercentageDataLabelUtil.getDataLabelInfo(node, dataModel);
    };
    
    PercentageDataLabels.prototype._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx,
        isMetaDataFormat, dp) {
        var value = dataLabelInfo.value;
        if(value === 0 && !this.drawZero(dp)) {
            return null;
        }
        return DataLabels.buildDataLabelText(this._properties, formatPatterns, dataLabelInfo,
                dataLabelCtx, isMetaDataFormat, PercentageDataLabelUtil.getTypes,
                PercentageDataLabelUtil.mergeDataLabels, null);
    };



    return PercentageDataLabels;
});
define('sap/viz/chart/components/plots/PercentagePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/ValueScale',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/plots/StackedColumnPlot',
    'sap/viz/chart/components/renderers/GridlineRenderer',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/datalabels/PercentageDataLabels',
    "sap/viz/chart/components/plots/XYPlotFactory"
], function Setup(oo,
        ValueScale,
        Constants,
        StackedColumnPlot,
        GridlineRenderer,
        DataHandler,
        PercentageDataLabels,
        XYPlotFactory) {

    /**
     * To initialize PercentagePlot object.
     *
     * @name PercentagePlot
     * @constructor
     */
    var PercentagePlot = function(runtime, options) {
        PercentagePlot.superclass.constructor.apply(this, arguments);
        this._isPercent = true;
    };

    oo.extend(PercentagePlot, StackedColumnPlot);

    PercentagePlot.prototype._getDataHandler = function() {
        if (this._options.isDualValueAxis) {
            return {
                "valueAxis": new DataHandler.getPercentageStackHandler(),
                "valueAxis2": new DataHandler.getPercentageStackHandler()
            };
        } else {
            return {
                "valueAxis": new DataHandler.getPercentageStackHandler()
            };
        }
    };

    PercentagePlot.prototype._total = function(itemIndex, data) {
        var valueAxis = data.hasOwnProperty("valueAxis2") ? this._data.valueAxis2 : this._data.valueAxis;
        var value = data.hasOwnProperty("valueAxis2") ? data.valueAxis2 : data.valueAxis;
        //When sum > 0 but value < 0 , skip this dataPoint
        if (value < 0 && valueAxis.categorySum[itemIndex] > 0) {
            return false;
        }
        valueAxis.scale.total(valueAxis.categorySum[itemIndex]);
        return true;
    };

    PercentagePlot.prototype._getPosition = function(seriesIndex, itemIndex, data) {
        var ret = this._total(itemIndex, data);
        if (!ret) {
            return null;
        }
        return PercentagePlot.superclass._getPosition.apply(this, arguments);
    };

    PercentagePlot.prototype._buildWrapperContext = function(data, context){
        var binding = data.hasOwnProperty('valueAxis') ? 'valueAxis'
                    : data.hasOwnProperty('valueAxis2') ? 'valueAxis2'
                    : null;
        if(binding){
            context.percentage = Math.abs(this._data[binding].scale.scale(data[binding]));
        }
        return context;
    };

    PercentagePlot.prototype._buildWrapperConfig = function(data, position, context, option){
        context = this._buildWrapperContext(data, context);
        return PercentagePlot.superclass._buildWrapperConfig.apply(this, [data, position, context, option]);
    };

    PercentagePlot.prototype._buildData = function(dpConfig) {
        var ret = PercentagePlot.superclass._buildData.apply(this, arguments);
        ret.percentageValue = dpConfig.ctx.percentage;
        return ret;
    };

    PercentagePlot.prototype._drawGridlines = function(parent) {
        var size = this._realSize;
        var isHorizontal = this.isHorizontal();
        var direction = isHorizontal ? Constants.DIRECTION.VERTICAL : Constants.DIRECTION.HORIZONTAL;
        var props = this._properties.proxy("gridline");
        var range = isHorizontal ? [0, size.width] : [size.height, 0];
        var scale = new ValueScale([0, 1], range);
        scale.setTickHint(this._data.valueAxis.tickHint);
        GridlineRenderer.drawValueGridline(parent, size.width, size.height, scale, props, direction,
            this._effectManager);
    };
    
    PercentagePlot.prototype._getDataLabels = function(name, runtime) {
        return new PercentageDataLabels(runtime, {
            name: name,
            horizontal: this.isHorizontal()
        });
    };
    XYPlotFactory.registerClazz("100_stacked_column", PercentagePlot);
    XYPlotFactory.registerClazz("100_stacked_bar", PercentagePlot);
    return PercentagePlot;
});

define('sap/viz/chart/components/util/LineSeriesUtil',[
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/renderers/LineRenderer',
    'sap/viz/chart/components/util/SeriesUtil'
], function(
    DataGraphics,
    SVG,
    DOM,
    TypeUtils,
    Constants,
    NameColorUtils,
    DataPointUtils,
    LineRenderer,
    SeriesUtil
) {

    var convertColor = NameColorUtils.convertColor;

    var COMB_LINE_ATTR_NAME = "combination-line";

    var CSS_CLASS = Constants.CSS.CLASS;

    var LINE_CLASS = CSS_CLASS.LINES + " " + CSS_CLASS.MORPHABLELINE;
    
    var LINE_TYPE = Constants.LINE_TYPE; 


    function prepareLineConfig(config, lineWidth, isHorizontal){
        config.graphic = {
            color: config.color,
            width: lineWidth
        };
        delete config.color;
        if (config.type === LINE_TYPE.DASHED || config.type === LINE_TYPE.DOTTED){
            config.graphic.dash = Constants.LINE_DASH_TYPE_ARRAY;
        }else if(config.type === Constants.LINE_TYPE.DOT) {
            config.graphic.dash = "0," + (lineWidth * 2);
            config.graphic.linecap="round";
        }
        delete config.type;
        config.isHorizontal = isHorizontal;
    }

    function renderLine(lineGroup, lineRenderer, config, ctx, isCombination, defaultLineRenderer){
        var lineTag = lineRenderer(config, defaultLineRenderer) || defaultLineRenderer.renderer(config);

        lineTag.setAttribute("class", LINE_CLASS);

        if(isCombination){
            lineTag.setAttribute(COMB_LINE_ATTR_NAME, "true");
        }

        DataGraphics.setData(lineTag, config.graphic);
        DataGraphics.setContext(lineTag, ctx);
        lineGroup.appendChild(lineTag);
    }

  
    
   
    
    function generateLineCandidates(data, semanticMgr, effectMgr, defaultColor, isNeedSimplifyLine, seriesType) {
        var candidates = [];
        var candidate = {
            points: []
        };
        var dataItem, dpConfig, nextDataItem, ctx, position, addCtx;
        var point, nextPoint, lastColor, currentColor, lastType, currentType;
        var length = data.length;
        for (var n = 0; n < length; n++) {
            dataItem = data[n];
            if (!dataItem || !dataItem.position) {
                if (candidate.points.length >= 2){
                    candidate.color = lastColor;
                    candidate.type = lastType;
                    candidates.push(candidate);
                }
                nextPoint = null;
                candidate = {
                    points: []
                };
                continue;
            }
            dpConfig = dataItem.dpConfig;
            position = dataItem.position;
            point = [
                position.x,
                position.y
            ];
            point.id = dpConfig.dataId;
            if (nextPoint == null){
                candidate.points.push(point);
            }
            ctx = [dpConfig.rawData.dp.context()];
            addCtx = [dpConfig.rawData.dp.additionCtx()];
            nextDataItem = data[n + 1];
            nextPoint = null;
            if (nextDataItem && nextDataItem.position){
                ctx.push(nextDataItem.dpConfig.rawData.dp.context());
                addCtx.push(nextDataItem.dpConfig.rawData.dp.additionCtx());
                position = nextDataItem.position;
                nextPoint = [
                    position.x,
                    position.y
                ];
                nextPoint.id = nextDataItem.dpConfig.dataId;
            }

            currentColor = effectMgr.register({
                fillColor: SeriesUtil.parseSemanticLineColor(ctx, semanticMgr, defaultColor, addCtx)
            });
            currentType = SeriesUtil.parseSemanticLineType(ctx, semanticMgr, seriesType, addCtx);

            if (candidate.points.length >= 2 && 
                // To keep the same effect as selected light line's dotted line style,
                // dotted lines would be drawn in seperated paths.
                // Otherwise, blanks between solid line would be dislocated.
                ((!isNeedSimplifyLine && (
                        lastType === LINE_TYPE.DASHED || 
                        lastType === LINE_TYPE.DOTTED ||
                        lastType === LINE_TYPE.DOT)) || 
                    lastColor !== currentColor || 
                    lastType !== currentType)
            ) {
                candidate.color = lastColor;
                candidate.type = lastType;
                candidates.push(candidate);
                nextPoint = null;
                candidate = {
                    points: [point]
                };
            } else if (nextPoint){
                candidate.points.push(nextPoint);
            }

            lastColor = currentColor;
            lastType = currentType;
        }
        if (candidate.points.length >= 2) {
            candidate.color = lastColor;
            candidate.type = lastType;
            candidates.push(candidate);
        }
        return candidates;
    }

    function getLinePoints(data){
        var position;
        var points = [], point;

        for (var n = 0; n < data.length; n++) {
            if (!data[n] || !data[n].position) {
                points.push('');
                continue;
            }
            position = data[n].position;
            point = [
                position.x,
                position.y
            ];
            point.id = data[n].dpConfig.dataId;
            points.push(point);
        }
        return points;
    }


    var utils = {
       

        drawLine: function(seriesG, data, semanticMgr, effectMgr, 
            seriesStyle, ctx, lineRenderer, isHorizontal, isNeedSimplifyLine, defaultLineRenderer) {
            var points = getLinePoints(data);

            var config = {
                points: points,
                isHorizontal: isHorizontal,
                ctx: ctx
            };

            if (lineRenderer.prepare){
                config = lineRenderer.prepare(config, defaultLineRenderer) || config;
            }

            var color = seriesStyle.color;
            var lineWidth = seriesStyle.lineWidth;
            var isCombination = seriesStyle.isCombination;

            var lineGroup = SVG.create("g");
            lineGroup.setAttribute("class", CSS_CLASS.LINES_GROUP);
            var seriesData = {
                color: color,
                width: lineWidth
            };
            if (seriesStyle.lineType === LINE_TYPE.DASHED || seriesStyle.lineType === LINE_TYPE.DOTTED){
                seriesData.dash = Constants.LINE_DASH_TYPE_ARRAY;
            }else if (seriesStyle.lineType === LINE_TYPE.DOT){
                seriesData.dash = "0," + (lineWidth * 2);
                seriesData.linecap="round";
            }
            DataGraphics.setData(lineGroup, seriesData);
            DataGraphics.setContext(lineGroup, ctx);

            var lineTag;
            if (semanticMgr.hasDataPointLineStyle() || seriesStyle.lineType === LINE_TYPE.DASHED  ||
                    seriesStyle.lineType === LINE_TYPE.DOTTED || seriesStyle.lineType === LINE_TYPE.DOT){
                // In case affecting standard performance case, using different code to judge semantic case.
                var candidates = generateLineCandidates(data, semanticMgr, effectMgr,
                        color, isNeedSimplifyLine, seriesStyle.lineType);
                candidates.forEach(function(config) {
                    prepareLineConfig(config, lineWidth, isHorizontal);
                    renderLine(lineGroup, lineRenderer, config, ctx, isCombination, defaultLineRenderer);
                });
            } else {
                config.graphic = seriesData;
                renderLine(lineGroup, lineRenderer, config, ctx, isCombination, defaultLineRenderer);
            }

            seriesG.insertBefore(lineGroup, seriesG.firstChild);
        },
        updateLine: function(seriesG, data, semanticMgr, effectMgr, 
            seriesStyle, ctx, lineRenderer, isHorizontal, isNeedSimplifyLine, defaultLineRenderer) {
            if (!TypeUtils.isFunction(lineRenderer.update)) {
                return false;
            }
            var points = getLinePoints(data);

            var config = {
                points: points,
                isHorizontal: isHorizontal,
                ctx: ctx
            };
            if (lineRenderer.prepare){
                config = lineRenderer.prepare(config, defaultLineRenderer) || config;
            }

            var color = seriesStyle.color;
            var lineWidth = seriesStyle.lineWidth;
            var isCombination = seriesStyle.isCombination;

            var lineTag;
            if (semanticMgr.hasDataPointLineStyle() || seriesStyle.lineType === LINE_TYPE.DASHED  ||
                    seriesStyle.lineType === LINE_TYPE.DOTTED || seriesStyle.lineType === LINE_TYPE.DOT ) {
                // In case affecting standard performance case, using different code to judge semantic case.
                var lineGroup = seriesG.querySelector("." + CSS_CLASS.LINES_GROUP);
                var lineTags = seriesG.querySelectorAll("." + CSS_CLASS.LINES);
                var candidates = generateLineCandidates(data, semanticMgr, effectMgr, color,
                        isNeedSimplifyLine, seriesStyle.lineType);
                candidates.forEach(function(config, i) {
                    prepareLineConfig(config, lineWidth, isHorizontal);
                    lineTag = lineTags[i];
                    if (lineTag) {
                        lineRenderer.update(lineTag, config, defaultLineRenderer);
                        DataGraphics.setData(lineTag, config.graphic);
                    } else {
                        renderLine(lineGroup, lineRenderer, config, ctx, isCombination, defaultLineRenderer);
                    }
                });
                for (var n = candidates.length; n < lineTags.length; ++n) {
                    DOM.remove(lineTags[n]);
                }
            } else {
                lineTag = seriesG.querySelector("." + CSS_CLASS.LINES);
                lineRenderer.update(lineTag, config, defaultLineRenderer);
            }
            return true;
        },
        linkLine: function(data) {
            var prevData = null;
            var prevDp;
            for (var i = 0; i < data.length; i++) {
                var curr = data[i];
                if (!curr || !curr.dataPoint) {
                    prevData = curr;
                    continue;
                }
                var ptData = DataGraphics.getData(curr.dataPoint);
                ptData.type = 'line';
                ptData.translate = curr.dpConfig.data.translate;
                if (prevData && prevData.dataPoint) {
                    prevDp = prevData.dataPoint;
                    ptData.prev = DataPointUtils.getDataPointId(prevDp);
                    DataGraphics.getData(prevDp).next = 
                        DataPointUtils.getDataPointId(curr.dataPoint);
                }
                prevData = curr;
            }
        }
       
    };
    return utils;
});

define('sap/viz/chart/components/renderers/SmoothLineRenderer',[
    "sap/viz/framework/common/util/SVG"
], function(
    SVG
) {

    var SmoothLineRenderGetter = function() {
        var controlPointsMap = {};

        var adjustControls = function(lastPointY, currentPointY, nextPointY, yValues) {
            var leftY = yValues.leftControlY;
            if (leftY > lastPointY && leftY > currentPointY) {
                leftY = yValues.leftControlY = Math.max(lastPointY, currentPointY);
                yValues.rightControlY = currentPointY * 2 - leftY;
            } else if (leftY < lastPointY && leftY < currentPointY) {
                leftY = yValues.leftControlY = Math.min(lastPointY, currentPointY);
                yValues.rightControlY = currentPointY * 2 - leftY;
            }

            var rightY = yValues.rightControlY;
            if (rightY > nextPointY && rightY > currentPointY) {
                rightY = yValues.rightControlY = Math.max(nextPointY, currentPointY);
                yValues.leftControlY = currentPointY * 2 - rightY;
            } else if (rightY < nextPointY && rightY < currentPointY) {
                rightY = yValues.rightControlY = Math.min(nextPointY, currentPointY);
                yValues.leftControlY = currentPointY * 2 - rightY;
            }
        };

        var calculateTwoControlPoints = function(lastPoint, currentPoint, nextPoint, isHorizontal) {
            //reference high chart "spline"
            //tensin is between 0 and 1. 
            var tension = 2.4; //2: the 1/2 of two points, 3: the 1/3 of two points,...

            var xIndex = 0;
            var yIndex = 1;
            if (isHorizontal) {
                xIndex = 1;
                yIndex = 0;
            }
            var lastPointX = lastPoint[xIndex];
            var lastPointY = lastPoint[yIndex];

            var nextPointX = nextPoint[xIndex];
            var nextPointY = nextPoint[yIndex];

            var currentPointX = currentPoint[xIndex];
            var currentPointY = currentPoint[yIndex];

            var leftControlX = ((tension - 1) * currentPointX + lastPointX) / tension;
            var leftControlY = ((tension - 1) * currentPointY + lastPointY) / tension;

            var rightControlX = ((tension - 1) * currentPointX + nextPointX) / tension;
            var rightControlY = ((tension - 1) * currentPointY + nextPointY) / tension;

            var yOffset = ((rightControlY - leftControlY) * (rightControlX - currentPointX)) /
                (rightControlX - leftControlX) + currentPointY - rightControlY;

            var yValues = {};
            yValues.leftControlY = leftControlY + yOffset;
            yValues.rightControlY = rightControlY + yOffset;
            //to make sure lines will not be out of data points "area"
            adjustControls(lastPointY, currentPointY, nextPointY, yValues);

            var controlPoints = controlPointsMap[currentPoint.id];
            controlPoints.leftControl[xIndex] = leftControlX;
            controlPoints.leftControl[yIndex] = yValues.leftControlY;

            controlPoints.rightControl[xIndex] = rightControlX;
            controlPoints.rightControl[yIndex] = yValues.rightControlY;
        };

        var ordinaryControls = function(point) {
            var id = point.id;
            var controlPoints = controlPointsMap[id];
            if (!controlPoints) {
                controlPoints = controlPointsMap[id] = {};
            }
            ["leftControl", "rightControl"].forEach(function(field) {
                controlPoints[field] = point.slice();
            });
        };

        var buildControlPoints = function(points, isHorizontal) {
            var current, before, after, right, left;
            for (var i = 0, len = points.length; i < len; ++i) {
                current = points[i];
                if (!current) {
                    continue;
                }
                ordinaryControls(current);
                before = points[i - 1];
                after = points[i + 1];
                if (i > 0 && before && after) {
                    calculateTwoControlPoints(before, current, after, isHorizontal);
                }
            }
            return points;
        };

        var outputInterpolatedPath = function (points) {
            var current, before, after, right, left;

            var d = "";
            var restart = true;
            for (var i = 0, len = points.length; i < len; i++) {
                current = points[i];
                if (!current) {
                    restart = true;
                    continue;
                }
                before = points[i - 1];

                if(restart) {
                    d += "M";
                    d += current[0] + "," + current[1];
                } else {
                    right = controlPointsMap[before.id].rightControl;
                    left = controlPointsMap[current.id].leftControl;
                    d += "C";
                    d += right[0] + "," + right[1] + " ";
                    d += left[0] + "," + left[1] + " ";
                    d += current[0] + "," + current[1];
                }
                restart = false;
            }
            return d;
        };

        var generatePath = function(config){
            var points = config.points;
            var resPath;
            var pointCandidates = (config == null || config.isHorizontal == null) ? 
                    points : SVG.simplifyPoints(points, config);
            //pointCandidates === points means no points are "simplified".
            if(pointCandidates === points) {
                resPath = outputInterpolatedPath(pointCandidates);
            } else {
                resPath = SVG.outputPath(pointCandidates);
            }
            return resPath;
        };

        var SmoothLineRender = function(config) {

            var graphic = config.graphic;

            var path = SVG.create("path");

            path.setAttribute("d", generatePath(config));
            path.setAttribute("fill", "none");
            path.setAttribute("stroke-linejoin", "round");
            path.setAttribute("stroke", graphic.color);
            path.setAttribute("stroke-width", graphic.width);
            if (graphic.dash){
                path.setAttribute("stroke-dasharray", graphic.dash);
            }
            if(graphic.linecap){
                path.setAttribute("stroke-linecap", graphic.linecap);
            }
            return path;
        };

        SmoothLineRender.prepare = function(config) {
            // controlPointsMap = {};
            buildControlPoints(config.points, config.isHorizontal);
            return config;
        };

        SmoothLineRender.update = function(node, config) {
            node.setAttribute("d", generatePath(config));
            if (config.graphic) {
                var graphic = config.graphic;
                if (graphic.color) {
                    node.setAttribute("stroke", graphic.color);
                }
                if (graphic.width) {
                    node.setAttribute("stroke-width", graphic.width);
                }
                if (graphic.dash) {
                    node.setAttribute("stroke-dasharray", graphic.dash);
                } else {
                    node.removeAttribute("stroke-dasharray");
                }
                
                if(graphic.linecap){
                    node.setAttribute("stroke-linecap", graphic.linecap);
                }else{
                    node.removeAttribute("stroke-linecap");
                }
                
            }
        };

        SmoothLineRender.expose = {
            renderer: SmoothLineRender,
            prepare: SmoothLineRender.prepare,
            update: SmoothLineRender.update
        };

        return SmoothLineRender;
    };

    // Why we need a getter?
    // Since in this renderer contains some local status related to each instance. 
    // Return a closure for each instance in case there exist conflicts.
    return SmoothLineRenderGetter;
});
define('sap/viz/chart/components/util/LineRendererUtil',[
    'sap/viz/chart/components/renderers/LineRenderer',
    'sap/viz/chart/components/renderers/SmoothLineRenderer'
], function(
    LineRenderer,
    SmoothLineRenderer
) {
    var getRenderer = function (customRenderer, isInterpolated){
        var ret = customRenderer;
        if (ret){
            return ret;
        } else {
            if (isInterpolated){
                ret = SmoothLineRenderer();
            } else {
                ret = LineRenderer();
            }
        }
        return ret;
    };

    var getDefaultRenderer = function (isInterpolated) {
        return isInterpolated ? SmoothLineRenderer() : LineRenderer();
    };

    return {
        getRenderer: getRenderer,
        getDefaultRenderer: getDefaultRenderer
    };
});
define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForLine',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/ChartTypeUtils",
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/interaction/Constants',
    'sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler',
    "sap/viz/framework/interaction/BehaviorManager"
], function(
    Constants,
    TypeUtils,
    HighlightHelper,
    DataGraphics,
    ChartTypeUtils,
    ObjectUtils,
    DataPointUtils,
    SDKConstants,
    DPBhvrHdlr,
    BehaviorManager
) {

    var timeLineType = ["info/timeseries_line"];
    var timeCombTypes = ["info/timeseries_combination",
                         "info/dual_timeseries_combination",
                         "info/timeseries_stacked_combination"];
    var TimeLineAndComb = timeLineType.concat(timeCombTypes);

    var lineType2 = [
        "info/line", "info/horizontal_line",
        "info/dual_line", "info/dual_horizontal_line",
        "info/combination", "info/horizontal_combination",
        "info/dual_combination", "info/dual_horizontal_combination",
        "info/stacked_combination", "info/horizontal_stacked_combination",
        "info/dual_stacked_combination", "info/dual_horizontal_stacked_combination"
    ].concat(timeLineType);
    lineType2 = ChartTypeUtils.addTrellisType(lineType2);

    var lineType = lineType2.concat(timeCombTypes);
    lineType = ChartTypeUtils.addTrellisType(lineType);

    var CSS_CLASS = Constants.CSS.CLASS;

    var DP_LAYER = "datapoint";
    var setMakerOpacity = DPBhvrHdlr.setMakerOpacity;

    var line = [{
        "id": "selectDataPoint_line",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": lineType2,
        },
        "handler": function(event, service) {
            if (service.isBigDataMode()) {
                DPBhvrHdlr.selectOnLineDuringBigData(event, service);
            } else {
                DPBhvrHdlr.selectOnLineOnNormalMode(event, service);
            }
        }
    }, {
        "id": "deselectDataPoint_line",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": lineType2
        },
        "handler": function(event, service) {
            if (service.isBigDataMode()) {
                return;
            }
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            var properties = service.getProperties();
            var lineRenderer;
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            elements.forEach(function(e) {
                DataPointUtils.unhighlight(e);
                lineRenderer = DPBhvrHdlr.getLineRenderer(service, e);
                DPBhvrHdlr.renderLightLine(service, e, false, lineRenderer);
                var width = 1;
                var extraData = DataGraphics.getData(e) || {};
                if (event.data.isAnyOtherSelected) {
                    prop = properties.get('interaction.deselected');
                } else {
                    prop = properties.get('plotArea.dataPoint');
                    if (extraData) {
                        width = extraData.strokeWidth;
                    }
                }
                var bSetChildOpacity = !extraData.isZeroValue;
                HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, width, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRendererExist, bSetChildOpacity);
                setMakerOpacity(service, e);
            });
        }
    }, {
        "id": "hoverOnDataPoint_line",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": lineType2
        },
        "handler": function (event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                DPBhvrHdlr.highlightOnLineDuringBigData(event, service);
            }
            else {
                service.fireEvent(event, true);
                var elements = HighlightHelper.turnToArray(event.data.targets);
                var properties = service.getProperties();
                var prop = properties.get('interaction.hover');
                var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
                elements.forEach(function (e) {
                    var extraData = DataGraphics.getData(e) || {};
                    var bSetChildOpacity = !extraData.isZeroValue;
                    HighlightHelper.drawStroke(service, e, event.data.byKeyboard ? 'path' : 'path, rect',
                        prop.stroke, 2, undefined, extraData);
                    HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRenderExist, bSetChildOpacity);
                });
            }
        }
    }, {
        "id": "unhoverOnDataPoint_line",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": lineType2
        },
        "handler": function (event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                DPBhvrHdlr.unhighlightOnLineDuringBigData(event, service);
            } else {
                service.fireEvent(event, true);
                var elements = HighlightHelper.turnToArray(event.data.targets);
                var props = service.getProperties();
                var prop;
                var isMarkerRenderExist = TypeUtils.isExist(props.get('plotArea.markerRenderer'));
                elements.forEach(function (e) {
                    var visible;
                    var width = 1;
                    var extraData = DataGraphics.getData(e) || {};
                    if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                        prop = props.get('interaction.selected');
                        visible = true;
                    } else {
                        if (service.shouldUseDeselectedColor()) {
                            prop = props.get('interaction.deselected');
                        } else {
                            prop = props.get('plotArea.dataPoint');
                            if (extraData) {
                                width = extraData.strokeWidth;
                            }
                        }
                        visible = false;
                    }
                    var bSetChildOpacity = !extraData.isZeroValue;
                    HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, width);
                    HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRenderExist, bSetChildOpacity);
                    if (!visible) {
                        setMakerOpacity(service, e);
                    }
                });
            }
        }
    }, {
        "id": "clearPlot_line",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": lineType2
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            service._getDecorationLayer().clear();

            var gray = event.data.isGray;
            var rangeSelection = event.data.rangeSelection;
            var bUseRange = rangeSelection && rangeSelection !== "clear";
            var properties = service.getProperties();
            var prop = properties.get('interaction.deselected');

            DPBhvrHdlr.cleanLine(event, service);

            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if (!mainNode || !mainNode.length) {
                return;
            }
            var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            mainNode.forEach(function(e) {
                var width = 1;
                var extraData = DataGraphics.getData(e) || {};
                if (gray || bUseRange) {
                    prop = properties.get('interaction.deselected');
                    if (bUseRange) {
                        prop = ObjectUtils.extend(true, {}, prop);
                        prop.opacity = 1;
                    }
                } else {
                    prop = properties.get('plotArea.dataPoint');
                    if (extraData) {
                        width = extraData.strokeWidth;
                    }
                }
                var bSetChildOpacity = !extraData.isZeroValue;
                HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, width, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRenderExist, bSetChildOpacity);
                setMakerOpacity(service, e);
            });
        }
    },{
        "id": "hover_range_selection_line",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": TimeLineAndComb,
            "targets": "v-m-action-layerrange"
        },
        "handler": function(event, service) {
            DPBhvrHdlr.showDetailForRangeSelectionWhenHover(event, service);
        }
    }, {
        "id": "hover_on_plot_time_line",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeLineType,
            "targets": "v-m-plot"
        },
        "handler": function(event, service) {
            DPBhvrHdlr.hoverOnLineDuringBigData(event, service);
        }
    }, {
        "id": "hover_on_non_plot_time_line",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeLineType,
            "excludeTargets": ["v-m-plot", Constants.CSS.CLASS.DATAPOINTS_MODULE]
        },
        "handler": function(event, service) {
            if (service.getStatus("rangeSelection")) {
                return;
            }
            service._getActionLayer().clear(DP_LAYER);
            service._getDecorationLayer().clear(DP_LAYER);
            service.fireEvent("hideTooltipHoverOnPlot", {
                mode: "infoMode"
            });
        }
    }, {
        "id": "hover_on_non_datapoint_time_line",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeLineType,
            "excludeTargets": [CSS_CLASS.DATAPOINT, CSS_CLASS.DATALABEL]
        },
        "handler": function(event, service) {
            if (service.isBigDataMode() || service.getStatus("rangeSelection")) {
                return;
            }
            service.fireEvent(event, true);
        }
    }, {
        "id": "click_on_non_selection_line",
        "triggerEvent": {
            "name": "click",
            "supportedChartTypes": lineType,
            "excludeTargets": HighlightHelper.getDeselAllExTargets(),
        },
        "handler": function(event, service) {

            if(!service.getProperties().get("interaction.enableDeselectAll")){
                return;
            }
            // For time combination chart in big data mode, we process in "click_on_time_comb_during_big_data" already
            if (service.isBigDataMode() && timeCombTypes.indexOf(service._getChartType()) > -1 ) {
                return;
            }

            if(TimeLineAndComb.indexOf(service._getChartType()) > -1){
                DPBhvrHdlr.clickOnLineDuringBigData(event, service);
            }else{
                service.fireEvent(event, true);
            }

        }
    }, {
        "id": "clearPlot_timeseries_line",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": TimeLineAndComb
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            if (!event.data.rangeSelection) {
                service._getDecorationLayer().clear();
                service._getActionLayer().clear();
            }
        }
    }, {
        "id": "update_range_selection_effect_line",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "down",
            "supportedChartTypes": TimeLineAndComb
        },
        "handler": function(event, service) {
            DPBhvrHdlr.updateRangeEffect(event, service);
        }
    }, {
        "id": "recover_range_selection_effect_line",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "up",
            "supportedChartTypes": TimeLineAndComb
        },
        "handler": function(event, service) {
            DPBhvrHdlr.recoverRangeEffect(event, service);
        }
    }];

    BehaviorManager.registerAll(line);
    return line;
});
define('sap/viz/chart/components/plots/BaseLinePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/plots/BaseColumnPlot',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/util/LineSeriesUtil',
    'sap/viz/chart/components/renderers/LineRenderer',
    'sap/viz/chart/components/util/LineRendererUtil',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/chart/behavior/config/DataPointBehaviorConfigForLine"
], function Setup(
    oo,
    Constants,
    BaseColumnPlot,
    DOM,
    DataGraphics,
    NameColorUtils,
    ContextBuilder,
    DataPointUtils,
    SeriesUtil,
    LineRenderer,
    LineRendererUtil,
    SVG,
    TypeUtils
) {
    var CSS_CLASS = Constants.CSS.CLASS;

    var BaseLinePlot = function(runtime, options) {
        BaseLinePlot.superclass.constructor.apply(this, arguments);
        this._lineRenderer = null;
        this._defaultLineRenderer = LineRendererUtil.getDefaultRenderer(this._properties.get("isSmoothed"));
    };

    oo.extend(BaseLinePlot, BaseColumnPlot);
    
    BaseLinePlot.prototype.destroy = function(){
        BaseLinePlot.superclass.destroy.apply(this, arguments);
        this._lineRenderer = null;
        this._dpPlotNode = null;
        this._dpParentNode = null;
        this._extendSize = null;
    };

    BaseLinePlot.prototype.getLineRenderer = function(){
        if (!this._lineRenderer){
            this._lineRenderer = LineRenderer();
        }
        return this._lineRenderer;
    };

    BaseLinePlot.prototype.getDefaultLineRenderer = function(){
        return this._defaultLineRenderer;
    };

    BaseLinePlot.prototype._preRender = function() {
        BaseLinePlot.superclass._preRender.apply(this, arguments);
        this._generateMarkerPath();
        this._lineRenderer = null;
    };

    BaseLinePlot.prototype._createMainNode = function(selectionNode) {
        var node = BaseLinePlot.superclass._createMainNode.apply(this, arguments);        
        if (this._extendSize) {
            this._dpPlotNode = selectionNode.parentNode.querySelector("." + 
                Constants.CSS.CLASS.DATAPOINTS_MODULE);
            var dataPointNodes = this._dpPlotNode;
            dataPointNodes.setAttribute("transform", selectionNode.getAttribute("transform"));
                
            var dpPlotNodes = selectionNode.parentNode.querySelector("." + 
                               Constants.CSS.CLASS.DATAPOINTS_PLOT);
            if (!dpPlotNodes) {
                dpPlotNodes = SVG.create("g", dataPointNodes);
                dpPlotNodes.setAttribute("class", Constants.CSS.CLASS.DATAPOINTS_PLOT); 
            }
            this._dpParentNode = d3.select(dpPlotNodes);
            node.dpPlotNodes = dpPlotNodes;
            
            if (!this._options.disableClipPath && !this._notNeedClippath) {
                dataPointNodes.setAttribute("clip-path", "url(#" + 
                    this.clipPath.getAttribute("id") + ")");
            }
        }
        return node;
    };

    var calculateRawLineRange = function(series, dataModel, getDataShape) {
        var range = {
            "valueAxis" : [Infinity, -Infinity],
            "valueAxis2" : [Infinity, -Infinity]
        };

        var valueAxisRange = {};
        valueAxisRange.valueAxis = dataModel._valueAxis && dataModel._valueAxis.lineRawRange;
        valueAxisRange.valueAxis2 = dataModel._valueAxis2 && dataModel._valueAxis2.lineRawRange;

        for (var s = 0; s < series.length; s++) {
            if ((!getDataShape || getDataShape(s) === "line") && series[s][0]) {
                var k = series[s][0].hasOwnProperty("valueAxis") ? "valueAxis" : "valueAxis2";
                var c = series[s][0].hasOwnProperty("valueAxis") ? "color" : "color2";
                var mndIndex = series[s][0][c] ? 
                    (TypeUtils.isExist(series[s][0][c].mndIndex) ? series[s][0][c].mndIndex : 0 ) : 0;
        
                range[k][1] = range[k][1] < valueAxisRange[k][mndIndex][1] ? 
                    valueAxisRange[k][mndIndex][1] : range[k][1];

                range[k][0] = range[k][0] > valueAxisRange[k][mndIndex][0] ? 
                    valueAxisRange[k][mndIndex][0] : range[k][0];
                
            }       
        }

        return range;
    };

    BaseLinePlot.prototype._getClipPathAttribute = function(width, height, scale, data) {
        var extendSize, newSizeProp;
        var newWidth = width + 1, newHeight = height + 1, 
            xTranslate = 0, yTranslate = 0;
        var isHorizontal = this.isHorizontal(),
            sizeProp = isHorizontal ? width : height;
        
        if (!this.isBigDataMode() && this._data.rawData && this._data.rawData.dataModel && 
            !this._isInTrellis &&
            (this.runtime().propertyManager().get("valueAxis.layout.direction") !== "topDown")) {
            var indexInfo = [], key, valueScale, domain, domainFixed, isFixed;
            //Compute whether need to extend clipPath according to the raw domain.
            var length = this._options && this._options.isDualValueAxis ? 2 : 1;
            var isValueAxis2 = this._options && this._options.valueAxisIndex === "valueAxis2";
            for (var i = 0; i < length; i++) { 
                var index = -1;
                key = "valueAxis" + (i || isValueAxis2 ? "2" : "");
                valueScale = data[key].scale;
                domain = valueScale.getDomain();
                domainFixed = valueScale.getDomainFixed();
                isFixed = valueScale.isFixed();
                if (domain[0] >= 0 && !(isFixed && domainFixed[0])) {
                    index = 0;
                } else if (domain[1] <= 0 && !(isFixed && domainFixed[1])) {
                    index = 1;
                }
                if (index !== -1 && domain[index] !== 0 && 
                    !valueScale.getZeroAdjusted()) {
                    index = -1;
                }
                indexInfo.push(index);
            }
            // Compute the size of extended clipPath.
            if (indexInfo.indexOf(-1) === -1 && (length === 1 || indexInfo[0] === indexInfo[1]) 
                ) {
                var max = 0, domains, range;
                var lineMarkerSize = this._properties.get(this._markerPropName + ".size");
                var temp = lineMarkerSize / 2 + 2;
                if (temp > 8) {
                    temp = 8;
                }

                var rawLineRange = calculateRawLineRange(this._getSeries(), this._data.rawData.dataModel, 
                    this._getDataShape ? this._getDataShape.bind(this) : null);
                 
                for (var j = 0; j < length; j++) { 
                    key = "valueAxis" + (j || isValueAxis2 ? "2" : "");
                    domains = data[key].scale.getDomain();
                    range = data[key].scale.getRange();
                    var currentOffset = (Math.abs((domains[1] - domains[0]) * temp / 
                            (sizeProp*(range[1] - range[0]))) - 
                            Math.abs(rawLineRange[key][indexInfo[j]])) /
                            ((domains[1] - domains[0]) * (range[1] - range[0]));
                    if (currentOffset > 0) {
                        max = Math.max(max, currentOffset);
                    }
                }
                this._extendSize = extendSize = max * sizeProp;
                // condition: chart only can zoom in "x" direction.
                if (extendSize && scale && 
                    ((!isHorizontal && (scale.y === 1 ||!scale.y)) ||
                    (isHorizontal && (scale.x === 1 ||!scale.x)))) {
                    newSizeProp = sizeProp + 1 + extendSize;
                    if (this.isHorizontal()) {
                        newWidth = newSizeProp;
                    } else {
                        newHeight = newSizeProp;
                    }
                    if (indexInfo[0] === 0 && isHorizontal) {
                        xTranslate = -extendSize;
                    } else if (indexInfo[0] === 1 && !isHorizontal) {
                        yTranslate = -extendSize;
                    }
                }
            }
        }
        return {
            y: -1,
            width: newWidth,
            height: newHeight,
            transform: 'translate(' + xTranslate + ', ' + yTranslate +')'
        };
    };

    BaseLinePlot.prototype.zoom = function(scale) {
        if (this.clipPath && scale) {
            this._setClipPathAttribute(this.clipPath.querySelector("rect"), 
                this._size.width, this._size.height, scale, this._data);
        }
        BaseLinePlot.superclass.zoom.apply(this, arguments);
    };

    BaseLinePlot.prototype.scroll = function() {
        BaseLinePlot.superclass.scroll.apply(this, arguments);
        if (!this._isInTrellis && this._dpParentNode && this._plotDpParentNode) {
            this._dpParentNode.attr("transform", 
                this._plotDpParentNode.attr("transform"));
        }
    };

    BaseLinePlot.prototype._hideDataPoints = function(dataPoints, visibleRange){
        for (var i in dataPoints) {
            if (dataPoints.hasOwnProperty(i)) {
                this._hideNode(dataPoints, i);
            }
        }

        this._lightLineOutOfRange(dataPoints, visibleRange);
    };

    BaseLinePlot.prototype._lightLineOutOfRange = function(dataPoints, visibleRange) {
        var outOfRange = function(index) {
            var j, dataPointModel;
            for(j = 0; j < visibleRange.min; j++){
                dataPointModel = dataPoints[j];
                if(dataPointModel && dataPointModel.getDataId() === index) {
                    return true;
                }
            }
            for(j = visibleRange.max + 1; j < dataPoints.length; j++){
                dataPointModel = dataPoints[j];
                if(dataPointModel && dataPointModel.getDataId() === index) {
                    return true;
                }
            }
            return false;
        };
        var lightLineNodes = this._selection.selectAll("." + CSS_CLASS.LIGHT_LINE)[0];
        for(var i = 0; i < lightLineNodes.length; i++) {
            var lightLineNode = lightLineNodes[i];
            var from = parseInt(lightLineNode.getAttribute('data-from'));
            var to = parseInt(lightLineNode.getAttribute('data-to'));
            if(outOfRange(from) && outOfRange(to)) {
                DOM.remove(lightLineNode);
            }
        }
    };
    
    BaseLinePlot.prototype._drawDataPoint = function(dpRenderer, dataPoint) {
        var dp = BaseLinePlot.superclass._drawDataPoint.apply(this, arguments);
        var dpData = dataPoint.getData();
        dpData.shape = this._getMarkerShape();
        DataGraphics.setData(dp, dpData);
        return dp;
    };
    
    BaseLinePlot.prototype._buildWrapperConfig = function(data, position, context, options) {
        var config = BaseLinePlot.superclass._buildWrapperConfig.apply(this, arguments);
        config.graphic.shape = this._getMarkerShape();
        return config;
    };
    
    BaseLinePlot.prototype._renderNode = function(dpRender, dpConfig, dataPointG, extraData){
        var saved = dpConfig.graphic.d;
        if(dpConfig.graphic.pattern === "noFill" && this._markerShadow){
            dpConfig.graphic.d = this._markerShadow;
        }
        var node = BaseLinePlot.superclass._renderNode.apply(this, arguments);
        dpConfig.graphic.d = saved;
        return node;
    };

    BaseLinePlot.prototype.update = function() {
        BaseLinePlot.superclass.update.apply(this, arguments);
        this._updateLightLine();
    };

    BaseLinePlot.prototype._updateLightLine = function() {
        if (!this._selection) {
            return;
        }
        var container = this._getDpPlotNode(),
            lightLines = container.querySelectorAll("." + CSS_CLASS.LIGHT_LINE);

        var lineRenderer = this.getLineRenderer();
        var isHorizontal = this.isHorizontal();

        [].forEach.call(lightLines, function(lineNode) {
            var fromId = lineNode.getAttribute("data-from");
            var nodeFrom = DataPointUtils.findByDataPointId(container, lineNode.getAttribute("data-from"));
            var toId = lineNode.getAttribute("data-to");
            var nodeTo = DataPointUtils.findByDataPointId(container, lineNode.getAttribute("data-to"));
            if (!nodeFrom || !nodeTo) {
                DOM.remove(lineNode);
            } else {
                var pointsToLink = [
                    DataGraphics.getData(nodeFrom).translate.slice(),
                    DataGraphics.getData(nodeTo).translate.slice()
                ];
                pointsToLink[0].id = fromId;
                pointsToLink[1].id = toId;
                var config = {
                    points: pointsToLink,
                    isHorizontal: isHorizontal
                };
                if (lineRenderer && lineRenderer.update){
                    lineRenderer.update(lineNode.firstChild, config);
                }
            }
        });
    };
    
    function validLineWidth(value) {
        value = parseInt(value, 10);
        return (value >= 0 && value <= 7) ? value : 2;
    }

    BaseLinePlot.prototype.getSeriesDPStyle = function(seriesIndex, context) {
        var isLine = !(this._options.renderType && 
                this._options.renderType.indexOf("combination") > -1 &&
                this._seriesType && this._seriesType[seriesIndex] === "bar");
        
        var seriesStyle = BaseLinePlot.superclass.getSeriesDPStyle.call(this, seriesIndex, context, isLine);
        // For line series, only two patterns are supported
        return seriesStyle;
        
    };
    var PATTERNVALS = ["diagonalLightStripe", "diagonalStripe", "reverseDiagonalStripe"];
    BaseLinePlot.prototype._getPatternConfig = function(config, context, options) {
        var isLine = !(this._options.renderType && 
               this._options.renderType.indexOf("combination") > -1 &&
               options.seriesType === "bar");
        config = BaseLinePlot.superclass._getPatternConfig.apply(this, arguments);
        if(isLine && config.graphic.pattern && PATTERNVALS.indexOf(config.graphic.pattern) > -1){
            config.graphic.pattern = null;
        }
        return config;
    };

    BaseLinePlot.prototype.getSeriesStyle = function(seriesIndex, context) {
        var semanticMgr = this._semanticMgr;
        var props = this._properties;
        var effectMgr = this._effectManager;
        context = context || ContextBuilder.buildSeriesLineContext(this._data, seriesIndex);

        var semanticProps = semanticMgr.analyzeSeriesStyle(context, "line");

        var lineWidth;
        if (semanticProps && semanticProps.line && semanticProps.line.width != null) {
            lineWidth = semanticProps.line.width;
        } else {
            lineWidth = props.has("line.width") ? props.get('line.width') : props.get('width');
        }
        lineWidth = validLineWidth(lineWidth);

        var color;
        if (semanticProps && semanticProps.line && semanticProps.line.color != null) {
            color = semanticProps.line.color;
        } else if (
            (semanticMgr.hasDataPointColorStyle() || semanticMgr.hasDataPointLineStyle()) && 
            semanticMgr.isOverrideMode() && semanticMgr.shouldChangeColor()) {
            color = semanticMgr.getOthersStyle("color").properties.color;
        } else {
            var seriesInfo = ContextBuilder.getSeriesScaleInfo(this._data, seriesIndex, ["color", "color2"]);
            if (seriesInfo){
                color = this._data[seriesInfo.field].scale.scale(seriesInfo.domain);
            } else {
                //If color is not bind, use default single color instead.
                color = this._getDefaultColor();
            }
        }
        color = effectMgr.register({
            fillColor: NameColorUtils.convertColor(color)
        });
        var lineType;
        if(semanticProps && semanticProps.line && semanticProps.line.type)
        {
            lineType = semanticProps.line.type;
        }
        return {
            color: color,
            lineWidth: lineWidth,
            lineType:lineType
        };
    };

    BaseLinePlot.prototype._getDefaultColor = function(){
        return (this._data.color || this._data.color2).scale.getRange()[0];
    };
    
    BaseLinePlot.prototype._isNeedSimplifyLine = function(){
        return this._isBigData;
    };


    BaseLinePlot.prototype._drawLine = function(seriesG, data, seriesIndex, isUpdate) {
        if (!this._isLineVisible()) {
            return;
        }
        var context = ContextBuilder.buildSeriesLineContext(this._data, seriesIndex);
        var seriesStyle = this.getSeriesStyle(seriesIndex, context);
        var lineRenderer = this.getLineRenderer();
        var semanticMgr = this._semanticMgr;
        var effectMgr = this._effectManager;
        var isHorizontal = this.isHorizontal();
        var isNeedSimplifyLine = this._isNeedSimplifyLine();
        var updated = false;
        if (isUpdate){
            updated = SeriesUtil.updateLine(seriesG, data, semanticMgr, effectMgr,
                seriesStyle, context, lineRenderer, isHorizontal, isNeedSimplifyLine, this._defaultLineRenderer.expose);
        }
        if (!updated){
            d3.select(seriesG).select("." + CSS_CLASS.LINES_GROUP).remove();
            SeriesUtil.drawLine(seriesG, data, semanticMgr, effectMgr,
                seriesStyle, context, lineRenderer, isHorizontal, isNeedSimplifyLine, this._defaultLineRenderer.expose);
        }
        if (!isNeedSimplifyLine) {
            SeriesUtil.linkLine(data);
        }
    };

    BaseLinePlot.prototype._updateLine = function(seriesG, data, seriesIndex) {
        this._drawLine(seriesG, data, seriesIndex, true);
    };

    BaseLinePlot.prototype._isLineVisible = function (){
        return this._properties.get('lineVisible');
    };

    return BaseLinePlot;
});

define('sap/viz/chart/components/renderers/PathRenderer',["sap/viz/framework/common/util/SVG",
    'sap/viz/framework/common/util/DataGraphics'], function(SVG, DataGraphics) {
    var pathRenderer = function(config) {
        var node = SVG.create("path");
        var graphic = config.graphic;
        if(graphic.d){
            node.setAttribute("d", graphic.d);
        }
        var fill = graphic.fill;
        var stroke = graphic.stroke ;
        var drawingEffect = graphic.drawingEffect;
        var strokeWidth = graphic.strokeWidth;
        if(graphic.pattern === 'noFill'){
            drawingEffect = null;
            fill =  graphic.bgColor;
            stroke = graphic.fill;
            strokeWidth = 2;
        }
        if(config.effectManager){
            fill = config.effectManager.register({
                drawingEffect: drawingEffect,
                fillColor: fill,
                patternEffect: graphic.pattern !== 'noFill' ? graphic.pattern : null ,
                graphType : graphic.shape
            });
        }

        node.setAttribute("fill", fill);
        var opacity = (graphic.opacity >= 0 && graphic.opacity <= 1) ? graphic.opacity : 1;
        if(opacity !== 1) {
            node.setAttribute("fill-opacity", opacity);
            node.setAttribute("stroke-opacity", opacity);
        }
        
        if(stroke) {
            node.setAttribute('stroke', stroke);
            node.setAttribute('stroke-width', strokeWidth);
        }
        DataGraphics.setCustomizationInfo(node, {'defaultRenderer' : true});
        return node;
    };

    pathRenderer.expose = {
        renderer: pathRenderer
    };

    return pathRenderer;
});

define('sap/viz/chart/components/datalabels/LineDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/DataGraphics'
], function(oo, DataLabels, DataPointUtils, DataGraphics) {
    var HARD_OFFSET = 3;
    // Get the previouse and next dataPoint nodes on the same line as a given node
    function getNeighbours(node) {
        var parent = node.parentNode,
            data = DataGraphics.getData(node);

        return {
            prev: data.prev ? DataPointUtils.findByDataPointId(parent, data.prev) : undefined,
            next: data.next ? DataPointUtils.findByDataPointId(parent, data.next) : undefined
        };
    }

    // Get the x, y corrdinates from an SVG node using its "transform" attribute
    function getCorrdinates(node) {
        if (node && node.hasAttribute('transform')) {
            var pos = node.getAttribute('transform').replace(/translate|\(|\)/g, '').split(/[,| ]+/);
            return {
                x: parseFloat(pos[0]),
                y: parseFloat(pos[1])
            };
        } else {
            return null;
        }
    }

    // Determine data label position based on its neighbour DataPoints
    function posByNeighbours(node, isTopDown) {
        var self = this._getDataLabelInfo(node).value,
            neighbours = getNeighbours.call(this, node),
            prev = neighbours.prev ? this._getDataLabelInfo(neighbours.prev).value : undefined,
            next = neighbours.next ? this._getDataLabelInfo(neighbours.next).value : undefined;

        if (isNaN(prev) && isNaN(next)) {
            return 'up'; // lone point
        } else if (isNaN(prev)) {
            prev = next;
        } else if (isNaN(next)) {
            next = prev;
        }

        if (prev > self && self < next) { // Valley
            return isTopDown ? 'up' : 'down';
        } else if (prev <= self && self >= next) { // Peak
            return isTopDown ? 'down' : 'up';
        } else {
            return 'adjust';
        } 
       
    }

    // adjust data label position to the left/right to avoid overlaping with the line segments
    // on the left/right of the dataPoint
    function adjust(pos, labelBBox, node, isTopDown) {
        var neighbours = getNeighbours(node),
            self = getCorrdinates(node),
            prev = getCorrdinates(neighbours.prev),
            next = getCorrdinates(neighbours.next),
            uphill = isTopDown ? (prev.y <= self.y && self.y <= next.y) :
            (prev.y >= self.y && self.y >= next.y),
            upper = uphill ? next : prev,
            basex = pos[0] + (uphill ? labelBBox.width : 0),
            refy = pos[1],
            refx, slope, offset;

        slope = (self.x - upper.x) / (self.y - upper.y);
        offset = self.x - slope * self.y;

        refx = slope * refy + offset;

        if (uphill && basex >= (refx - HARD_OFFSET)) {
            pos[0] -= (basex - refx + HARD_OFFSET);
        }

        if (!uphill && basex <= (refx + HARD_OFFSET)) {
            pos[0] += (refx + HARD_OFFSET - basex);
        }

        return pos;
    }

    var LineDataLabels = function(runtime, options) {
        LineDataLabels.superclass.constructor.apply(this, arguments);
        this.isHorizontal = options.isHorizontal;
        this._labelPosition = this.isHorizontal ? "outside" : "up";
    };

    oo.extend(LineDataLabels, DataLabels);

    LineDataLabels.prototype._computeDataLabelTranslate = function(node, ctm, labelPosition, labelBBox) {
        if (this.isHorizontal) {
            return LineDataLabels.superclass._computeDataLabelTranslate.apply(this, [node,ctm, "right", labelBBox]);
        }
        var isTopDown = this._properties.parentLevel.get("valueAxis.layout.direction") === "topDown" ;
        labelPosition = posByNeighbours.call(this, node, isTopDown);

        var labelFinalPos = labelPosition;
        if(labelPosition === 'adjust'){
            labelFinalPos = isTopDown ? 'down' : 'up';
        }
        var pos = this._computeDataLabelPosition(ctm, this._fixBBoxWhenInvisible(node), labelFinalPos, 
            labelBBox, {}, node);
            
        if(labelPosition === 'adjust'){
            pos = adjust(pos, labelBBox, node, isTopDown);
        }

        if (labelFinalPos === 'down') {
            pos[1] += labelBBox.height;
        }

        //base class will do this
        this._forceInner(pos, labelBBox);
        return pos;
    };
    return LineDataLabels;
});

define('sap/viz/chart/components/accessibility/LineDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator",
], function(oo, BaseDataPointNavigator) {

    function LineDataPointNavigator() {
        LineDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._isRadarChart = (this._renderType) ? this._renderType.indexOf('radar') > -1 : undefined;
        // In radar chart, datapoint navigation order will be affected if first value is null.
        // If the first value is null, the last datapoint should be navigated first.
        this._firstValueIsNull = [];
        this._sortedDPByFirstValueAxis = [];
        this._sortedDPBySecondaryValueAxis = [];
        this._allDataPoints = [];
        this._setupDataPointsMap();
    }

    oo.extend(LineDataPointNavigator, BaseDataPointNavigator);

    var prot = LineDataPointNavigator.prototype;

    prot._setupDataPointsMap = function() {
        if (this._series) {
            var seriesNum = this._series.length;
            for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
                var singleSeries = [];
                if (this._series[seriesIndex]) {
                    for (var seriesDelta = 0; seriesDelta < this._series[seriesIndex].length; seriesDelta++) {
                        if (this._series[seriesIndex][seriesDelta]) {
                            singleSeries.push(this._series[seriesIndex][seriesDelta]);
                        } else {
                            if (seriesDelta === 0) {
                                this._firstValueIsNull.push(seriesIndex);
                            }
                        }
                    }
                    this._allDataPoints.push(singleSeries);
                } else {
                    this._allDataPoints.push(undefined);
                }
            }
        }
    };

    prot.destroy = function() {
        LineDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._sortedDPByFirstValueAxis = null;
        this._sortedDPBySecondaryValueAxis = null;
        this._allDataPoints = null;
        this._firstValueIsNull = null;
    };

    prot.left = function(id) {
        return this._isRadarChart ? this.getCounterClockwiseDataPointInSeries(id) : this._isVerticalRender ? 
            this.getPrevDataPointInSeries(id) : this._getShortestDPInCategory(id, this._constants.LEFT);
    };

    prot.right = function(id) {
        return this._isRadarChart ? this.getClockwiseDataPointInSeries(id) : this._isVerticalRender ? 
            this.getNextDataPointInSeries(id) : this._getShortestDPInCategory(id, this._constants.RIGHT);
    };

    prot.up = function(id) {
        return this._isVerticalRender ? 
            this._getShortestDPInCategory(id, this._constants.UP) : this.getPrevDataPointInSeries(id);
    };

    prot.down = function(id) {
        return this._isVerticalRender ?
            this._getShortestDPInCategory(id, this._constants.DOWN) : this.getNextDataPointInSeries(id);
    };

    prot.getNextDataPointInSeries = function(id) {
        var currentDp = this.getDataPoint(id);
        var originalDp = this.locate(currentDp.address());
        var address = currentDp.address();
        var seriesIndex = address[1];
        var nextDp = null;
        if (this._allDataPoints[seriesIndex]) {
            var nextDpIndex = this._allDataPoints[seriesIndex].indexOf(originalDp) + 1;
            if (nextDpIndex < this._allDataPoints[seriesIndex].length) {
                nextDp =  this._allDataPoints[seriesIndex][nextDpIndex].dp;
            }
        }
        return nextDp;
    };

    prot.getPrevDataPointInSeries = function(id) {
        var currentDp = this.getDataPoint(id);
        var originalDp = this.locate(currentDp.address());
        var address = currentDp.address();
        var seriesIndex = address[1];
        var prevDp = null;
        if (this._allDataPoints[seriesIndex]) {
            var prevDpIndex = this._allDataPoints[seriesIndex].indexOf(originalDp) - 1;
            if (prevDpIndex > -1) {
                prevDp =  this._allDataPoints[seriesIndex][prevDpIndex].dp;
            }
        }
        return prevDp;
    };

    prot.getClockwiseDataPointInSeries = function(id) {
        var currentDp = this.getDataPoint(id);
        var originalDp = this.locate(currentDp.address());
        var address = currentDp.address();
        var seriesIndex = address[1];
        var nextDp = null;
        if (this._allDataPoints[seriesIndex]) {
            var startIndex = this._firstValueIsNull.indexOf(seriesIndex) > -1 ?
                this._allDataPoints[seriesIndex].length - 1 : 0;
            var currentDpIndex = this._allDataPoints[seriesIndex].indexOf(originalDp);
            var nextDpIndex = (currentDpIndex === 0) ?  (this._allDataPoints[seriesIndex].length - 1) 
                : (currentDpIndex - 1);
            if (nextDpIndex < this._allDataPoints[seriesIndex].length && nextDpIndex !== startIndex) {
                nextDp =  this._allDataPoints[seriesIndex][nextDpIndex].dp;
            }
        }
        return nextDp;
    };

    prot.getCounterClockwiseDataPointInSeries = function(id) {
        var currentDp = this.getDataPoint(id);
        var originalDp = this.locate(currentDp.address());
        var address = currentDp.address();
        var seriesIndex = address[1];
        var prevDp = null;
        if (this._allDataPoints[seriesIndex]) {
            var startIndex = this._firstValueIsNull.indexOf(seriesIndex) > -1 ? 
                this._allDataPoints[seriesIndex].length - 1 : 0;
            var currentDpIndex = this._allDataPoints[seriesIndex].indexOf(originalDp);
            if (currentDpIndex === startIndex) {
                return prevDp;
            }
            var prevDpIndex = (currentDpIndex === this._allDataPoints[seriesIndex].length - 1) ? 0 
                : (currentDpIndex + 1);
            if (prevDpIndex > -1 && prevDpIndex < this._allDataPoints[seriesIndex].length) {
                prevDp =  this._allDataPoints[seriesIndex][prevDpIndex].dp;
            }
        }
        return prevDp;
    };

    function updateSortedDPByAxis(columnIdx) {
        if (this._isDual) {
            if (!this._sortedDPByFirstValueAxis[columnIdx]) {
                this._sortedDPByFirstValueAxis[columnIdx] = [];
                this._sortedDPBySecondaryValueAxis[columnIdx] = [];
                var dps = this.getColumn(columnIdx);
                for (var i = 0; i < dps.length; i++) {
                    if (this.locate(dps[i].address()).valueAxis) {
                        this._sortedDPByFirstValueAxis[columnIdx].push(dps[i]);
                    } else if (this.locate(dps[i].address()).valueAxis2) {
                        this._sortedDPBySecondaryValueAxis[columnIdx].push(dps[i]);
                    }
                }

                this._sortedDPByFirstValueAxis[columnIdx].sort((function(a, b) {
                    return this.locate(a.address()).valueAxis - this.locate(b.address()).valueAxis;
                }).bind(this));
                this._sortedDPBySecondaryValueAxis[columnIdx].sort((function(a, b) {
                    return this.locate(a.address()).valueAxis2 - this.locate(b.address()).valueAxis2;
                }).bind(this));
            }
        } else {
            if (!this._sortedDataPointsByDirection[columnIdx]) {
                this.dataPointValueSortInCategory(columnIdx);
            }
        }
    }

    prot.dataPointValueSortInCategory = function (columnIndex) {
        this._sortedDataPointsByDirection[columnIndex] = this.getColumn(columnIndex);
        var that = this;
        var isTopDown = this._propMgr.get("valueAxis.layout.direction") === "topDown";
        this._sortedDataPointsByDirection[columnIndex].sort(function (a, b) {
            var aDp = that.locate(a.address());
            var bDp = that.locate(b.address());
            return isTopDown ?(bDp.valueAxis - aDp.valueAxis): (aDp.valueAxis - bDp.valueAxis);
        });
    };

    prot._getShortestDPInCategory = function(id, direction) {
        var currentDp = this.getDataPoint(id);
        var shortestDp = null;
        var shortestDpIdx = -1;
        var address = currentDp.address();
        var columnIdx = address[0];
        var curtDpIndex = -1;
        var isValueAxis2DP = false;

        updateSortedDPByAxis.call(this, columnIdx);
        if (this._isDual) {
            var originalDp = this.locate(currentDp.address());
            if (originalDp.valueAxis) {
                curtDpIndex = this._sortedDPByFirstValueAxis[columnIdx].indexOf(currentDp);
            } else if (originalDp.valueAxis2) {
                isValueAxis2DP = true;
                curtDpIndex = this._sortedDPBySecondaryValueAxis[columnIdx].indexOf(currentDp);
            }
        } else {
            curtDpIndex = this._sortedDataPointsByDirection[columnIdx].indexOf(currentDp);
        }
        if (direction === this._constants.UP || direction === this._constants.RIGHT) {
            shortestDpIdx = curtDpIndex + 1;
        } else if (direction === this._constants.DOWN || direction === this._constants.LEFT) {
            shortestDpIdx = curtDpIndex - 1;
        }

        if (this._isDual) {
            if (!isValueAxis2DP) {
                if (shortestDpIdx > this._sortedDPByFirstValueAxis[columnIdx].length - 1) {
                    shortestDp = null;
                } else if (shortestDpIdx === -1) {
                    shortestDpIdx = this._sortedDPBySecondaryValueAxis[columnIdx].length - 1;
                    shortestDp = this._sortedDPBySecondaryValueAxis[columnIdx][shortestDpIdx];
                } else {
                    shortestDp = this._sortedDPByFirstValueAxis[columnIdx][shortestDpIdx];
                }
            } else {
                if (shortestDpIdx > this._sortedDPBySecondaryValueAxis[columnIdx].length - 1) {
                    shortestDp = this._sortedDPByFirstValueAxis[columnIdx][0];
                } else if (shortestDpIdx === -1) {
                    shortestDp = null;
                } else {
                    shortestDp = this._sortedDPBySecondaryValueAxis[columnIdx][shortestDpIdx];
                }                
            }
        } else {
            shortestDp = this._sortedDataPointsByDirection[columnIdx][shortestDpIdx];
        }

        return shortestDp;       
    };

    prot.getColumn = function(columnIndex) {
        var column = [];
        if (this._series) {
            for (var i = 0; i < this._series.length; i++) {
                if (this._series[i] && this._series[i][columnIndex]) {
                    column.push(this._series[i][columnIndex].dp);
                }
            } 
        }
        return column;
    };

    return LineDataPointNavigator;
});

define('sap/viz/chart/components/trendline/mixin/linePlot',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/trendline/mixin/columnPlot'
], function(Constants, oo, ColumnPlotTrendLine) {
    function LinePlotTrendLine(){
    }
    oo.extend(LinePlotTrendLine, ColumnPlotTrendLine);
    LinePlotTrendLine.prototype._getTrendLineContainer = function(trendlineG, container){
        var dataPointLayer = container.querySelector("."+Constants.CSS.CLASS.DATAPOINT_GROUP);
        if(dataPointLayer){
            container.insertBefore(trendlineG, dataPointLayer);
        }else{
            container.appendChild(trendlineG);
        }
    };
    return LinePlotTrendLine;
});
define('sap/viz/chart/components/plots/LinePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/chart/components/plots/BaseLinePlot',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/chart/components/util/LineRendererUtil',
    'sap/viz/chart/components/datalabels/LineDataLabels',
    "sap/viz/chart/components/plots/XYPlotFactory",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/LineDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    'sap/viz/chart/components/trendline/mixin/linePlot',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/DOM"
], function Setup(
    oo,
    SVG,
    DataGraphics,
    ObjectUtils,
    TypeUtils,
    UADetector,
    BaseLinePlot,
    ScaleHandler,
    ItemScaleHandler,
    SeriesRenderer,
    PathRenderer,
    DrawUtil,
    LineRendererUtil,
    LineDataLabels,
    XYPlotFactory,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants,
    LinePlotTrendLine,
    Constants,
    DOM
) {
    var categorySize = {
        desktop : {
            minWidth : 24
        },
        mobile : {
            minWidth : 48
        }
    };
    var trellisCategorySize = {
        desktop : {
            minWidth : 16
        },
        mobile : {
            minWidth : 16
        }
    };

    var LinePlot = function(runtime, options) {
        LinePlot.superclass.constructor.apply(this, arguments);
        this._markerPropName = "marker";
        
        this._dataPointRenderer = PathRenderer;
        this._flipNegativeShape = false;
        
        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.setUseSemanticDPLineStyle(true);
        semanticMgr.setUseSemanticPattern(true);

        var markManager = this.runtime().markManager();
        markManager.setMode("line");
        markManager.lock();
        markManager.setSeriesShape("line");
        this._attachMarkRestrict();

        //each watcher should be removed in destroy function
        this.markerShapePW = this._properties.watch("marker.shape", this._onShapeChange.bind(this));

        this._isMarkerVisible = this._properties.get("marker.visible");
    };

    oo.extend(LinePlot, BaseLinePlot);

    LinePlot.prototype.destroy = function() {
        this.markerShapePW.remove();
        this.markerShapePW = null;

        LinePlot.superclass.destroy.call(this);
        this._dataPointRenderer = null;
        this._flipNegativeShape = null;
        this._markerD = null;
        this._realSize = null;
    };
    
    LinePlot.prototype._onShapeChange = function() {
        this._attachMarkRestrict();
    };
    
    LinePlot.prototype._EmptyDOM = function(selectionNode) {
        LinePlot.superclass._EmptyDOM.apply(this, arguments);
        DOM.empty(this._getDpPlotNode());
    };

    LinePlot.prototype._attachMarkRestrict = function() {
        var shapes = [],
            shape = this._getMarkerShape(),
            markMgr = this.runtime().markManager();
        shapes.push(shape);
        // This code is really unnecessary since we don't have properties to customize marker shape for each measure
        if(this._options.isDualValueAxis){
            shapes.push(shape);
        }
        markMgr.setShape(shapes, "circle");
    };
    
    LinePlot.prototype._adjustPosition = function(position, seriesIndex) {};

    LinePlot.prototype._preRender = function() {
        LinePlot.superclass._preRender.apply(this, arguments);

        this._isMarkerVisible = this._properties.get("marker.visible");
      
    };

    LinePlot.prototype._applyScroll = function() {
        LinePlot.superclass._applyScroll.apply(this);
        this.renderTrendlines(this._selection);
    };
    
    LinePlot.prototype._getValueScaleHandlers = function(isHorizontal) {
        var options = {
            isHorizontal: isHorizontal,
            alignment: isHorizontal ? "right" : "top"
        };
        if (this._options.isDualValueAxis) {
            return [ScaleHandler.getValueScaleHandler("valueAxis", options), 
                ScaleHandler.getValueScaleHandler("valueAxis2", options)];
        } else {
            return [ScaleHandler.getValueScaleHandler("valueAxis", options)];
        }
    };

    LinePlot.prototype._getCategoryScaleHandlers = function() {
        return [ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: false,
            itemScaleHandler: ItemScaleHandler.get(false),
            alignment: "center"
        })];
    };

    LinePlot.prototype._getGridLineScale = function(range){
        var valueAxisDir = this._properties.origin.get("valueAxis.layout.direction");
        range = valueAxisDir === "topDown" ? [range[1], range[0]]: range;
        return LinePlot.superclass._getGridLineScale.call(this, range);
    };

    LinePlot.prototype._getSeriesRenderer = function() {
        return new SeriesRenderer(this._drawLine.bind(this), this._updateLine.bind(this));
    };

    LinePlot.prototype._adjustPosition = function(position) {};

    LinePlot.prototype._updateDatapoint = function(dataPointG, dpRenderer, dpConfig,
        position) {
        LinePlot.superclass._updateDatapoint.apply(this, arguments);

        if (dataPointG && position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            var translate = DataGraphics.getData(dataPointG).translate;
            if (translate){
                translate[0] = position.x;
                translate[1] = position.y;
            }
        }
    };

    LinePlot.prototype.getLineRenderer = function(){
        if (!this._lineRenderer){
            var props = this._properties;
            this._lineRenderer = LineRendererUtil.getRenderer(
                props.get('lineRenderer'),
                props.get("isSmoothed")
            );
        }
        return this._lineRenderer;
    };

    LinePlot.prototype._buildConfig = function(data, position, context) {
        var config = LinePlot.superclass._buildConfig.apply(this, arguments);
        config.graphic.d = this._markerD;
        if (!this._isMarkerVisible) {
            config.graphic.opacity = 0;
        }
        return config;
    };

    LinePlot.prototype._getDataLabels = function(name, runtime) {
        var options = ObjectUtils.extend({}, this._options);
        options.name = name;
        return new LineDataLabels(runtime, options);
    };

    LinePlot.prototype._getMinCategoryWidth = function(isRangeIncomplete){
        var inTrellis = !!this._options.inTrellis;
        var props = this._properties;
        var sizeKey = "categoryAxis.label.style.fontSize";
        var ratio = parseInt(props.origin.get(sizeKey))/parseInt(props.origin.getDefault(sizeKey));

        if (isRangeIncomplete ||
            inTrellis || 
            (props.get('isFixedDataPointSize') && !props.origin.get("interaction.noninteractiveMode"))) {
            var sizeDefinition = inTrellis ? trellisCategorySize : categorySize;
            var minWidth = UADetector.isMobile() ? 
                sizeDefinition.mobile.minWidth : sizeDefinition.desktop.minWidth * ratio;
            return minWidth;
        } else {
            return 0;
        }
    };
    
    LinePlot.prototype.getPreferredSize = function () {
        var inTrellis = !!this._options.inTrellis;
        var ranges = this._getCategoryRange();
        var isHorizontal = this.isHorizontal();
        var categoryCount = this._getCategoryCount();
        var categoryWidth = isHorizontal? this._size.height/categoryCount : this._size.width/categoryCount;
        var isInterative = !this._properties.origin.get("interaction.noninteractiveMode");
        var isRangeIncompleteFn = this._isRangeIncomplete;
        function useFullRangeAlgo(){
            return ranges && !isRangeIncompleteFn(ranges) && isInterative;
        }

        if (isInterative && (!useFullRangeAlgo()) &&
                 (inTrellis || isRangeIncompleteFn(ranges) || this._properties.get('isFixedDataPointSize'))) {
            var minWidth = this._getMinCategoryWidth(isRangeIncompleteFn(ranges));
            var categorySizeChanged = false;
            if (categoryWidth < minWidth) {
                categorySizeChanged = true;
                categoryWidth = minWidth;
            }
            if (categorySizeChanged) {
                if (isHorizontal) {
                    this._realSize.height = categoryWidth * categoryCount;
                } else {
                    this._realSize.width = categoryWidth * categoryCount;
                }
            }
            //time implement _shiftOffsetForIncompleteRange as empty function
            if(isRangeIncompleteFn(ranges) &&  
                this._shiftOffsetForIncompleteRange(ranges, categoryCount)){
                return this._realSize;
            }
        }

        if(useFullRangeAlgo()){
            var visibleCategoryCount = ranges[1] - ranges[0] + 1;
            if(isHorizontal){
                this._realSize.height = this._size.height * categoryCount/ visibleCategoryCount;
                this._offset.y = -ranges[0] *  this._realSize.height / categoryCount;
            }else{
                this._realSize.width = this._size.width  * categoryCount / visibleCategoryCount;
                this._offset.x = -ranges[0] *  this._realSize.width / categoryCount;
            }
        }
        return this._realSize;
    };

    LinePlot.prototype.isMarkerVisible = function() {
        return this._isMarkerVisible;
    };

    LinePlot.prototype._calMarkProps = function() {
        var series = this._getSeries();
        var seriesMaxLength = 0;
        series.forEach(function(e) {
            seriesMaxLength = Math.max(seriesMaxLength, e.length);
        });
        var _length = this.isHorizontal() ? this._realSize.height : this._realSize.width;
        var _isBigData = (_length / seriesMaxLength) < 10;
        var _displayMode = this._properties.get('marker.displayMode');
        this._isMarkerVisible = this._properties.get('marker.visible');

        if (_displayMode === "auto" && _isBigData) {
            this._isMarkerVisible = false;
        }
    };

    LinePlot.prototype._preShowDataPoints = function() {
        this._calMarkProps();
        return LinePlot.superclass._preShowDataPoints.apply(this, arguments);
    };
    
    XYPlotFactory.registerClazz("line", LinePlot);
    XYPlotFactory.registerClazz("horizontal_line", LinePlot);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR, ChartConstants.LINE, DataPointNavigator);
    (new LinePlotTrendLine()).inject(LinePlot.prototype);
    return LinePlot;
});

define('sap/viz/chart/components/renderers/AreaRenderer',["sap/viz/framework/common/util/SVG",
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/chart/components/util/ColorUtil"
    ],function(SVG, DataGraphics, Constants, NameColorUtils, ColorUtil) {

    var DIRECTION_LEFT = "DIRECTION_LEFT";
    var DIRECTION_RIGHT = "DIRECTION_RIGHT";
    var DIRECTION_BOTH = "DIRECTION_BOTH";

    var CSS_CLASS = Constants.CSS.CLASS;

    var analyzePath = function(path, tempData, isHorizontal){
        if (tempData.length > 1) {
            path.areaPath = buildPath(path.areaPath, tempData, isHorizontal);
            path.detectionPath = buildDetection(path.detectionPath, tempData, isHorizontal);
        } else if (tempData[0] && tempData[0].dataPoint) {
            path.linePath = buildPath(path.linePath, tempData, isHorizontal);
            path.detectionPath = buildDetection(path.detectionPath, tempData, isHorizontal);
        }
    };

    var getAreaPath = function(points, isHorizontal) {
        if (!points) {
            return null;
        }
        var path = {
            "areaPath": "",
            "linePath": "",
            "detectionPath": ""
        };
        var itemLength = points.length;
        var lastIsNull = false;
        var rendererWithNullValue = false;
        var tempData = [];
        var point;
        for(var i = 0; i < itemLength; i ++) {
            point = points[i];
            if(point) {
                if (point.dataPoint) {
                    tempData.push(point);
                    rendererWithNullValue = false;
                    lastIsNull = false;
                    continue;
                }
                if (!lastIsNull) {
                    tempData.push(point);
                    rendererWithNullValue = false;
                } else {
                    if (!rendererWithNullValue) {
                        rendererWithNullValue = true;
                        analyzePath(path, tempData, isHorizontal);
                    }
                    tempData = [point];
                }
                lastIsNull = true;
            } else {
                if (!rendererWithNullValue) {
                    rendererWithNullValue = true;
                    analyzePath(path, tempData, isHorizontal);
                }
                tempData = [];
            }
        }
        analyzePath(path, tempData, isHorizontal);
        if (path.areaPath) {
            path.areaPath += "Z";
        }
        return path;
    };

    var setPathDef = function (area, line, detection, config){
        var pathObject = getAreaPath(config.points, config.isHorizontal);
        if (!pathObject){
            return;
        }
        var path, node;
        [
            {node: area, pathKey: "areaPath"},
            {node: line, pathKey: "linePath"},
            {node: detection, pathKey: "detectionPath"}
        ].forEach(function(ele){
            node = ele.node;
            path = pathObject[ele.pathKey];
            if (path) {
                node.setAttribute("d", path);
            } else {
                node.removeAttribute("d");
            }
        });
    };

    var AreaRenderer = function(config) {
        var context = config.ctx;
        var graphic = config.graphic;
        var opacity = graphic.opacity;

        var area = SVG.create("path");
        area.setAttribute("class", CSS_CLASS.AREA_PATH + " " + CSS_CLASS.MORPHABLEAREABG);
        area.setAttribute("fill", getEffectColor(config));
        area.setAttribute("opacity", opacity);
        if (config.propManager.get("plotArea.area.stroke.visible")) {
            var bgColor =  ColorUtil.getBgColor(config.propManager, ["plotArea.grid.background.color",
                "plotArea.background.color", "general.background.color", "plotArea.area.stroke.color"]);
            var strokeColor = NameColorUtils.convertColor(bgColor);
            area.setAttribute("stroke", strokeColor);
            area.setAttribute("stroke-width", "1");
            area.setAttribute("stroke-opacity", "1");
        }
        var line = SVG.create("path");
        line.setAttribute("stroke", graphic.color);
        line.setAttribute("stroke-width", "1px");
        line.setAttribute("opacity", opacity);
        line.setAttribute("class", CSS_CLASS.AREA_LINE_PATH + " " + CSS_CLASS.MORPHABLEAREABG);

        var detection = SVG.create("path");
        detection.setAttribute("class", CSS_CLASS.AREA_DETECTION_PATH);
        detection.setAttribute("opacity", "0");

        var areaG = SVG.create("g");
        [area, line, detection].forEach(function(node){
            DataGraphics.setContext(node, context);
            areaG.appendChild(node);
        });

        setPathDef(area, line, detection, config);

        return areaG;
    };

    AreaRenderer._getAreaPathByDataPoints = getAreaPath;

    var buildDetectionCoord = function(position, direction, isHorizontal) {
        if (!position) {
            return;
        }
        var x = +position.x;
        var y = +position.y;
        var w = +position.width;
        var h = +position.height;
        var coorda = position;
        var coordb = position;
        if (direction === DIRECTION_LEFT || direction === DIRECTION_BOTH){
            coorda = {};
            coorda.x = isHorizontal ? x : x - 10;
            coorda.y = isHorizontal ? y - 10 : y;
            coorda.width = w;
            coorda.height = h;
        }
        if (direction === DIRECTION_RIGHT || direction === DIRECTION_BOTH){
            coordb = {};
            coordb.x = isHorizontal ? x : x + 10;
            coordb.y = isHorizontal ? y + 10 : y;
            coordb.width = w;
            coordb.height = h;
        }
        return [{"position":coorda}, {"position":coordb}];
    };

    var buildDetection = function(d, data, isHorizontal) {
        var first = data[0].position;
        var last = data[data.length - 1].position;
        if (first === last) {
            d = buildPath(d, buildDetectionCoord(first, DIRECTION_BOTH, isHorizontal), isHorizontal);
        } else {
            d = buildPath(d, buildDetectionCoord(first, DIRECTION_LEFT, isHorizontal), isHorizontal);
            d = buildPath(d, buildDetectionCoord(last, DIRECTION_RIGHT, isHorizontal), isHorizontal);
        }
        return d;
    };

    var getPathString = function(command, x, y){
        return command + x + "," + y;
    };

    var buildPath = function(d, data, isHorizontal) {
        var n = 1, length = data.length;
        var position = data[0].position;
        d += getPathString("M", position.x, position.y);
        var dRev;

        if (isHorizontal) {
            dRev = getPathString("L", position.x - position.width, position.y);
            for (; n < length; n++) {
                position = data[n].position;
                d += getPathString("L", position.x, position.y);
                dRev = getPathString("L", position.x - position.width, position.y) + dRev;
            }
        } else {
            dRev = getPathString("L", position.x, position.y + position.height);
            for (; n < length; n++) {
                position = data[n].position;
                d += getPathString("L", position.x, position.y);
                dRev = getPathString("L", position.x, position.y + position.height) + dRev;
            }
        }
        d += dRev;
        return d;
    };

    AreaRenderer.update = function(node, config) {
        var area = node.querySelector("." + CSS_CLASS.AREA_PATH);
        var line = node.querySelector("." + CSS_CLASS.AREA_LINE_PATH);
        var detection = node.querySelector("." + CSS_CLASS.AREA_DETECTION_PATH);

        setPathDef(area, line, detection, config);
    };

    var getEffectColor = function(config) {
        var fill = config.effectManager.register({
            drawingEffect: config.graphic.drawingEffect,
            fillColor: config.graphic.color,
            direction: config.isHorizontal ? 'horizontal' : 'vertical'
        });
        return fill;
    };

    AreaRenderer.expose = {
        renderer: AreaRenderer,
        update: AreaRenderer.update
    };

    return AreaRenderer;
});

define('sap/viz/chart/components/util/AreaSeriesUtil',[
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/renderers/AreaRenderer'
], function(
    DataGraphics,
    TypeUtils,
    Constants,
    NameColorUtils,
    DataPointUtils,
    AreaRenderer
) {

    var defaultAreaRenderer = AreaRenderer;
    var convertColor = NameColorUtils.convertColor;
    var AREA_OPACITY = 0.8;

    var CSS_CLASS = Constants.CSS.CLASS;

    function getValidDataPoints(data, seriesIndex, config) {
        var itemLength = data.length;
        var dataPoints = [];
        var extraData, dataPoint, firstDpIdx, lastDpIdx;
        var nullIndex = -1;
        var firstLastDpObj = config.seriesFirstAndLastDpIdx;
        if (firstLastDpObj) {
            firstDpIdx = firstLastDpObj.firstIdx;
            lastDpIdx = firstLastDpObj.lastIdx;
        } else {
            firstDpIdx = 0;
            lastDpIdx = itemLength - 1;
        }
        //add seriresIndex and itemIndex for draw selection area logic
        for(var i = 0; i < itemLength; i++) {
            if(data[i]) {
                dataPoint = data[i].dataPoint;
                if (!dataPoint) {
                    continue;
                }
                extraData = DataGraphics.getData(dataPoint);
                extraData.seriesIndex = seriesIndex;
                extraData.itemIndex = i;
                var dataIdx = firstLastDpObj && data[i].dpConfig.dataId || i;
                //Only one data point
                if (itemLength === 1) {
                    extraData.labelPosition = Constants.LABEL_POSITION.MIDDLE;
                    extraData.isIsolate = true;
                //First data point
                } else if (dataIdx === firstDpIdx) {
                    extraData.labelPosition = Constants.LABEL_POSITION.RIGHT;
                //Last data point
                } else if (dataIdx === lastDpIdx) {
                    extraData.labelPosition = Constants.LABEL_POSITION.LEFT;
                    if (nullIndex === i - 1) {
                        extraData.isIsolate = true;
                    }
                } else {
                    if (i - nullIndex === 1) {
                        extraData.labelPosition = Constants.LABEL_POSITION.RIGHT;
                    } else {
                        extraData.labelPosition = Constants.LABEL_POSITION.MIDDLE;
                    }
                }
                dataPoints.push(dataPoint);
                DataGraphics.setData(dataPoint, extraData);
            } else {
                nullIndex = i;
                if (i <= 0 || !data[i - 1] || !data[i - 1].dataPoint) {
                    continue;
                }
                dataPoint = data[i - 1].dataPoint;
                extraData = DataGraphics.getData(dataPoint);
                if (i === 1) {
                    extraData.isIsolate = true;
                } else {
                    if (extraData.labelPosition === Constants.LABEL_POSITION.RIGHT) {
                        extraData.labelPosition = Constants.LABEL_POSITION.MIDDLE;
                        extraData.isIsolate = true;
                    } else {
                        extraData.labelPosition = Constants.LABEL_POSITION.LEFT;
                    }
                }
            }
        }
        return dataPoints;
    }

    function addDetectionRect(data) {
        var itemLength = data.length;
        var shapeData;
        var currentPoint, leftPoint, rightPoint;

        //add seriresIndex and itemIndex for draw selection area logic
        for(var i = 0; i < itemLength; i++) {
            currentPoint = data[i];
            if(!currentPoint || !currentPoint.dataPoint) {
                continue;
            }
            leftPoint = null;
            rightPoint = null;

            if (i > 0 && data[i - 1]) {
                leftPoint = data[i - 1];
            }
            if (i < itemLength - 1 && data[i + 1]) {
                rightPoint = data[i + 1];
            }
            shapeData = {
                areaPath: buildDetection(currentPoint, leftPoint, rightPoint)
            };
            DataGraphics.setGraphicInfo(currentPoint.dataPoint, shapeData);
        }
    }

    function buildDetection(point, pointLeft, pointRight) {
        //define points of detection area
        var position = point.position;
        var px = position.x;
        var py = position.y;
        var pwidth = position.width;
        var pheight = position.height;

        var lPosition, rPosition;
        var x, y, result = [];
        if (pointLeft) {
            lPosition = pointLeft.position;
            if (!pointLeft.dataPoint) {
                result.push({"x": lPosition.x, "y": lPosition.y});
            } else {
                x = (px - pwidth) -
                    ((px - pwidth) - (lPosition.x - lPosition.width)) / 2;
                y = (py + pheight) -
                    ((py + pheight) - (lPosition.y + lPosition.height)) / 2;
                result.push({"x": x, "y": y});
                x = px - (px - lPosition.x) / 2;
                y = py - (py - lPosition.y) / 2;
                result.push({"x": x, "y": y});
            }
        }
        result.push({"x": px, "y": py});
        if (pointRight) {
            rPosition = pointRight.position;
            if (!pointRight.dataPoint) {
                result.push({"x": rPosition.x, "y": rPosition.y});
            } else {
                x = px + (rPosition.x - px) / 2;
                y = py + (rPosition.y - py) / 2;
                result.push({"x": x, "y": y});
                x = (px - pwidth) +
                    ((rPosition.x - rPosition.width) - (px - pwidth)) / 2;
                y = (py + pheight) +
                    ((rPosition.y + rPosition.height) - (py + pheight)) / 2;
                result.push({"x": x, "y": y});
            }
        }
        result.push({"x": px - pwidth, "y": py + pheight});
        result.push(result[0]);

        return result;
    }


    var utils = {

        drawArea: function(pathGroup, data, index, drawingEffect, effectMgr,
            context, areaRenderer, seriesStyle, isHorizontal, propMgr, seriesFirstAndLastNullVDpIdx) {
            addDetectionRect(data);
            var color = seriesStyle.color;

            var config = {
                graphic: {
                    color: color,
                    opacity: AREA_OPACITY,
                    drawingEffect: drawingEffect
                },
                points: data,
                effectManager: effectMgr,
                ctx: context,
                isHorizontal: isHorizontal,
                propManager: propMgr,
                seriesFirstAndLastNullVDpIdx: seriesFirstAndLastNullVDpIdx
            };

            var customizedRenderG;
            if(areaRenderer) {
                customizedRenderG = areaRenderer(config, AreaRenderer.expose);
            }

            var areaG = customizedRenderG || defaultAreaRenderer(config);
            areaG.setAttribute("class", CSS_CLASS.AREA);
            var dataPoints = getValidDataPoints(data, index, config);
            //store color for HighlightHelper.getFillColors in clearPlot handler

            if(areaRenderer) {
                //for customized render result, we have to update saved color, because
                //customized color may be different from series color.
                //we do not check customizedRenderG, because areaRenderer may change config.color, but do not
                //create any DOM elements.
                var areaPath = areaG.querySelector('.' + CSS_CLASS.AREA_PATH);
                if(areaPath) {
                    var domColor = areaPath.getAttribute('fill');
                    if(domColor) {
                        color = domColor;
                    }
                }
            }

            DataPointUtils.setAreaId(areaG, index);
            DataGraphics.setData(areaG, {
                "color" : color,
                "dataPoints" : dataPoints
            });
            DataGraphics.setContext(areaG, context);
            pathGroup.appendChild(areaG);
        },
        updateArea: function(pathGroup, data, index, areaRenderer, context, options) {
            if (!pathGroup) {
                return false;
            }
            areaRenderer = areaRenderer || defaultAreaRenderer;
            if (!areaRenderer.update || !TypeUtils.isFunction(areaRenderer.update)) {
                return false;
            }
            var areaG = DataPointUtils.findArea(pathGroup, index);
            if (!areaG){
                return false;
            }
            addDetectionRect(data);

            var config = {
                points: data,
                isHorizontal: options.isHorizontal,
                ctx: context,
                graphic: {
                    color: options.fillColor,
                    opacity: options.opacity,
                    drawingEffect: options.drawingEffect
                },
                effectManager: options.effectManager,
                isMultiSeries: options.isMultiSeries,
                seriesFirstAndLastDpIdx: options.seriesFirstAndLastDpIdx
            };

            areaRenderer.update(areaG, config, AreaRenderer.expose);

            var dataPoints = getValidDataPoints(data, index, config);
            DataGraphics.getData(areaG).dataPoints = dataPoints;
            return true;
        }
    };
    return utils;
});

define('sap/viz/chart/components/renderers/AreaRefLineRenderer',["sap/viz/framework/common/util/SVG",
    'sap/viz/framework/common/util/DataGraphics'], function(SVG, DataGraphics) {
    var areaRefLineRenderer = function(config) {
        var node = SVG.create("line");
        var graphic = config.graphic;
        var fill = config.effectManager.register({
            fillColor: graphic.fill,
        });
        node.setAttribute("stroke", fill);
        var opacity = (graphic.opacity >= 0 && graphic.opacity <= 1) ? graphic.opacity : 1;
        if(opacity !== 1) {
            node.setAttribute("fill-opacity", opacity);
            node.setAttribute("stroke-opacity", opacity);
        }
        var position = config.position;
        node.setAttribute("x1", 0);
        node.setAttribute("y1", 0);
        node.setAttribute("x2", -position.width);
        node.setAttribute("y2", position.height);
        node.setAttribute("pointer-events", "none");
        return node;
    };

    areaRefLineRenderer.update = function(node, config){
        var position = config.position;
        node.setAttribute("x2", -position.width);
        node.setAttribute("y2", position.height);
    };

    return areaRefLineRenderer;
});

define('sap/viz/chart/components/datalabels/AreaDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/chart/components/util/ColorUtil",
], function(oo, DataLabels, DataPointUtils, DataGraphics, Constants, ColorUtil) {
    var AreaDataLabels = function(runtime, options, seriesColorStyleMap) {
        AreaDataLabels.superclass.constructor.apply(this, arguments);
        this.isHorizontal = options.isHorizontal;
        this._seriesColorStyleMap = seriesColorStyleMap;
        this._labelPosition = this.isHorizontal ? "left" : "down";
    };

    var PADDING_BOUNDRY = 0;
    var LABEL_PADDING = 2;

    oo.extend(AreaDataLabels, DataLabels);

    AreaDataLabels.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var extraData = DataGraphics.getData(item.dataPoint);
        return extraData.isIsolate;
    };

    AreaDataLabels.prototype._render = function(selection, dataPoints) {
        var hideWhenOverlap = this._properties.get('hideWhenOverlap');
        if (hideWhenOverlap) {
            this._ignoreEmptyDataLabel = true;
        }
        AreaDataLabels.superclass._render.apply(this, arguments);
    };

    AreaDataLabels.prototype.drawZero = function() {
        var hideWhenOverlap = this._properties.get('hideWhenOverlap');
        if (hideWhenOverlap) {
            return false;
        } else {
            return true;
        }
    };

    AreaDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition,
        labelBBox, config, node) {
        var position = AreaDataLabels.superclass._computeDataLabelPosition.apply(this,
            [ctm, shapeBBox, labelPosition, labelBBox, config, node]);
        var extraData = DataGraphics.getData(node);
        var x = position[0];
        var y = position[1];
        var size = this._size;
        var width = (extraData.position && extraData.position.width) || 0;
        var height = (extraData.position && extraData.position.height) || 0;
        var hideWhenOverlap = this._properties.get('hideWhenOverlap');

        if (this.isHorizontal) {
            if (hideWhenOverlap && labelBBox.width > Math.abs(width)) {
                return null;
            }
            if (extraData.labelPosition === Constants.LABEL_POSITION.RIGHT) {
                y = y + (labelBBox.height / 2) + PADDING_BOUNDRY;
            } else if (extraData.labelPosition === Constants.LABEL_POSITION.LEFT) {
                y = y - (labelBBox.height / 2) - PADDING_BOUNDRY;
            }

            x = x - (width / 2) + (shapeBBox.width / 2) + (labelBBox.width / 2);
            if (x < 0) {
                x = LABEL_PADDING;
            }
        } else {
            if (hideWhenOverlap && labelBBox.height > Math.abs(height)) {
                return null;
            }
            if (extraData.labelPosition === Constants.LABEL_POSITION.RIGHT) {
                x = x + (labelBBox.width / 2) + PADDING_BOUNDRY;
            } else if (extraData.labelPosition === Constants.LABEL_POSITION.LEFT) {
                x = x - (labelBBox.width / 2) - PADDING_BOUNDRY;
            }

            y = y + (height / 2) + (shapeBBox.height / 2);
            if (y > size.height) {
                y = size.height - LABEL_PADDING;
            }
        }

        return [x, y];
    };

    AreaDataLabels.prototype._setDataLabelColor = function(item, range, backgroundColor, color) {
        var data = DataGraphics.getData(item.dataPoint);
        var seriesColor = this._seriesColorStyleMap && this._seriesColorStyleMap[data.seriesIndex] &&
            this._seriesColorStyleMap[data.seriesIndex].color;
        DataLabels.prototype._setDataLabelColor.call(this, item, range, backgroundColor, color, seriesColor);
    };

    return AreaDataLabels;
});

define('sap/viz/chart/behavior/config/tooltip/AreaChartTooltip',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/chart/behavior/config/tooltip/Tooltip"
], function Setup(oo, Tooltip) {

    var AreaChartTooltip = function(properties) {
        AreaChartTooltip.superclass.constructor.apply(this, arguments);
    };

    oo.extend(AreaChartTooltip, Tooltip);

    var DETECTION_GAP = 8;
    // Currently, just sync with paddingBottom,
    // after adding top detection, should be sync with paddingTop when mouse is on tooltip
    var MOUSE_GAP = 10;

    AreaChartTooltip.prototype._addPadding = function() {
        if (this.isActionMode()) {
            var position = this._data.position;
            var x = position.x;
            var y = position.y;
            var limit = this._getLimit();
            var divNode = this._div.node();
            var offsetWidth = divNode.offsetWidth;
            var offsetHeight = divNode.offsetHeight;
            if (position.direction === "left" || position.direction === "right") {
                offsetWidth = offsetWidth + DETECTION_GAP;
                offsetHeight = offsetHeight + MOUSE_GAP;
            } else if (position.direction === "top" || position.direction === "bottom") {
                offsetWidth = offsetWidth + MOUSE_GAP;
                offsetHeight = offsetHeight + DETECTION_GAP;
            } else {
                offsetHeight = offsetHeight + MOUSE_GAP;
            }
            if (position.direction === "left") {
                if (x - offsetWidth < limit.left) {
                    this._div.style("padding-left", DETECTION_GAP + "px");
                } else {
                    this._div.style("padding-right", DETECTION_GAP + "px");
                }
            } else if (position.direction === "right" || !position.direction) {
                if (x + offsetWidth > limit.right) {
                    this._div.style("padding-right", DETECTION_GAP + "px");
                } else {
                    this._div.style("padding-left", DETECTION_GAP + "px");
                }
            } else if (position.direction === "top" || position.direction === "bottom") {
                if (x + offsetWidth < limit.right) {
                    this._div.style("padding-left", MOUSE_GAP + "px");
                } else {
                    this._div.style("padding-right", MOUSE_GAP + "px");
                }
            } else {
                this._div.style("padding-left", 0 + "px");
                this._div.style("padding-right", 0 + "px");
            }

            if (position.direction === "top" || !position.direction) {
                if (y - offsetHeight < limit.top) {
                    this._div.style("padding-top", DETECTION_GAP + "px");
                } else {
                    this._div.style("padding-bottom", DETECTION_GAP + "px");
                }
            } else if (position.direction === "bottom") {
                if (y + offsetHeight > limit.bottom) {
                    this._div.style("padding-bottom", DETECTION_GAP + "px");
                } else {
                    this._div.style("padding-top", DETECTION_GAP + "px");
                }
            } else if (position.direction === "left" || position.direction === "right") {
                if (y - offsetHeight > limit.top) {
                    this._div.style("padding-bottom", MOUSE_GAP + "px");
                } else {
                    this._div.style("padding-top", MOUSE_GAP + "px");
                }
            } else {
                if (y - offsetHeight < limit.top) {
                    this._div.style("padding-top", MOUSE_GAP + "px");
                } else {
                    this._div.style("padding-bottom", MOUSE_GAP + "px");
                }
            }
        } else {
            this._div.style("padding-top", 0 + "px");
            this._div.style("padding-bottom", 0 + "px");
            this._div.style("padding-left", 0 + "px");
            this._div.style("padding-right", 0 + "px");
        }
    };

    AreaChartTooltip.prototype._calculateMobilePos = function(limit, position) {
        var x = position.x;
        var y = position.y;

        var closeButtonSize = this._display.closeButton.size;
        var mouseMarginTop = this._display.mouseMarginTop;

        var divNode = this._div.node();
        var offsetWidth = divNode.offsetWidth;
        var offsetHeight = divNode.offsetHeight;
        if (position.direction === "left") {
            x = x - offsetWidth < limit.left ? x : x - offsetWidth;
        } else if (position.direction === "right") {
            x = x + offsetWidth + closeButtonSize > limit.right ? x - offsetWidth : x ;
        } else if (position.direction === "top" || position.direction === "bottom") {
            if (x + offsetWidth + closeButtonSize < limit.right) {
                x = x;
            } else {
                x = x - offsetWidth;
            }
        } else {
            if ((x + offsetWidth / 2 + closeButtonSize / 2) > limit.right) {
                x = limit.right - offsetWidth - closeButtonSize / 2;
            } else if (x - offsetWidth / 2 < limit.left) {
                x = limit.left;
            } else {
                x = x - offsetWidth / 2 - closeButtonSize / 2;
            }
        }

        if (position.direction === "top") {
            y = y - offsetHeight - mouseMarginTop - closeButtonSize / 2 < limit.top ?
                y : y - offsetHeight - mouseMarginTop;
        } else if (position.direction === "bottom") {
            y = y + offsetHeight + closeButtonSize / 2 > limit.bottom ? y - offsetHeight : y;
        } else if (position.direction === "left" || position.direction === "right" || !position.direction) {
            if (y - offsetHeight - mouseMarginTop - closeButtonSize / 2 > limit.top) {
                y = y - offsetHeight - mouseMarginTop - closeButtonSize / 2;
            } else {
                y = y;
            }
        }

        return {
            "x": x,
            "y": y
        };
    };

    AreaChartTooltip.prototype._calculateDesktopPos = function(limit, position) {
        var x = position.x;
        var y = position.y;

        var divNode = this._div.node();
        var offsetWidth = divNode.offsetWidth;
        var offsetHeight = divNode.offsetHeight;

        if (this._mode === this._tooltipMode.INFO_MODE) {
            if (position.direction === "left") {
                x = x - offsetWidth - DETECTION_GAP < limit.left ?
                    x + DETECTION_GAP : x - offsetWidth - DETECTION_GAP;
            } else if (position.direction === "right") {
                x = x + offsetWidth + DETECTION_GAP > limit.right ?
                    x - offsetWidth - DETECTION_GAP : x + DETECTION_GAP;
            } else if (position.direction === "top" || position.direction === "bottom") {
                if (x + offsetWidth + MOUSE_GAP < limit.right) {
                    x = x + MOUSE_GAP;
                } else {
                    x = x - offsetWidth - MOUSE_GAP;
                }
            } else {
                if ((x + offsetWidth / 2) > limit.right) {
                    x = limit.right - offsetWidth;
                } else if (x - offsetWidth / 2 < limit.left) {
                    x = limit.left;
                } else {
                    x = x - offsetWidth / 2;
                }
            }

            if (position.direction === "top") {
                y = y - offsetHeight - DETECTION_GAP < limit.top ?
                    y + DETECTION_GAP : y - offsetHeight - DETECTION_GAP;
            } else if (position.direction === "bottom") {
                y = y + offsetHeight + DETECTION_GAP > limit.bottom ?
                    y - offsetHeight - DETECTION_GAP : y + DETECTION_GAP;
            } else if (position.direction === "left" || position.direction === "right" ||
                !position.direction) {
                if (y - offsetHeight - MOUSE_GAP > limit.top) {
                    y = y - offsetHeight - MOUSE_GAP;
                } else {
                    y = y + MOUSE_GAP;
                }
            }
        } else {
            if (position.direction === "left") {
                x = x - offsetWidth < limit.left ? x : x - offsetWidth;
            } else if (position.direction === "right") {
                x = x + offsetWidth > limit.right ? x - offsetWidth : x ;
            } else if (position.direction === "top" || position.direction === "bottom") {
                if (x + offsetWidth < limit.right) {
                    x = x;
                } else {
                    x = x - offsetWidth;
                }
            } else {
                if ((x + offsetWidth / 2) > limit.right) {
                    x = limit.right - offsetWidth;
                } else if (x - offsetWidth / 2 < limit.left) {
                    x = limit.left;
                } else {
                    x = x - offsetWidth / 2;
                }
            }

            if (position.direction === "top") {
                y = y - offsetHeight < limit.top ? y : y - offsetHeight;
            } else if (position.direction === "bottom") {
                y = y + offsetHeight > limit.bottom ? y - offsetHeight : y;
            } else if (position.direction === "left" || position.direction === "right" ||
                !position.direction) {
                if (y - offsetHeight > limit.top) {
                    y = y - offsetHeight;
                } else {
                    y = y;
                }
            }
        }

        return {
            "x": x,
            "y": y
        };
    };

    return AreaChartTooltip;
});

define('sap/viz/chart/components/accessibility/AreaDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/accessibility/StackedColumnDataPointNavigator"
], function(oo, TypeUtils, StackedColumnDataPointNavigator) {

    function AreaDataPointNavigator(options) {
        AreaDataPointNavigator.superclass.constructor.apply(this, arguments);
    }

    oo.extend(AreaDataPointNavigator, StackedColumnDataPointNavigator);

    var prot = AreaDataPointNavigator.prototype;

    prot._isMeaningful = function(dp) {
        return dp && TypeUtils.isExist(dp.valueAxis) && !dp.isNullValue;
    };

    return AreaDataPointNavigator;
});

define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForArea',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/components/util/ChartTypeUtils",
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/DOM',
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/interaction/InteractionUtils",
    "sap/viz/framework/interaction/BehaviorManager"
], function(
    Constants,
    TypeUtils,
    HighlightHelper,
    DataGraphics,
    DataPointUtils,
    ChartTypeUtils,
    DataUtils,
    DOM,
    SVG,
    InteractionUtils,
    BehaviorManager
) {
    var areaType = [
        "info/area",
        "info/horizontal_area",
        "info/100_area",
        "info/100_horizontal_area"
    ];
    areaType = ChartTypeUtils.addTrellisType(areaType);

    var CSS_CLASS = Constants.CSS.CLASS;
    var refLinePattern = CSS_CLASS.AREA_REF_LINE;

    var HOVER_STROKE_WIDTH = 2;
    var SELECTED_STROKE_WIDTH = 1;
    var DEFAULT_OPACITY = 0.8;
    var DISPLAY_OPACITY = "1";

    var POSSIBLE_CHILD_NODE_TYPES = ["path", "circle", "rect", "ellipse"];

    function generateTrellisKey(data){
        var key;
        if(data.trellisColumn) {
            key = key || "";
            data.trellisColumn.forEach(function (e) {
                key += DataUtils.getDimensionValue(e) + ".";
            });
        }
        if(data.trellisRow) {
            key = key || "";
            data.trellisRow.forEach(function (e) {
                key += DataUtils.getDimensionValue(e) + ".";
            });
        }
        return key;
    }

    function arrangeDataPointsByTrellis(dataPoints) {
        var arrangedDataPoints = {};
        for(var i = 0; i < dataPoints.length; i ++) {
            var trellisInfo = DataGraphics.getData(dataPoints[i]).trellisInfo;
            var key = generateTrellisKey(trellisInfo);
            if (!arrangedDataPoints[key]){
                arrangedDataPoints[key] = [];
                arrangedDataPoints[key].info = trellisInfo;
            }
            arrangedDataPoints[key].push(dataPoints[i]);
        }
        return arrangedDataPoints;
    }

    function drawSelectedArea(dataPoints, service, arranged, trellisInfo) {
        if(!arranged && DataGraphics.getData(dataPoints[0]).trellisInfo) {
            //for trellis plot
            var trellisDataPoints = arrangeDataPointsByTrellis(dataPoints);
            for(var key in trellisDataPoints) {
                if(trellisDataPoints.hasOwnProperty(key)) {
                    var dps = trellisDataPoints[key];
                    drawSelectedArea(dps, service, true, dps.info);
                }
            }
            return;
        }
        var isHorizontal = service.isHorizontal();
        var dpGroup = dataPoints[0].parentNode.parentNode;
        var parent = SVG.create("g");
        parent.setAttribute("class", CSS_CLASS.AREA_GROUP_SELECTED);
        dpGroup.parentNode.insertBefore(parent, dpGroup);
        var arrangedDataPoints = arrangeSelectedDataPoints(dataPoints);
        for(var i = 0; i < arrangedDataPoints.length; i++) {
            if (arrangedDataPoints[i]){
                addSelectedAreaBySeries(service, arrangedDataPoints[i], parent, isHorizontal, i, trellisInfo);
            }
        }
    }

    function removeSelectedArea(service) {
        var nodes = service.getNodes(service.NodeType.AREA_GROUP_SELECTED, false);
        for(var i = 0, len = nodes.length; i < len; i++) {
            DOM.remove(nodes[i]);
        }
    }

    function arrangeSelectedDataPoints(dataPoints) {
        var arrangedDataPoints = [];
        for(var i = 0; i < dataPoints.length ; i++) {
            var extraData = DataGraphics.getData(dataPoints[i]);
            arrangedDataPoints[extraData.seriesIndex] = arrangedDataPoints[extraData.seriesIndex] || [];
            arrangedDataPoints[extraData.seriesIndex][extraData.itemIndex] = dataPoints[i];
        }
        return arrangedDataPoints;
    }

    function addSelectedAreaBySeries(service, extraDataSeries, parent, isHorizontal, index, trellisInfo) {
        if (!extraDataSeries || extraDataSeries.length < 2) {
            return;
        }
        var drawingEffect = service.getProperties().get('plotArea.drawingEffect');
        var path, area, dataPoint, fill;
        var colors = getFillColorBySeriesIndex(index, service, drawingEffect, trellisInfo);
        if(colors) {
            fill = colors.customizedColor || colors.defaultColor;
        }

        var properties = service.getProperties();
        var customizedAreaRenderer = properties.get('plotArea.areaRenderer');
        if (service._getChartType() === "info/combinationEx") {
            customizedAreaRenderer = properties.get('plotArea.area.renderer');
        }
        if(customizedAreaRenderer) {
            var areaG = DataPointUtils.findArea(parent.parentNode, index);
            var areGData = DataGraphics.getData(areaG);
            if(areGData.color) {
                fill = areGData.color;
            }
        }

        var itemLength = extraDataSeries.length;
        var tempData = [], points = [];
        for(var i = 0; i < itemLength; i ++) {
            dataPoint = extraDataSeries[i];
            if(extraDataSeries[i]) {
                tempData.push(DataGraphics.getData(dataPoint));
                points.push(dataPoint);
            } else {
                path = buildPath(tempData, isHorizontal);
                if (path) {
                    area = createArea(path, points, fill);
                    parent.appendChild(area);
                }
                tempData = [];
                points = [];
            }
        }
        path = buildPath(tempData, isHorizontal);
        if (path) {
            area = createArea(path, points, fill);
            parent.appendChild(area);
        }
    }

    function getFillColorBySeriesIndex(index, service, drawingEffect, trellisInfo) {
        var plotModule;
        if (trellisInfo){
            plotModule = service.getModule("main").getChildPlot(trellisInfo);
        } else {
            plotModule = service.getModule("main.plot");
        }
        if (!plotModule || !plotModule.getSeriesStyle) {
            return null;
        }
        var config = plotModule.getSeriesStyle(index);
        var options = {
            isReverse: true
        };
        var colors = HighlightHelper.getColors(service, null, null, null, drawingEffect, options, config);
        if (colors) {
            return colors;
        }
        return null;
    }

    function createArea(path, dataPoints, fill) {
        var area = SVG.create("path");
        area.setAttribute("d", path);
        area.setAttribute("fill", fill);
        area.setAttribute("fill-opacity", DEFAULT_OPACITY);
        DataGraphics.setData(area, {"dataPoints" : dataPoints});
        area.setAttribute("class", CSS_CLASS.AREA_SELECTED);
        return area;
    }

    var getPathStr = function(command, x, y){
        return command + x + "," + y;
    };

    var buildPath = function(data, isHorizontal) {
        var n = 1, length = data.length;
        if (length <= 1) {
            return null;
        }
        var position = data[0].position;
        var d = getPathStr("M", position.x, position.y);
        var dRev;

        if (isHorizontal) {
            dRev = getPathStr("L", position.x - position.width, position.y);
            for (; n < length; n++) {
                position = data[n].position;
                d += getPathStr("L", position.x, position.y);
                dRev = getPathStr("L", position.x - position.width, position.y) + dRev;
            }
        } else {
            dRev = getPathStr("L", position.x, position.y + position.height);
            for (; n < length; n++) {
                position = data[n].position;
                d += getPathStr("L", position.x, position.y);
                dRev = getPathStr("L", position.x, position.y + position.height) + dRev;
            }
        }
        d += dRev;
        return d;
    };

    function createRefLine(service, e){
        var data = DataGraphics.getData(e);
        var trellisInfo = data.trellisInfo;
        var plotModule;
        if (trellisInfo){
            plotModule = service.getModule("main").getChildPlot(trellisInfo);
        } else {
            plotModule = service.getModule("main.plot");
        }
        if (!plotModule || !plotModule.drawAreaRefLine) {
            return null;
        }
        return plotModule.drawAreaRefLine(data.seriesIndex, data.itemIndex);
    }

    function renderRefLine(service, e, isShow, colorProp, strokeWidth){
        var dpId = DataPointUtils.getDataPointId(e);
        var nodes = service.getNodes(service.NodeType.AREA_REF_LINE, false);
        var refNode = DataPointUtils.findByDataPointIds(nodes, dpId)[0];
        if (!refNode){
            refNode = createRefLine(service, e);
            if (!refNode){
                return;
            }
        }
        refNode.setAttribute("stroke-width", strokeWidth);
        var drawingEffect = service.getProperties().get('plotArea.drawingEffect');
        var color = HighlightHelper.getColors(service, e, colorProp, null, drawingEffect);
        color = color.customizedColor || color.defaultColor;
        refNode.setAttribute("stroke", color);
        if (isShow) {
            refNode.setAttribute("opacity", DISPLAY_OPACITY);
            refNode.setAttribute("fill-opacity", DISPLAY_OPACITY);
            refNode.setAttribute("stroke-opacity", DISPLAY_OPACITY);
        } else {
            var defaultOpacity = DataGraphics.getData(e).opacity;
            if (defaultOpacity === 0) {
                refNode.setAttribute("opacity", defaultOpacity);
                refNode.setAttribute("fill-opacity", defaultOpacity);
                refNode.setAttribute("stroke-opacity", defaultOpacity);
            } else {
                refNode.removeAttribute("opacity");
                refNode.removeAttribute("fill-opacity");
                refNode.removeAttribute("stroke-opacity");
            }
        }
    }

    function setOpacity(e, isShow) {
        var child = e.firstChild;
        if (isShow){
            e.setAttribute("opacity", DISPLAY_OPACITY);
            if (child){
                child.setAttribute("stroke-opacity", DISPLAY_OPACITY);
                child.setAttribute("fill-opacity", DISPLAY_OPACITY);
            }
        } else {
            var defaultOpacity = DataGraphics.getData(e).opacity;
            e.removeAttribute("stroke");
            e.removeAttribute("opacity");
            e.removeAttribute("fill-opacity");
            e.removeAttribute("stroke-opacity");
            if (child){
                if (defaultOpacity === 0){
                    e.setAttribute("opacity", defaultOpacity);
                    child.setAttribute("stroke-opacity", defaultOpacity);
                    child.setAttribute("fill-opacity", defaultOpacity);
                } else {
                    child.removeAttribute("stroke-opacity");
                    child.removeAttribute("fill-opacity");
                }
            }
        }
    }

    var area = [{
        "id": "selectDataPoint_area",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            //elements my be empty which is caused by lazy loading
            if (!elements || !elements.length) {
                return;
            }
            removeSelectedArea(service);
            drawSelectedArea(elements, service);
            var dataModel = service.getDataModel();
            var properties = service.getProperties();
            var prop = properties.get('interaction.selected');
            var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            elements.forEach(function(e) {
                var dataId = DataPointUtils.getDataPointId(e);
                var dataPoint = dataModel.getDataPoint(dataId);
                if (dataPoint) {
                    renderRefLine(service, e, true, prop.color, 1);
                    POSSIBLE_CHILD_NODE_TYPES.forEach(function(type){
                        HighlightHelper.drawStroke(service, e, type, prop.stroke, 1);
                        HighlightHelper.drawFill(service, e, type, prop, isMarkerRenderExist, true);
                    });
                    setOpacity(e, true);
                }
            });
        }
    }, {
        "id": "deselectDataPoint_area",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            removeSelectedArea(service);
            var dataModel = service.getDataModel();
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop = event.data.isAnyOtherSelected?
                properties.get('interaction.deselected'):
                properties.get('plotArea.dataPoint');
            var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            elements.forEach(function(e) {
                var dataId = DataPointUtils.getDataPointId(e);
                var dataPoint = dataModel.getDataPoint(dataId);
                if (dataPoint) {
                    renderRefLine(service, e, false, prop.color, 1);
                    POSSIBLE_CHILD_NODE_TYPES.forEach(function(type){
                        HighlightHelper.drawStroke(service, e, type, prop.stroke, 1);
                        HighlightHelper.drawFill(service, e, type, prop, isMarkerRenderExist, true);
                    });
                    setOpacity(e, false);
                }
            });
        }
    }, {
        "id": "hoverOnDataPoint_area",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var dataModel = service.getDataModel();
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop = properties.get('interaction.hover');
            var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            elements.forEach(function(e) {
                var dataId = DataPointUtils.getDataPointId(e);
                var dataPoint = dataModel.getDataPoint(dataId);
                if (dataPoint) {
                    renderRefLine(service, e, true, prop.color, 2);
                    POSSIBLE_CHILD_NODE_TYPES.forEach(function(type){
                        HighlightHelper.drawStroke(service, e, type, prop.stroke, 2);
                        HighlightHelper.drawFill(service, e, type, prop, isMarkerRenderExist, true);
                    });
                    setOpacity(e, true);
                }
            });
        }
    }, {
        "id": "unhoverOnDataPoint_area",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop;
            var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var selectedDataPoints = service.getStatus("selectedDataPoints");
            elements.forEach(function(e) {
                var visible;
                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    prop = properties.get('interaction.selected');
                    visible = true;
                } else {
                    if (selectedDataPoints.length) {
                        prop = properties.get('interaction.deselected');
                    } else {
                        prop = properties.get('plotArea.dataPoint');
                    }
                    visible = false;
                }
                renderRefLine(service, e, visible, prop.color, 1);
                POSSIBLE_CHILD_NODE_TYPES.forEach(function(type){
                    HighlightHelper.drawStroke(service, e, type, prop.stroke, 1);
                    HighlightHelper.drawFill(service, e, type, prop, isMarkerRenderExist, true);
                });
                setOpacity(e, visible);
            });
        }
    }, {
        "id": "clearPlot_area",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var mainNode = service.getStatus("areaDataPoints") || service.getNodes(service.NodeType.DATA_POINT, false);
            if (!mainNode || !mainNode.length) {
                return;
            }
            var gray = event.data.isGray;
            var properties = service.getProperties();
            var prop = gray? properties.get('interaction.deselected'): properties.get('plotArea.dataPoint');
            var isMarkerRenderExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            mainNode.forEach(function(e) {
                renderRefLine(service, e, false, prop.color, 1);
                POSSIBLE_CHILD_NODE_TYPES.forEach(function(type){
                    HighlightHelper.drawStroke(service, e, type, prop.stroke, 1);
                    HighlightHelper.drawFill(service, e, type, prop, isMarkerRenderExist, true);
                });
                setOpacity(e, false);
            });

            var color = properties.get('interaction.deselected.color');
            var drawingEffect = properties.get('plotArea.drawingEffect');
            var areaNodes = service.getNodes(service.NodeType.AREA, false);
            areaNodes.forEach(function(e){
                var options = {
                    isReverse : true
                };
                var colors = HighlightHelper.getColors(service, e, color, null, drawingEffect, options);
                var areaPath = e.querySelector('.' + CSS_CLASS.AREA_PATH);
                var linePath = e.querySelector('.' + CSS_CLASS.AREA_LINE_PATH);
                if(gray && colors.customizedColor) {
                    e.setAttribute('fill', colors.customizedColor);
                    areaPath.setAttribute('fill', colors.customizedColor);
                    linePath.setAttribute('fill', colors.customizedColor);
                }else{
                    e.setAttribute('fill', colors.defaultColor);
                    areaPath.setAttribute('fill', colors.defaultColor);
                    linePath.setAttribute('fill', colors.defaultColor);
                }
            });
        }
    },
    InteractionUtils.getDeselectEvent("click_on_non_selection_area", areaType,
            HighlightHelper.getDeselAllExTargets())];
    BehaviorManager.registerAll(area);
    return area;
});

define('sap/viz/chart/behavior/config/AreaBehaviorConfig',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/interaction/Constants",
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/chart/components/util/ChartTypeUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/interaction/BehaviorManager"
], function(
    Constants,
    SDKConstants,
    UADetector,
    DataPointUtils,
    HighlightHelper,
    TypeUtils,
    SelectionUtil,
    ObjectUtils,
    ChartTypeUtils,
    DataGraphics,
    BehaviorManager
) {
    var areaTypeExcludeComboEx = [
        "info/area",
        "info/horizontal_area",
        "info/100_area",
        "info/100_horizontal_area"
    ];
    var areaType = areaTypeExcludeComboEx.concat(["info/combinationEx"]);

    areaType = ChartTypeUtils.addTrellisType(areaType);

    var BehaviorConstants = SDKConstants.BEHAVIOR;
    var CSS_CLASS = Constants.CSS.CLASS;
    var dataPointPattern = CSS_CLASS.DATAPOINT;
    var dataLabelPattern = CSS_CLASS.DATALABEL;
    var areaPattern = CSS_CLASS.AREA;
    var selectedAreaPattern = CSS_CLASS.AREA_SELECTED;

    function getMousePosition(e) {
        if (isMobile()) {
            return e.data.point;
        }
        var event = e.data.originalEvent || window.event;
        return {
            x: event.clientX,
            y: event.clientY
        };
    }

    function getDataPointCoord(dataPoint) {
        var rect = dataPoint.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
    }

    function getDataPointByMousePoint(point, nodes, service) {
        var isHorizontal = service.isHorizontal();
        var coord = isHorizontal ? "y" : "x";
        var temp, result, position;
        nodes.forEach(function(item) {
            position = getDataPointCoord(item);
            var less = Math.abs(position[coord] - point[coord]);
            if (!result || !temp) {
                result = item;
                temp = less;
                return;
            }
            if (less < temp) {
                temp = less;
                result = item;
            }
        });
        return result;
    }

    function getRelatedPoints(target) {
        if (target) {
            var dataPoints = DataGraphics.getData(target).dataPoints;
            return dataPoints;
        }
    }

    function getHitDataPoint(event, service) {
        var mousePosition = getMousePosition(event);
        var relatedPoints = getRelatedPoints(event.data.currentTarget);
        return getDataPointByMousePoint(mousePosition, relatedPoints, service);
    }

    function isMobile() {
        return UADetector.isMobile();
    }

    function getAdjustedPoint(dataPoint, event, service) {
        var point = event.data.point;
        var position = {};
        position.isHorizontal = service.isHorizontal();
        var mousePoint = getMousePosition(event);
        var mousePosX = mousePoint.x || 0;
        var mousePosY = mousePoint.y || 0;
        var dpPosition = getDataPointCoord(dataPoint);
        if (position.isHorizontal) {
            position.direction = dpPosition.y - mousePosY > 0 ? "top" : "bottom";
            position.x = point.x;
            if (isMobile()) {
                position.y = dpPosition.y;
            } else {
                position.y = point.y + (mousePoint.y && (dpPosition.y - mousePoint.y) || 0);
            }
        } else {
            position.direction = dpPosition.x - mousePosX> 0 ? "left" : "right";
            if (isMobile()) {
                position.x = dpPosition.x;
            } else {
                position.x = point.x + (mousePoint.x && (dpPosition.x - mousePoint.x) || 0);
            }
            position.y = point.y;
        }
        return position;
    }

    function getDataPointByRefNode(event, service) {
        var dpId = DataPointUtils.getDataPointId(event.data.currentTarget);
        var nodes = service.getNodes(service.NodeType.DATA_POINT, false);
        return DataPointUtils.findByDataPointIds(nodes, dpId)[0];
    }

    var area = [{
        "id": "click_on_datalabel",
        "triggerEvent": {
            "name": "click",
            "targets": [dataLabelPattern],
            "excludeTargets":['v-m-action-layerrange'],
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            event.data.point = getAdjustedPoint(getDataPointByRefNode(event, service), event, service);
            service.fireEvent(event, true);
        }
    }, {
        "id": "hover_on_datalabel",
        "triggerEvent": {
            "name": "hover",
            "targets": [dataLabelPattern],
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            event.data.point = getAdjustedPoint(getDataPointByRefNode(event, service), event, service);
            service.fireEvent(event, true);
        }
    }, {
        "id": "click_on_datapoint",
        "triggerEvent": {
            "name": "click",
            "targets": [dataPointPattern],
            "excludeTargets":['v-m-action-layerrange'],
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            event.data.point = getAdjustedPoint(event.data.currentTarget, event, service);
            service.fireEvent(event, true);
        }
    }, {
        "id": "hover_on_datapoint",
        "triggerEvent": {
            "name": "hover",
            "targets": [dataPointPattern],
            "supportedChartTypes": areaTypeExcludeComboEx
        },
        "handler": function(event, service) {
            event.data.point = getAdjustedPoint(event.data.currentTarget, event, service);
            service.fireEvent(event, true);
        }
    }, {
        "id": "click_on_area",
        "triggerEvent": {
            "name": "click",
            "targets": [areaPattern, selectedAreaPattern],
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            var targetPoint = getHitDataPoint(event, service);
            event.data.currentTarget = event.data.target = targetPoint;
            event.data.point = getAdjustedPoint(targetPoint, event, service);
            service.fireEvent(event, true);
        }
    }, {
        "id": "hover_on_area",
        "triggerEvent": {
            "name": "hover",
            "targets": [areaPattern, selectedAreaPattern],
            "supportedChartTypes": areaType
        },
        "handler": function(event, service) {
            var targetPoint = getHitDataPoint(event, service);
            event.data.currentTarget = event.data.target = targetPoint;
            event.data.point = getAdjustedPoint(targetPoint, event, service);
            service.fireEvent(event, true);
        }
    }];
    BehaviorManager.registerAll(area);
    return area;
});

define('sap/viz/chart/components/plots/AreaPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/BaseColumnPlot',
    'sap/viz/chart/components/plots/LinePlot',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/util/AreaSeriesUtil',
    'sap/viz/chart/components/renderers/AreaSeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    'sap/viz/chart/components/renderers/AreaRefLineRenderer',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/datalabels/AreaDataLabels',
    "sap/viz/chart/components/plots/XYPlotFactory",
    "sap/viz/chart/behavior/config/TooltipClassMap",
    "sap/viz/chart/behavior/config/tooltip/AreaChartTooltip",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/AreaDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    "sap/viz/chart/behavior/config/DataPointBehaviorConfigForArea",
    "sap/viz/chart/behavior/config/AreaBehaviorConfig"

], function Setup(
    oo,
    BaseColumnPlot,
    LinePlot,
    ContextBuilder,
    DOM,
    SVG,
    DataGraphics,
    Constants,
    ObjectUtils,
    DataUtils,
    NameColorUtils,
    UADetector,
    DrawUtil,
    DataPointUtils,
    SeriesUtil,
    AreaSeriesRenderer,
    PathRenderer,
    AreaRefLineRenderer,
    ScaleHandler,
    DataHandler,
    ItemScaleHandler,
    AreaDataLabels,
    XYPlotFactory,
    TooltipClassMap,
    AreaChartTooltip,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants
) {

    var MARKER_RADIUS = 3;
    var MARKER_BORDER_WIDTH = 2;
    var AREA_OPACITY = 0.8;

    var categorySize = {
        desktop : {
            minWidth : 24
        },
        mobile : {
            minWidth : 48
        }
    };
    var trellisCategorySize = {
        desktop : {
            minWidth : 16
        },
        mobile : {
            minWidth : 16
        }
    };

    var CSS_CLASS = Constants.CSS.CLASS;

    var DATAPOINT_CLASS = [
        CSS_CLASS.DATAPOINT,
        CSS_CLASS.MORPHABLEDATAPOINT,
        CSS_CLASS.DATAPOINTDEFAULT
    ].join(" ");

    var AreaPlot = function(runtime, options) {
        this._seriesColorStyleMap = {};
        AreaPlot.superclass.constructor.apply(this, arguments);
        this._dataPointRenderer = PathRenderer;
        this._flipNegativeShape = false;
        var markMgr = this.runtime().markManager();
        markMgr.setMode("single");
        markMgr.lock();
        markMgr.setShape("circle");
        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.bindSeriesStyleProperty(this._name + ".seriesStyle");
    };

    oo.extend(AreaPlot, BaseColumnPlot);

    AreaPlot.prototype._getDataLabels = function(name, runtime) {
        var options = ObjectUtils.extend({}, this._options);
        options.name = name;
        return new AreaDataLabels(runtime, options, this._seriesColorStyleMap);
    };

    AreaPlot.prototype._getDataHandler = function() {
        return {
            "valueAxis" : DataHandler.getStackHandler(false)
        };
    };

    AreaPlot.prototype._buildConfig = function(data, position, context) {
        var config = AreaPlot.superclass._buildConfig.apply(this, arguments);
        config.graphic.d = this._markerD;
        return config;
    };

    AreaPlot.prototype._getFillColorConfig = function(config, context, options, data) {
        var additionCtx =  (data && !data.isNullValue) ? data.dp.additionCtx() : {};
        var result = options.disableSemantic ? null :
            this._semanticMgr.analyzeDataPoint("color", context, true, additionCtx);
        if (result == null || (result.properties == null)) {
            if (config.graphic) {
                if (config.graphic.fill) {
                    config.graphic.fill = NameColorUtils.convertColor(config.graphic.fill);
                }
                if (config.graphic.color) {
                    config.graphic.color = NameColorUtils.convertColor(config.graphic.color);
                }
                if(config.graphic.borderColor) {
                    config.graphic.borderColor = NameColorUtils.convertColor(config.graphic.borderColor);
                }
                config.graphic.opacity = 0;
            }
            if (config.data && config.data.color) {
                config.data.color = NameColorUtils.convertColor(config.data.color);
            }
            return config;
        }

        if (result.properties.color) {
            var color = NameColorUtils.convertColor(result.properties.color);
            if (config.graphic) {
                if(config.graphic.hasOwnProperty("fill")) {
                    config.graphic.fill = color;
                }
                if(config.graphic.hasOwnProperty("color")) {
                    config.graphic.color = color;
                }
                config.graphic.opacity = result.isOthers ? 0 : 1;
            }
            if (config.data && config.data.color) {
                config.data.color = color;
            }
            config.displayName = result.displayName;
        } else {
            config.graphic.opacity = 0;
        }

        if (result.properties.stroke) {
            config.graphic.stroke = result.properties.stroke;
        }
        if (result.properties.strokeWidth) {
            config.graphic.strokeWidth = result.properties.strokeWidth;
        }
        return config;
    };

    AreaPlot.prototype._preRender = function() {
        AreaPlot.superclass._preRender.apply(this, arguments);
        this._markerD = DrawUtil.createMarkerData({
            type : "circle",
            rx : MARKER_RADIUS,
            ry : MARKER_RADIUS,
            borderWidth : MARKER_BORDER_WIDTH
        });
    };

    AreaPlot.prototype._getSeriesRenderer = function() {
        return new AreaSeriesRenderer(this._renderArea.bind(this), this._updateArea.bind(this));
    };

    AreaPlot.prototype._updateArea = function(areaGroup, data, index, renderer) {
        var _getFill = function(data) {
            //since the first dp may be null value, the fill value must be scaned to get
            for(var i = 0; i < data.length; i ++) {
                if(data[i] && data[i].dpConfig && data[i].dataPoint && data[i].dpConfig.graphic &&
                    data[i].dpConfig.graphic.fill) {
                    //adapt to effectManager, especially the ghost template
                    return data[i].dpConfig.graphic.fill;
                }
            }
            return undefined;
        };
        var props = this._properties.get();
        var areaRenderer = renderer || this._properties.get("areaRenderer");
        var context = ContextBuilder.buildSeriesLineContext(this._data, index);
        var datapoints = this._series[index].getDataPoints();
        var options = {
            drawingEffect: props.drawingEffect,
            effectManager: this._effectManager,
            fillColor: _getFill(data),
            opacity: AREA_OPACITY,
            isHorizontal: this.isHorizontal(),
            seriesFirstAndLastDpIdx: {
                firstIdx: datapoints[0] && datapoints[0].getDataPointId(),
                lastIdx: datapoints[datapoints.length - 1] &&
                    datapoints[datapoints.length - 1].getDataPointId()
            }
        };
        var updated = SeriesUtil.updateArea(areaGroup, data, index, areaRenderer, context, options);
        if (!updated) {
            var areaG = DataPointUtils.findArea(areaGroup, index);
            if (areaG){
                areaGroup.removeChild(areaG);
            }
            this._renderArea(areaGroup, data, index);
        }
    };

    AreaPlot.prototype._renderArea = function(areaGroup, data, index, ctx, renderer) {
        var props = this._properties;
        var areaRenderer = renderer || props.get("areaRenderer");
        var drawingEffect = props.get("drawingEffect");
        var revIdx = this._data.series.length - 1 - index;
        var effectMgr = this._effectManager;

        var context = ctx || ContextBuilder.buildSeriesLineContext(this._data, revIdx,
                ["color", "color2", "trellisColumn", "trellisRow"]);
        var seriesStyle = this.getSeriesStyle(index, context);
        if(this._seriesColorStyleMap) {
            this._seriesColorStyleMap[index] = seriesStyle;
        }
        var propMgr = this.runtime().propertyManager();
        var datapoints = this._series[index].getDataPoints();
        var seriesFirstAndLastDpIdx = {
            firstIdx: datapoints[0] && datapoints[0].getDataPointId(),
            lastIdx: datapoints[datapoints.length - 1] && datapoints[datapoints.length - 1].getDataPointId()
        };
        SeriesUtil.drawArea(areaGroup, data, index, drawingEffect, effectMgr,
            context, areaRenderer, seriesStyle, this.isHorizontal(), propMgr, seriesFirstAndLastDpIdx);
    };

    AreaPlot.prototype.getSeriesStyle = function(seriesIndex, context) {

        var revIdx = this._data.series.length - 1 - seriesIndex;
        var semanticMgr = this._semanticMgr;

        context = context || ContextBuilder.buildSeriesLineContext(this._data, revIdx,
                ["color", "color2", "trellisColumn", "trellisRow"]);

        var semanticProps = semanticMgr.analyzeSeriesStyle(context, "area");

        var color;
        if (semanticProps && semanticProps.area && semanticProps.area.color) {
            color = semanticProps.area.color;
        } else if (semanticMgr.hasDataPointColorStyle() && semanticMgr.isOverrideMode()) {
            color = semanticMgr.getOthersStyle("color").properties.color;
        } else {
            var seriesInfo = ContextBuilder.getSeriesScaleInfo(this._data, revIdx, ["color"]);
            if (seriesInfo){
                color = this._data[seriesInfo.field].scale.scale(seriesInfo.domain);
            } else {
                //If color is not bind, use default single color instead.
                color = this._data.color.scale.getRange()[0];
            }
        }
        return {
            color: NameColorUtils.convertColor(color)
        };

    };

    AreaPlot.prototype._hideNode = function(dataPoints, index) {
        var dataPointModel = dataPoints[index];
        if (dataPointModel) {
            DOM.remove(dataPointModel.getNode());
            DOM.remove(dataPointModel.getRefNode());
            dataPointModel.setNode(null).setRefNode(null);
        }
    };

    AreaPlot.prototype._showDataPoints = function(dataPointG) {
        this._preShowDataPoints();
        var newDataPoints = [];
        this._dataPointContext = [];
        this._seriesRenderer.resetDataPoints();

        var mndIndex;
        var dataColor = this._data.color;
        if(dataColor && dataColor.metaData){
            var result = DataUtils.checkMndStatus(dataColor.metaData , dataColor.rowArray);
            if(result.isOnlyOneMndValue){
                mndIndex = result.mndIndex;
            }
        }
        var seriesIter = this.createSeriesIterator(this._series.length);
        var range = this._getVisibleRange();
        var nodeGroup;
        while (seriesIter.hasNext()) {
            var seriesIndex = seriesIter.next();
            var seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }
            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
            var dataPoints = seriesModel.getDataPoints();
            var curRange = this._getDataPointRange(dataPoints, range);
            this._hideDataPoints(dataPoints, curRange);
            for (var itemIndex = curRange.min; itemIndex <= curRange.max; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }
                var data = dataPointModel.getRawData();
                var dp = data.dp;
                var position = this._getDataPointPosition(dataPointModel);
                if (!position) {
                    continue;
                }
                var itemChanged = false;
                var dpConfig = dataPointModel.getConfig();
                if(!dpConfig){
                    itemChanged = true;
                    var ctx = dp && dp.context() ? dp.context() : Constants.NULL_VALUE;
                    dpConfig = this._buildWrapperConfig(data, position, ctx, {itemIndex : itemIndex});
                }
                this._dataPointContext.push(dpConfig);
                var dpData = dataPointModel.getData();
                if(!dpData){
                    itemChanged = true;
                    var currentId = dataPointModel.getId();
                    dpData = this._buildData(dpConfig);
                    dataPointModel.init(dpConfig, currentId, dpData,
                        dp && dp.id ? dp.id : Constants.NULL_VALUE, mndIndex);
                }

                var dpNode = dataPointModel.getNode();
                var dpRefNode = dataPointModel.getRefNode();
                if(dpNode){
                    if(itemChanged){
                        this._updateDatapoint(dpNode, dpRenderer, dpConfig, position);
                        this._updateDatapointRefLine(dpRefNode, dpConfig, position);
                        newDataPoints.push(dpNode);
                    }
                } else {
                    nodeGroup = this._drawDataPointWithRefLine(dpRenderer, dataPointModel);
                    if (nodeGroup) {
                        dpNode = nodeGroup.node;
                        dpRefNode = nodeGroup.refNode;
                        dataPointModel.setNode(dpNode).setRefNode(dpRefNode);
                        if (dpNode) {
                            newDataPoints.push(dpNode);
                        }
                    } else {
                        dataPointModel.setNode(null).setRefNode(null);
                    }
                }

                this._seriesRenderer.addDataPoint(
                    seriesIter.index(), itemIndex, dpConfig, position, dpNode, dpRefNode);

            }
        }
        return newDataPoints;
    };

    AreaPlot.prototype._getValueScaleHandlers = function(isHorizontal) {
        return [ScaleHandler.getValueScaleHandler("valueAxis", {
            isHorizontal: isHorizontal
        })];
    };

    AreaPlot.prototype._getCategoryScaleHandlers = function() {
        return [ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: false,
            itemScaleHandler: ItemScaleHandler.get(false),
            alignment: "center"
        })];
    };

    AreaPlot.prototype._adjustPosition = function(position) {
        if (this.isHorizontal()) {
            position.x += position.width;
        }
    };

    AreaPlot.prototype.drawAreaRefLine = function(sIdx, cIdx){
        var series = this._series[sIdx];
        if (!series){
            return null;
        }
        var dataPoint = series.getDataPoints()[cIdx];
        if (!dataPoint){
            return null;
        }
        var dpConfig = dataPoint.getConfig();
        if (dpConfig.ctx === Constants.NULL_VALUE) {
            return null;
        }
        var position = this._adjustDataPointPosition(dataPoint.getPosition());
        if (!position) {
            return null;
        }
        var refLineNode = AreaRefLineRenderer(dpConfig);
        refLineNode.setAttribute("class", CSS_CLASS.AREA_REF_LINE);
        DataPointUtils.setDataId(refLineNode, dataPoint.getDataId());
        DataPointUtils.setDataPointId(refLineNode, dataPoint.getDataPointId());
        if (position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            var str = 'translate(' + position.x + ', ' + position.y + ')';
            refLineNode.setAttribute("transform", str);
        }
        dataPoint.setRefNode(refLineNode);
        this._seriesRenderer.addDataPointRefLine(sIdx, cIdx, refLineNode);
        return refLineNode;
    };

    AreaPlot.prototype._drawDataPointWithRefLine = function(dpRenderer, dataPoint) {
        var dpConfig = dataPoint.getConfig();
        if (dpConfig.ctx === Constants.NULL_VALUE) {
            return null;
        }

        var position = this._adjustDataPointPosition(dataPoint.getPosition());
        if (!position) {
            return null;
        }

        var dataPointG = SVG.create("g");
        DataPointUtils.setDataId(dataPointG, dataPoint.getDataId());
        DataPointUtils.setDataPointId(dataPointG, dataPoint.getDataPointId());
        DataGraphics.setContext(dataPointG, dataPoint.getContext());
        DataGraphics.setAdditionCtx(dataPointG, dataPoint.getAdditionCtx());
        DataGraphics.setData(dataPointG, dataPoint.getData());
        dataPointG.setAttribute("class", DATAPOINT_CLASS);

        var opacity = dpConfig.graphic.opacity;
        var refLineNode = null;
        if (opacity !== 0){
            refLineNode = AreaRefLineRenderer(dpConfig);
            refLineNode.setAttribute("class", CSS_CLASS.AREA_REF_LINE);
            DataPointUtils.setDataId(refLineNode, dataPoint.getDataId());
            DataPointUtils.setDataPointId(refLineNode, dataPoint.getDataPointId());
        } else {
            dataPointG.setAttribute("opacity", opacity);
        }

        if (position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            var str = 'translate(' + position.x + ', ' + position.y + ')';
            dataPointG.setAttribute("transform", str);
            if (refLineNode){
                refLineNode.setAttribute("transform", str);
            }
        }

        var node = this._applyDataPointRenderer(dpRenderer, dpConfig);
        if (!node && this._dataPointRenderer) {
            node = this._dataPointRenderer(dpConfig);
        }

        dataPointG.appendChild(node);

        if (this._flipNegativeShape) {
            var negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
            if (negative) { //flip
                this._addNegativeClass(dataPointG, dpConfig);
            }
        }
        return {
            node: dataPointG,
            refNode: refLineNode
        };
    };

    //This is for checking if the data point is on the edge of plot
    //Move all data point be in plot
    AreaPlot.prototype._adjustDataPointPosition = function(position) {
        if (!position){
            return null;
        }
        var plotAreaSize = this._realSize;
        var paddingEdge = MARKER_RADIUS + MARKER_BORDER_WIDTH / 2;
        var x = position.x;
        var y = position.y;
        //Add 1 px tolerance
        if (x < -1 || y < -1 || x > plotAreaSize.width + 1 || y > plotAreaSize.height + 1) {
            return {
                "x": x,
                "y": y
            };
        }
        if ((x - paddingEdge) < 0) {
            x = paddingEdge;
        } else if ((x + paddingEdge) > plotAreaSize.width) {
            x = plotAreaSize.width - paddingEdge;
        }
        if ((y - paddingEdge) < 0) {
            y = paddingEdge;
        } else if ((y + paddingEdge) > plotAreaSize.height) {
            y = plotAreaSize.height - paddingEdge;
        }
        return {
            "x": x,
            "y": y
        };
    };

    AreaPlot.prototype._buildData = function(dpConfig) {
        return {
            color: dpConfig.graphic.fill,
            position: dpConfig.position,
            trellisInfo: dpConfig.trellisInfo,
            opacity: dpConfig.graphic.opacity
        };
    };

    AreaPlot.prototype._getSeries = function() {
        if(this._data.series){
            return this._data.series.slice().reverse();
        } else {
            return [];
        }
    };

    AreaPlot.prototype._isEmptySeries = function(array) {
        if (!array || array.length <= 0) {
            return true;
        }
        for(var i = 0; i < array.length; i ++) {
            if (array[i]) {
                return false;
            }
        }
        return true;
    };

    AreaPlot.prototype._fixSeriesForMulti = function(areaSeries) {
        var seriesData = areaSeries || this._data.series;
        //If all values of the category are null, skip the category
        var series, i, j, category;
        var iLen = seriesData.length;
        var jLen;
        var tempData = [], emptyCatory = [];
        for(i = 0; i < iLen; i ++) {
            series = seriesData[i];
            jLen = series.length;
            for(j = 0; j < jLen; j ++) {
                tempData[j] = tempData[j] || [];
                if (series[j]) {
                    tempData[j][i] = series[j];
                }
            }
        }

        for(i = 0; i < tempData.length; i ++) {
            category = tempData[i];
            if (category.length === 0) {
                emptyCatory.push(i);
            }
        }

        //for area chart with multi series, the null value will be operated as 0
        //but the context will show that this is a null value
        for(i = 0; i < iLen; i ++) {
            series = seriesData[i];
            jLen = series.length;
            //Skip empty series
            if (this._isEmptySeries(series)) {
                continue;
            }
            for(j = 0; j < jLen; j ++) {
                var v = series.measureMeta[0];
                if (emptyCatory.indexOf(j) >= 0) {
                    continue;
                }
                if(series[j] === undefined) {
                    series[j] = {
                        "isNullValue": true
                    };
                    series[j][v] = 0;
                }
            }
        }
    };

    AreaPlot.prototype.setData = function(data) {
        AreaPlot.superclass.setData.apply(this, arguments);
        this._fixSeriesForMulti();
    };

    AreaPlot.prototype._updateDatapoint = function(dataPointG, dpRenderer, dpConfig, position) {
        AreaPlot.superclass._updateDatapoint.apply(this, arguments);

        if (dataPointG && position.hasOwnProperty("x") && position.hasOwnProperty("y") &&
            position.hasOwnProperty("height") && position.hasOwnProperty("width")) {
            var data = DataGraphics.getData(dataPointG);
            if (data && data.position){
                data.position.x = position.x;
                data.position.y = position.y;
                data.position.height = position.height;
                data.position.width = position.width;
            }
        }
    };

    AreaPlot.prototype._updateDatapointRefLine = function(refLineNode, dpConfig, position) {
        if (refLineNode && position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            refLineNode.setAttribute("transform", 'translate(' + position.x + ', ' + position.y +
                ')');
            AreaRefLineRenderer.update(refLineNode, dpConfig);
        }
    };

    AreaPlot.prototype._buildWrapperConfig = function(data, position, context) {
        var config = AreaPlot.superclass._buildWrapperConfig.apply(this, arguments);
        config.position = position;
        return config;
    };

    AreaPlot.prototype._getMinCategoryWidth = function(isRangeIncomplete){
        var inTrellis = !!this._options.inTrellis;
        var props = this._properties;
        if (isRangeIncomplete ||
            inTrellis || (props.get('isFixedDataPointSize') && !props.origin.get("interaction.noninteractiveMode"))) {
            var sizeDefinition = inTrellis ? trellisCategorySize : categorySize;
            var minWidth = UADetector.isMobile()? sizeDefinition.mobile.minWidth : sizeDefinition.desktop.minWidth;
            return minWidth;
        } else {
            return 0;
        }
    };

    AreaPlot.prototype.getSeriesIndex = function(dp){
        return this._series.length -  dp._addr[1] - 1;
    };

    AreaPlot.prototype.getPreferredSize = function () {
        return LinePlot.prototype.getPreferredSize.apply(this, arguments);
    };

    XYPlotFactory.registerClazz("area", AreaPlot);
    XYPlotFactory.registerClazz("horizontal_area", AreaPlot);
    TooltipClassMap.register(["info/area", "info/horizontal_area",
                                    "info/trellis_area", "info/trellis_horizontal_area",
                                    "info/100_area", "info/100_horizontal_area", "info/trellis_100_area",
                                    "info/trellis_100_horizontal_area"
                                   ], AreaChartTooltip);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.AREA, DataPointNavigator);
    return AreaPlot;
});

define('sap/viz/chart/components/datalabels/AreaPercentageDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/datalabels/AreaDataLabels',
    'sap/viz/chart/components/util/PercentageDataLabelUtil'
], function(oo, DataLabels, AreaDataLabels, PercentageDataLabelUtil) {
    var AreaPercentageDataLabels = function (ctx, options, seriesColorStyleMap) {
        AreaPercentageDataLabels.superclass.constructor.apply(this, arguments);
    };

    oo.extend(AreaPercentageDataLabels, AreaDataLabels);
    
    AreaPercentageDataLabels.prototype._getDataLabelInfo = function(node) {
        var dataModel = this._data && this._data.rawData && this._data.rawData.dataModel;
        return PercentageDataLabelUtil.getDataLabelInfo(node, dataModel);
    };
    
    AreaPercentageDataLabels.prototype._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx,
        isMetaDataFormat, dp) {
        var value = dataLabelInfo.value;
        if(value === 0 && !this.drawZero(dp)) {
            return null;
        }

        return DataLabels.buildDataLabelText(this._properties, formatPatterns, dataLabelInfo,
                dataLabelCtx, isMetaDataFormat, PercentageDataLabelUtil.getTypes,
                PercentageDataLabelUtil.mergeDataLabels, null);
    };

    return AreaPercentageDataLabels;
});
define('sap/viz/chart/components/plots/PercentageAreaPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/AreaPlot',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/scales/ValueScale',
    'sap/viz/chart/components/renderers/GridlineRenderer',
    'sap/viz/chart/components/datalabels/AreaPercentageDataLabels',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/plots/XYPlotFactory"
], function Setup(oo,
        AreaPlot,
        TypeUtils,
        Constants,
        DataHandler,
        ValueScale,
        GridlineRenderer,
        AreaPercentageDataLabels,
        ObjectUtils,
        XYPlotFactory) {

    var PercentageAreaPlot = function(runtime, options) {
        PercentageAreaPlot.superclass.constructor.apply(this, arguments);
    };

    oo.extend(PercentageAreaPlot, AreaPlot);

    PercentageAreaPlot.prototype._getDataHandler = function() {
        return {
            "valueAxis": DataHandler.getStackHandler(false, true)
        };
    };

    PercentageAreaPlot.prototype._drawGridlines = function(parent) {
        var size = this._realSize;
        var isHorizontal = this.isHorizontal();
        var direction = isHorizontal ? Constants.DIRECTION.VERTICAL : Constants.DIRECTION.HORIZONTAL;
        var props = this._properties.proxy("gridline");
        var range = isHorizontal ? [0, size.width] : [size.height, 0];
        var scale = new ValueScale([0, 1], range);
        scale.setTickHint(this._data.valueAxis.tickHint);
        GridlineRenderer.drawValueGridline(parent, size.width, size.height, scale, props, direction,
            this.runtime().effectManager());
    };

    PercentageAreaPlot.prototype._getAxisPosition = function(handlers, seriesIndex, itemIndex, data) {
        var dataHandler = this._dataHandler;
        var valueAxis = this._data.valueAxis;
        var categorySum = valueAxis.categorySum[itemIndex];
        var value;
        for (var i = 0, length = handlers.length; i < length; i++) {
            var handler = handlers[i];
            if (data.hasOwnProperty(handler.id)) {
                if (data[handler.id] < 0 && categorySum > 0) {
                    value = 0;
                } else {
                    value = data[handler.id];
                }
                return handler.scale(value, {
                    index: itemIndex,
                    seriesIndex: seriesIndex,
                    dataHandler: dataHandler[handler.id]
                });
            }
        }
        //if value does not exist, use index. for categoryAxis
        return handlers[0].scale(null, {
            index: itemIndex,
            seriesIndex: seriesIndex,
            rawData: data
        });
    };

    PercentageAreaPlot.prototype._getPosition = function(seriesIndex, itemIndex, data) {
        var valueAxis = this._data.valueAxis;
        valueAxis.scale.total(valueAxis.categorySum[itemIndex]);
        return PercentageAreaPlot.superclass._getPosition.apply(this, arguments);
    };

    PercentageAreaPlot.prototype._buildWrapperConfig = function(data, position, context, option){
        var itemIndex = option && option.itemIndex;
        var valueAxis = this._data.valueAxis;
        if (valueAxis.categorySum) {
            valueAxis.scale.total(valueAxis.categorySum[itemIndex]);
        }
        if (context) {
            context.percentage = this._data.valueAxis.scale.scale(data.valueAxis);
        }
        var config = PercentageAreaPlot.superclass._buildWrapperConfig.apply(this, arguments);
        //remove context if current value axis is negative
        if (data.valueAxis < 0 && valueAxis.categorySum[itemIndex] > 0) {
            config.ctx = Constants.NULL_VALUE;
        }
        return config;
    };

    PercentageAreaPlot.prototype._buildData = function(dpConfig, position, currentId, prevData, prevId) {
        var ret = PercentageAreaPlot.superclass._buildData.apply(this, arguments);
        ret.percentageValue = dpConfig.ctx.percentage;
        return ret;
    };

    PercentageAreaPlot.prototype._getDataLabels = function(name, runtime) {
        var options = ObjectUtils.extend({}, this._options);
        options.name = name;
        return new AreaPercentageDataLabels(runtime, options, this._seriesColorStyleMap);
    };
    XYPlotFactory.registerClazz("100_area", PercentageAreaPlot);
    XYPlotFactory.registerClazz("100_horizontal_area", PercentageAreaPlot);

    return PercentageAreaPlot;
});

define('sap/viz/chart/metadata/bindings/CombinationBindings',[], function Setup() {

    var feeds = [{
        "id": "dataFrame",
        "name": "IDS_DATA_FRAME",
        "type": "Dimension",
        "min": 0,
        "max": 1,
        "acceptMND": false,
        "role": "frame.data"
    }, {
        "id": "trellisColumn",
        "name": "IDS_TRELLIS_COLUMN",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.columnCategory"
    }, {
        "id": "trellisRow",
        "name": "IDS_TRELLIS_ROW",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.rowCategory"
    }, {
        "id": "categoryAxis",
        "name": "IDS_CATEGORY_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "layout.category"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 2,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }];

    return feeds;
});
define('sap/viz/chart/components/util/CombinationDataLabelUtil',[
        'sap/viz/chart/components/util/DataPointUtils'
    ],
    function Setup(DataPointUtils) {
        var CombinationDataLabelUtil = {

            isIntersectedHelper: function(dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint) {
                var combinationCheckObj = {};
                var i;
                var isCheckLine = this.allowIntersectionCheck(currectDataPoint);
                for (i = 0; i < allDataPoints.length; i++) {
                    var isCheckColumn = this.allowIntersectionCheck(allDataPoints[i]);
                    if (isCheckLine && !isCheckColumn) {
                        var dataPointBox = dataPointBoxes[i];
                        if (!(dataLabelBBox.left > dataPointBox.right ||
                                dataLabelBBox.right < dataPointBox.left ||
                                dataLabelBBox.top > dataPointBox.bottom ||
                                dataLabelBBox.bottom < dataPointBox.top)) {
                            combinationCheckObj.intersected = true;
                            break;
                        }
                    } else if (!isCheckLine && isCheckColumn) {
                        var dataPointBox2 = dataPointBoxes[i];
                        if (!(dataPointBox2.right < dataLabelBBox.left ||
                                dataPointBox2.left > dataLabelBBox.right ||
                                dataPointBox2.top > dataLabelBBox.bottom ||
                                dataPointBox2.bottom < dataLabelBBox.top)) {
                            combinationCheckObj.hitPoint = true;
                            break;
                        }
                    }
                }
                return combinationCheckObj;
            }
        };
        return CombinationDataLabelUtil;
    });
define('sap/viz/chart/components/datalabels/CombinationDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/datalabels/ColumnDataLabels',
    'sap/viz/chart/components/util/CombinationDataLabelUtil',
    'sap/viz/chart/components/datalabels/LineDataLabels'
], function(oo, DataGraphics, ColumnDataLabels, CombinationDataLabelUtil, LineDataLabels) {
    var Vertical = function(ctx, options) {
        Vertical.superclass.constructor.apply(this, arguments);
        this.isHorizontal = false;
        this._labelPosition = "up";
    };
    oo.extend(Vertical, ColumnDataLabels);

    Vertical.prototype._computeDataLabelTranslate = function(node) {
        var fn;
        if (DataGraphics.getData(node).type !== "line") {
            fn = ColumnDataLabels.prototype._computeDataLabelTranslate;
        } else {
            fn = LineDataLabels.prototype._computeDataLabelTranslate;
        }
        return fn.apply(this, arguments);
    };

    Vertical.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox,
        config, node) {
        var fn;
        if (DataGraphics.getData(node).type !== "line") {
            fn = ColumnDataLabels.prototype._computeDataLabelPosition;
        } else {
            fn = LineDataLabels.prototype._computeDataLabelPosition;
        }
        return fn.apply(this, arguments);
    };

    Vertical.prototype.allowIntersectionCheck = function(dp) {
        return DataGraphics.getData(dp).type === "line";
    };

    Vertical.prototype.intersectResult = function(dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint) {
        return CombinationDataLabelUtil.isIntersectedHelper.
               call(this, dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint);
    };
    
    Vertical.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var outofDataPoint = true;
        if(!this.allowIntersectionCheck(item.dataPoint)){
            outofDataPoint = Vertical.superclass.isDataLabelOutOfDataPoint.apply(this, arguments);
        }
        return outofDataPoint;
       
    };

    return Vertical;
});

define('sap/viz/chart/components/datalabels/HCombinationDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/datalabels/BarDataLabels',
    'sap/viz/chart/components/util/CombinationDataLabelUtil',
    'sap/viz/chart/components/datalabels/LineDataLabels',
    'sap/viz/chart/components/datalabels/DataLabels',
], function(oo, DataGraphics, BarDataLabels, CombinationDataLabelUtil, LineDataLabels, DataLabels) {
    var Horizontal = function(runtime, options) {
        Horizontal.superclass.constructor.apply(this, arguments);
        this.isHorizontal = true;
        this._labelPosition = "outside";
    };
    oo.extend(Horizontal, BarDataLabels);

    Horizontal.prototype._computeDataLabelTranslate = function(node) {
        var proto;
        if (DataGraphics.getData(node).type !== "line") {
            proto = BarDataLabels.prototype;
        } else {
            proto = LineDataLabels.prototype;
        }
        this._computeDataLabelPosition = proto._computeDataLabelPosition;
        return proto._computeDataLabelTranslate.apply(this, arguments);
    };

    Horizontal.prototype.allowIntersectionCheck = function(dp){
        return DataGraphics.getData(dp).type === "line";
    };

    Horizontal.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var outofDataPoint = true;
        if(!this.allowIntersectionCheck(item.dataPoint)){
            outofDataPoint = Horizontal.prototype.isDataLabelOutOfDataPoint.apply(this, arguments);
        }
        return outofDataPoint;
       
    };

    Horizontal.prototype.intersectResult = function(dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint) {
        return CombinationDataLabelUtil.isIntersectedHelper.
               call(this, dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint);
    };

    return Horizontal;
});

define('sap/viz/chart/components/accessibility/CombinationDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator",
    "sap/viz/chart/components/accessibility/ColumnDataPointNavigator",
    "sap/viz/chart/components/accessibility/LineDataPointNavigator"
], function(oo, BaseDataPointNavigator,
    ColumnDataPointNavigator, LineDataPointNavigator) {

    function CombinationDataPointNavigator(options) {
        CombinationDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._dataShapes = null;
        this._barSeries = [];
        this._lineSeries = [];
        this._barNavigator = null;
        this._lineNavigator = null;
        this._initSubComponent(options);
    }

    oo.extend(CombinationDataPointNavigator, BaseDataPointNavigator);

    var prot = CombinationDataPointNavigator.prototype;
 
    prot._initSubComponent= function(options) {
        if (this._series) {
            this._setupSeriesTypeTable();
            for (var k = 0; k < this._seriesTypeLookup.length; k++) {
                if (this._seriesTypeLookup[k] === this._constants.BAR) {
                    this._barSeries.push(this._series[k]);
                    //It is as a placeholder. 
                    this._lineSeries.push(undefined);
                } else {
                    this._lineSeries.push(this._series[k]);
                }
            }
            var barOptions = {
                isVerticalRender : options.isVerticalRender,
                dataModel : options.dataModel,
                series : this._barSeries,
                propertyManager : options.propertyManager
            };
            this._barNavigator = new ColumnDataPointNavigator(barOptions);
            var lineOptions = {
                isVerticalRender : options.isVerticalRender,
                dataModel : options.dataModel,
                series : this._lineSeries,
                propertyManager : options.propertyManager
            };
            this._lineNavigator = new LineDataPointNavigator(lineOptions);
        }
    };

    prot.destroy = function() {
        CombinationDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._dataShapes = null;
        this._seriesTypeLookup = null;
        this._barSeries = null;
        this._lineSeries = null;
        if (this._lineNavigator) {
            this._lineNavigator.destroy();
        }
        if (this._barNavigator) {
            this._barNavigator.destroy();            
        }
        this._lineNavigator = null;
        this._barNavigator = null;
    };

    prot.left = function(id) {
        return this._DPRouter(id, this._constants.LEFT);
    };

    prot.right = function(id) {
        return this._DPRouter(id, this._constants.RIGHT);
    };

    prot.up = function(id) {
        return this._DPRouter(id, this._constants.UP); 
    };

    prot.down = function(id) {
        return this._DPRouter(id, this._constants.DOWN);  
    };

    prot._DPRouter = function (id, direction) {
        var dp = this.getDataPoint(id);
        if (dp) {
            var seriesType = this._getSeriesType(dp);
            if (this._isVerticalRender) {
                if (direction === this._constants.UP || direction === this._constants.DOWN) {
                    dp = this._getShortestDPInCategory(id, direction);
                }
            } else {
                if (direction === this._constants.LEFT || direction === this._constants.RIGHT) {
                    dp = this._getShortestDPInCategory(id, direction);
                }
            }

            switch(seriesType) {
                case this._constants.LINE:
                    if (this._isVerticalRender) {
                        if (direction === this._constants.LEFT) {
                            dp = this._lineNavigator.left(id);
                        } else if (direction === this._constants.RIGHT) {
                            dp = this._lineNavigator.right(id);
                        } 
                    } else {
                        if (direction === this._constants.UP) {
                            dp = this._lineNavigator.up(id);
                        } else if (direction === this._constants.DOWN) {
                            dp = this._lineNavigator.down(id);
                        } 
                    }
                    break;
                case this._constants.BAR:
                    if (this._isVerticalRender) {
                        if (direction === this._constants.LEFT) {
                            dp = this._barNavigator.left(id);
                        } else if (direction === this._constants.RIGHT) {
                            dp = this._barNavigator.right(id);
                        }
                    } else {
                        if (direction === this._constants.UP) {
                            dp = this._barNavigator.up(id);
                        } else if (direction === this._constants.DOWN) {
                            dp = this._barNavigator.down(id);
                        }
                    }
                    break;
            }
        }
        return dp;
    };

    prot._getShortestDPInCategory = function(id, direction) {
        var currentDp = this.getDataPoint(id);
        var shortestDp = null;
        var shortestDpIdx = -1;
        var address = currentDp.address();
        var columnIdx = address[0];

        if (!this._sortedDataPointsByDirection[columnIdx]) {
            this.dataPointValueSortInCategory(columnIdx);
        }

        var curtDpIndex = this._sortedDataPointsByDirection[columnIdx].indexOf(currentDp);
        if (direction === this._constants.UP || direction === this._constants.RIGHT) {
            shortestDpIdx = curtDpIndex + 1;
        } else if (direction === this._constants.DOWN || direction === this._constants.LEFT) {
            shortestDpIdx = curtDpIndex - 1;
        }
        if (shortestDpIdx > -1 && 
            shortestDpIdx < this._sortedDataPointsByDirection[columnIdx].length) {
            shortestDp = this._sortedDataPointsByDirection[columnIdx][shortestDpIdx];
            if (this._seriesTypeLookup[currentDp.address()[1]] === this._constants.BAR) {
                var seriesType = this._seriesTypeLookup[shortestDp.address()[1]];
                while (seriesType !== this._constants.LINE) {
                    shortestDpIdx += 
                        (direction === this._constants.UP || direction === this._constants.RIGHT) ? 1 : -1;
                    if (shortestDpIdx > this._sortedDataPointsByDirection[columnIdx].length || 
                        shortestDpIdx < 0) {
                        shortestDp = null;
                        break;
                    }
                    seriesType = this._seriesTypeLookup[
                        this._sortedDataPointsByDirection[columnIdx][shortestDpIdx].address()[1]];
                }
                shortestDp = this._sortedDataPointsByDirection[columnIdx][shortestDpIdx];
            }
        }
        return shortestDp;       
    };

    return CombinationDataPointNavigator;
});

define('sap/viz/chart/components/plots/CombinationPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/plots/BaseLinePlot',
    'sap/viz/chart/components/plots/StackedColumnPlot',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    'sap/viz/chart/components/renderers/LineRenderer',
    'sap/viz/chart/components/renderers/SmoothLineRenderer',
    'sap/viz/chart/components/util/DrawUtil',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/chart/components/util/LineRendererUtil',
    'sap/viz/chart/components/datalabels/CombinationDataLabels',
    'sap/viz/chart/components/datalabels/HCombinationDataLabels',
    "sap/viz/chart/components/plots/XYPlotFactory",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/CombinationDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants"
], function Setup(
    oo,
    SVG,
    ObjectUtils,
    DataGraphics,
    Constants,
    BaseLinePlot,
    StackedColumnPlot,
    ScaleHandler,
    ItemScaleHandler,
    SeriesRenderer,
    PathRenderer,
    LineRenderer,
    SmoothLineRenderer,
    DrawUtil,
    DataPointUtils,
    LineRendererUtil,
    CombinationDataLabels,
    HCombinationDataLabels,
    XYPlotFactory,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants
) {

    var LINE = "line";
    var BAR = "bar";
    var DATAPOINT_CLASS =
        Constants.CSS.CLASS.DATAPOINT + ' ' +
        Constants.CSS.CLASS.MORPHABLEDATAPOINT + ' ' +
        Constants.CSS.CLASS.DATAPOINTDEFAULT;

    var CombinationPlot = function(runtime, options) {
        //comboEx has almost all features of flexible stack
        this._isFlexibleStack = true;
        CombinationPlot.superclass.constructor.apply(this, arguments);

        this._markerPropName = "line.marker";

        StackedColumnPlot.prototype._initCategoryAxis.call(this, ScaleHandler, ItemScaleHandler);

        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.setUseSemanticDPLineStyle(true);

        this._attachMarkManager();

        this.dataShapePrimaryAxisPW = this._properties.watch("dataShape.primaryAxis",
            this._onDataShapeChange.bind(this));

        var isDualValueAxis = options && options.isDualValueAxis;
        if(isDualValueAxis){
            this.dataShapeSecondaryAxisPW = this._properties.watch("dataShape.secondaryAxis",
                this._onDataShapeChange.bind(this));
        }

        this.lineMarkerShapePW = this._properties.watch("line.marker.shape", this._onDataShapeChange.bind(this));

        this._semanticMgr.setUseSemanticPattern(true);
        this._defaultLineRenderer = LineRendererUtil.getDefaultRenderer(this._properties.get("line.isSmoothed"));
    };

    oo.extend(CombinationPlot, BaseLinePlot);

    CombinationPlot.prototype._isSupportBarPathGenerator = function () {
        return true;
    };

    CombinationPlot.prototype._hideDataPoints = function(dataPoints, visibleRange){
        if (dataPoints[0] && this._seriesType[dataPoints[0].getSeriesIndex()] === LINE) {
            for (var i in dataPoints) {
                if (dataPoints.hasOwnProperty(i)) {
                    this._hideNode(dataPoints, i);
                }
            }
            this._lightLineOutOfRange(dataPoints, visibleRange);
        } else {
            this._columnOutOfRange(dataPoints, visibleRange);
        }
    };

    CombinationPlot.prototype.destroy = function() {

        if(this.dataShapePrimaryAxisPW){
            this.dataShapePrimaryAxisPW.remove();
            this.dataShapePrimaryAxisPW = null;
        }


        if(this.dataShapeSecondaryAxisPW) {
            this.dataShapeSecondaryAxisPW.remove();
            this.dataShapeSecondaryAxisPW = null;
        }
        this.lineMarkerShapePW.remove();
        this.lineMarkerShapePW = null;

        CombinationPlot.superclass.destroy.call(this);

        this._barCategoryAxis = null;
        this._categoryScaleHandler = null;
        this._realSize = null;
        this._measureIndex = null;
        this._markerD = null;
        this._seriesType = null;
    };

    CombinationPlot.prototype._attachMarkManager = function() {
        var markerMgr = this.runtime().markManager();
        var primaryAxis = this._properties.get("dataShape.primaryAxis");
        var lineMarker = this._getMarkerShape();
        var propRoot = this._properties.parentLevel;

        var shapes = [];
        markerMgr.lock();
        markerMgr.setMode("combination");
        var seriesShape = [];

        shapes.push(CombinationPlot.processMark.call(this, primaryAxis, lineMarker, propRoot));
        seriesShape.push(primaryAxis);
        if(this._options && this._options.isDualValueAxis){
            var secondaryAxis = this._properties.get("dataShape.secondaryAxis");
            shapes.push(CombinationPlot.processMark.call(this, secondaryAxis, lineMarker, propRoot));
            seriesShape.push(secondaryAxis);
        }
        markerMgr.setShape(shapes, lineMarker);
        markerMgr.setSeriesShape(seriesShape);
    };

    CombinationPlot.processMark = function(arr, lineMark, propRoot) {
        var result = [];
        if(!arr || !arr.length){
            return result;
        }
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === LINE) {
                result.push(lineMark);
            } else {
                //we should use default shape
                var defaultMarkerShape = this._getLegendMarkerShape();
                result.push(defaultMarkerShape);
            }
        }
        return result;
    };

    CombinationPlot.prototype._onDataShapeChange = function() {
        this._attachMarkManager();
    };

    CombinationPlot.prototype._getCategoryScaleHandlers = function(isHorizontal) {
        return [ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: isHorizontal,
            itemScaleHandler: ItemScaleHandler.get(false),
            alignment: "center"
        })];
    };

    CombinationPlot.prototype._getSeriesRenderer = function() {
        return new SeriesRenderer(this._drawLine.bind(this), this._updateLine.bind(this));
    };

    CombinationPlot.prototype._applyChanges = function() {
        CombinationPlot.superclass._applyChanges.apply(this, arguments);
        StackedColumnPlot.prototype._initBarCategoryAxis.apply(this, arguments);
    };

    CombinationPlot.prototype._adjustPosition = function(position, seriesIndex) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
        if (!isLine) {
            CombinationPlot.superclass._adjustPosition.apply(this, arguments);
        }
    };

    CombinationPlot.prototype._preRender = function() {
        CombinationPlot.superclass._preRender.apply(this, arguments);
        var seriesCount = this._data.series.length;
        this._measureIndex = [];
        var barIndex = 0;

        for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
            var shape = this._getDataShape(seriesIndex);
            if (shape === BAR) {
                this._measureIndex[seriesIndex] = barIndex;
                barIndex++;
            }
        }
    };

    CombinationPlot.prototype._getDataShape = function(seriesIndex) {
        var items = this._data.series[seriesIndex];
        var item = null;
        for (var i = 0; i < items.length; i++) {
            item = items[i];
            if (item) {
                break;
            }
        }
        if (item) {
            var propKey = item.hasOwnProperty("valueAxis")?  "dataShape.primaryAxis":"dataShape.secondaryAxis" ;
            var dataShapes = this._properties.get(propKey);
            // for bug BITSDC1-6233 check the datashapes.
            if (!( dataShapes instanceof Array)) {
                dataShapes = this._properties.get(propKey, 'defaultValue');
            }

            var index;
            if (item.color){
                index = item.color.mndIndex;
            } else if (item.color2){
                index = item.color2.mndIndex;
            } else {
                index = -1;
            }

            // for bug BITSDC1-6233 check the datashapes.
            if (dataShapes[index] !== LINE && dataShapes[index] !== BAR) {
                dataShapes[index] = LINE;
            }

            return dataShapes[index];

        }
        return LINE;
    };

    CombinationPlot.prototype._getXPosition = function(seriesIndex, itemIndex, data) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
        if (this.isHorizontal()) {
            //value
            var result = CombinationPlot.superclass._getXPosition.apply(this, arguments);
            if (isLine) {
                return [result[0] + result[1], result[1]];
            } else {
                return result;
            }
        } else {
            //category
            if (isLine) {
                return CombinationPlot.superclass._getXPosition.apply(this, arguments);
            } else {
                seriesIndex = this._measureIndex[seriesIndex];
                return this._getAxisPosition([this._barCategoryAxis], seriesIndex, itemIndex,
                    data);
            }
        }
    };

    CombinationPlot.prototype._getYPosition = function(seriesIndex, itemIndex, data) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
        if (!this.isHorizontal()) {
            //value
            var result = CombinationPlot.superclass._getYPosition.apply(this, arguments);
            return result;
        } else {
            //category
            if (isLine) {
                return CombinationPlot.superclass._getYPosition.apply(this, arguments);
            } else {
                seriesIndex = this._measureIndex[seriesIndex];
                return this._getAxisPosition([this._barCategoryAxis], seriesIndex, itemIndex, data);
            }
        }
    };

    CombinationPlot.prototype.getLineRenderer = function(){
        if (!this._lineRenderer){
            var props = this._properties;
            this._lineRenderer = LineRendererUtil.getRenderer(
                props.get('line.lineRenderer'),
                props.get("line.isSmoothed")
            );
        }
        return this._lineRenderer;
    };

    CombinationPlot.prototype._isLineVisible = function (){
        return this._properties.get('line.visible');
    };

    CombinationPlot.prototype._getPatternConfig = BaseLinePlot.prototype._getPatternConfig;

    CombinationPlot.prototype._drawLine = function(seriesG, data, seriesIndex, isUpdate) {
        if (this._getDataShape(seriesIndex) !== LINE) {
            return 0;
        }
        CombinationPlot.superclass._drawLine.apply(this, arguments);
        return 1;
    };

    CombinationPlot.prototype._updateDatapoint = function(dataPointG, dpRenderer, dpConfig, position) {
        CombinationPlot.superclass._updateDatapoint.apply(this, arguments);
        if (position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            var translate = DataGraphics.getData(dataPointG).translate;
            if (translate) {
                translate[0] = position.x;
                translate[1] = position.y;
            }
        }
        if(dataPointG.getAttribute("combination-column")){
            this._updateStrokeWidth(dataPointG);

        }
    };

    CombinationPlot.prototype._buildConfig = function(data, position, context) {
        var config = CombinationPlot.superclass._buildConfig.apply(this, arguments);
        config.graphic.d = this._markerD;

        if (!this._properties.get("line.marker.visible")) {
            config.graphic.opacity = 0;
        }
        return config;
    };

    CombinationPlot.prototype._getDataPointRenderer = function(seriesIndex) {
        var render;
        if (this._getDataShape(seriesIndex) === LINE) {
            this._isLineMarker = true;
            render = this._customMarkerRenderer || PathRenderer;
        } else {
            this._isLineMarker = false;
            render = CombinationPlot.superclass._getDataPointRenderer.apply(this, arguments);
        }
        return render;
    };


    CombinationPlot.prototype._getDataLabels = function(name, runtime) {
        var options = ObjectUtils.extend({}, this._options);
        options.name = name;
        if (options.isHorizontal) {
            return new HCombinationDataLabels(runtime, options);
        } else {
            return new CombinationDataLabels(runtime, options);
        }
    };

    CombinationPlot.prototype._getColumnCount = function() {
        var seriesCount = this._data.series.length;
        var barCount = 0;
        for (var i = 0; i < seriesCount; i++) {
            if (this._getDataShape(i) == BAR) {
                barCount++;
                this._seriesType[i] = BAR;
            } else {
                this._seriesType[i] = LINE;
            }
        }
        return barCount;
    };

    CombinationPlot.prototype._drawDataPoint = function(dpRenderer, dataPoint) {

        var dpConfig = dataPoint.getConfig();



        var dataPointG = SVG.create("g");
        DataPointUtils.setDataId(dataPointG, dataPoint.getDataId());
        DataPointUtils.setDataPointId(dataPointG, dataPoint.getDataPointId());
        DataGraphics.setContext(dataPointG, dataPoint.getContext());
        DataGraphics.setAdditionCtx(dataPointG, dataPoint.getAdditionCtx());

        var extraData = dataPoint.getData();
        extraData.seriesIndex = dataPoint.getSeriesIndex();
        extraData.itemIndex = dataPoint.getItemIndex();

        if(this._isLineMarker) {
            extraData.shape = this._properties.get('line.marker.shape');
        }
        dataPointG.setAttribute("class", DATAPOINT_CLASS);

        if (this._isLineMarker === true) {
            dataPointG.setAttribute("combination-marker","true");
        }else{
            dataPointG.setAttribute("combination-column","true");
        }
        // For customer render user
        dpConfig["isLineMarker"] = this._isLineMarker;
        var node = this._renderNode(dpRenderer, dpConfig, dataPointG, extraData);
        var shadowNode = this._drawShadowNode(dpConfig.graphic, dataPointG, node, extraData, dpRenderer);
        delete dpConfig["isLineMarker"];

        DataGraphics.setData(dataPointG, extraData);
        var position = dataPoint.getPosition();
        if (position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            dataPointG.setAttribute("transform",
                'translate(' + position.x + ', ' + position.y + ')');
        }

        var negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
        if (negative && !this._isLineMarker) { //flip
            this._addNegativeClass(dataPointG, dpConfig);
        }



        return dataPointG;
    };

    CombinationPlot.prototype._isNeedSimplifyLine = function(){
        return false;
    };

    CombinationPlot.prototype.getSeriesStyle = function(seriesIndex, context){
        var seriesStyle = CombinationPlot.superclass.getSeriesStyle.apply(this, arguments);
        seriesStyle.isCombination = true;
        return seriesStyle;
    };
    XYPlotFactory.registerClazz("combination", CombinationPlot);
    XYPlotFactory.registerClazz("horizontal_combination", CombinationPlot);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR, ChartConstants.COLUMN_COMBINATION, DataPointNavigator);
    return CombinationPlot;
});

define('sap/viz/chart/components/legend/SizeLegend',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/legend/BaseLegend',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/format/UnitFormat',
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/lang/LangManager'
], function(
    oo,
    BaseLegend,
    TextUtils,
    DrawUtil,
    TypeUtils,
    UnitFormat,
    Constants,
    NameColorUtils,
    langManager
) {

    function SizeLegend(runtime, options) {
        SizeLegend.superclass.constructor.apply(this, arguments);

        var props = this._properties.get('label.style');
        this._labelFont = {
            'fontfamily': props.fontFamily,
            'fontsize': props.fontSize,
            'fontweight': props.fontWeight,
            'color': props.color,
            'fontstyle': props.fontStyle
        };

        this._layoutInfo = {
            guideLineWidth: 10,
            labelPaddingLeft: 15
        };
        this._labels = [];
        this._scale = null;
        this._semanticStyle = null;
        this._labelHeight = 0;
        this._parent = null;
        this._type = "SizeLegend";
    }

    oo.extend(SizeLegend, BaseLegend);

    /**
     * To fix non property definition for standalone mode.
     */
    SizeLegend.prototype._addDefaultProperties = function() {
        SizeLegend.superclass._addDefaultProperties.call(this);
        this._properties.add({
            'drawingEffect': 'normal',
            'formatString': null,
            'unitFormatType' : null,
            inGeo : false,
            plotArea : {
                colorPalette : null
            }
        });
    };
    
    SizeLegend.prototype.visible = function() {
        var visibility = true;
        if(this.getPosition() === "bottom" && 
           this._properties.origin.get("legendGroup.layout.position") === "auto") {
            visibility =  false;
        }
        else {
            visibility = SizeLegend.superclass.visible.call(this);
        }
        return visibility;
    };        
    
    SizeLegend.prototype.render = function(selection, needRender) {
        this._parent = selection;
        /*
         * if(!needRender){ //Once rootContainer calls to render the
         * legend, we don't know the exact scale yet so we don't need to
         * render at this time; return; }
         */
        if (this._scale && this._labels.length > 0) {
            SizeLegend.superclass.render.apply(this, arguments);
        }

        if (!this.isVisible() && !this._isDedicated) {
            selection.selectAll('g.v-content').remove();
            return this;
        }

        var props = this._properties.get();
        var drawingEffect = props.drawingEffect;
        if (this._scale && this._labels.length > 0) {
            // append container
            var legendContent = selection.selectAll('g.v-content').data(['content']);
            legendContent.enter().append('g').classed('v-content', true).classed('v-label', true).classed(
                'viz-legend-valueLabel', true);
            legendContent.exit().remove();
            legendContent.attr('transform', 'translate(0, ' + this._pos.y + ')');

            // Smart value label management.
            var textHeight = parseInt(this._labelFont.fontsize, 10); // 1em
            var visibleData = [],
                labelFont = "font-size:" + this._labelFont.fontsize + "; font-weight:" +
                this._labelFont.fontweight + "; font-family:" + this._labelFont.fontfamily +
                "; font-style:" + this._labelFont.fontstyle;
            if (this._labelHeight === 0) {
                this._labelHeight = TextUtils.fastMeasure('M', this._labelFont.fontsize,
                    this._labelFont.fontweight, this._labelFont.fontfamily).height;
            }
            var visibleCount = Math.floor((this._scale(this._labels[0]) + textHeight) / this._labelHeight);
            switch (visibleCount) {
                case 0:
                case 1:
                    visibleData.push(this._labels[0]);
                    break;
                case 2:
                    visibleData.push(this._labels[0]);
                    if (this._labels.length > 1) {
                        visibleData.push(this._labels[this._labels.length - 1]);
                    }
                    break;
                default:
                    visibleData = this._labels;
            }

            var bubbleSizeArr = [],
                maxWidth = -1,
                dataWidth, value;
            for (var i = 0, len = visibleData.length; i < len; i++) {
                bubbleSizeArr.push(this._scale(visibleData[i]) / 2);
                value = this._getLabelValue(visibleData[i]);

                dataWidth = TextUtils.fastMeasure(value, this._labelFont.fontsize, this._labelFont.fontweight,
                    this._labelFont.fontfamily).width;
                if (dataWidth > maxWidth) {
                    maxWidth = dataWidth;
                }
            }
            var maxBubbleSize = bubbleSizeArr[0];
            var wrap = legendContent;
            var circlesWrap = wrap.selectAll('g.v-circles');
            if (!circlesWrap.empty()) {
                circlesWrap.remove();
            }
            circlesWrap = wrap.append('g').attr('class', 'v-circles').data([bubbleSizeArr]);

            circlesWrap.attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize + textHeight / 2) +
                ')');
            var colorToDraw;
            var colorPalette = this._properties.origin.get("plotArea.colorPalette");
            if(colorPalette && colorPalette.length && colorPalette.length > 0){
                colorToDraw = NameColorUtils.convertColor(colorPalette[0]);
            }else{
                colorToDraw = '#748CB2';
            }
            var useDefaultColor = true; // according to PO, we do not
            // change the color of size
            // legend.
            if (!useDefaultColor && this._semanticStyle && !TypeUtils.isEmptyObject(this._semanticStyle)) {
                if (this._semanticStyle.others && this._semanticStyle.others.properties &&
                    this._semanticStyle.others.properties.color) {
                    colorToDraw = this._semanticStyle.others.properties.color;
                }
            }
            var parameter = {
                drawingEffect: drawingEffect,
                graphType: 'circle',
                fillColor: colorToDraw
            };
            var fillID = this.runtime().effectManager().register(parameter);
            var circleElements = circlesWrap.selectAll('path').data(bubbleSizeArr, function(d, i) {
                return d;
            });
            circleElements.exit().remove();
            circleElements.enter().append('path').attr('stroke', 'white').attr('stroke-width', 1).attr('fill',
                fillID).attr('opacity', '1').attr('fill-opacity', '0.85');
            circleElements.attr('d', function(d, i) {
                return DrawUtil.createMarkerData({
                    type: 'circle',
                    borderWidth: 0,
                    rx: d,
                    ry: d
                });
            }).attr('transform', function(d, i) {
                return ['translate(', 0, ',', maxBubbleSize - d, ')'].join('');
            });

            var labelsWrap = wrap.selectAll('g.v-valueLabels');
            if (labelsWrap.empty()) {
                labelsWrap = wrap.append('g').attr('class', 'v-valueLabels').data([visibleData]);
            }
            var labelX = (maxBubbleSize * 2 + this._layoutInfo.labelPaddingLeft +
                this._layoutInfo.guideLineWidth + maxWidth) > this._sizeLA_width ? this._sizeLA_width : (
                maxBubbleSize * 2 + this._layoutInfo.labelPaddingLeft + this._layoutInfo.guideLineWidth +
                maxWidth);
            labelsWrap.attr('transform', 'translate(' + labelX + ', ' + (maxBubbleSize + textHeight) + ')');
            var valueElements = labelsWrap.selectAll('text').data(visibleData, function(d, i) {
                return d;
            });
            valueElements.exit().remove();
            var textNodes = valueElements.enter().append('text');

            var textAnchor = null;
            var envManager = this.runtime().envManager();
            if (envManager) {
                textAnchor = envManager.textAnchor();
            }
            
            var that = this;
            valueElements.text(function(d, i) {
                return that._getLabelValue(d);
            }).attr('dx', function (d) {
                var labelWidth = TextUtils.fastMeasure(that._getLabelValue(d), 
                    that._labelFont.fontsize,
                    that._labelFont.fontweight,
                    that._labelFont.fontfamily).width;
                return -labelWidth;
            }).attr('dy', function (d, i) {
                var dy = (i - 1) * maxBubbleSize - 2;
                if (visibleData.length === 2 && i === 1) {
                    dy = maxBubbleSize - 2;
                }
                return dy;
            }).attr("text-anchor", textAnchor);

            var guidelineWrap = wrap.selectAll('g.v-guideLines');
            if (!guidelineWrap.empty()) {
                // Empty
                guidelineWrap.remove();
            }
            guidelineWrap = wrap.append('g').attr('class', 'v-guideLines').attr('transform',
                'translate(' + maxBubbleSize + ',' + (maxBubbleSize + textHeight / 2) + ')');
            if (visibleData.length > 0) {
                guidelineWrap.append('path').attr('stroke', 'gray').attr(
                    'd',
                    'M 0 ' + -maxBubbleSize + ' L ' + (maxBubbleSize + this._layoutInfo.guideLineWidth) +
                    " " + -maxBubbleSize);
            }
            if (visibleData.length > 1) {
                guidelineWrap.append('path').attr('stroke', 'gray').attr(
                    'd',
                    'M 0 ' + maxBubbleSize + 'L' + (maxBubbleSize + this._layoutInfo.guideLineWidth) + " " +
                    maxBubbleSize);
            }
            if (visibleData.length > 2) {
                guidelineWrap.append('path').attr('stroke', 'gray').attr(
                    'd',
                    'M 0 ' + (maxBubbleSize - bubbleSizeArr[1]) + ' L ' + maxBubbleSize + " 0" + ' M ' +
                    maxBubbleSize + " 0 " + " L " +
                    (maxBubbleSize + this._layoutInfo.guideLineWidth) + " 0");
            }

            // var defaultValueLabelStyle =
            // this._ctx.styleManager.queryDefault('v-label');
            wrap.attr('font-family', this._labelFont.fontfamily).attr('font-size', this._labelFont.fontsize)
                .attr('font-weight', this._labelFont.fontweight).attr('fill', this._labelFont.color).attr(
                    'font-style', this._labelFont.fontstyle);

        }
        return this;
    };
    SizeLegend.prototype.hasData = function(){
        return (this._scale && this._labels.length > 0);
    };

    SizeLegend.prototype._getBodyPreferredSize = function() {
        this._setupThemeStyleDef();
        var maxWidth = 0,
            maxHeight = 0,
            minWidth = 0,
            minHeight = 0;
        var props = this._properties.get();
        var position = props.position;
        if (this._scale && this._labels.length > 0) {
            var data = this._labels,
                value, valueSize = [],
                maxValueWidth = -1,
                maxBubbleSize, i, len;
            for (i = 0, len = data.length; i < len; i++) {
                value = this._getLabelValue(data[i]);

                valueSize[i] = TextUtils.fastMeasure(value, this._labelFont.fontsize,
                    this._labelFont.fontweight, this._labelFont.fontfamily);
                if ((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
                    maxValueWidth = valueSize[i].width;
                }
            }
            var space = maxValueWidth + this._layoutInfo.labelPaddingLeft + this._layoutInfo.guideLineWidth;
            maxBubbleSize = this._scale(data[0]);

            maxHeight = maxBubbleSize + valueSize[len - 1].height;
            maxWidth = maxBubbleSize + space;
            minWidth = maxWidth;
            minHeight = maxHeight;

            if (!props.inGeo) {
                //TODO workaround to add 1em padding in the bottom or right 
                if (position === 'top' || position === 'bottom') {
                    maxWidth = maxWidth + valueSize[len - 1].height;
                    minWidth = minWidth + valueSize[len - 1].height;
                } else {
                    maxHeight = maxHeight + valueSize[len - 1].height;
                    minHeight = maxHeight;
                }
            }
        }
        return {
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            minWidth: minWidth,
            minHeight: minHeight
        };
    };

    SizeLegend.prototype.setData = function(info) {
        if (!info) {
            return;
        }
        if (info.bubbleWidth) {
            this._bindingFields = info.bubbleWidth.metaData;
        }
        this._labels = info.labels;
        this._scale = info.scale;
        this._semanticStyle = info.semanticStyle;
    };

    SizeLegend.prototype._setupThemeStyleDef = function() {
        SizeLegend.superclass._setupThemeStyleDef.apply(this, arguments);
        var props = this._properties.get();
        var valueLabelStyle;
        valueLabelStyle = {
            "fill": props.label.style.color,
            "font-family": props.label.style.fontFamily,
            "font-size": props.label.style.fontSize,
            "font-weight": props.label.style.fontWeight,
            "font-style": props.label.style.fontStyle
        };
        if (valueLabelStyle) {
            if (valueLabelStyle['fill']) {
                this._labelFont.color = valueLabelStyle['fill'];
            }
            if (valueLabelStyle['font-family']) {
                this._labelFont.fontfamily = valueLabelStyle['font-family'];
            }
            if (valueLabelStyle['font-size']) {
                this._labelFont.fontsize = valueLabelStyle['font-size'];
            }
            if (valueLabelStyle['font-weight']) {
                this._labelFont.fontweight = valueLabelStyle['font-weight'];
            }
            if (valueLabelStyle['font-style']) {
                this._labelFont.fontstyle = valueLabelStyle['font-style'];
            }
        }
    };

    SizeLegend.prototype._getLabelValue = function(value) {
        value = (value === null) ? langManager.get('IDS_ISNOVALUE') : value;
        var props = this._properties.get();
        var metaDataFormatString = null;
        if (this._bindingFields && this._bindingFields.length) {
            metaDataFormatString = this._bindingFields[0].formatString;
            if (TypeUtils.isArray(metaDataFormatString)) {
                metaDataFormatString = metaDataFormatString[0];
            }
        }
        var unitFormatType = props.unitFormatType;
        var options = {
            decimalFormatString: 
            UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.SIZELEGEND)
        };
        value = UnitFormat.format(value, props.formatString || metaDataFormatString, unitFormatType, options);
        return value;
    };
    SizeLegend.prototype.getZonePrefix = function(){
        return 'sizeLegend';
    };

    SizeLegend.prototype.destroy = function() {
        SizeLegend.superclass.destroy.call(this);
        this._labelFont = null;
        this._layoutInfo = null;
        this._labels = null;
        this._scale = null;
        this._semanticStyle = null;
        this._labelHeight = null;
        this._parent = null;
        this._type = null;
    };
    
    return SizeLegend;
});

define('sap/viz/chart/scales/TimeScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/ValueScale',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/DataUtils'
], function(oo, ValueScale, TypeUtils, DataUtils) {

    var TimeScale = function(domain, range) {
        TimeScale.superclass.constructor.apply(this, arguments);
        this.__className = "sap.viz.scale.TimeScale";
    };

    oo.extend(TimeScale, ValueScale);

    TimeScale.prototype.scale = function (value) {
        this._ensureScaled();
        var v = value;
        if (v) {
            if (TypeUtils.isArray(v)) {
                v = v[0];
            }
            v = DataUtils.getDimensionParsedValue(v);
        }

        // fix bug BITVDC22-2516, if domain[0] == domain[1],
        // scale(v) will alway return 0 which is not expected.
        if (this._domain[0] === this._domain[1] && v !== this._domain[0] ) {
            return v < this._domain[0] ? -Infinity : Infinity;
        }
        return this._scale(v);
    };

    TimeScale.prototype.normalizeValue = function(v) {
        return new Date(v).getTime();
    };

    TimeScale.prototype.destroy = function() {
        TimeScale.superclass.destroy.apply(this, arguments);
    };

    return TimeScale;
});

define('sap/viz/chart/components/renderers/ValueBasedColorRenderer',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/NameColorUtils",
    'sap/viz/framework/common/util/TypeUtils' 
], function(Constants,
    NameColorUtils,
    TypeUtils
) {

    var ret = {};

    ret.cleanVBCAxisLines = function (selection) {
        var lineClass = Constants.CSS.CLASS.AXIS.VBCLINE;
        selection.selectAll("." + lineClass).remove();
    };

    ret.drawVBCAxis = function(selection, vbcStart, vbcEnd, color, props, effectManager) {
        var lineClass = Constants.CSS.CLASS.AXIS.VBCLINE;
        //UX set stoke width to 3.
        var STROKE_WIDTH = 3;
        //axis line width will affect VBCAxis Line yOffset.
        var axisLineWidth = props.get('axisLine.size');
        if (!TypeUtils.isNumber(axisLineWidth)) {
            axisLineWidth = 1;
        }
        var yOffset = axisLineWidth / 2 + STROKE_WIDTH / 2;
        var stroke = effectManager.register({
            fillColor: NameColorUtils.convertColor(color)
        });

        var line = selection.append("line")
                .style("pointer-events", "none" )
                .attr("class", lineClass)
                .attr("shape-rendering", "crispEdges");

        line.attr("stroke", stroke)
            .attr("stroke-width", STROKE_WIDTH)
            .attr("x1", vbcStart)
            .attr("y1", yOffset)
            .attr("x2", vbcEnd)
            .attr("y2", yOffset);
        return line;   
    };

    return ret;
});

define('sap/viz/chart/components/axis/renderer/TimeBodyRenderer',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/components/util/StyleUtils",
    "sap/viz/framework/common/util/PositionUtil",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/framework/common/util/FiscalUtil",
    "sap/viz/chart/components/util/DataPointUtils"
], function(
    Constants,
    TextUtils,
    TypeUtils,
    SVG,
    DOM,
    StyleUtils,
    PositionUtils,
    NumberUtils,
    TimeUtil,
    FiscalUtil,
    DataPointUtils
) {

    var LABEL_OFFSET = 11;
    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;
    var AXIS_INTERACTION_CLASS_NAMES = 'v-label-interaction';

    var TICK_SIZE = 5;
    var LONG_TICK_SIZE = 10;
    var HOVERSHADOW_PADDING = 2;

    var ret = {
        minTicksCount: 1
    };

    ret.drawTicks = function(selection, ticks, width, height, position, props, color, effectManager, force) {
        var tickClass = AXIS_CLASS_NAMES.PERIMETER + " " + AXIS_CLASS_NAMES.TICK;
        var stroke = effectManager.register({
            fillColor: color || props.get('color')
        });
        var strokeWidth = props.get('axisLine.size');
        var i = 0;
        var length = ticks.length;
        var x1s = [];
        var y1s = [];
        var x2s = [];
        var y2s = [];
        var tick;
        var tickSize;
        var scrollOffset = ticks.offset || 0;
        switch (position) {
            case Constants.POSITION.LEFT:
                for (; i < length; ++i) {
                    tick = ticks[i];
                    tickSize = tick.major ? LONG_TICK_SIZE : TICK_SIZE;
                    x1s[i] = width;
                    y1s[i] = tick.position - scrollOffset;
                    x2s[i] = width - TICK_SIZE;
                    y2s[i] = tick.position - scrollOffset;
                }
                break;
            case Constants.POSITION.RIGHT:
                for (; i < length; ++i) {
                    tick = ticks[i];
                    tickSize = tick.major ? LONG_TICK_SIZE : TICK_SIZE;
                    x1s[i] = 0;
                    y1s[i] = tick.position - scrollOffset;
                    x2s[i] = tickSize;
                    y2s[i] = tick.position - scrollOffset;
                }
                break;
            case Constants.POSITION.TOP:
                for (; i < length; ++i) {
                    tick = ticks[i];
                    tickSize = tick.major ? LONG_TICK_SIZE : TICK_SIZE;
                    x1s[i] = tick.position - scrollOffset;
                    y1s[i] = height;
                    x2s[i] = tick.position - scrollOffset;
                    y2s[i] = height - tickSize;
                }
                break;
            case Constants.POSITION.BOTTOM:
                for (; i < length; ++i) {
                    tick = ticks[i];
                    tickSize = tick.major ? LONG_TICK_SIZE : TICK_SIZE;
                    x1s[i] = tick.position - scrollOffset;
                    y1s[i] = 0;
                    x2s[i] = tick.position - scrollOffset;
                    y2s[i] = tickSize;
                }
                break;
        }       

        var tickSelections = selection.selectAll("." + AXIS_CLASS_NAMES.TICK).data(ticks);

        tickSelections.enter().append("line")
            .attr("class", tickClass)
            .attr("stroke-width", strokeWidth)
            .attr("shape-rendering", "crispEdges");
        tickSelections.exit().remove();

        tickSelections.each(function(d, i) {
            this.setAttribute("x1", x1s[i]);
            this.setAttribute("y1", y1s[i]);
            this.setAttribute("x2", x2s[i]);
            this.setAttribute("y2", y2s[i]);
            this.setAttribute("stroke",stroke);
        });
    };

    ret.drawLabels = function(timeBodyCtx, labels, width, height, position, props, effectManager,
            displayMode, step, currentLevel) {  

        var isFiscal = FiscalUtil.hasFiscalLevel(props && props.origin);
        var selection = timeBodyCtx._labelGroupNode;
        var scale = timeBodyCtx._data;
        
        var labelClass = AXIS_CLASS_NAMES.LABEL + " " + AXIS_CLASS_NAMES.MORPHABLE_LABEL + " " +
                AXIS_CLASS_NAMES.LABEL_BACKWORD;
        var styles = props.get('label.style');
        var offset = TextUtils.getTextBaselineOffset(styles);
        var fill = effectManager.register({
            fillColor: styles.color
        });
        var fillUpperLevel = effectManager.register({
            fillColor: styles.parentColor
        });
        var fontSize = styles.fontSize;
        var fontWeight = styles.fontWeight;
        var fontFamily = styles.fontFamily;
        var fontStyle = styles.fontStyle;
        
        var textAnchor = null;
        var envManager = timeBodyCtx.runtime().envManager();
        if(envManager) {
            textAnchor = envManager.textAnchor();
        }

        selection.selectAll('.' + AXIS_INTERACTION_CLASS_NAMES).remove();
        selection.selectAll('.v-label-upperLevel').remove();
        var labelSelections = selection.selectAll("." + AXIS_CLASS_NAMES.LABEL).data(labels);
        labelSelections.enter().append("g").each(function(){
            this.setAttribute("class", labelClass);
            this.setAttribute("fill", fill);
            this.setAttribute("font-size", fontSize);
            this.setAttribute("font-weight", fontWeight);
            this.setAttribute("font-family", fontFamily);
            this.setAttribute("font-style", fontStyle);
            this.setAttribute('pointer-events', 'none');
            this.setAttribute("text-anchor", textAnchor);
        });
        labelSelections.exit().remove();

        var isTop = position === Constants.POSITION.TOP;
        var scrollOffset = labels.offset || 0;

        var isForceCategoryForMinLevel = timeBodyCtx.isForceCategoryForMinLevel(currentLevel, step);
        labelSelections.each(function(d){
            var layers = d.layers;
            var length = layers.length;
            var sel = d3.select(this);
            if (length){
                // Add an interaction layer under the label layer
                var interactionG = selection.insert("g", '.' + AXIS_CLASS_NAMES.LABEL)
                    .attr("class", AXIS_INTERACTION_CLASS_NAMES);
                var rectG = interactionG.append('g').attr("class", AXIS_CLASS_NAMES.LABEL_SELECTION_TIMEAXIS).node();
                
                // Add an empty rect for interaction, and for layer 1, only have interaction when step is 1
                var rect, layer = layers[0];

                //according to the requirement of PO, for fiscal, if some labels are overlapped for 1 step, 
                //we need to disable label rect 
                var isDisableLabelRect = (isFiscal && step === 1 && labels.isOverlappedLabelHide &&
                    layers.length === 1);
                if(step === 1 && layer.text && !isDisableLabelRect) {
                    rect = SVG.create("rect");
                    rect.setAttribute("class", AXIS_CLASS_NAMES.BACKGROUND_RECT);
                    rect.setAttribute("fill", "transparent");
                    rectG.appendChild(rect);
                }

                var text = this.querySelector(".v-label-baseLevel");
                if(!text){
                    text = SVG.create("text");
                    text.setAttribute("class", "v-label-baseLevel");
                    this.appendChild(text);
                }
                
                rectG.setAttribute("timelabel-id", layer.id);
                DataPointUtils.setContext(rectG, layer);
                var baseLayerTop = isTop ? height - LABEL_OFFSET - offset :
                        LABEL_OFFSET + layer.height - offset;
                fillText(text, layer, fillUpperLevel);
                text.setAttribute("x", layer.left - scrollOffset);
                text.setAttribute("y", baseLayerTop);
                text.setAttribute("timelabel-id", layer.id);

                var x, rectWidth;
                if(step === 1 && layer.text && !isDisableLabelRect) {
                    // For layer 1, only have interaction when step is 1, 
                    // and the behavior is different between continuous and category look
                    if(displayMode === 'CONTINUOUS' || isForceCategoryForMinLevel) {
                        x = layer.left - HOVERSHADOW_PADDING - scrollOffset;
                        rectWidth = layer.width + 2 * HOVERSHADOW_PADDING;
                        var textSize = TextUtils.fastMeasure(layer.text, fontSize, fontWeight, fontFamily);
                        rect.setAttribute("x", x);
                        rect.setAttribute("y", baseLayerTop + textSize.y - HOVERSHADOW_PADDING);
                        rect.setAttribute("width", rectWidth);
                        rect.setAttribute("height", layer.height + 2 * HOVERSHADOW_PADDING);
                    }
                    else if(layer.hasOwnProperty('rectX')){
                        x = layer.rectX - scrollOffset;
                        rect.setAttribute("x", x);
                        rect.setAttribute("y", 1);
                        rectWidth = layer.rectWidth;
                        if(x > width) {
                            rectWidth = 0;
                        }
                        else if(x + rectWidth > width) {
                            rectWidth = width - x;
                        }
                        rect.setAttribute("width", rectWidth);
                        rect.setAttribute("height", baseLayerTop + HOVERSHADOW_PADDING);
                    }
                }
                
                //use data driven to draw upper levels.
                var upperLevelRectG = interactionG.selectAll('.' + 
                        AXIS_CLASS_NAMES.LABEL_SELECTION_TIMEAXIS_UPPERLEVEL)
                    .data(layers.slice(1), function(d) {
                        return d.level;
                    });
                upperLevelRectG.enter().insert("g", '.' + AXIS_CLASS_NAMES.LABEL_SELECTION_TIMEAXIS)
                    .each(function(d) {
                        this.setAttribute("class", AXIS_CLASS_NAMES.LABEL_SELECTION_TIMEAXIS_UPPERLEVEL);
                    }).sort(function(a, b) {
                        if(a.level && b.level) {
                            return TimeUtil.levelComparator.bind(timeBodyCtx)(b.level, a.level);
                        }
                        return false;
                    });
                upperLevelRectG.exit().remove();

                var that = this;
                upperLevelRectG.each(function(d, i){
                    this.setAttribute("timelabel-id", d.id);
                    layer = layers[i + 1];
                    baseLayerTop = isTop ? height - LABEL_OFFSET - offset :
                        LABEL_OFFSET + d.height - offset;
                    var heightOffset = d.height * (i + 1) * (isTop ? -1 : 1);
                    var upperLevelRect = this.querySelector("." +  AXIS_CLASS_NAMES.BACKGROUND_RECT);
                    if(layer.hasOwnProperty('rectX')) {                            
                        upperLevelRect = SVG.create("rect");
                        upperLevelRect.setAttribute("class", AXIS_CLASS_NAMES.BACKGROUND_RECT);
                        upperLevelRect.setAttribute("fill", "transparent");
                        this.appendChild(upperLevelRect);
                        x = layer.rectX - scrollOffset;
                        rectWidth = layer.rectWidth ? layer.rectWidth : layer.width + HOVERSHADOW_PADDING;
                        if(x < 0) {
                            rectWidth = Math.max(0, rectWidth + x);
                            x = -1; // We need 1px offset
                        }
                        if(x > width) {
                            rectWidth = 0;
                        }
                        else if(x + rectWidth > width) {
                            rectWidth = width - x;
                        }
                        upperLevelRect.setAttribute("x", x);
                        upperLevelRect.setAttribute("y", (baseLayerTop + d.height * i * (isTop ? -1 : 1)) + 3);
                        upperLevelRect.setAttribute("width", rectWidth);
                        upperLevelRect.setAttribute("height", d.height);
                    }

                    var upperLevelText = that.querySelector(".v-label-upperLevel:nth-child(" + (i + 2) + ")");
                    if(!upperLevelText) {
                        upperLevelText = SVG.create("text");
                        upperLevelText.setAttribute("class", "v-label-upperLevel");
                        that.appendChild(upperLevelText);
                    }
                    fillText(upperLevelText, d, fillUpperLevel);
                    upperLevelText.setAttribute("timelabel-id", layer.id);
                    upperLevelText.setAttribute("fill", fillUpperLevel);
                    upperLevelText.setAttribute("x", d.left - scrollOffset);
                    upperLevelText.setAttribute("y", baseLayerTop + heightOffset);
                });
                
            } else {
                sel.selectAll(".v-label-baseLevel").remove();
                sel.selectAll(".v-label-upperLevel").remove();
            }
        });
    };

    function fillText(textNode, layer, fill){
        var text = layer.text;
        var format = layer.format;
        var beginer = "{{";
        var ender = "}}";
        if(!text){
            textNode.textContent = '';
            return;
        }
        DOM.empty(textNode);
        if(format.indexOf(beginer) < 0 || format.indexOf(ender) < 0){
            textNode.textContent = text;
            return;
        }
        var idx = 0;
        var beginIdx;
        var endIdx;
        var mutex = 0;
        var tokens = [];
        var flags = [];
        var start = 0;
        while(idx < text.length){
            beginIdx = text.indexOf(beginer, idx);
            endIdx = text.indexOf(ender, idx);
            if(beginIdx < 0 && endIdx < 0){
                tokens.push(text.slice(start));
                flags.push(0);
                break;
            }
            if(beginIdx >= 0 && (beginIdx < endIdx || endIdx < 0)){
                if(mutex === 0){
                    tokens.push(text.slice(start, beginIdx));
                    flags.push(0);
                    start = beginIdx + beginer.length;
                }
                idx = beginIdx + beginer.length;
                ++mutex;
            }else{
                if(mutex > 0){
                    --mutex;
                    if(mutex === 0){
                        tokens.push(text.slice(start, endIdx));
                        flags.push(1);
                        start = endIdx + ender.length;
                    }
                }
                idx = endIdx + ender.length;
            }
        }
        tokens.forEach(function(token, i){
            var tspan = SVG.create('tspan');
            tspan.textContent = token;
            if(flags[i]){
                tspan.setAttribute('fill', fill);
            }
            textNode.appendChild(tspan);
        });
    }

    return ret;

});

define('sap/viz/chart/components/axis/sub/TimeAxisCommon',[
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/framework/common/format/FormatManager',
    "sap/viz/framework/common/util/ObjectUtils",
], function(
    TimeUtil,
    TextUtils,
    NumberUtils,
    TypeUtils,
    FormatManager,
    ObjectUtils
){

    var KEEP_FIRST = "KEEP_FIRST";
    var KEEP_LONGER = "KEEP_LONGER";
    
    var floor = Math.floor;
    var ceil = Math.ceil;
    var max = Math.max;
    var min = Math.min;

     //trial mode only generate few labels to see if there is overlapping
    var TRIAL_MODE = 1; 
    var PIVOT_MODE = 1 << 2;

    var FORMAT_CONFIG_FIELD = 'formatString';
    var VISIBLE_CONFIG_FIELD = 'visible';
    var LAYER_CONFIG_FIELD = 'row';
   

    // The more labels we try, the higher chance we find overlapped case, but the lower performance
    var SINGLE_TRIAL_COUNT = 4;

    //short format support
    var SHORT_FORMAT_LEVELS = ["day", "second"];
    var BIG_LEVEL_FOR_SHORT_LEVEL = {day:"month", second:"minute"};

    var levelComparator = TimeUtil.levelComparator;

    function getValuesFunc(name, timeBodyCtx){
        // the returned function is called in the scope of a item
        return function(utc, start, end, isTrial, limit, customStart, allowFirstValue, weekConfig){
            // if empty range, force to return one value, so that one label and tick can show.
            if(start === end){
                return [start];
            }
            var align = this.hasOwnProperty('align') ? this.align : true;
            var count = isTrial && SINGLE_TRIAL_COUNT;
            return TimeUtil[name](start, end, this.step, count, align, limit, customStart, utc,
                allowFirstValue, timeBodyCtx, weekConfig);
        };
    }

    // some helper functions for level item condition function
    function sameYear(context){
        var ds = new Date(context.start);
        var de = new Date(context.end);
        if(context.utc){
            return ds.getUTCFullYear() === de.getUTCFullYear();
        }
        return ds.getFullYear() === de.getFullYear();
    }

    function sameMonth(context){
        var ds = new Date(context.start);
        var de = new Date(context.end);
        if(context.utc){
            return ds.getUTCFullYear() === de.getUTCFullYear() && ds.getUTCMonth() === de.getUTCMonth();
        }
        return ds.getFullYear() === de.getFullYear() && ds.getMonth() === de.getMonth();
    }

    function notCheck(condition){
        return function(context){
            return !condition(context);
        };
    }

    var YEAR_MONTH_DAY = "YearMonthDay";
    var YEAR_QUARTER = "YearQuarter";
    var YEAR_MONTH = "YearMonth";
    var combinedTimePattern = {};
    combinedTimePattern[YEAR_MONTH_DAY] = ["day", "year"];
    combinedTimePattern[YEAR_QUARTER] = ["quarter", "year"];
    combinedTimePattern[YEAR_MONTH] = ["month", "year"];
    function shouldUseShortFormat(level, value, prevValue, utc, context, position, prevPosition) {
        position = position || context.scale(value);
        var res = true;
        if (SHORT_FORMAT_LEVELS.indexOf(level) === -1 || !TypeUtils.isExist(prevValue)) {
            if (isPositionVisible(position, context)) {
                res = false;
            }
        } else {
            prevPosition = prevPosition || context.scale(prevValue);

            var currentDate = new Date(value);
            var table = TimeUtil.getTimeTable(currentDate);
            var num = table[level];
            var bigLv = BIG_LEVEL_FOR_SHORT_LEVEL[level];
            var same = context.timeBodyCtx.levelDict[bigLv].same(currentDate, prevValue, utc, context.weekConfig);

            if ((level === "day" && num === 1) || (num === 0)) {
                res = false;
            } else if (!same) {
                res = false;
            } else if (!isPositionVisible(prevPosition, context) && isPositionVisible(position, context)) {
                res = false;
            }
        }
        return res;
    }


    var combinationDict = {
        'hourminutesecond': {},
        'hourminute': {},
        'monthday': {},
        'yearmonthday': {},
        'yearquarter': {},
        'yearmonth': {}
    };
    
    var initLevelStoreValues = function (levelStore, levelDict) {
        levelStore.forEach(function (item) {
            item.density = getDensity(item.name, item.step, levelDict);
            item.values = item.values || levelDict[item.name].values;
        });
    };
   
    function getDensity(level, step, levelDict) {
        var density = TimeUtil.ONE_YEAR * 2 / (step * levelDict[level].period);
        return density >= 1 ? floor(density) : density;
    }


    function isPositionVisible(position, context){
        if(!TypeUtils.isExist(position)){
            return false;  
        }

        if(!context || !context.scale){
            return true;
        }

        var value = context.scale.invert(position);
        return isValueVisible(value, context);
    }

    function isValueVisible(value,context){
        if(!TypeUtils.isExist(value)){
            return false;  
        }

        if(!context || !context.limit){
            return true;
        }

        if(context.limit.length === 4){
            return context.limit[2] <= value && value <= context.limit[3];
        }else if(context.limit.length === 2){
            return context.limit[0] <= value && value <= context.limit[1];
        }

        return false;
    }

    function isLevelVisible(levelName, labelLevels, config, context) {
        var isVisible = config[levelName] && config[levelName].hasOwnProperty(VISIBLE_CONFIG_FIELD) ?
        config[levelName][VISIBLE_CONFIG_FIELD] : context.timeBodyCtx.levelDict[levelName].visible;
        if(TypeUtils.isFunction(isVisible)){
            return isVisible(labelLevels.slice());
        }
        return isVisible;
    }

    function isLabelVisible(label,context){
        if(!label){
            return false;  
        }

        for(var ii = 0; ii< label.layers.length; ii++){
            var layer = label.layers[ii];
            if(!isPositionVisible(layer.left)){
                return false; 
            }
        }
        return true;
    }

    /**
    *   get date info string array from a time stamp used by range selection tooltip
    */
    function getTimeValueFormat(value, context, currentLevel, tTimeAxisBody){
        var texts = {};
        var levels = ObjectUtils.extend(true, [], TimeUtil.normalizeLevels(context.levels, tTimeAxisBody));
        if(currentLevel){
            currentLevel = TimeUtil.normalizeLevelName(currentLevel); 
            if(currentLevel && levels.indexOf(currentLevel) === -1){ 
                levels.push(currentLevel); 
                levels.sort(levelComparator.bind(tTimeAxisBody)); 
            } 
        }
        var timeLevels = [];
        var index;
        if(levels.indexOf("second") >= 0){
            index = levels.indexOf("minute");
            if(index >= 0){
                levels.splice(index, 1);
            }
            index = levels.indexOf("hour");
            if(index >= 0){
                levels.splice(index, 1);
            } 
        }else if(levels.indexOf("minute") >= 0){
            index = levels.indexOf("hour");
            if(index >= 0){
                levels.splice(index, 1);
            }
        }
        
        if(levels.indexOf("day") >= 0){
            index = levels.indexOf("month");
            if(index >= 0){
                levels.splice(index, 1);
            }
        }
        
        if(['second','minute', 'hour'].indexOf(levels[0]) >= 0){
            timeLevels[0] = levels[0];
            levels.splice(0,1);
            
        }

        var currentInfo;
        var extraConfig;
        var prevInfo = getPrevInfo(null, null);
        
        var dayTexts = [];
        var timeTexts = [];
        var result;
        if(timeLevels.length > 0){
            timeLevels.forEach(function (lv){
                currentInfo = getCurrentInfo(value, lv, timeLevels, null);
                extraConfig = getExtraConfig(null, true);
                result = formatLabel(currentInfo, prevInfo, context, extraConfig);
                timeTexts.push(result.text);
            });
        }
        
        if(levels.length > 0){
            var timePattern = checkCombinedTimePattern(levels);
            result = null;
            if (timePattern.length > 0) {
                currentInfo = getCurrentInfo(value, timePattern[0].pattern, levels, null);
                extraConfig = getExtraConfig(true, true);
                result = formatLabel(currentInfo, prevInfo, context, extraConfig);
            }
            if(!result ){
                extraConfig = getExtraConfig(false, true);
                levels.forEach(function(lv){
                    currentInfo = getCurrentInfo(value, lv, levels, null);
                    result = formatLabel(currentInfo, prevInfo, context, extraConfig);
                    dayTexts.push(result.text);
                });
            }else{
                dayTexts.push(result.text);
            }
        }

        result = [combineLabels(dayTexts, context),  combineLabels(timeTexts, context)];
        return result;
    }

    function getCurrentInfo(value, levelName, levels, position){
        return  {   value: value, 
                    levelName: levelName,
                    labelLevels: levels,
                    position: position,
                };
    }

    function getPrevInfo(value, position){
        return  {   prevValue: value,
                    prevPosition: position
                };
    }

    function getExtraConfig(isCombination, isForcedFullFormat){
        return  {   isCombination: isCombination,
                    isForcedFullFormat: isForcedFullFormat
                };
    }

    function formatLabel(currentInfo, prevInfo, context, extraConfig){
        var value = currentInfo.value;
        var levelName = currentInfo.levelName;
        var labelLevels = currentInfo.labelLevels;
        var position = currentInfo.position;

        var prevValue = prevInfo && prevInfo.prevValue;
        var prevPosition = prevInfo && prevInfo.prevPosition;

        var isCombination = extraConfig && extraConfig.isCombination;
        var isForcedFullFormat = extraConfig && extraConfig.isForcedFullFormat;

        var config = context.config;
        var combinationConfig = context.combinationConfig;
        var utc = context.utc;
        var d = new Date(value);
        // Clear the milliseconds since the default formatter has some issues with it
        if(utc){
            d.setUTCMilliseconds(0);
        }else{
            d.setMilliseconds(0);
        }

        var userFormat = config && config[levelName]? config[levelName][FORMAT_CONFIG_FIELD] : null;
        var defaultFormat = context.timeBodyCtx.levelDict[levelName] && context.timeBodyCtx.levelDict[levelName].format;
        var result;
        var text;

        if ([YEAR_MONTH, YEAR_QUARTER, YEAR_MONTH_DAY].indexOf(levelName) > -1) {
            var combinationName = String(levelName).toLowerCase();
            defaultFormat = combinationDict[combinationName] && combinationDict[combinationName].format;
            if (levelName === YEAR_MONTH && combinationConfig.yearmonth) {
                userFormat = combinationConfig.yearmonth[FORMAT_CONFIG_FIELD];
            } else if (levelName === YEAR_QUARTER && combinationConfig.yearquarter) {
                userFormat = combinationConfig.yearquarter[FORMAT_CONFIG_FIELD];
            } else if (levelName === YEAR_MONTH_DAY && combinationConfig.yearmonthday) {
                userFormat = combinationConfig.yearmonthday[FORMAT_CONFIG_FIELD];
            }
            if (!defaultFormat && !userFormat) {
                result = FormatManager.format(d, levelName, utc);
                if (result === FormatManager.DEFAULT_FORMATTED_VALUE) {
                    return undefined;
                }
            }
        }

        if (levelName === "day" && combinationConfig.monthday) {
            if(!shouldUseShortFormat("day",value, prevValue, utc, context,position, prevPosition)){
                if (!isCombination) {
                    userFormat = combinationConfig.monthday[FORMAT_CONFIG_FIELD];
                }
            }
        } else if (levelName === "minute" && combinationConfig.hourminute) {
            userFormat = combinationConfig.hourminute[FORMAT_CONFIG_FIELD];
        } else if (levelName === "second" && combinationConfig.hourminutesecond) {
            if(!shouldUseShortFormat("second",value, prevValue, utc, context,position, prevPosition)){ 
                userFormat = combinationConfig.hourminutesecond[FORMAT_CONFIG_FIELD];
            }
        } 

        //use custom function first, if not working  fallback to built-in format
        if(TypeUtils.isFunction(userFormat)){  
            text = userFormat(value, prevValue, utc, labelLevels.slice());
            if(text){
                result = {format: userFormat, text: text};
            }
        }else if(TypeUtils.isString(userFormat)){
            text = FormatManager.format(d, userFormat, utc);
            if(text){
                if(text instanceof Date){ text = userFormat; }
                result = {format: userFormat, text: text};
            }
        }

        if(!result){
            if(TypeUtils.isString(defaultFormat)){
                text = FormatManager.format(d, defaultFormat, utc);
                if(text instanceof Date){ text = defaultFormat; }
                result = {format: defaultFormat, text: text};
            }else if(TypeUtils.isFunction(defaultFormat)){
                var formatResult = defaultFormat(value, prevValue, utc, labelLevels,
                                                 context, position, prevPosition, isForcedFullFormat);
                if (TypeUtils.isPlainObject(formatResult)){
                    result = formatResult;
                }else{
                    result = {format: defaultFormat, text: formatResult};
                }
            }
        }

        //some formater return number
        if(TypeUtils.isString(result)){
            result = {text: result};
        }
        result.text = TypeUtils.isNumber(result.text)?result.text.toString():result.text;
        return result;
    }

    function combineLabels(texts, context){
        return texts.join(context.levelLabelSeparator);
    }
    

    function measureTextSize(text, style) {
        text = text.replace(/\{\{|\}\}/g, '');
        var size = TextUtils.canvasMeasure(text, style.fontSize, style.fontWeight, style.fontFamily);
        return NumberUtils.preciseObject(size);
    }

  
    // Get labels and calculate their sizes
    function getLabelsAndSetLayout(levelItem, context){
        var labels = getLabels.apply(null, arguments);
        layoutLabels(labels, context);
        return labels;
    }

    function getLabelsWithFirstLastDataAndSetLayout(levelItem, context, mode, values) {
        //We have to add label for first and last data. 
        //(not the first and last "label")
        //Please refer to BITSDC2-4156 [Fiori] Improve first & last date on Time Axis
        //we do not change "try level" process, but get more labels again.
        var labels = getLabels(levelItem, context, mode, values, undefined, true);
        layoutLabels(labels, context);
        return labels;
    }

    function resetAndLayoutLabelsWithFirstLastData(levelItem, tl, context, forceResetlabels) {
        //after first last data labels are added, and layout,
        //we have to delete overlapping labels, and make sure 
        //all labels can be displayed with right format.
        var labelArray = tl.labels;
        var labelOffset = tl.labels.offset;

        //remove possible overlapping because of first and last data
        var rightOverlap;
        var leftOverlap;
        var iLabel;

        var isDeleteLabel = true;

        var firstRightOverlapIndex = Infinity;
        var firstLeftOverlapIndex = Infinity;
        var lastRightOverlapIndex = Infinity;
        var lastLeftOverlapIndex = Infinity;
        for (iLabel = labelArray.length - 1; iLabel >= 0; iLabel--) {
            if (labelArray[iLabel].isFirstData) {
                rightOverlap = getTwoLabelsOverlappedNum(labelArray[iLabel],
                    labelArray[iLabel + 1], context.labelMargin);
                if (rightOverlap) {
                    firstRightOverlapIndex = iLabel + 1;
                }
                leftOverlap = getTwoLabelsOverlappedNum(labelArray[iLabel],
                    labelArray[iLabel - 1], context.labelMargin);
                if (leftOverlap) {
                    firstLeftOverlapIndex = iLabel - 1;
                }
            } else if (labelArray[iLabel].isLastData) {
                rightOverlap = getTwoLabelsOverlappedNum(labelArray[iLabel],
                    labelArray[iLabel + 1], context.labelMargin);
                if (rightOverlap) {
                    lastRightOverlapIndex = iLabel + 1;
                }
                leftOverlap = getTwoLabelsOverlappedNum(labelArray[iLabel],
                    labelArray[iLabel - 1], context.labelMargin);
                if (leftOverlap) {
                    lastLeftOverlapIndex = iLabel - 1;
                }
            }
        }

        isDeleteLabel = false;
        if (lastRightOverlapIndex !== Infinity) {
            labelArray.splice(lastRightOverlapIndex, 1);
            isDeleteLabel = true;
        }

        if (lastLeftOverlapIndex !== Infinity) {
            labelArray.splice(lastLeftOverlapIndex, 1);
            isDeleteLabel = true;
        }

        if (firstRightOverlapIndex !== Infinity &&
            (firstRightOverlapIndex < 
                Math.min(lastLeftOverlapIndex, lastRightOverlapIndex))
            ) {
            labelArray.splice(firstRightOverlapIndex, 1);
            isDeleteLabel = true;
        }

        if (firstLeftOverlapIndex !== Infinity &&
            (firstLeftOverlapIndex < 
                Math.min(lastLeftOverlapIndex, lastRightOverlapIndex))
            ) {
            labelArray.splice(firstLeftOverlapIndex, 1);
            isDeleteLabel = true;
        }

        if (isDeleteLabel || forceResetlabels) {
            //some labels are deleted. we have to rebuild label text and relayout labels.
            var values = [];
            for (iLabel = 0; iLabel < labelArray.length; iLabel++) {
                values.push(labelArray[iLabel].value);

            }
            labelArray = getLabelsWithFirstLastDataAndSetLayout(levelItem, context, 0, values);
            if (labelArray.length >= tl.labels.length) {
                //It means we delete first or last label, and then add them 
                //in getLabelsWithFirstLastDataAndSetLayout.
                //We cannot delete new added first and last label.
                isDeleteLabel = false;
            }
            tl.labels = labelArray;
            tl.labels.offset = labelOffset;
        }
        return isDeleteLabel;
    }

    function getLabelLevels(levelItem, context){
        var labelLevels, allLevels;
        var levelIdx = context.levels.indexOf(levelItem.name);
        if(levelIdx >= 0){
            labelLevels = context.levels.slice(levelIdx);
            allLevels = context.levels;
        }else{
            labelLevels = [levelItem.name].concat(context.levels).sort(levelComparator.bind(context.timeBodyCtx));
            allLevels = labelLevels.slice();
            labelLevels = labelLevels.slice(labelLevels.indexOf(levelItem.name));
        }

        var config = context.config;
        var levelsByLayer = [[]];
        var levels;
        // Prepare label levels on each layer.
        // NOTE: The current level must be shown at the first position of the first layer.
        for(var ii = 0; ii < labelLevels.length; ++ii){
            var levelName = labelLevels[ii];
            if (isLevelVisible(levelName, labelLevels, config, context)) {
                var layerIdx = floor(config[levelName] && config[levelName][LAYER_CONFIG_FIELD]);
                if(layerIdx >= 1){
                    // custom config is valid
                    layerIdx = layerIdx > context.maxLayerCount ? context.maxLayerCount : layerIdx;
                }else if(ii === 0){
                    // invalid custom config, default current level label layer
                    layerIdx = 1;
                }else{
                    // invalid custom config, default upper level label layer
                    layerIdx = 2;
                }
                levels = levelsByLayer[layerIdx - 1] = levelsByLayer[layerIdx - 1] || [];
                levels.push(levelName);
            }
        }
        // Empty first layer is not allowed
        if(!levelsByLayer[0].length){
            levelsByLayer = levelsByLayer.slice(1);
        }

        return [labelLevels, allLevels, levelsByLayer];
    }

    function getValueForFormat(value, curLvName, levelName, utc, context){
        var tempV = value;
        if(curLvName === "week" && 
           levelComparator.bind(context.timeBodyCtx)(levelName, "week") >0  &&
           TimeUtil.getWeek(value, utc, context.weekConfig) === 1){
            //special handle for first week
            tempV = value + TimeUtil.ONE_WEEK;
        }
        return tempV;
    }

    //Check whether the time pattern is combined
    function checkCombinedTimePattern (levels) {
        var timePattern = [];
        if (combinedTimePattern) {
            var keys = Object.keys(combinedTimePattern);
            keys.forEach(function(key) {
                var matcher = {
                    startIdx: -1,
                    endIdx: -1, 
                    pattern: ""
                };
                var list = combinedTimePattern[key];
                var listPos = 0;
                var listLen = list.length;
                var isMatch = false;
                var patternIdx = -1;
                for (var j = 0; j < levels.length; j++) {
                    if (levels[j] !== list[listPos]) {
                        if (isMatch) {
                            break;
                        }
                        continue;
                    } else {
                        isMatch = true;
                        if (patternIdx < 0) {
                            patternIdx = j;
                        }
                        listPos++;
                        if (listPos === listLen) {
                            matcher.startIdx = patternIdx;
                            matcher.endIdx = patternIdx + listLen - 1;
                            matcher.pattern = key;
                            timePattern.push(matcher);
                            break;
                        }
                    }
                }
            });
        }
        return timePattern;
    }

    // Generate label structure
    function getLabels(currentLevelItem, context, mode, values, positions, addFirstLastData){
        // trial mode does not create real label for rendering. instead, it creates 
        // experimental labels and see if there is a overlapping

        //illegal case
        if(values && positions && values.length !== positions.length){
            return null;
        }
        
        var hasStablePos = !!positions;
        positions = positions||[];

        var isTrial = TypeUtils.isSet(mode, TRIAL_MODE);
        var intervalPivot = TypeUtils.isSet(mode, PIVOT_MODE) ? context.intervalPivot : null;
        values = values || currentLevelItem.values(context.utc, context.start, context.end,
                isTrial, context.limit, intervalPivot, context.categoryLook, context.weekConfig);
        
        //add first and last data label. There may be not the exact first and last labels, 
        //but it is used to display the first and last data in the plot.
        //BITSDC2-4156 [Fiori] Improve first & last date on Time Axis
        var firstDataIndex = -1;
        var lastDataIndex = -1;
        var firstLastObj;
        if (addFirstLastData) {
            firstLastObj = insertFirstLastValues(values, currentLevelItem.name, context);
            firstDataIndex = firstLastObj.firstDataIndex;
            lastDataIndex = firstLastObj.lastDataIndex;
        }

        var ii, jj, kk;
        var value, prevValue, label, prevLabel;
        var levels, levelName, tempV ;
        var utc = context.utc;
        var weekConfig = context.weekConfig;
        
        var temp =  getLabelLevels(currentLevelItem, context);
        var labelLevels = temp[0];
        var allLevels = temp[1];
        var levelsByLayer = temp[2];
        var curLvName = currentLevelItem.name;
      
        // Ensure we have only one value out of limit
        for(ii = 0; ii < values.length; ++ii){
            if (isValueVisible(values[ii], context)) {
                if (ii > 1) {
                    values = values.slice(ii - 1);
                    if (addFirstLastData) {
                        firstDataIndex = ((firstDataIndex >= (ii - 1)) ? (firstDataIndex - (ii - 1)) : -1);
                        lastDataIndex = ((lastDataIndex >= (ii - 1)) ? (lastDataIndex - (ii - 1)) : -1);
                    }
                }
                break;
            }
        }

        var labels = [];

        //each value
        for(ii = 0; ii < values.length; ++ii){
            value = values[ii];
            prevValue = values[ii - 1];
            label = {value:value, layers: []};

            var position = positions[ii];
            var prevPosition = positions[ii-1];

            //...each layer
            for(jj = 0; jj < levelsByLayer.length; ++jj){
                levels = levelsByLayer[jj] || [];
                var texts = [];
                var formats = [];
                var level = null;
                //....each level 
                for(kk = 0; kk < levels.length; ++kk){
                    levelName = levels[kk];
                    if(!level) {
                        level = levelName;
                    }
                    else {
                        if(TimeUtil.levelComparator.bind(context.timeBodyCtx)(levelName, level) < 0) {
                            level = levelName;
                        }
                    }
                    var formatResult;
                    tempV = getValueForFormat(value, curLvName, levelName, utc, context);
                    var currentInfo = getCurrentInfo(tempV, levelName, labelLevels, position);
                    var prevInfo = getPrevInfo(prevValue, prevPosition);
                    var extraConfig = getExtraConfig(levels.length > 1 && levels.indexOf("day") > -1, false);
                    formatResult = formatLabel(currentInfo, prevInfo, context, extraConfig);

                    texts.push(formatResult.text);
                    formats.push(TypeUtils.isFunction(formatResult.format) ? '' : formatResult.format);
                }
               
                label.layers[jj] = {formats: formats,texts: texts, levels: levels};                
                label.layers[jj].level = level;
            }

            if (addFirstLastData) {
                if(ii === firstDataIndex) {
                    label.isFirstData = true;
                }
                else if(ii === lastDataIndex) {
                    label.isLastData = true;
                }
            }
            labels.push(label);
        }

        //remove duplicate
        if(!context.firstLastTicksOnly && labels.length > 1) {
            var lastVisibleTextByLevel = {};
            var lastVisibleValueByLevel = {};
            //each value
            for(ii = 1; ii < values.length; ++ii){
                value = values[ii];
                prevValue = values[ii-1];

                label =  labels[ii];
                prevLabel = labels[ii-1];

                //...each layer
                //allow the duplicate lable in first layer 
                //so we start from second layer
                for(jj = 1; jj < levelsByLayer.length; ++jj){
                    var layer = label.layers[jj];
                    var prevLayer = prevLabel.layers[jj];

                    levels = levelsByLayer[jj] || [];
                    
                     //....each level
                    for(kk = 0; kk < levels.length; ++kk){
                        levelName = levels[kk];
                        var isSameFn = context.timeBodyCtx.levelDict[levels[kk]].same;
                        var text =  layer.texts[kk];
                        var prevText = prevLayer.texts[kk];
                        var lastVisibleText = lastVisibleTextByLevel[levelName];
                        var lastVisibleValue = lastVisibleValueByLevel[levelName];

                        tempV = getValueForFormat(value, curLvName, levelName, utc, context);

                        //special handle for leftmost label in final stage
                        if(hasStablePos && ii === 1 && !isPositionVisible(positions[0], context)){
                            labels[0].layers[jj].texts[kk] = '';
                            if(isPositionVisible(positions[1], context)){
                                lastVisibleTextByLevel[levelName] = text;
                                lastVisibleValueByLevel[levelName] = tempV; 
                            }
                        }else{
                            //remove the same text or the same meaning
                            if((text === prevText || text === lastVisibleText) ||
                               (isSameFn && (isSameFn(tempV, prevValue, utc, weekConfig) || 
                                    isSameFn(lastVisibleValue, tempV, utc, weekConfig))) ){
                                label.layers[jj].texts[kk] = '';
                            }else{
                                lastVisibleTextByLevel[levelName] = text;
                                lastVisibleValueByLevel[levelName] = tempV;
                            }
                        }
                    }
                }
            }    
        }

        labels.forEach(function(label, idx){
            for(ii = 0; ii < label.layers.length; ii++){
                label.layers[ii].texts = label.layers[ii].texts.filter(function(ele){return ele.length>0;});
                label.layers[ii].formats = label.layers[ii].formats.filter(function(ele){return ele.length>0;});

                label.layers[ii].text = combineLabels(label.layers[ii].texts, context)||'';
                label.layers[ii].format = combineLabels(label.layers[ii].formats, context)||'';

                var tempV = getValueForFormat(label.value, curLvName, levelName, utc, context);
                var prevValue;
                if (idx > 0) {
                    prevValue = labels[idx - 1].value;
                }
                var timePattern = checkCombinedTimePattern(label.layers[ii].levels);
                if (timePattern.length > 0) {
                    var currentInfo = getCurrentInfo(tempV, timePattern[0].pattern, labelLevels, position);
                    var prevInfo = getPrevInfo(prevValue, null);
                    var extraConfig = getExtraConfig(true, false);
                    var combinationLabel = formatLabel(currentInfo, prevInfo, context, extraConfig);
                    if (label.layers[ii].texts.length > 0 &&
                        label.layers[ii].texts.indexOf('') < 0 &&
                        combinationLabel &&
                        combinationLabel.text) {
                        var dayIdx = label.layers[ii].levels.indexOf("day");
                        var ff = label.layers[ii].formats[dayIdx];
                        if (timePattern[0].pattern !== YEAR_MONTH_DAY &&
                            label.layers[ii].levels.length === 2) {
                            label.layers[ii].text = combinationLabel.text;
                        }

                        if (timePattern[0].pattern === YEAR_MONTH_DAY) {
                            if ((ff && ff.search(/M|m/) > -1 && ff.search(/D|d/) > -1) ||
                                label.layers[ii].levels.length === label.layers[ii].texts.length) {
                                label.layers[ii].text = combinationLabel.text;
                            }
                        } 

                    }
                }

                if(label.layers[ii].text){
                    var size = measureTextSize(label.layers[ii].text, context.style);
                    label.layers[ii].height = size.height;
                    label.layers[ii].width = size.width;
                }else{
                    label.layers[ii].height = 0;
                    label.layers[ii].width = 0;
                }

                //init location, will be changed by later layout function
                label.layers[ii].left = label.layers[ii].right = label.layers[ii].center = 0.0;
                //delete un-need property 
                delete(label.layers[ii].formats);
                delete(label.layers[ii].texts);
            }
        });

        labels.allLevels = allLevels;
        labels.levels = labelLevels;
        labels.layerCount = levelsByLayer.length;
        return labels;
    }

    // Measure label sizes
    function layoutLabels(labels, context, noShift, enableForceToShowFirstLast){
        var ii, jj, label, layer, size;
        var totalWidth = context.width;
        var leftMostIndex = -1;
        var rightMostIndex = Infinity;
        var shift = !noShift;

        var firstDataIndex = -1;
        var lastDataIndex = -1;
        for (ii = 0 ; ii < labels.length; ii++) {
            label = labels[ii];
            if (enableForceToShowFirstLast) {
                if (label.isFirstData) {
                    firstDataIndex = ii;
                } else if (label.isLastData) {
                    lastDataIndex = ii;
                }
            }
            label.center = context.scale(label.value);
            for(jj = label.layers.length-1; jj >=0; jj--){
                layer = label.layers[jj];
                if(layer.text){
                    layer.left = label.center - layer.width / 2;
                
                    if(shift && layer.left < 0){
                        layer.left = 0;
                        leftMostIndex = Math.max(leftMostIndex, ii);
                    }

                    layer.right = layer.left + layer.width;

                    if(shift && layer.right > totalWidth && totalWidth>= layer.width){
                        rightMostIndex = Math.min(ii, rightMostIndex);
                        layer.right = totalWidth;
                        layer.left = totalWidth - layer.width;
                    }
                }else{
                    layer.left = layer.right = label.center;
                }
            }
        }

        if (enableForceToShowFirstLast) {
            if (leftMostIndex > firstDataIndex && firstDataIndex !== -1) {
                leftMostIndex = firstDataIndex;
            }
            if (rightMostIndex < lastDataIndex && lastDataIndex !== -1) {
                rightMostIndex = lastDataIndex;
            }
        }

        if(leftMostIndex > 0) {
            //we will not allow duplicate for the second and more layers. So we 
            //have to "revert" deleted texts for these layers if we delete some lables before
            for(jj = 1; jj < labels[leftMostIndex].layers.length; jj++) {
                if(labels[leftMostIndex].layers[jj].text === "") {
                    labels[leftMostIndex].layers[jj] = ObjectUtils.clone(labels[leftMostIndex - 1].layers[jj]);
                }
            }
            labels.splice(0, leftMostIndex); 
        }
        if(rightMostIndex !== Infinity){
            //delete labels from rightMostIndex
            labels.splice(rightMostIndex+1, labels.length);
        }
    }

    //first label and last label is very tricky
    //require special handle
    function layoutFirstAndLastLabel(labels, context){
        if(labels.length < 2){
            return;
        }    
        emptyLabelIfOverlap(labels[0], labels[1], KEEP_FIRST, context);

        var lastLabel = labels[labels.length-1];
        var secondLastLabel = labels[labels.length-2];
        emptyLabelIfOverlap(lastLabel, secondLastLabel, KEEP_FIRST, context); 
    }

    var emptyLayer = function(layer) {
        var middle = (layer.left + layer.right) / 2;
        layer.text = "";
        layer.width = 0;
        layer.left = middle;
        layer.right = middle;
        layer.isEmpty = true;
    };
    
    //try to empty some layer if two layer overlap in some exteme case
    function emptyLabelIfOverlap(firstLabel, secondLabel, mode, context){
        for(var ii = 0; ii < firstLabel.layers.length; ++ii){
            var rightLayer = firstLabel.layers[ii];
            var leftLayer = secondLabel.layers[ii];

            if(!leftLayer || !rightLayer){
                continue;
            }

            var center = (leftLayer.left+leftLayer.right)/2;
            if(!isPositionVisible(center, context)){
                continue;
            }

            var extremePadding = 1.0;
            if (getTwoLayersOverlappedNum(leftLayer, rightLayer, extremePadding) > 0) {
                if (context.enableForceToShowFisrtLast) {
                    //we have to keep first or last
                    if (firstLabel.isFirstData || firstLabel.isLastData) {
                        emptyLayer(leftLayer);
                    }
                    else {
                        emptyLayer(rightLayer);
                    }
                }
                else {
                    if (mode === KEEP_FIRST) {
                        emptyLayer(leftLayer);
                    } else {  //keep longer
                        if (rightLayer.text.length >= leftLayer.text.length) {
                            emptyLayer(leftLayer);
                        } else {
                            emptyLayer(rightLayer);
                        }
                    }
                }
            }
        }
    }


    //at the end, we did anything to prevent overlapping.
    //but still there is some overlap in some extreme case
    //then, we have no choice but remove it
    function preventAnyOverlapping(ctx) {
        var labels = ctx.labels;
        var context = ctx.context;
        if(labels.length < 2){
            return;
        }

        //a O(N^2) run time to check thoroughly
        var ii;
        for(ii = 0; ii < labels.length-1; ii++){
            var leftLabel = labels[ii];

            for(var jj = ii+1; jj < labels.length && jj < ii + MAX_CHECK_STEP; ++jj){
                var rightLabel = labels[jj];
                if(ii === 0) {
                    emptyLabelIfOverlap(leftLabel, rightLabel, KEEP_FIRST, context);
                }
                else if(jj === labels.length - 1) {
                    emptyLabelIfOverlap(rightLabel, leftLabel, KEEP_FIRST, context);
                }
                else {
                    emptyLabelIfOverlap(rightLabel, leftLabel, KEEP_LONGER, context);
                }
            }
        }


        var EXTREME_MIN_WIDTH = 0.1;
        labels.forEach(function(label){
            label.layers.forEach(function(layer){
                if( Math.abs(layer.right - layer.left) < EXTREME_MIN_WIDTH) {
                    emptyLayer(layer);
                    labels.isOverlappedLabelHide = true;
                }
            });
        });

        if (ctx.displayMode === 'CONTINUOUS' && ctx.labels.length > 0 &&
            ctx.ticks.length === 0 && ctx.originalTicks && ctx.originalTicks.length > 0) {
            //for time column "no-tick" mode, if some labels are removed, we have to revert all the ticks 
            //from original ticks, and then change remaining ticks to major ticks.
            var emptyLabelValues = [];
            var iLabel;
            var iLayer;
            var iTick;
            for (iLabel = 0; iLabel < labels.length; iLabel++) {
                var isAllEmpty = true;
                for (iLayer = 0; iLayer < labels[iLabel].layers.length; iLayer++) {
                    if (!labels[iLabel].layers[iLayer].isEmpty) {
                        isAllEmpty = false;
                        break;
                    }
                }
                if (isAllEmpty) {
                    emptyLabelValues.push(labels[iLabel].value);
                }
            }

            if (emptyLabelValues.length > 0 && emptyLabelValues.length < ctx.originalTicks.length) {
                for (iTick = 0; iTick < ctx.originalTicks.length; iTick++) {
                    if (emptyLabelValues.indexOf(ctx.originalTicks[iTick].value) < 0) {
                        ctx.originalTicks[iTick].major = true;
                        ctx.ticks.push(ctx.originalTicks[iTick]);
                    }
                }
            }
        }
    }

    function getTwoLayersOverlappedNum(rightLayer, leftLayer, labelMargin){
        if(!rightLayer || !leftLayer){
            return 0;
        }    

        if( (rightLayer.left+rightLayer.right)/2 < (leftLayer.left+leftLayer.right)/2 ){
            var temp = rightLayer;
            rightLayer = leftLayer;
            leftLayer = temp;
        }

        labelMargin = labelMargin || 0.0;

        if(rightLayer.width > 0 && rightLayer.text.length > 0 && 
            leftLayer.width > 0 && leftLayer.text.length){
            var delta = rightLayer.left - leftLayer.right - labelMargin;
            if(delta < 0){
                return -delta;
            }
        }
        return 0;
    }

    function getTwoLabelsOverlappedNum(rightLabel, leftLabel, labelMargin){
        if(!rightLabel || !leftLabel){
            return 0;
        }
        var result;
        for(var ii = 0; ii < rightLabel.layers.length; ++ii){
            var layer = rightLabel.layers[ii];
            var prevLayer = leftLabel.layers[ii];

            result = getTwoLayersOverlappedNum(layer, prevLayer, labelMargin);
            if(result > 0){
                break;
            } 
        }
        return result;
    }

    var MIN_CHECK_STEP = 2;
    var MAX_CHECK_STEP = 4;
    // Check whether any labels are overlapped, and return the overlapped amount in pixel
    function getOverlappedPixelNum(labels, labelMargin, returnIndex){
        var result = returnIndex ? [0, -1]:0; 
        if(labels.length < 2){
            return result;
        }

        //a complete overlapping check algo requires O(n^2) runtime.
        //to save performance, we check by n-gram algo
        //in some cases, e.g. label A does not overlap with label B 
        // but overlap with label C
        for(var ii = MIN_CHECK_STEP; ii <= MAX_CHECK_STEP; ii++){
            var checkStep = ii;
            var offset = checkStep - 1;
            var beg = offset;
            for(var jj = beg; jj < labels.length; ++jj){
                var temp = getTwoLabelsOverlappedNum(labels[jj], labels[jj-offset], labelMargin);
                if(temp >0){
                    result = returnIndex ?[temp, jj]:temp;
                    return result;
                }
            }
        }
        return result;
    }

    function tickComparator(t1, t2){
        return t1.value - t2.value;
    }

    function isTimeFloorValue(value, levelResult, context) {
        var timeFloorValue = TimeUtil.truncate(value, levelResult,
            context.utc, context.timeBodyCtx._properties.origin);
        return (timeFloorValue === value);
    }

    function insertFirstLastValues(values, levelResult, context) {
        var resultObj = {};
        resultObj.firstDataIndex = -1;
        resultObj.lastDataIndex = -1;

        var firstAndLastValues;
        if (context.dataBound && context.dataBound.length >= 2) {
            firstAndLastValues = context.dataBound.slice();
        }
        else {
            firstAndLastValues = context.domain.slice();
        }
        firstAndLastValues.sort();
        var iTime;

        var timeFloorResultCache = [];
        if (context.isContinuous) {
            //If the time axis levels is set to DAY but the data set contains data point at the HOUR level, 
            //(i-e not at 00:00:00 or not as Jan 3, 2014), then we should ignore the property forceToShowFirstLastData
            //for continuous mode, we do not add first/last values
            //if these values are not time floor values.
            //for example, 2001-11-01 00:00:00 is time floor value for day level, 
            //and 2001-11-01 01:00:00 is not time floor value for day level.
            for (iTime = 0; iTime < firstAndLastValues.length; iTime++) {
                timeFloorResultCache.push(isTimeFloorValue(firstAndLastValues[iTime],
                    levelResult, context));
            }
        }

        //insert firstAndLastValues into values        
        for (iTime = 0; iTime < firstAndLastValues.length; iTime++) {
            //check if the first and last is existing
            var indexOfValue = values.indexOf(firstAndLastValues[iTime]);
            if (indexOfValue >= 0 && iTime === 0) {
                resultObj.firstDataIndex = indexOfValue;
                resultObj.firstDataAdded = false;
                continue;
            }

            if (indexOfValue >= 0 && iTime === 1) {
                resultObj.lastDataIndex = indexOfValue;
                resultObj.lastDataAdded = false;
                continue;
            }

            var j;
            for (j = 0; j < values.length; j++) {
                if (values[j] > firstAndLastValues[iTime] &&
                    (!context.isContinuous || timeFloorResultCache[iTime])) {
                    values.splice(j, 0, firstAndLastValues[iTime]);
                    if(resultObj.firstDataIndex === -1) {
                        resultObj.firstDataIndex = j;
                        resultObj.firstDataAdded = true;
                    } else {
                        resultObj.lastDataIndex = j;
                        resultObj.lastDataAdded = true;
                    }
                    break;
                }
            }

            if (resultObj.firstDataIndex < 0 && iTime === 0 &&
                (!context.isContinuous || timeFloorResultCache[iTime])) {
                values.push(firstAndLastValues[iTime]);
                resultObj.firstDataIndex = values.length - 1;
                resultObj.firstDataAdded = true;
            }

            if (resultObj.lastDataIndex < 0 && iTime === 1 &&
                (!context.isContinuous || timeFloorResultCache[iTime])) {
                values.push(firstAndLastValues[iTime]);
                resultObj.lastDataIndex = values.length - 1;
                resultObj.lastDataAdded = true;
            }
        }

        return resultObj;
    }

    var removeNearestTickValueWithoutLabel = function(labelValues, basisValueIndex, values) {
        //if new added first or last label, we have to remove the nearest tick of it if the tick has no label.
        //it is the requirement of PO.
        var leftValue = values[basisValueIndex - 1];
        var rightValue = values[basisValueIndex + 1];

        //to find the nearestValue
        var nearestValue;
        var nearestValueIndex;
        if(TypeUtils.isExist(leftValue)) {
            nearestValue = leftValue;
            nearestValueIndex = basisValueIndex - 1;
            if (TypeUtils.isExist(rightValue)) {
                //to choose the nearest index, we compare the two distances.
                if((values[basisValueIndex] - leftValue) > (rightValue - values[basisValueIndex])) {
                    nearestValue = rightValue;
                    nearestValueIndex = basisValueIndex + 1;
                }
            }
        } else if(TypeUtils.isExist(rightValue)) {
            nearestValue = rightValue;
            nearestValueIndex = basisValueIndex + 1;
        }

        if(nearestValue) {
            if(labelValues.indexOf(nearestValue) < 0) {
                //cannot find label. Remove the value
                values.splice(nearestValueIndex, 1);
            }
        }

        return nearestValueIndex;
    };

    // Generate tick outputs
    function getTicks(levelResult, context, addFirstLastData, labelsWithFirstAndLastData) {
        var ret = [];
        if(levelResult.tickLevel) {
            var labels = levelResult.labels;
            if (addFirstLastData && labelsWithFirstAndLastData) {
                labels = labelsWithFirstAndLastData;
            }
            var values = levelResult.tickLevel.values(context.utc, context.start, context.end, false, 
                    context.limit, undefined, context.categoryLook, context.weekConfig);
            
            if (addFirstLastData) {
                var firstLastObj = insertFirstLastValues(values, levelResult.tickLevel.name, context);
                //in category look mode, we do not need any tick changes.
                //here we have a special handle:
                //if new added first or last label, we have to remove the nearest tick of it if the tick has no label.
                //it is the requirement of PO.
                if ((firstLastObj.firstDataAdded || firstLastObj.lastDataAdded) && values.length > 1) {
                    var labelValues = [];
                    var iLabel;
                    for (iLabel = 0; iLabel < labels.length; iLabel++) {
                        labelValues.push(labels[iLabel].value);
                    }

                    var nearestValueIndex;
                    if (firstLastObj.lastDataAdded && values.length > 1) {
                        nearestValueIndex = removeNearestTickValueWithoutLabel(labelValues,
                            firstLastObj.lastDataIndex, values);
                    }

                    if (firstLastObj.firstDataAdded && values.length > 1) {
                        if (nearestValueIndex <= firstLastObj.firstDataIndex) {
                            firstLastObj.firstDataIndex--;
                        }
                        removeNearestTickValueWithoutLabel(labelValues, firstLastObj.firstDataIndex, values);
                    }

                    if (!levelResult.hasMajor) {
                        //all ticks should have label
                        var iTickValue;
                        for (iTickValue = (values.length - 1); iTickValue >= 0; iTickValue--) {
                            if (labelValues.indexOf(values[iTickValue]) < 0) {
                                //a tick value has no label.
                                values.splice(iTickValue, 1);
                            }
                        }
                    }
                }
            }

            for(var i = 0, j = 0; i < values.length; ++i) {
                var v = values[i];
                var label = j < labels.length && labels[j];
                if (addFirstLastData && label.value < v) {
                    j++;
                    label = j < labels.length && labels[j];
                }
                var isMajor = label && levelResult.hasMajor && label.value === v;
                ret.push({
                    value: v,
                    position: isMajor ? label.center : context.scale(v),
                    major: isMajor
                });
                if(isMajor){
                    ++j;
                }
            }
        }

        //make sure ticks is sorted 
        ret.sort(tickComparator);

        return ret;
    }

    //get ticks indepent from labels
    function getIndependentTicks(tickLevel, context){
        var ret = [];
        if(tickLevel){
            var values = tickLevel.values(context.utc, context.start, context.end, false, 
                    context.limit, undefined, context.categoryLook);
            for(var i = 0, j = 0; i < values.length; ++i){
                var v = values[i];
                ret.push({
                    value: v,
                    position: context.scale(v),
                    major: false
                });
            }
        }

        //make sure ticks is sorted 
        ret.sort(tickComparator);
        return ret;
    }


    return {
        combinationDict: combinationDict,
        isPositionVisible:isPositionVisible,
        isValueVisible:isValueVisible,
        isLabelVisible:isLabelVisible,

        getTicks:getTicks,
        getIndependentTicks:getIndependentTicks,

        getDensity:getDensity,

        preventAnyOverlapping:preventAnyOverlapping,

        getLabelsAndSetLayout: getLabelsAndSetLayout,
        getLabelsWithFirstLastDataAndSetLayout: getLabelsWithFirstLastDataAndSetLayout,
        resetAndLayoutLabelsWithFirstLastData: resetAndLayoutLabelsWithFirstLastData,

        getLabels: getLabels,
        layoutLabels: layoutLabels,
        layoutFirstAndLastLabel: layoutFirstAndLastLabel,
        getOverlappedPixelNum:getOverlappedPixelNum,
        getTwoLayersOverlappedNum: getTwoLayersOverlappedNum,
        getTwoLabelsOverlappedNum: getTwoLabelsOverlappedNum,

        getTimeValueFormat: getTimeValueFormat,
        getValuesFunc: getValuesFunc,
        shouldUseShortFormat: shouldUseShortFormat,
        initLevelStoreValues: initLevelStoreValues,
        notCheck: notCheck,
        sameMonth: sameMonth,
        sameYear: sameYear,
        getPrevInfo: getPrevInfo,
        getCurrentInfo: getCurrentInfo,

        TRIAL_MODE: TRIAL_MODE,
        PIVOT_MODE: PIVOT_MODE,
        FORMAT_CONFIG_FIELD: FORMAT_CONFIG_FIELD
    };
});


define('sap/viz/chart/components/axis/sub/TimeAxisBodyTransformer',[
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ObjectUtils",
    'sap/viz/framework/common/util/ArrayUtils',
    "sap/viz/chart/components/axis/sub/TimeAxisCommon",
], function(
    TimeUtil,
    TextUtils,
    NumberUtils,
    TypeUtils,
    ObjectUtils,
    ArrayUtils,
    AxisCommon
){
    var floor = Math.floor;
    var ceil = Math.ceil;
    var max = Math.max;
    var min = Math.min;

    var getTicks = AxisCommon.getTicks; 
    var getLabels = AxisCommon.getLabels;
   
    var levelComparator = TimeUtil.levelComparator;
    var getLabelsAndSetLayout = AxisCommon.getLabelsAndSetLayout;
    var getLabelsWithFirstLastDataAndSetLayout = AxisCommon.getLabelsWithFirstLastDataAndSetLayout;
    var resetAndLayoutLabelsWithFirstLastData = AxisCommon.resetAndLayoutLabelsWithFirstLastData;

    var layoutFirstAndLastLabel = AxisCommon.layoutFirstAndLastLabel;
    var getOverlappedPixelNum =  AxisCommon.getOverlappedPixelNum;

    function initCatLevelStore(timeBodyCtx){
        var result = timeBodyCtx.levelStore.filter(function(ele){
            return !ele.continuousOnly &&
                    (levelComparator.bind(timeBodyCtx)(ele.name, timeBodyCtx.minCategoryLevel) >= 0);
        });
        result.sort(CatLevelItemComparator.bind(timeBodyCtx));
        return result;
    }

    //a set of reason enum why cannot convert to categogory look directly
    var REASON = {ILLEGAL_LEVEL: "ILLEGAL_LEVEL",
                  NO_TICKS: "NO_TICKS",
                  NO_LABELS: "NO_LABELS",
                  WRONG_TICK_STEP: "WRONG_TICK_STEP",
                  LABEL_TOO_BIG: "LABEL_TOO_BIG",
                  LABEL_TOO_SMALL: "LABEL_TOO_SMALL",
                  LABEL_OVERLAPPED: "LABEL_OVERLAPPED",
                  GOOD: "GOOD"};


    function shouldFirstLastMode(levelItem, context){
        if(!levelItem || !context.forceToShowFirstLastData){
            return false;
        }
        var cmp = levelComparator.bind(context.timeBodyCtx);
        context.levels.sort(cmp);
        var smallestLV = context.levels[0];
        var name = levelItem.name;
        return cmp(name, smallestLV ) === 0;
    }
    
    function firstLastDataWrapper(ticksAndLabels, context) {
        var tl = ticksAndLabels;
        var offset = tl.labels.offset;
        //for category look, we add first and last data in categoryWrapper.
        //and we do not add first/last for category look after 2017-03
        var lv = tl.labelLevel;
        var isForceCategoryForMinLevel = false;
        if (lv && lv.name) {
            isForceCategoryForMinLevel =
                context.timeBodyCtx.isForceCategoryForMinLevel(lv.name, lv.step, context.levels);
        }
        if (!isForceCategoryForMinLevel &&
            tl.displayMode === "CONTINUOUS" &&
            shouldFirstLastMode(tl.labelLevel, context)) {
            //add first and last label
            context.isContinuous = true;
            var labelsWithFirstLastData = getLabelsWithFirstLastDataAndSetLayout(tl.labelLevel, context);
            tl.labels = labelsWithFirstLastData;

            var isDeleteLabel = true;
            //here we must use while loop, because if we delete some labels, many labels are changed, 
            //we cannot make sure new labels have no overlapping if we do not check them again. 
            //We just need 2 or 3 times to reset all labels usually (and the label reset algorithm is linear). 
            //So the performance should be acceptable.
            var maxTries = tl.labels.length;
            var i;
            for(i = 0; ((isDeleteLabel && tl.labels.length > 1) && (i < maxTries)); i++) {
                isDeleteLabel = resetAndLayoutLabelsWithFirstLastData(tl.labelLevel, tl, context);
            }

            var ticks = getTicks(tl.levelResult, context, true, tl.labels);
            tl.ticks = ticks;

            //reset offset
            tl.labels.offset = offset;
            tl.ticks.offset = offset;
            //delete continuous flag from context, because the context is 
            //just for labels and ticks in this function
            delete context.isContinuous;
        }
    }

    function categoryWrapper(ticksAndLabels, context, adjustEnable){
        var tl = ticksAndLabels;
        if(tl.ticks.length === 0 || tl.labels.length === 0|| !tl.labelLevel){
            return;
        }
        tl.displayMode = "CONTINUOUS";
        if(mustCategoryLook(tl.labelLevel, context)){
            if(adjustEnable){
                context.categoryLook = true;
                var reason = ableToCategoryLook(tl, context);
                //only use the level allowed for category

                var levelArgs = getLevelArgsForCategory(context);
                var legal = findLevelItemById(tl.labelLevel.id, levelArgs);  

                if(reason === REASON.GOOD && !legal) { 
                    reason = REASON.ILLEGAL_LEVEL;
                }

                if( reason !== REASON.GOOD){
                    var success = adjustLevelForCatogory(tl, context, reason);
                    if(!success) {
                        var len = tl.labels.length;
                        var NARROW_SIZE = 200;
                        if(context.width > NARROW_SIZE){
                            context.categoryLook = false;
                            return;
                        }else if( reason === REASON.LABEL_OVERLAPPED ||
                            reason === REASON.LABEL_TOO_BIG ||
                            reason === REASON.ILLEGAL_LEVEL ){
                            //keep the first and the last one
                            if(len > 2){
                                var firstLabel = tl.labels[0];
                                var lastLabel = tl.labels[len-1];
                                tl.labels.splice(0, len);
                                tl.labels.push(firstLabel);
                                tl.labels.push(lastLabel);
                            }
                            layoutLabelsForCategory(tl, context); 
                            return; 
                        }else if(reason === REASON.WRONG_TICK_STEP){
                            //only keep one
                            tl.labels.splice(1, len);
                            layoutLabelsForCategory(tl, context); 
                            return; 
                        }else{
                            // NO ABLE TO category look. GIVE UP
                            context.categoryLook = false;
                            return;
                        }
                    }
                }
                else {
                    //if reason is GOOD, we have to make sure we have the first value.
                    var currentLv = ticksAndLabels.labelLevel;
                    levelArgs = getLevelArgsForCategory(context, currentLv);
                    resetTicksAndLables(currentLv, context, levelArgs, ticksAndLabels);
                }
            }

            layoutLabelsForCategory(tl, context);
            if (!adjustEnable && shouldFirstLastMode(tl.labelLevel, context)) {
                //some labels are deleted or empty.
                resetLabelForCategoryLook(tl.labelLevel, tl, context);
            }
        }
    }

    //"must" is a strong word. it means no matter what, must use category look
    function mustCategoryLook(levelItem, context){
        if(!levelItem){
            return false;
        }
        var cmp = levelComparator.bind(context.timeBodyCtx);
        context.levels.sort(cmp);
        var smallestLV = context.levels[0];
        var name = levelItem.name;

        if( cmp(name, context.timeBodyCtx.minCategoryLevel) >= 0 && cmp(name, smallestLV ) > 0 ){
            if (!(name === context.timeBodyCtx.maxCategoryLevel.name &&
                levelItem.step > context.timeBodyCtx.maxCategoryLevel.step)) {
                return true;
            }
        }
        return false;
    }

    
    //three manual-adjusted threshold to decide if the label is too big/small in category
    var CT_LABEL_MAX_OFFSET = 400; 
    var CT_LABEL_MAX_MULTIPLIER = 4;
    var CT_LABEL_MIN_MULTIPLIER = 0.1;

    //return true if can display the category look properly
    //if not, return the reason
    function ableToCategoryLook(ticksAndLabels, context){
        var ticks = ticksAndLabels.ticks;
        var labels = ticksAndLabels.labels;
        var labelLevel = ticksAndLabels.labelLevel;
        var tickLevel = ticksAndLabels.tickLevel;

        if(ticks.length < 2){
            return REASON.NO_TICKS;
        }else if(labels.length === 0 ){
            return REASON.NO_LABELS;
        }else if(labelLevel && tickLevel && tickLevel.step > 1){
            return REASON.WRONG_TICK_STEP;
        }

        var delta = Math.abs(ticks[1].position - ticks[0].position);
        var ii, layer;
        var labelMaxSize = delta * CT_LABEL_MAX_MULTIPLIER;  
        var labelMinSize = delta * CT_LABEL_MIN_MULTIPLIER;  
        
        for(ii = 0; ii< labels.length; ii++){
            layer = labels[ii].layers[0];

            if(layer.width > labelMaxSize ){
                return REASON.LABEL_TOO_BIG;
            }else if(layer.width  < labelMinSize && layer.width + CT_LABEL_MAX_OFFSET < delta ){
                return REASON.LABEL_TOO_SMALL;
            }
        }

        var labelsToCheck = ticksAndLabels.labels;
        if(shouldFirstLastMode(labelLevel, context)) {
            var iLabel;
            var originalLabels = [];
            for (iLabel = 0; iLabel < ticksAndLabels.labels.length; iLabel++) {
                if (!(ticksAndLabels.labels[iLabel].isFirstData || ticksAndLabels.labels[iLabel].isLastData)) {
                    originalLabels.push(ticksAndLabels.labels[iLabel]);
                }
            }
            labelsToCheck = originalLabels;
        }

        //category use smaller label margin than usual
        if(getOverlappedPixelNum(labelsToCheck, context.labelMargin)  > 0 ){
            return REASON.LABEL_OVERLAPPED;
        }

        return REASON.GOOD;
    }

    //get Level Arguments For Category
    function getLevelArgsForCategory(context) {
        //category look uses a slight different levels 
        //than continuous one. Init it from level store.
        var CatLevelStore = initCatLevelStore(context.timeBodyCtx);

        var result = [];
        // If range is empty, return the default
        if(context.start === context.end){
            return CatLevelStore.slice();
        }
        var cmp = levelComparator.bind(context.timeBodyCtx);
        context.levels.sort(cmp);
        var levels = context.levels;
        var unit = context.intervalUnit;
        var ii, jj, lv;
        var smallestLV = context.levels[0];
        
        for (ii = 0; ii < CatLevelStore.length; ii++) {
            lv = CatLevelStore[ii];
            if(lv.condition && !lv.condition(context)){
                continue;
            }
            if(unit){
                if(unit === lv.name){
                    result.push(lv);
                }
            }else if(levels.indexOf(lv.name) >= 0 && mustCategoryLook(lv, context)){
                result.push(lv);
            }
        }

        if(!unit){
            if(result.length >= 2){    
                //detect gap and fix it. "year, day" and "quarter, day" will not be helpful. 
                for(ii=1; ii< result.length; ii++){
                    if(result[ii-1].name === "day" && cmp( result[ii].name, 'quarter') >= 0  ){
                        result = result.concat( findLevelsItemsByName("month", CatLevelStore) );
                    }
                }
            }
            
            if(result.length <= 2){
               //handle if only one level or zero item e.g
                TimeUtil.DEFAULT_LEVELS.forEach(function(lv){
                    var found = false;
                    for(ii = 0; ii < result.length; ii++){
                        if(result[ii].name === lv){
                            found = true;
                            break;
                        }
                    }

                    if(!found){
                        result = result.concat(findLevelsItemsByName(lv, CatLevelStore)); 
                    }
                });
            }    
        }

        result.sort(CatLevelItemComparator.bind(context.timeBodyCtx));
        return result; 
    }

    //a manual-adjusted number that performs best for the later algorithm
    var WANTED_LEVEL_NUM = 5;
    //find levels bigger or smaller than certain lv
    function findDifLevel(lv, levelArgs, bigger, timeBodyCtx){
        var name = lv.name;
        var cmpr = levelComparator.bind(timeBodyCtx);
        var index = 0;

        for (var ii = 0; ii < levelArgs.length; ii++) {
            if(cmpr(name, levelArgs[ii].name) === 0 ){
                index = ii;
                break;
            }else if( cmpr(name, levelArgs[ii].name) > 0 &&
                       levelArgs[ii+1] &&  cmpr(name, levelArgs[ii+1].name) <= 0 ){
                index = ii;
                break;
            }
        }

        var result;
        if(bigger){
            result = levelArgs.slice(index, index+WANTED_LEVEL_NUM);
        }else{
            result = levelArgs.slice(max(index-WANTED_LEVEL_NUM,0), index);
        }
        result.sort(CatLevelItemComparator.bind(timeBodyCtx));
        return result;
    }

    function findBigLevels(lv, levelArgs, timeBodyCtx){
        return findDifLevel(lv, levelArgs, true, timeBodyCtx);
    }

    function findSmallLevels(lv, levelArgs, timeBodyCtx){
        return findDifLevel(lv, levelArgs, false, timeBodyCtx);
    }

    function findLevelItemById(id, levelArgs){
        for(var jj = 0; jj < levelArgs.length ;jj++){
            if(levelArgs[jj].id === id){
                return levelArgs[jj];
            }
        }
        return null;
    }

    function findLevelsItemsByName(lvName, levelsItems){
        return levelsItems.filter(function(ele){
            return ele.name === lvName;
        });
    }

    var resetLabelForCategoryLook = function (nextLV, tl, context) {
        var isDeleteLabel = true;
        var maxTries = tl.labels.length;
        var i;
        var forceResetLabels = false;
        for (i = 0; ((isDeleteLabel && tl.labels.length > 1) && (i < maxTries)) ; i++) {
            //here we must use while loop, because if we delete some labels, many labels arae changed, 
            //we cannot make sure new labels have no overlapping if we do not check them again. 
            isDeleteLabel = resetAndLayoutLabelsWithFirstLastData(nextLV, tl, context, forceResetLabels);
            forceResetLabels = false;

            //we should layout labels for category mode, and then check empty labels.
            layoutLabelsForCategory(tl, context);
            if (!isDeleteLabel) {
                //check if there is empty label in Category labels
                var iLabel;
                for (iLabel = tl.labels.length - 1; iLabel >= 0; iLabel--) {
                    var isEmptyLabel = false;
                    var iLayer;
                    var emptyLayerNum = 0;
                    for (iLayer = 0; iLayer < tl.labels[iLabel].layers.length; iLayer++) {
                        if (tl.labels[iLabel].layers[iLayer].isEmpty) {
                            emptyLayerNum++;
                            break;
                        }
                    }
                    if (emptyLayerNum > 0) {
                        tl.labels.splice(iLabel, 1);
                        //if empty label is deleted, we have to force reset labels. It is
                        //because deleted labels may be the first label of the year.
                        if (tl.labels.length > 1) {
                            forceResetLabels = true;
                        }
                        isDeleteLabel = true;
                        break;
                    }
                }
            }
        }
    };
    
    function resetTicksAndLables(nextLV, context, levelArgs, ticksAndLabels, disableForceFirstLast) {
        var resetRes = false;
        var tempLabels;
        if (shouldFirstLastMode(nextLV, context)) {
            tempLabels = getLabelsWithFirstLastDataAndSetLayout(nextLV, context);
        } else {
            tempLabels = getLabelsAndSetLayout(nextLV, context);
        }
        var tl = { level:nextLV.name, 
                   labelLevel:nextLV, 
                   labels : tempLabels };

        //get tick level from label base           
        var tickLevelItem = null;
        var base = nextLV.base;
        if(base) {
            var id = base[0];
            var temp = findLevelItemById(id, levelArgs);
            if(temp && !(tl.labelLevel.step > 1 && temp.step > 1)) {
                tickLevelItem = temp;
            }
        }

        tickLevelItem = tickLevelItem || tl.labelLevel;
        tl.tickLevel = tickLevelItem;
        tl.ticks = AxisCommon.getIndependentTicks(tickLevelItem, context);

        layoutLabelsForCategory(tl, context);
        
        if (!disableForceFirstLast && shouldFirstLastMode(tl.labelLevel, context)) {
            resetLabelForCategoryLook(nextLV, tl, context);
        }

        var tryResult = ableToCategoryLook(tl, context); 

        if(tryResult === REASON.GOOD ) {
            //replace with new one
            ticksAndLabels.level = tl.level;
            ticksAndLabels.labelLevel = tl.labelLevel;
            ticksAndLabels.tickLevel = tl.tickLevel;
            
            //we use extend here to keep original labels and ticks offset
            ObjectUtils.extend(ticksAndLabels.labels, tl.labels);
            ObjectUtils.extend(ticksAndLabels.ticks, tl.ticks);
            //The number of tl labels may be less than ticksAndLabels.
            //we should remove extra original labels and ticks.
            ticksAndLabels.labels.splice(tl.labels.length);
            ticksAndLabels.ticks.splice(tl.ticks.length);
            resetRes = true;
        }
        return resetRes;
    }

    //adjust and change the level in order to display category look well
    //change the level according to the given reason 
    function adjustLevelForCatogory(ticksAndLabels, context, reason) {
        var currentLv = ticksAndLabels.labelLevel;
        var levelArgs = getLevelArgsForCategory(context, currentLv);
        var nextLVs;
        var ii;
    
        //to do
        if(!reason) {
            return false;
        }else if(reason === REASON.GOOD){
            //already good
            return true; 
        } else if(reason === REASON.NO_TICKS ||
                  reason === REASON.NO_LABELS ||
                  reason === REASON.LABEL_TOO_SMALL ) {
            nextLVs = findSmallLevels(currentLv, levelArgs, context.timeBodyCtx);  
        } else if(reason === REASON.LABEL_TOO_BIG ||
                  reason === REASON.LABEL_OVERLAPPED ) {
            nextLVs = findBigLevels(currentLv, levelArgs, context.timeBodyCtx); 
        }else if(reason === REASON.ILLEGAL_LEVEL){    
            nextLVs = findBigLevels(currentLv, levelArgs, context.timeBodyCtx);
            nextLVs = nextLVs.concat(findSmallLevels(currentLv, levelArgs, context.timeBodyCtx)) ;
        } else if(reason === REASON.WRONG_TICK_STEP) {
            //try the equal level and biger
            nextLVs = findBigLevels(currentLv, levelArgs, context.timeBodyCtx); 
            nextLVs.splice(0, 0, currentLv);
        }else {
            //UNKNOWN REASON
            return false;
        }

        if(!nextLVs || !nextLVs.length) {
            //NOT NEXT LEVELS
            return false;
        }

        //try potential next levels
        var returnRes = false;
        for (ii = 0; ii < nextLVs.length; ii++) {
            //disableForceFirstLast is true, becasue it is just try levels.
            if(resetTicksAndLables(nextLVs[ii], context, levelArgs, ticksAndLabels, true)) {
                returnRes = true;
                break;
            }
        }
        return returnRes;
    } 


    //find the two nearest ticks that surround value
    //and return position and index
    function getNearbyTicksPosition(value, ticks){
        if (!TypeUtils.isExist(value) ||
            !ticks || ticks.length < 2) {
            return -1;
        }

        var getter = function(tick){return tick.value;};
        var index =  ArrayUtils.bisearch(ticks, value, getter);
        index =  Math.min(index, ticks.length - 1);

        if(ticks[index].value > value){
            index--;
        }
        
        var result = [];
        if (index >= 0) {
            var width;
            if (index === (ticks.length - 1)) {
                //the last label. We have to use the second last interval.
                width = ticks[index].position - ticks[index - 1].position;
            }
            else {
                width = ticks[index + 1].position - ticks[index].position;
            }
            var temp = ticks[index].position;
            result = [temp, temp+width, index, index+1];
        }
        return result;
    }

    function layoutLabelsForCategory(ticksAndLabels,  context){
        var labels = ticksAndLabels.labels;
        var ticks = ticksAndLabels.ticks;
        var ii, jj, label, layer;
        var totalWidth = context.width;

        var forceToShowFirstLastData = shouldFirstLastMode(ticksAndLabels.labelLevel, context);

        if(ticks.length < 2){ 
            return false; 
        }

        var firstDataIndex = -1;
        var lastDataIndex = -1;
        for (ii = 0 ; ii < labels.length; ii++) {
            if (forceToShowFirstLastData) {
                if (labels[ii].isFirstData) {
                    firstDataIndex = ii;
                } else if (labels[ii].isLastData) {
                    lastDataIndex = ii;
                }
            }
        }
            
        //a index indicate where labels should be not visible in category look    
        var rightMostIndex = Infinity;
        var leftMostIndex = -1;

        //move the label to the middle of ticks    
        for(ii = 0; ii < labels.length; ii++){
            label = labels[ii];
            var indexes = getNearbyTicksPosition(label.value, ticks);
            //if the range is invisible, the label should be removed. 
            if(indexes.length === 0 ||
                (indexes[0] < 0 && indexes[1] < 0)) {
                //we have to remove the label
                leftMostIndex = ii + 1;
                continue; 
            }
            for(jj = 0; jj < label.layers.length; jj++){
                layer = label.layers[jj];
                var t1 = indexes[0]; //left tick
                var t2 = indexes[1]; //right tick
                var center = (t2 - t1)/2 + t1;
                layer.left = center - layer.width/2;

                // The left most label should be completely visible
                if(layer.left < 0) {
                    layer.left = 0;
                    leftMostIndex = ii;
                }

                layer.right = layer.left + layer.width;
                layer.center = (layer.right - layer.left)/2 + layer.left;

                //the right most label. remove it so will not overlap with prev one
                if(layer.right > totalWidth && totalWidth - layer.width >= 0) {
                    //For category look, if the right label is cut, we have to move it to the left.
                    if((t1 + layer.width) < totalWidth ||
                        (forceToShowFirstLastData && labels[ii].isLastData)
                        ) {
                        var labelOffset = layer.right - totalWidth;
                        layer.left -= labelOffset;
                        layer.center -= labelOffset;
                        layer.right -= labelOffset;
                    }
                    else {
                        rightMostIndex = Math.min(ii, rightMostIndex);
                        break;
                    }
                }  
            }
        }

        if (forceToShowFirstLastData) {
            if (leftMostIndex > firstDataIndex && firstDataIndex !== -1) {
                leftMostIndex = firstDataIndex;
            }
            //it should be from (lastDataIndex + 1).
            if (rightMostIndex < (lastDataIndex + 1) && lastDataIndex !== -1) {
                rightMostIndex = (lastDataIndex + 1);
            }
        }

        if(rightMostIndex !== Infinity){
            //delete labels from rightMostIndex
            labels.splice(rightMostIndex, labels.length);
        }
        
        if(leftMostIndex > 0) {
            labels.splice(0, leftMostIndex);
        }
        
        //no major tick in category look
        for(ii = 0; ii< ticks.length; ii++){
            ticks[ii].major = false;
        }

        layoutFirstAndLastLabel(labels, context);
        ticksAndLabels.displayMode = "CATEGORY"; 
        return true;
    }

    function CatLevelItemComparator(a, b){
        if(a.name === b.name){
            return a.step - b.step;
        }else{
            return levelComparator.bind(this)(a.name, b.name);
        }
    }

// time column related-------------------------------------
    function timeColumnWrapper(ticksAndLabels, context){
        var tl = ticksAndLabels;
        if (!context.isColumnLike) {
            return;
        }
        var ticks = ticksAndLabels.ticks;
        if (ticks.length === 0 || tl.labels.length === 0 || !tl.labelLevel) {
            return;
        }
        //data label use smallest to display the column
        var cmp = TimeUtil.levelComparator.bind(context.timeBodyCtx);
        context.levels.sort(cmp);
        var smallestLV = context.levels[0];
        var lv = tl.labelLevel;

        //we have to switch axis to category mode if both
        //1. Minimal level and minimal step (1)
        //2. Multiply series column-like
        var isForceCategoryForMinLevel =
            context.timeBodyCtx.isForceCategoryForMinLevel(lv.name, lv.step, context.levels);

        if (cmp(lv.name, smallestLV ) <= 0 && !isForceCategoryForMinLevel) {
            //for step > 1 && continous look, we remove all minor ticks.
            if (lv.step > 1 && tl.displayMode === 'CONTINUOUS') {
                var iTick;
                if (tl.labelLevel.name === tl.tickLevel.name &&
                    tl.labelLevel.step === tl.tickLevel.step) {
                    //if labels and ticks have the same label and step,
                    //we should change all ticks to major ticks.
                    for (iTick = (tl.ticks.length - 1) ; iTick >= 0; iTick--) {
                        tl.ticks[iTick].major = true;
                    }
                }
                else {
                    for (iTick = (tl.ticks.length - 1) ; iTick >= 0; iTick--) {
                        if (!tl.ticks[iTick].major) {
                            tl.ticks.splice(iTick, 1);
                        }
                    }
                }
            }
            else if(!context.timeBodyCtx._isKeepMinimalLevelContinuousTicks) {
                //to save original ticks for hidden labels.
                tl.originalTicks = ticks;
                tl.ticks = [];
            }
        } else if (tl.displayMode === "CATEGORY" ||
            isForceCategoryForMinLevel) {

            //add one extra tick on the leftmost
            var lastOne = ticks[ticks.length-1];
            var originalLastValue = lastOne.value;
            var v = TimeUtil.ceil(lastOne.value, lv.name, context.utc,
                context.timeBodyCtx._properties.origin);

            var isLastTickEnd = false;
            //assume exceed on the left 
            if(!AxisCommon.isValueVisible(v, context)){
                v = context.end;
                isLastTickEnd = true;
            }
            if(!AxisCommon.isValueVisible(v, context)){
                //this is not accurate in month, year level
                //use as last resolution
                v = lastOne.value + TimeUtil.getPeriod(lv.name);
                isLastTickEnd = true;
            }

            if (v !== originalLastValue) {
                ticks.push({
                    value: v,
                    position: context.scale(v),
                    major: false
                });
            }

            if(smallestLV !== "week") {
                //move tick to the middle of data labels
                var period = context.timeBodyCtx.levelDict[smallestLV].period;
                var t1 = context.limit[0];
                t1 = TimeUtil.truncate(t1, smallestLV, context.utc, context.timeBodyCtx._properties.origin);

                var t2 = t1 + period;
                var p1 = context.scale(t1);
                var p2 = context.scale(t2);
                var shift = (p2 - p1)/2;

                tl.ticks.forEach(function (tick, index) {
                    //we do not move the last tick because it should be the end.
                    if (index !== (ticks.length - 1) || !isLastTickEnd ||
                        !AxisCommon.isValueVisible(v, context)) {
                        //visible last end tick should not be moved
                        tick.position -= shift;
                        tick.value = context.scale.invert(tick.position);
                    }
                });

                //make label in the middle of ticks
                layoutLabelsForCategory(tl,  context);
            } else if (lv.name === "year") {
                //week is triky when the tick level is month\quarter\halftear
                //since one week can across more than one months\quarters\halftears
                //so only move it when the level is year to make everyone's life easier
                tl.ticks.forEach(function (tick, index) {
                    //we do not move the last tick because it should be the end.
                    if (index !== (ticks.length - 1) || !isLastTickEnd ||
                        !AxisCommon.isValueVisible(v, context)) {
                        //visible last end tick should not be moved
                        var thisYear = TimeUtil.getFullYear(new Date(tick.value), context.utc);
                        var lastYear = thisYear - 1;

                        //get the monday of last year and first mondy of this year
                        var weekNum = TimeUtil.getWeekNumInYear(lastYear);
                        var t1 = TimeUtil.getDateByWeek(lastYear, weekNum, context.utc, context.weekConfig);
                        var t2 = TimeUtil.getDateByWeek(thisYear,1, context.utc, context.weekConfig);


                        t1 = t1.getTime();
                        t2 = t2.getTime();

                        //get the middle, which is the where tick will locates
                        tick.value = (t2 - t1) / 2 + t1;
                        tick.position = context.scale(tick.value);
                    }
                }); 
 
                //make label in the middle of ticks
                layoutLabelsForCategory(tl,  context);
            }
        }
    }

    return {categoryWrapper: categoryWrapper,
            shouldFirstLastMode: shouldFirstLastMode,
            firstLastDataWrapper: firstLastDataWrapper,
            mustCategoryLook:mustCategoryLook,
            timeColumnWrapper: timeColumnWrapper};
});


define('sap/viz/chart/components/axis/sub/TimeAxisBodyHelper',[
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ObjectUtils",
    'sap/viz/framework/common/util/ArrayUtils',
    "sap/viz/chart/components/axis/sub/TimeAxisCommon",
    "sap/viz/chart/components/axis/sub/TimeAxisBodyTransformer",
], function(
    TimeUtil,
    TextUtils,
    NumberUtils,
    TypeUtils,
    ObjectUtils,
    ArrayUtils,
    AxisCommon,
    BodyTransformer
){
    var floor = Math.floor;
    var ceil = Math.ceil;
    var max = Math.max;
    var min = Math.min;

    // Const ----------------------------------------------------------------
    var MIN_TICK_DISTANCE = 8;
    var FIXED_SPACING = 80;
    var LIMIT_MARGIN = 100;
    var LABEL_MARGIN = 5;
    var MAX_LAYER_COUNT = 3;
    var LEVEL_LABEL_SEPARATOR = ', ';
    var DEFAULt_INTERVAL_NUMBER = 1;
    var MIN_LEVEL = 'minlevel';

    var KEEP_MISSING_LEVELS_MODE = 1 ;
    var ADVANCED_MODE = 1 << 2;
   
    // The more labels we try, the higher chance we find overlapped case, but the lower performance
    var SINGLE_TRIAL_COUNT = 4;
    var LEVEL_TRIAL_COUNT = 10;
    var TRIAL_SHIFT_TABLE = {
        'second': 5,
        'minute': 20,
        'hour': 0.5,
        'day': 2,
        'week': 0.5,
        'month': 0.5,
        'quarter': 1,
        'halfyear': 3,
        'year': 1,
        'fiscal_period': 1,
        'fiscal_year': 1
    };

    var getTicks = AxisCommon.getTicks; 

    var levelComparator = TimeUtil.levelComparator;
    var getLabelsAndSetLayout = AxisCommon.getLabelsAndSetLayout;
    var getLabelsWithFirstLastDataAndSetLayout = AxisCommon.getLabelsWithFirstLastDataAndSetLayout;
    var getLabels = AxisCommon.getLabels;
    var layoutLabels = AxisCommon.layoutLabels;
    var getOverlappedPixelNum =  AxisCommon.getOverlappedPixelNum;
    var mustCategoryLook =  BodyTransformer.mustCategoryLook;

    var TRIAL_MODE = AxisCommon.TRIAL_MODE;
    var PIVOT_MODE = AxisCommon.PIVOT_MODE;

    var getDensity = AxisCommon.getDensity;
    var combinationDict = AxisCommon.combinationDict;

    // Public ---------------------------------------------------

    /**
     * Get time axis ticks and labels
     */
    function getTicksAndLabels(args) {
        var domain = args.timeBodyCtx.normalizeDomain(args.domain);
        var dataBound = args.timeBodyCtx.normalizeDomain(args.dataBound);
        var result = null;
        if(domain){
            var levels = args.levels;
            if (!levels || !levels.length){
                levels = TimeUtil.DEFAULT_LEVELS;
            }
            args.timeBodyCtx.fixLevelGap(levels);
            var context = {
                domain: domain,
                dataBound: dataBound,
                width: max(0, args.width),
                levels: levels,
                start: domain[0],
                end: domain[1],
                limitInput: args.limit,
                style: args.labelStyle,
                config: normalizeConfigs(args.config, args.timeBodyCtx),
                combinationConfig: normalizeConfigs(args.combinationConfig, args.timeBodyCtx),
                utc: args.utc,
                isColumnLike: args.isColumnLike,
                isZoomIn: args.zoomType === "zoomIn",
                prevLv: args.prevLv,
                findLevelMemory: args.findLevelMemory,

                // constants
                minTickDistance: normalizeNumber(args.minTickDistance, MIN_TICK_DISTANCE),
                fixedSpacing: normalizeNumber(args.fixedSpacing, FIXED_SPACING),
                limitMargin: normalizeNumber(args.limitMargin, LIMIT_MARGIN),
                labelMargin: normalizeNumber(args.labelMargin, LABEL_MARGIN),
                maxLayerCount: normalizeNumber(args.maxLayerCount, MAX_LAYER_COUNT),
                levelLabelSeparator: normalizeNumber(args.levelLabelSeparator, LEVEL_LABEL_SEPARATOR),
                forceToShowFirstLastData: args.forceToShowFirstLastData,
                timeBodyCtx: args.timeBodyCtx,
                weekConfig: args.weekConfig
            };
            
            if(args.showFirstLastDataOnly) {
                result = getFirstLastTicksAndLabels(context);
                result.ticks.offset = result.labels.offset = args.offset || 0;
            } else {
                var intervalUnit = normalizeIntervalUnit(args.intervalUnit, levels, context);
                if(intervalUnit){
                    context.intervalUnit = intervalUnit;
                    context.intervalNumber = normalizeIntervalNumber(args.intervalNumber);
                    context.intervalPivot = normalizeIntervalPivot(args.intervalPivot);
                    result = getFixedTicksAndLabels(context);
                }else{
                    result = getAdaptiveTicksAndLabels(context);
                }
                result.ticks.offset = result.labels.offset = args.offset || 0;
    
                BodyTransformer.categoryWrapper(result, context, true);
                BodyTransformer.firstLastDataWrapper(result, context);
                BodyTransformer.timeColumnWrapper(result, context);
            }
            fixFirstTwoLabelFormat(result, result.context);
            AxisCommon.preventAnyOverlapping(result);
        }
        return result;
    }

    /**
     * Get time axis ticks and labels based on an existing result to implement lazy rendering
     */
    function updateTicksAndLabels(ticksAndLabels, args){
        var tickLevel = ticksAndLabels.tickLevel;
        var labelLevel = ticksAndLabels.labelLevel;
        var context = ticksAndLabels.context;
        if(tickLevel && labelLevel && context){
            context.limit = getLimit(args.limit, context, labelLevel);
            if(!args.showFirstLastDataOnly) {
                var mode;
                if(context.intervalUnit){
                    mode = PIVOT_MODE;
                }

                var labels;
                //add level cmp here
                if(BodyTransformer.shouldFirstLastMode(labelLevel, context)) {
                    labels = getLabelsWithFirstLastDataAndSetLayout(labelLevel, context, mode);
                } else {
                    labels = getLabelsAndSetLayout(labelLevel, context, mode);
                }

                //For category look, we do not need to update ticks. For continues look, 
                //firstLastDataWrapper will update ticks
                var ticks = getTicks({
                        hasMajor: tickLevel.step !== labelLevel.step,
                        tickLevel: tickLevel,
                        labels: labels
                    }, context);

                ticks.offset = labels.offset = args.offset || 0;
                ticksAndLabels.ticks = ticks;
                ticksAndLabels.labels = labels;
                
                BodyTransformer.categoryWrapper(ticksAndLabels, context, false);
                BodyTransformer.firstLastDataWrapper(ticksAndLabels, context);
                BodyTransformer.timeColumnWrapper(ticksAndLabels, context);
            }
            else {
                var ticksLabels = getFirstLastTicksAndLabels(context);
                ticksAndLabels.ticks = ticksLabels.ticks;
                ticksAndLabels.labels = ticksLabels.labels;

                ticksAndLabels.ticks.offset = args.offset || 0;
                ticksAndLabels.labels.offset = ticksAndLabels.ticks.offset;
            }
            fixFirstTwoLabelFormat(ticksAndLabels, ticksAndLabels.context);
            AxisCommon.preventAnyOverlapping(ticksAndLabels);
        }
    }

    // Private ------------------------------------------------------------------

    // IntervalUnit case, final width can be very large
    function getFixedTicksAndLabels(context){
        var levelName = context.intervalUnit;
        var step = context.intervalNumber;
        var level = context.timeBodyCtx.levelDict[levelName];
        var period = level.period * step;
        var levelItem = {
            id: 'fixed',
            name: levelName,
            step: step,
            density: getDensity(levelName, step, context.timeBodyCtx.levelDict),
            values: level.values,
            align: false
        };

        // find best spacing
        var spacing = context.fixedSpacing;
        var originWidth = context.width;
        var range = context.end - context.start;
        if (context.dataBound) {
            range = context.dataBound[1] - context.dataBound[0];
        }
        context.width = max(originWidth, ceil(range * spacing / period));
        context.scale = getScale(context.domain, context.width);
        context.limit = getLimit(context.limitInput, context, levelItem);
        // get all labels first to check overlap issue
        var labels = getLabelsAndSetLayout(levelItem, context, PIVOT_MODE);
        var delta = getOverlappedPixelNum(labels, context.labelMargin);
        var prevDelta = null;
        var enableForceToShowFirstLast = BodyTransformer.shouldFirstLastMode(levelItem, context);
        
        while(delta){
            spacing = max(spacing, spacing + delta);
            //adjust context width. zoom in or zoom out
            context.width = max(originWidth, ceil(range * spacing / period));   
            context.scale = getScale(context.domain, context.width);
            context.limit = getLimit(context.limitInput, context, levelItem);
            layoutLabels(labels, context, null, enableForceToShowFirstLast);
            delta = getOverlappedPixelNum(labels, context.labelMargin);
            
            // avoid dead loop if delta is a tiny number.
            if(Math.abs(delta - prevDelta) < 0.01 ) {
                break;
            }
            prevDelta = delta;
        }
        // remove duplicated labels
        labels = getLabelsAndSetLayout(levelItem, context, PIVOT_MODE);

        // find tick level from the bases of label level
        var base = context.timeBodyCtx.levelStore.filter(function(item){
            return item.name === levelName && step % item.step === 0;
        });
        var tickLevelItem;
        for(var i = 0; i < base.length; ++i){
            var item = base[i];
            var distance = context.scale(context.start + item.step * context.timeBodyCtx.levelDict[item.name].period);
            if(distance >= context.minTickDistance){
                tickLevelItem = item;
                break;
            }
        }
        if(tickLevelItem){
            tickLevelItem = ObjectUtils.extend({
                align: false
            }, tickLevelItem);
        }else{
            tickLevelItem = levelItem;
        }

        var levelResult = {
            hasMajor: tickLevelItem.step !== levelItem.step,
            tickLevel: tickLevelItem,
            labels: labels
        };
        var ticks = getTicks(levelResult, context);

        context.enableForceToShowFirstLast = enableForceToShowFirstLast;

        return {
            width: context.width,
            level: levelName,
            ticks: ticks,
            labels: labels,
            tickLevel: tickLevelItem,
            labelLevel: levelItem,
            levelResult: levelResult,
            context: context
        };
    }
    
    //just get the first and last ticks and labels
    function getFirstLastTicksAndLabels(context) {
        var labels = [];
        var ticks = [];
        var levelItem = {};
        context.scale = getScale(context.domain, context.width);
        context.limit = getLimit(context.limitInput, context);
        context.firstLastTicksOnly = true;
        var levelArgs = getLevelArgs(context);
                
        if(levelArgs.length > 0) {
            levelItem = levelArgs[0];
            
            //use dataBound to fetch labels and ticks
            var values;
            if(context.dataBound && context.dataBound.length >= 2) {
                values = context.dataBound.slice();
            }
            else {
                values = context.domain.slice();
            }
            labels = getLabelsAndSetLayout(levelItem, context, 0, values);

            //fetch the two ticks
            var levelResult = {};
            levelResult.labels = labels;
            levelResult.tickLevel = levelItem;
            
            var firstTick = {
                    value: values[0],
                    position: context.scale(values[0]),
                    major: false
                };
            var lastTick = {
                    value: values[values.length - 1],
                    position: context.scale(values[values.length - 1]),
                    major: false
                };
            
            if(values[0] > values[values.length - 1]) {
                ticks.push(lastTick);
                ticks.push(firstTick);
            }
            else {
                ticks.push(firstTick);
                ticks.push(lastTick);
            }
        }
        
        return  {
            width: context.width,
            level: levelItem.name,
            ticks: ticks,
            labels: labels,
            tickLevel: levelItem,
            labelLevel: levelItem,
            context: context
        };
    }    

    // Responsive case, dynamically decide which level to use
    function getAdaptiveTicksAndLabels(context){
        context.scale = getScale(context.domain, context.width);
        context.limit = getLimit(context.limitInput, context);
        var levelArgs = getLevelArgs(context);
        var levelResult = findLevel(levelArgs, context);
        // Can not find suitable level using normal method, try something advanced
        if(levelResult.labels.length <= 1 || levelResult.overlapped){
            levelArgs = getLevelArgs(context, KEEP_MISSING_LEVELS_MODE);
            levelResult = findLevel(levelArgs, context, ADVANCED_MODE);
        }
        var ticks = getTicks(levelResult, context);

        var enableForceToShowFirstLast = BodyTransformer.shouldFirstLastMode(levelResult.labelLevel, context);
        context.enableForceToShowFirstLast = enableForceToShowFirstLast;

        return  {
            width: context.width,
            level: levelResult.level,
            ticks: ticks,
            labels: levelResult.labels,
            tickLevel: levelResult.tickLevel,
            labelLevel: levelResult.labelLevel,
            levelResult: levelResult,
            context: context
        };
    }

    function cloneLabelPosition(originLabel, destLabel){
        for(var ii = originLabel.layers.length-1; ii >=0; ii--){
            var layer = originLabel.layers[ii];
            var destLayer = destLabel.layers[ii];
            if(layer && destLayer){
                destLayer.left = (layer.left + layer.right) / 2 - destLayer.width / 2;
                if (destLayer.left < 0) {
                    destLayer.left = 0;
                    destLayer.right = destLayer.width;
                } else {
                    destLayer.right = (layer.left + layer.right) / 2 + destLayer.width / 2;
                }
                destLayer.center = (destLayer.right + destLayer.left)/2;
                //label.center is really not useful, keep it for historic reason
                destLabel.center = TypeUtils.isExist(destLabel.center)? destLabel.center  : destLayer.center;
            }
        }
        //to record label first and last flag
        destLabel.isFirstData = originLabel.isFirstData;
        destLabel.isLastData = originLabel.isLastData;
    }

    //first two label's format and text should change after transform to category look
    function fixFirstTwoLabelFormat(ticksAndLabels, context){
        if(ticksAndLabels.labels.length < 2){
            return;
        }

        var positions = [];
        var values = [];
        var ii;
        var number = 5;
        
        for(ii=0; ii < number && ii < ticksAndLabels.labels.length; ii++){
            var label = ticksAndLabels.labels[ii];
            var pos =  ArrayUtils.min(label.layers,
                                       function(layer, index){ return (layer.left+layer.right)/2;});
            positions.push(pos);
            values.push(label.value);
        }

        // use  new positions to update label text to adapt short format
        //we only need two new label
        var newLabels = getLabels(ticksAndLabels.labelLevel, context, 0, values, positions);

        for(ii=0; ii < newLabels.length; ii++){
            cloneLabelPosition(ticksAndLabels.labels[ii], newLabels[ii]);
            ticksAndLabels.labels[ii] = newLabels[ii]; 
        }
    }

    // Transform size limit into timestamp limit
    function getLimit(limitInput, context, levelItem){
        if(limitInput){
            var scale = context.scale;
            var margin = context.limitMargin;
            if(levelItem){
                // Ensure we have at least one extra value out of limit
                var stepMargin = scale(context.timeBodyCtx.levelDict[levelItem.name].period *
                    levelItem.step) - scale(0);
                margin = max(margin, stepMargin);
            }
            var start = max(0, limitInput[0] - margin);
            var end = min(scale.range()[1], limitInput[1] + margin);
            return [
                floor(scale.invert(start)),
                ceil(scale.invert(end)),
                floor(scale.invert(limitInput[0])),
                ceil(scale.invert(limitInput[1]))
            ];
        }
        return null;
    }

    function fixLevelGap(levels, timeBodyCtx) {
        levelComparator = levelComparator.bind(timeBodyCtx);
        //fix the some extreme level case e.g "year, day" or "quarter, minute"
        levels.sort(levelComparator);

        //exception
        if(levels.length === 2 && levels[1] === "year" && levels[0] === "week"){
            return;
        }else if(levels.length >= 2){
            var ii, lv, prevLv;
            for (ii = 1; ii < levels.length; ii++) {
                lv = levels[ii];
                prevLv = levels[ii-1];
                //add month and day to fix the gap
                if(levelComparator(lv, "quarter") >= 0 && levelComparator(prevLv, "day") <= 0){
                    if(levels.indexOf("month") === -1){
                        levels.push("month");
                    }
                    if(levels.indexOf("day") === -1){
                        levels.push("day");
                    }
                }

                //day, minute also have huge gap
                if(levelComparator(lv, "day") >= 0 && levelComparator(prevLv, "minute") <= 0){
                    if(levels.indexOf("hour") === -1){
                        levels.push("hour");
                    }
                    if(levels.indexOf("minute") === -1){
                        levels.push("minute");
                    }
                }
            }
        }

        levels.sort(levelComparator);
    }

    // Get possible items
    function getLevelArgs(context, mode){
        var i, item;
        var levels = context.levels;
        // If range is empty, return the smallest custom level
        if(context.start === context.end){
            for (i = 0; i < context.timeBodyCtx.levelStore.length; ++i) {
                item = context.timeBodyCtx.levelStore[i];
                if(item.name === levels[0] && item.step === 1){
                    return [item];
                }
            }
        }
        var levelArgs = context.timeBodyCtx.levelStore.filter(function (item) {
            return item.condition ? item.condition(context) : true;
        });
        var customLevelHash = {};
        for(i = levels.length; i--;){
            customLevelHash[levels[i]] = 1;
        }

        // remove too loose levels
        var range = context.end - context.start;
        for(i = levelArgs.length; i--;){
            item = levelArgs[i];
            if (range < item.step * context.timeBodyCtx.levelDict[item.name].period) {
                levelArgs.pop();
            }else{
                break;
            }
        }

        // remove too tight levels
        for(i = 0; i < levelArgs.length; ++i){
            item = levelArgs[i];
            var distance = context.scale(context.start + item.step * context.timeBodyCtx.levelDict[item.name].period);
            if(distance >= context.minTickDistance){
                break;
            }
        }
        // add extra levels (more year levels) if necessary
        levelArgs = levelArgs.slice(i).concat(getExtraLevelArgs(context));

        // remove levels that are not custom levels but within custom levels range
        if(!TypeUtils.isSet(mode, KEEP_MISSING_LEVELS_MODE)){
            var customLevelArgs = context.timeBodyCtx.levelStore.filter(function (item) {
                return customLevelHash[item.name];
            });
            var maxDensity = customLevelArgs[0].density;
            var minDensity = customLevelArgs[customLevelArgs.length - 1].density;
            var levelsToRemove = {};
            levelArgs = levelArgs.filter(function(item){
                if(item.density >= minDensity && item.density <= maxDensity && !customLevelHash[item.name]){
                    levelsToRemove[item.name] = 1;
                    return false;
                }
                return true;
            }).filter(function(item){
                return !levelsToRemove[item.name];
            });
        }

        // remove levels with same density
        var densities = {};
        for(i = levelArgs.length; i--;){
            item = levelArgs[i];
            if(densities[item.density]){
                levelArgs.splice(i, 1);
            }else if(customLevelHash[item.name]){
                densities[item.density] = 1;
            }
        }
        densities = {};
        levelArgs = levelArgs.filter(function(item){
            if(!densities[item.density]){
                densities[item.density] = 1;
                return true;
            }
            return false;
        });

        // If the remaining level items overlaps with customer input,
        // ignore the levels that are denser than custom levels.
        for(i = 0; i < levelArgs.length; ++i){
            item = levelArgs[i];
            if(customLevelHash[item.name]){
                break;
            }
        }
        levelArgs = i < levelArgs.length ? levelArgs.slice(i) : levelArgs;
        
        if(context.firstLastTicksOnly && levels.length > 0 && 
           levelArgs.length > 0) {
            //add the smallest level
            for (i = 0; i < context.timeBodyCtx.levelStore.length; ++i) {
                item = context.timeBodyCtx.levelStore[i];
                if(item.name === levels[0] && item.step === 1 &&
                    levelArgs[0].id !== item.id) {
                    levelArgs.unshift(item);
                    break;
                }
            }
        }
        
        return levelArgs;
    }

    // Get very large level items when the data range is too big to fit any predefined level
    function getExtraLevelArgs(context){
        var range = context.end - context.start;
        var lastLevelItem = context.timeBodyCtx.levelStore[context.timeBodyCtx.levelStore.length - 1];
        var lastLevelName = lastLevelItem.name;
        var lastLevel = context.timeBodyCtx.levelDict[lastLevelName];
        var levelArgs = [];
        var i = 2;
        var step = i * lastLevelItem.step;
        var basicLevels = context.timeBodyCtx.levelStore.filter(function (item) {
            return item.name === lastLevelName;
        });
        while(step * lastLevel.period <= range){
            var distance = context.scale(context.start + step * lastLevel.period);
            if(distance >= context.minTickDistance){
                var base = basicLevels.concat(levelArgs).filter(function(item){
                    return step % item.step === 0;
                }).map(function(item){
                    return item.id;
                });
                levelArgs.push({
                    id: i,
                    name: lastLevelName,
                    step: step,
                    values: lastLevel.values,
                    density: getDensity(lastLevelName, step, context.timeBodyCtx.levelDict),
                    base: base
                });
            }
            i++;
            step = i * lastLevelItem.step;
        }
        return levelArgs;
    }
    
    //test a level to see if it fit
    function trySingleLevel(lvItem, context){
        //e.g the range is from 2010.01.01 to 2011.01.01. the level is month
        //this algo will PEEK from 2010.01.01 to 2010.02.01, from 2010.02.01 to 2010.03.01,
        //from 2010.03.01 to 2010.04.01, etc
        //If it did not find any overlapping in these range, it will say this level is okay.
        //but the problems are the visible range is continous, not discrete 
        //because of randomness of calendar, especially week 
        //its algo is not perfect
        var originalStart = context.start;
        var originalLimit = context.limit;
        context.limit = null;
        var result = true;
        var lvName = lvItem.name;
        var shift = TRIAL_SHIFT_TABLE[lvName] * TimeUtil.getPeriod(lvName);
        var mem = context.findLevelMemory;
        var dif = context.end - context.start;
        var id = lvItem.id;
        var shouldFirstLast = BodyTransformer.shouldFirstLastMode(lvItem, context);

        //use memory to avoid repeat computation
        //the assumption is that, if a level fit a size A, than that level will fit any size smaller or equal than A 
        if(mem && mem[id] && mem[id] <= dif){
            return result;
        }else{
            //try multiple times
            for (var i = 0; i < LEVEL_TRIAL_COUNT && context.start < context.end; i++) {
                var labels = AxisCommon.getLabels(lvItem, context, TRIAL_MODE);
                //no shifting when finding level, shifting causes randomness.
                AxisCommon.layoutLabels(labels, context, true, shouldFirstLast);
                var overlap = getOverlappedPixelNum(labels, context.labelMargin, true);
                if(overlap[0] > 0){
                    result = false;
                    break;
                }
                //property only object clone       
                context.start += shift;
            }
    
            context.start = originalStart;
            context.limit = originalLimit;
            if(mem && result){
                mem[id] = Math.min(dif, mem[id]);
            }
            return result; 
        }
    }

    // find the best level that labels do not overlap
    function findLevel(levelArgs, context, mode){
        var labelLevelIndex = -1;
        var tickLevelIndex = -1;
        var i, j, labels, labelLevelItem, tickLevelItem, overlapped;

        if(levelArgs.length){
            overlapped = true;
            //try each level and see if it fit
            for(i = 0; i < levelArgs.length; ++i){
                var item = levelArgs[i];
                if(mustCategoryLook(item, context) && item.continuousOnly ){
                    continue;
                }
                if(trySingleLevel(item, context)){
                    labels = getLabelsAndSetLayout(item, context);
                    if( getOverlappedPixelNum(labels, context.labelMargin) === 0 ){
                        labelLevelIndex = i;
                        overlapped = false;
                        break;
                    }
                }
            }

            labelLevelItem = levelArgs[labelLevelIndex];
            if(labelLevelIndex < 0){
                labelLevelIndex = levelArgs.length - 1;
                labelLevelItem = levelArgs[labelLevelIndex];
                labels = getLabelsAndSetLayout(labelLevelItem, context);
            }

            var needToCate = mustCategoryLook(labelLevelItem, context);
            // Tick level must be a base of the label level
            var base = labelLevelItem.base;
            if(base){
                for(i = 0; i < base.length; ++i){
                    var id = base[i];
                    for(j = labelLevelIndex; j--;){
                        if(levelArgs[j].id === id){
                            //category look only allow tick with 1 step
                            if(needToCate && levelArgs[j].step > 1){
                                continue;
                            }
                            tickLevelIndex = j;
                            break;
                        }
                    }
                    if(tickLevelIndex >= 0){
                        break;
                    }
                }
            }
            if(tickLevelIndex < 0){
                tickLevelIndex = labelLevelIndex;
            }
            tickLevelItem = levelArgs[tickLevelIndex];


            // If we can not find a suitable label level (all overlapped, or only 1 label),
            // try to show labels for the first and the last tick.
            if(TypeUtils.isSet(mode, ADVANCED_MODE)){
                if((overlapped || labels.length === 1) && tickLevelItem.step < labelLevelItem.step){
                    var values = tickLevelItem.values(context.utc, context.start, context.end);
                    if(values.length > 1){
                        values = [values[0], values[values.length - 1]];
                        var newLabels = getLabelsAndSetLayout(labelLevelItem, context, 0, values);
                        // If there is only one original label, and the new labels are overlapped,
                        // don't change to new labels.
                        if(labels.length > 1 || !getOverlappedPixelNum(newLabels, context.labelMargin)){
                            labels = newLabels;
                            overlapped = getOverlappedPixelNum(labels, context.labelMargin);
                        }
                    }
                }
                if(overlapped){
                    // If still overlapped, upgrade to upper levels
                    var baseLevels = context.timeBodyCtx.levelStore.filter(function (item) {
                        return item.step === 1 && item.density <= labelLevelItem.density;
                    });
                    for(i = 0; i < baseLevels.length && overlapped; ++i){
                        labelLevelItem = tickLevelItem = baseLevels[i];
                        labels = getLabelsAndSetLayout(labelLevelItem, context);
                        overlapped = getOverlappedPixelNum(labels, context.labelMargin);
                    }
                }
            }
        }
        return  {
            hasMajor: tickLevelItem !== labelLevelItem,
            level: labelLevelItem ? labelLevelItem.name : null,
            tickLevel: tickLevelItem,
            labelLevel: labelLevelItem,
            labels: labels || [],
            overlapped: overlapped
        };
    }


    // Normalize inputs -------------------------------------------------
    function normalizeConfigs(config, timeBodyCtx) {
        var result = {};
        config = config || {};
        for(var name in config){
            if(config.hasOwnProperty(name)){
                var normalizedName = TimeUtil.normalizeLevelName(name);
                if (timeBodyCtx.levelDict[normalizedName]) {
                    result[normalizedName] = config[name];
                }

                if (combinationDict[normalizedName]) {
                    result[normalizedName] = config[name];
                }
            }
        }
        return result;
    }

    function normalizeIntervalUnit(unit, levels, context) {
        unit = String(unit).toLowerCase();
        if(unit ===  MIN_LEVEL){
            unit = levels[0];
        }
        return context.timeBodyCtx.levelDict[unit] ? unit : null;
    }

    function normalizeIntervalNumber(interval){
        interval = floor(+interval);
        return isNaN(interval) || interval <= 0 ? DEFAULt_INTERVAL_NUMBER : interval;
    }

    function normalizeIntervalPivot(start){
        // null and boolean will generate valid Date object.
        if(start === null || typeof start === 'boolean'){
            return null;
        }
        var pivot = new Date(start).getTime();
        return isNaN(pivot) ? null : pivot;
    }

    function normalizeNumber(n, defaultValue){
        return isNumber(n) ? n : defaultValue;
    }

    // utility --------------------------------------------------
    function getScale(domain, width){
        return d3.scale.linear().domain(domain).range([0, width]);
    }

    function isZoomedIn(context){
        return context.limitInput && (context.limitInput[0] > 0 || context.limitInput[1] < context.width);
    }

    function isNumber(it){
        return typeof it === 'number' && !isNaN(it);
    }

    return {
        getTicksAndLabels: getTicksAndLabels,
        updateTicksAndLabels: updateTicksAndLabels,
        getScale: getScale,
        fixLevelGap: fixLevelGap
    };
});


define('sap/viz/chart/components/axis/sub/TimeAxisBody',[
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/AxisComponent",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/axis/renderer/ValueBodyRenderer",
    "sap/viz/chart/components/renderers/ValueBasedColorRenderer",
    "sap/viz/chart/components/axis/renderer/TimeBodyRenderer",
    "sap/viz/chart/components/util/ClippathUtil",
    "sap/viz/chart/components/util/ZoomUtil",
    "sap/viz/chart/components/axis/sub/TimeAxisBodyHelper",
    "sap/viz/chart/components/axis/sub/TimeAxisCommon",
    'sap/viz/framework/common/format/FormatManager',
    "sap/viz/chart/components/util/BoundUtil",
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/api/env/Locale",
    "sap/viz/framework/common/lang/LangManager"
], function(
    TimeUtil,
    Constants,
    oo,
    AxisComponent,
    NumberUtils,
    ValueBodyRenderer,
    ValueBasedColorRenderer,
    TimeBodyRenderer,
    ClippathUtil,
    ZoomUtil,
    TimeAxisBodyHelper,
    TimeAxisCommon,
    FormatManager,
    BoundUtil,
    ObjectUtils,
    TypeUtils,
    Locale,
    LangManager
) {

    var LABEL_OFFSET = 11;
    var ROUGH_TICK_INTERVAL = 80;
    var VALUEAXIS_DEFAULT_PADDING = 5;
    var VALUEAXIS_PADDING = 3;

    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;
    var TIME_LEVEL = Constants.TIME_LEVEL;

    var EASTERN_LANGUAGE = ["ja", "zh_CN", "zh_TW", "ko"];

    var TimeAxisBody = function(runtime, options) {
        TimeAxisBody.superclass.constructor.apply(this, arguments);
        //this.__className = "sap.viz.chart.elements.axis.sub.TimeAxisBody";
        this._ticksAndLabels = null;
        this._tickGroupNode = null;
        this._labelGroupNode = null;
        this._scrollOffset = 0;

        if (options) {
            this._isColumnLike = !!options.isColumnLike;
            this._isLineChart = !!options.isLineChart;
            this._isMultiplySeriesColumn = options.isMultiplySeriesColumn;
            this._isKeepMinimalLevelContinuousTicks = options.isKeepMinimalLevelContinuousTicks;
            this._allowInterval = options.hasOwnProperty('allowInterval') ? options.allowInterval : true;
        }
        this.initLevelList();
        this.initLevelStore();
        this.initLevelDict();
        TimeAxisCommon.initLevelStoreValues(this.levelStore, this.levelDict);

        //fiscal and time has different min category level
        //the lowest level that allow day. not category look below thie level
        this.minCategoryLevel = "day";

        //lv bigger than 5 years, not category
        this.maxCategoryLevel = {
            name: "year",
            step: 5
        };
        this._isSupportVBCAxisLine = true;
        this._cachedVBCStyleArray = [];
    };
    oo.extend(TimeAxisBody, AxisComponent);

    TimeAxisBody.prototype.normalizeDomain = function (domain) {
        if (TypeUtils.isArray(domain) && domain.length > 1) {
            var start = new Date(domain[0]).getTime();
            var end = new Date(domain[1]).getTime();
            if (!isNaN(start) && !isNaN(end)) {
                return start <= end ? [start, end] : [end, start];
            }
        }
        return null;
    };

    TimeAxisBody.prototype.initLevelList = function(){
        this.levelList = ObjectUtils.clone(TimeUtil.levelList);
    };

    TimeAxisBody.prototype.initLevelStore = function () {
        // Every item defines a valid zooming level.
        // In "adaptive" mode, the final status must be one of these items (or the "extras" of the last item)
        // Possible members are listed as follows:
        // {
        //     id: "seconds_2",  // ID of this item, used to uniquely identify it.
        //     name: "second",   // level name,
        //     step: 2,          // step between 2 adjacent ticks/labels, by the unit defined by "name"
        //     density: ...      // a number showing how dense the ticks will be if this level item is applied
        //     base: [...],      // an array of level item IDs that can be the "base" of this item.
        //                       // All ticks in the current level item must also exists in any of
        //                       its "base" level item.
        //     align: true,      // whether the ticks need to be "aligned" to some special point,
        //                       // In "adaptive" mode, "align" is always true.
        //                       // e.g. the first day of every month must exist when using day level.
        //     values: func,     // a function returning an array of timestamps that matches this item.
        //     condition: func,  // a predicate function deciding whether this level item exists for the given context.
        // }
        // This list is pre-sorted from the densiest to the loosest.
        this.levelStore = [{
            id: 'seconds_1',
            name: 'second',
            step: 1
        }, {
            id: 'seconds_5',
            name: 'second',
            base: ['seconds_1'],
            step: 5
        }, {
            id: 'seconds_15',
            name: 'second',
            base: ['seconds_1', 'seconds_5'],
            step: 15
        }, {
            id: 'seconds_30',
            name: 'second',
            base: ['seconds_1', 'seconds_2', 'seconds_5', 'seconds_15'],
            step: 30
        }, {
            id: 'minutes_1',
            name: 'minute',
            step: 1
        }, {
            id: 'minutes_5',
            name: 'minute',
            base: ['minutes_1'],
            step: 5
        }, {
            id: 'minutes_15',
            name: 'minute',
            base: ['minutes_1', 'minutes_5'],
            step: 15
        }, {
            id: 'minutes_30',
            name: 'minute',
            base: ['minutes_1', 'minutes_5', 'minutes_15'],
            step: 30
        }, {
            id: 'hours_1',
            name: 'hour',
            step: 1
        }, {
            id: 'hours_6',
            name: 'hour',
            base: ['hours_1'],
            step: 6
        }, {
            id: 'hours_12',
            name: 'hour',
            base: ['hours_1', 'hours_6'],
            step: 12
        }, {
            id: 'days_1',
            name: 'day',
            step: 1
        }, {
            id: 'days_5',
            name: 'day',
            base: ['days_1'],
            step: 5
        }, {
            id: 'weeks_1',
            name: 'week',
            step: 1
        }, {
            id: 'weeks_2',
            name: 'week',
            base: ['weeks_1'],
            step: 2
        }, {
            id: 'days_15',
            name: 'day',
            base: ['days_1', 'days_5'],
            step: 15,
            continuousOnly: true
        }, {
            id: 'months_1',
            condition: TimeAxisCommon.notCheck(TimeAxisCommon.sameMonth),
            name: 'month',
            step: 1
        }, {
            id: 'weeks_10',
            name: 'week',
            base: ['weeks_1', 'weeks_2'],
            step: 10,
            continuousOnly: true
        }, {
            id: 'months_3',
            name: 'month',
            base: ['months_1'],
            step: 3
        }, {
            id: 'quarters_1',
            name: 'quarter',
            step: 1
        }, {
            id: 'quarters_2',
            condition: TimeAxisCommon.notCheck(TimeAxisCommon.sameYear),
            name: 'quarter',
            base: ['quarters_1'],
            step: 2
        }, {
            id: 'halfyears_1',
            name: 'halfyear',
            step: 1
        }, {
            id: 'quarters_3',
            name: 'quarter',
            condition: TimeAxisCommon.sameYear,
            base: ['quarters_1'],
            step: 3
        }, {
            id: 'years_1',
            name: 'year',
            step: 1
        }, {
            id: 'years_5',
            name: 'year',
            base: ['years_1'],
            step: 5
        }];
    };

    TimeAxisBody.prototype.initLevelDict = function () {
        // Level dictionary defines some common properties that are shared among level items with the same level name.
        // {
        //      period: TimeUtil.ONE_MINUTE,    // the unit of this level, in milliseconds.
        //      format: '{{hh:}}mm',            // the default format of this level. if a function can only return the
        //                                      // format text or both the format text and the corresponding format
        //      visible: true,                  // a boolean or a predicate function to decide whether the label of
        //                                      // this level is visible.
        //      values: function(){...},        // the default "values" function for the items that
        //                                      // belongs to this level
        // }
        this.levelDict = {
            'second': {
                period: TimeUtil.ONE_SECOND,
                format: function (value, prevValue, utc, labelLevels,
                                 context, position, prevPosition, isForcedFullFormat) {
                    var currentDate = new Date(value);
                    var ff;
                    if (!isForcedFullFormat &&
                        TimeAxisCommon.shouldUseShortFormat("second", value, prevValue, utc, context, position,
                        prevPosition)) {
                        ff = 'ss\'\'';
                    } else {
                        ff = 'hh:mm:ss';
                    }
                    return {
                        text: FormatManager.format(currentDate, ff, utc),
                        format: ff
                    };
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('seconds'),
                same: TimeUtil.isSameSecond
            },
            'minute': {
                period: TimeUtil.ONE_MINUTE,
                format: 'hh:mm',
                visible: function (labelLevels) {
                    return labelLevels.indexOf('second') < 0;
                },
                values: TimeAxisCommon.getValuesFunc('minutes'),
                same: TimeUtil.isSameMinute
            },
            'hour': {
                period: TimeUtil.ONE_HOUR,
                format: 'hh:00',
                visible: function (labelLevels) {
                    return labelLevels.indexOf('minute') < 0 &&
                    labelLevels.indexOf('second') < 0;
                },
                values: TimeAxisCommon.getValuesFunc('hours'),
                same: TimeUtil.isSameHour
            },
            'day': {
                period: TimeUtil.ONE_DAY,
                format: function (value, prevValue, utc, labelLevels,
                                 context, position, prevPosition, isForcedFullFormat) {
                    var currentDate = new Date(value);
                    var ff;
                    if (!isForcedFullFormat &&
                        TimeAxisCommon.shouldUseShortFormat("day", value, prevValue, utc, context, position,
                        prevPosition)) {
                        ff = 'd';
                    } else {
                        var postfix = EASTERN_LANGUAGE.indexOf(Locale.get()) > -1 ? LangManager.get('IDS_DAY') : '';
                        ff = 'MMM d' + postfix;
                    }
                    return {
                        text: FormatManager.format(currentDate, ff, utc),
                        format: ff
                    };
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('days'),
                same: TimeUtil.isSameDay
            },
            'week': {
                period: TimeUtil.ONE_WEEK,
                format: function (value, prevValue, utc, labelLevels, context) {
                    var d = new Date(value);
                    var week = TimeUtil.getWeek(d, utc, context.weekConfig);

                    //For US, UI5 set the first day of first week to Jan.1
                    //but when format it did not treat the really first day in first week
                    //have to hard code here
                    if(context.weekConfig &&
                       context.weekConfig.type === "Gregorian" &&
                       context.weekConfig.region === "US"){
                        if(week === 1 && TimeUtil.getMonth(d, utc) === 11){
                            d = new Date(TimeUtil.getFullYear(d, utc)+1, 0, 1);
                        }
                    }

                    var result = FormatManager.format(d, "Week", utc);
                    if (result === FormatManager.DEFAULT_FORMATTED_VALUE) {
                        if (TimeUtil.getMonth(d, utc) === 0 && week >= 52) {
                            return "W1";
                        } else {
                            return "W" + week;
                        }
                    }
                    return result;
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('weeks'),
                same: TimeUtil.isSameWeek
            },
            'month': {
                period: TimeUtil.ONE_MONTH,
                format: 'MMM',
                visible: function (labelLevels) {
                    return labelLevels.indexOf('day') < 0;
                },
                values: TimeAxisCommon.getValuesFunc('months'),
                same: TimeUtil.isSameMonth
            },
            'quarter': {
                period: TimeUtil.ONE_QUARTER,
                format: function (value, prevValue, utc) {
                    var d = new Date(value);
                    var result = FormatManager.format(d, "Quarter", utc);
                    if (result === FormatManager.DEFAULT_FORMATTED_VALUE) {
                        var m = utc ? d.getUTCMonth() : d.getMonth();
                        return 'Q' + (Math.floor(m / 3) + 1);
                    }
                    return result;
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('quarters'),
                same: TimeUtil.isSameQuarter
            },
            'halfyear': {
                period: TimeUtil.HALF_YEAR,
                format: function (value, prevValue, utc) {
                    var d = new Date(value);
                    var m = utc ? d.getUTCMonth() : d.getMonth();
                    return m < 6 ? "H1" : "H2";
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('halfyears'),
                same: TimeUtil.isSameHalfYear
            },
            'year': {
                period: TimeUtil.ONE_YEAR,
                format: function (value, prevValue, utc, labelLevels, context) {
                    // If week level exists, might need to use the next year if it
                    // is the first week of the next year (e.g. 2014/12/29 is W1 of 2015)
                    var d = new Date(value);
                    var y = utc ? d.getUTCFullYear() : d.getFullYear();
                    var lvs = labelLevels;
                    var len = lvs.length;
                    // Only support ["week", "year"], or ["day", "week", "year"]
                    // and [year,week] in ui5
                    if ((len === 2 && lvs[0] === 'week') ||
                        (len === 3 && lvs[0] === 'day' && lvs[1] === 'week') ||
                        (context.weekConfig && context.weekConfig.type === "Gregorian" &&
                         context.levels.indexOf('week') > -1)) {
                        var m = utc ? d.getUTCMonth() : d.getMonth();
                        if (m === 11) {
                            var w = TimeUtil.getWeek(value, utc, context.weekConfig);
                            if (w === 1) {
                                y++;
                            }
                        }
                    }
                    return y;
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('years'),
                same: TimeUtil.isSameYear
            }
        };
    };

    TimeAxisBody.prototype.normalizePadding = function (paddingValue) {
        //Math.round is used for backward compatibility.
        return Math.round(paddingValue);
    };

    TimeAxisBody.prototype.setHasNegativeValue = function(value){
        this._hasNegativeValue = value;
        return this;
    };

    TimeAxisBody.prototype.update = function(zoomType) {
        if (this._data && this._properties.get('visible') && this._isSpaceEnough()) {
            var ticksAndLabels = this._getTicksAndLabels(this._realSize.width, this._size.width, zoomType);
            this._renderTicksAndLabels(ticksAndLabels);
        }
    };

    TimeAxisBody.prototype._getAxisColor = function(){
        var props = this._properties;
        var color = props.get('color');
        if(this._hasNegativeValue && props.origin.get("plotArea.gridline.zeroLine.unhighlightAxis")){
            color = props.origin.get("plotArea.gridline.color");
        }
        return color;
    };

    TimeAxisBody.prototype._renderTicksAndLabels = function(ticksAndLabels){
        if(!ticksAndLabels){
            return;
        }

        var props = this._properties;
        var width = this._size.width;
        var height = this._size.height;
        var position = this._position;
        var ticks = ticksAndLabels.ticks;
        var labels = ticksAndLabels.labels;
        var step = ticksAndLabels && ticksAndLabels.labelLevel ? ticksAndLabels.labelLevel.step : 1;
        var adjustFirstLastRect = this._properties.get('label.forceToShowFirstLastData');

        var getRange = function(layer, label, idx) {
            var start = label.value, end;
            if(ticksAndLabels.level === 'week' && label.layers[0].level === 'week') {
                // When one week crosses two years, we need to modify the value for the second and third layer
                var truncatedDate = TimeUtil.truncate(start, label.layers[0].level, undefined, props.origin),
                    ceiledDate = TimeUtil.ceil(start, label.layers[0].level, undefined, props.origin);
                if(new Date(truncatedDate).getYear() !== new Date(ceiledDate).getYear()) {
                    start = TimeUtil.truncate(ceiledDate, layer.level, undefined, props.origin);
                }
            }
            start = TimeUtil.truncate(start, layer.level, undefined, props.origin);
            end = TimeUtil.ceil(start, layer.level, undefined, props.origin);
            if(that._isColumnLike && ticksAndLabels.displayMode === 'CONTINUOUS') {
                end = TimeUtil.truncate(end, ticksAndLabels.level, undefined, props.origin);
            }
            return {min:start, max:end};
        };

        var minFloor;
        if(!this._properties.get('label.showFirstLastDataOnly')) {
            var labelsLen = labels.length, that = this;
            var scale = TimeAxisBodyHelper.getScale(this._data.getDomain(), this._realSize.width);
            for(var i = 0; i < labelsLen; i++) {
                var label = labels[i];
                label.layers[0].id = '0-' + label.value;
                label.layers[0].range = {
                    min: label.value,
                    max: TimeUtil.ceil(label.value, label.layers[0].level,
                        undefined, props.origin)
                };
                if(step === 1) {
                    if (adjustFirstLastRect && (label.isFirstData || label.isLastData)) {
                        minFloor = TimeUtil.floor(label.layers[0].range.min, label.layers[0].level,
                            undefined, props.origin);
                        label.layers[0].rectX = scale(minFloor);
                        label.layers[0].range.min = minFloor;
                    }
                    else {
                        label.layers[0].rectX = scale(label.layers[0].range.min);
                    }
                    label.layers[0].rectWidth = scale(label.layers[0].range.max) - label.layers[0].rectX;
                }
                for(var j = 1; j < label.layers.length; j++) {
                    var layer = label.layers[j];
                    layer.id = j + '-' + label.value;
                    if(TypeUtils.isNonEmptyString(layer.text)) {
                        var range = getRange(layer, label, i);
                        layer.range = range;
                        if (adjustFirstLastRect && (label.isFirstData || label.isLastData)) {
                            minFloor = TimeUtil.floor(range.min, layer.level, undefined, props.origin);
                            layer.rectX = scale(minFloor);
                            layer.range.min = minFloor;
                        }
                        else {
                            layer.rectX = scale(range.min);
                        }
                        layer.rectWidth = scale(range.max) - layer.rectX;
                        // In case the user configure the upper layer smaller
                        for(var k = j - 1; k >= 0; k--) {
                            if(label.layers[k].range && range.min >= label.layers[k].range.min &&
                                    range.max < label.layers[k].range.max) {
                                label.layers[k].range.max = range.max;
                                if(label.layers[k].hasOwnProperty('rectX')) {
                                    label.layers[k].rectWidth = scale(label.layers[k].range.max) -
                                        label.layers[k].rectX;
                                }
                            }
                        }
                    }
                }
            }
        }

        var effectMgr = this.runtime().effectManager();
        if (props.get('axisTick.visible') && this._tickGroupNode) {
            //ticks should follow property setting
            var color = this._properties.get('color');
            TimeBodyRenderer.drawTicks(this._tickGroupNode, ticks, width, height,
                position, props, color, effectMgr);
        }
        if (props.get('label.visible') && this._labelGroupNode) {
            TimeBodyRenderer.drawLabels(this, labels, width, height,
                position, props, effectMgr, ticksAndLabels.displayMode, step, ticksAndLabels.level);
        }
        this._lockLabels(ticksAndLabels.labels);
    };

    TimeAxisBody.prototype._lockLabels = function(labels){
        if (!this._labelGroupNode || labels.layerCount <= 1) {
            return;
        }

        var showFirstLastDataOnly = this._properties.get('label.showFirstLastDataOnly');
        if(showFirstLastDataOnly){
            return;
        }

        var leftEdge = 0;
        var labelNodes = this._labelGroupNode.node().querySelectorAll('.v-label');
        var labelCount = labelNodes.length ? labelNodes.length : 0;
        var scrollOffset = labels.offset || 0;
        var i, j;
        function hasLayer(labelIdx, layerIdx){
            var label = labels[labelIdx];
            var layers = label && label.layers;
            return layers && layers[layerIdx] && layers[layerIdx].text;
        }
        for(j = 0; j < labels.layerCount - 1; ++j){
            var upperLayer = null;
            var prevLabelIdx = null;
            var lockedLabel = null;
            var found = false;
            for(i = 0; i < labelCount; ++i){
                var label = labels[i];
                // unlock every label first
                upperLayer = labelNodes[i].querySelectorAll('.v-label-upperLevel')[j];
                if(upperLayer){
                    upperLayer.removeAttribute('dx');
                }
                var hasUpper = hasLayer(i, j + 1);
                if(label.layers[0].right - scrollOffset > leftEdge && !found){
                    // found the first visible label from left
                    found = 1;
                    if(hasUpper){
                        // has upper layers, to translate this one
                        upperLayer = labelNodes[i].querySelectorAll('.v-label-upperLevel')[j];
                        lockedLabel = label;
                    }else if (TypeUtils.isNumber(prevLabelIdx) && prevLabelIdx >= 0 ){
                        // no upper layers, but prev label exists, lock the prev label at left
                        upperLayer = labelNodes[prevLabelIdx].querySelectorAll('.v-label-upperLevel')[j];
                    }
                    if(upperLayer){
                        // do the locking job
                        var nextHasUpper = hasLayer(i + 1, j + 1);
                        var x = parseFloat(upperLayer.getAttribute('x'));
                        if(x < leftEdge){
                            if(!nextHasUpper){
                                upperLayer.setAttribute('dx', leftEdge - x);
                            }else if(lockedLabel){
                                var baseLevelNode = labelNodes[i].querySelectorAll('.v-label-baseLevel')[0];
                                var baseLevelLeft = parseFloat(baseLevelNode.getAttribute('x'));
                                var baseLevelCenter = baseLevelLeft + label.layers[0].width / 2;
                                var upperLevelLeft = baseLevelCenter - lockedLabel.layers[j + 1].width / 2;
                                if(upperLevelLeft > leftEdge){
                                    upperLayer.setAttribute('dx', leftEdge - x);
                                }else{
                                    upperLayer.setAttribute('dx', upperLevelLeft - x);
                                }
                            }
                        }
                    }
                }
                if(!found && hasUpper){
                    prevLabelIdx = i;
                    lockedLabel = label;
                }
            }
        }
    };

    TimeAxisBody.prototype.isExistingItem = function (resultArray, vbcItem) {
        var isExisting = false;
        var i;
        for (i = 0; i < resultArray.length; i++) {
            if (ObjectUtils.deepEqual(resultArray[i], vbcItem)) {
                isExisting = true;
                break;
            }
        }
        return isExisting;
    };

    TimeAxisBody.prototype.normalizeVBCArray = function (styleArray, dpContext) {
        var resultArray;
        var allStyle = ObjectUtils.clone(styleArray);
        resultArray = [];
        var i;
        for (i = 0; i < allStyle.length; i++) {
            if (!allStyle[i].callback) {
                //callback is handled by dpContext
                resultArray.push(allStyle[i]);
            }
        }

        //callback functions have higher priority.
        if (dpContext) {
            for (i = 0; i < dpContext.length; i++) {
                if (dpContext[i].vbcContext.color && dpContext[i].rawData &&
                    dpContext[i].rawData.timeAxis &&
                    dpContext[i].rawData.timeAxis[0]) {
                    var vbcItem = {};
                    vbcItem.start = dpContext[i].rawData.timeAxis[0].parsedValue;
                    vbcItem.end = dpContext[i].rawData.timeAxis[0].parsedValue;
                    vbcItem.color = dpContext[i].vbcContext.color;
                    if (!this.isExistingItem(resultArray, vbcItem)) {
                        resultArray.push(vbcItem);
                    }
                }
            }
        }
        return resultArray;
    };

    TimeAxisBody.prototype.renderValueBasedColorLine = function(dpContext) {
        var ticksAndLabels = this._ticksAndLabels;
        var selection = this._lineSelection;
        if (selection) {
            var props = this._properties;
            var width = this._size.width;
            var height = this._size.height;
            var effectManager = this.runtime().effectManager();

            if (this._isSupportVBCAxisLine && props.get('axisLine.visible') &&
                width > 0 && height > 0) {

                var group = selection.select("." + AXIS_CLASS_NAMES.LINE_GROUP);
                if(!group.node()){
                    group = selection.append("g").attr("class", AXIS_CLASS_NAMES.LINE_GROUP);
                }

                var xOffset = 0;
                if (ticksAndLabels && ticksAndLabels.labels && ticksAndLabels.labels.offset) {
                    xOffset = ticksAndLabels.labels.offset;
                }
                else if (ticksAndLabels && ticksAndLabels.ticks && ticksAndLabels.ticks.offset) {
                    xOffset = ticksAndLabels.ticks.offset;
                }

                //value based color is displayed with axis line.
                var timeDomain = this._data.getDomain();
                var scale = TimeAxisBodyHelper.getScale(timeDomain, this._realSize.width);
                var defaultColor = props.origin.get('general.defaultTimePeriodColor');

                var styleArray = props.origin.get('general.timePeriodStyle');
                if (styleArray && styleArray.length) {
                    if (dpContext) {
                        //render is called by plot.
                        styleArray = this.normalizeVBCArray(styleArray, dpContext);
                        this._cachedVBCStyleArray = styleArray.slice();
                    }
                    else {
                        if (!this._cachedVBCStyleArray.length) {
                            this._cachedVBCStyleArray = this.normalizeVBCArray(styleArray);
                        }
                        styleArray = this._cachedVBCStyleArray.slice();
                    }

                    var iItem;
                    var vbcStart;
                    var vbcEnd;
                    var color;
                    ValueBasedColorRenderer.cleanVBCAxisLines(group);
                    var firstLastValues;
                    for (iItem = 0; iItem < styleArray.length; iItem++) {
                        if (styleArray[iItem] &&
                            TypeUtils.isExist(styleArray[iItem].start) &&
                            TypeUtils.isExist(styleArray[iItem].end)) {

                            var startTime = styleArray[iItem].start;
                            var endTime = styleArray[iItem].end;
                            if (startTime === Constants.PLOTAREA.LAST_DATAPOINT ||
                                endTime === Constants.PLOTAREA.FIRST_DATAPOINT) {
                                endTime = styleArray[iItem].start;
                                startTime = styleArray[iItem].end;
                            }
                            if (startTime === Constants.PLOTAREA.FIRST_DATAPOINT ||
                                endTime === Constants.PLOTAREA.LAST_DATAPOINT) {
                                if (!firstLastValues) {
                                    //firstLastValues can be reused if it is initialized.
                                    firstLastValues = timeDomain.slice();
                                    //the "firstDataPoint" and "lastDataPoint" implementation will not follow
                                    //window.start and window.end behaviors. The exact first and last values
                                    //are fetched. To use dataBound to fetch values.
                                    if (ticksAndLabels && ticksAndLabels.context) {
                                        if (ticksAndLabels.context.dataBound &&
                                            ticksAndLabels.context.dataBound.length >= 2) {
                                            firstLastValues = ticksAndLabels.context.dataBound.slice();
                                        }
                                        else if (ticksAndLabels.context.domain) {
                                            firstLastValues = ticksAndLabels.context.domain.slice();
                                        }
                                    }
                                }
                                if (startTime === Constants.PLOTAREA.FIRST_DATAPOINT) {
                                    startTime = firstLastValues[0];
                                }
                                if (endTime === Constants.PLOTAREA.LAST_DATAPOINT) {
                                    endTime = firstLastValues[1];
                                }
                            }

                            var startTimeStamp = new Date(startTime).getTime();
                            var endTimeStamp = new Date(endTime).getTime();
                            if (!TypeUtils.isNumber(startTimeStamp) || !TypeUtils.isNumber(endTimeStamp)) {
                                continue;
                            }
                            var tempValue;
                            if (startTimeStamp > endTimeStamp) {
                                tempValue = startTimeStamp;
                                startTimeStamp = endTimeStamp;
                                endTimeStamp = tempValue;
                            }
                            //according to UX, we "floor" start and end timestamp, and "extend"
                            //start and end time stamp to half of minimal level length.
                            var cmp = TimeUtil.levelComparator.bind(this);
                            ticksAndLabels.context.levels.sort(cmp);
                            var smallestLV = ticksAndLabels.context.levels[0];

                            var period = this.levelDict[smallestLV].period;
                            startTimeStamp = TimeUtil.truncate(startTimeStamp, smallestLV,
                                ticksAndLabels.context.utc,
                                props.origin, ticksAndLabels.context.weekConfig) - period / 2;
                            endTimeStamp = TimeUtil.truncate(endTimeStamp, smallestLV,
                                ticksAndLabels.context.utc,
                                props.origin, ticksAndLabels.context.weekConfig) + period / 2;

                            vbcStart = scale(startTimeStamp) - xOffset;
                            vbcEnd = scale(endTimeStamp) - xOffset;
                            if (vbcStart > width || vbcEnd < 0) {
                                continue;
                            }
                            if (vbcStart < 0) {
                                vbcStart = 0;
                            }
                            if (vbcEnd > width) {
                                vbcEnd = width;
                            }
                            color = (styleArray[iItem].color || defaultColor);
                            //we may need to merge vbc lines.
                            ValueBasedColorRenderer.drawVBCAxis(group, vbcStart, vbcEnd, color, props,
                                effectManager);
                        }
                    }
                }
            }
        }
    };

    TimeAxisBody.prototype._renderAxisLine = function(selection, ticksAndLabels){
        if(selection){
            var props = this._properties;
            var width = this._size.width;
            var height = this._size.height;

            if (props.get('axisLine.visible') && width > 0 && height > 0) {
                var group = selection.select("." + AXIS_CLASS_NAMES.LINE_GROUP);
                if(!group.node()){
                    group = selection.append("g").attr("class", AXIS_CLASS_NAMES.LINE_GROUP);
                }
                var axisSize = this._isVertical() ? height : width;
                var range = [0, axisSize];
                var properties = props.get();
                var effectManager = this.runtime().effectManager();
                var position = this._position;
                properties.color = this._getAxisColor();
                ValueBodyRenderer.drawLines(group, range, width, height, position, properties, effectManager);

                //update ticksAndLabels to draw ValueBasedColorLine
                this._ticksAndLabels = ticksAndLabels;
                this._lineSelection = selection;
                //for TimeWaterFall, we call renderValueBasedColorLine from plot, because
                //ValueBasedColorLine may have callback function setting from plot.

                this.renderValueBasedColorLine();
            }
        }
    };

    TimeAxisBody.prototype.scroll = function(offset) {
        var props = this._properties;
        var offsetX = -offset.x;
        var ticksAndLabels = this._ticksAndLabels;
        var delta =  Math.abs(this._scrollOffset - offsetX);
        delta = NumberUtils.preciseSimple(delta);
        //if delta is 0, we still have to redraw axis to make sure value based color is right.
        if( this._isHorizontal() && ticksAndLabels ){
            this._scrollOffset = offsetX;
            TimeAxisBodyHelper.updateTicksAndLabels(ticksAndLabels, {
                offset: offsetX,
                limit: [offsetX, offsetX + this._size.width],
                showFirstLastDataOnly: props.get('label.showFirstLastDataOnly')
            });
            this._renderTicksAndLabels(ticksAndLabels);
            this._renderAxisLine(this._selection, ticksAndLabels);
        }
    };

    TimeAxisBody.prototype.render = function(selection) {
        this._selection = selection;
        BoundUtil.drawBound(selection, this._size.width, this._size.height, null, true);
        selection.select("g." + AXIS_CLASS_NAMES.LINE_GROUP).remove();
        selection.select("g." + AXIS_CLASS_NAMES.TICK_GROUP).remove();
        selection.select("g." + AXIS_CLASS_NAMES.LABEL_GROUP).remove();

        // This clippath is required for property zone
        var clippathid = ClippathUtil.drawClippath(d3.select(selection.node().parentNode),
            this._size.width + 2, this._size.height + 2, -1, -1);
        selection.attr('clip-path', 'url(#' + clippathid + ')');

        var props = this._properties;
        if (this._data && props.get('visible')) {
        // render even if this._isSpaceEnough() is false because we need the property/feeding zone bound
            var group = null;
            var position = this._position;
            var width = this._size.width;
            var height = this._size.height;
            var effectManager = this.runtime().effectManager();

            //labels are rendered firstly, because label area rect should be displayed under the VBC line.
            if (props.get('label.visible')) {
                clippathid = ClippathUtil.drawClippath(selection, width + 2, height + 2, -1, -1, "labels");
                group = selection.append("g").attr('clip-path', 'url(#' + clippathid + ')');
                this._labelGroupNode = group.append("g").attr("class", AXIS_CLASS_NAMES.LABEL_GROUP);
            }

            var ticksAndLabels = this._getTicksAndLabels(this._realSize.width, width);
            this._renderAxisLine(selection, ticksAndLabels);

            if (props.get('axisTick.visible')) {
                clippathid = ClippathUtil.drawClippath(selection, width + 2, height + 2, -1, -1, "ticks");
                group = selection.append("g").attr('clip-path', 'url(#' + clippathid + ')');
                this._tickGroupNode = group.append("g").attr("class", AXIS_CLASS_NAMES.TICK_GROUP);
            }


            this._renderTicksAndLabels(ticksAndLabels);

            if (ticksAndLabels) {
                selection.datum({
                    level: ticksAndLabels.level
                });
            }
        }
    };

    TimeAxisBody.prototype.getPreferredSize = function(refSize) {
        var pfdSize = {
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0,
            spacings: [{
                "interval": 0,
                "type": Constants.SPACING_TYPE.STEP
            }]
        };
        var props = this._properties;
        //only consider time axis is in top or bottom
        if (this._data && props.get('visible') && this._isHorizontal()) {
            var scale = this._data;
            var range = scale.getRange();
            var rangeLong = Math.abs(range[0] - range[1]);
            var spacing = LABEL_OFFSET;
            var viewportWidth = refSize ? refSize.width : (this._size.width || rangeLong);
            var result = this._getTicksAndLabels(rangeLong, viewportWidth);
            if (result) {
                this._realSize.width = result.width;

                if (props.get('label.visible')) {
                    var labelStyle = this._properties.get('label.style');
                    var labelHeight = this._measureTextSize('1', labelStyle).height;
                    spacing += labelHeight * Math.max(result.labels.layerCount, 2);
                }
            }

            pfdSize.minWidth = viewportWidth;
            pfdSize.maxWidth = viewportWidth;
            pfdSize.minHeight = spacing;
            pfdSize.maxHeight = spacing;

            pfdSize.spacings = [{
                "interval": spacing,
                "type": Constants.SPACING_TYPE.STEP
            }];
        }
        var precisedSize = NumberUtils.preciseObject(pfdSize);
        this._updatePfdSize(precisedSize);
        return precisedSize;
    };

    TimeAxisBody.prototype.getRealSize = function() {
        return {
            width: this._realSize.width,
            height: this._realSize.height
        };
    };

    TimeAxisBody.prototype.destroy = function() {
        TimeAxisBody.superclass.destroy.apply(this, arguments);
        this._ticksAndLabels = null;
        this._tickGroupNode = null;
        this._labelGroupNode = null;
        this._findLevelMemory = null;
    };

    TimeAxisBody.prototype._getTicksAndLabels = function(totalWidth, viewportWidth, zoomType) {
        var props = this._properties;
        var unit = this._allowInterval && props.get('interval.unit');
        var domain = this._data.getDomain();
        var dataBound = this._data.getDataBound();
        var range = ZoomUtil.getZoomRange(props.origin, domain);
        var zoomStart = range[0];
        var zoomEnd = range[1];
        var isValid = ZoomUtil.isZoomRangeValid(zoomStart, zoomEnd, domain);
        var incomplete = ZoomUtil.isRangeIncomplete(range);
        var levelConfig = props.get("levelConfig");
        var weekConfig = levelConfig && levelConfig.week;

        // ignore interval mode when zooming
        var statusMgr = this.runtime().statusManager();
        if(statusMgr.get('zooming')){
            unit = null;
        }else if(this._isLineChart && isValid && incomplete){
            var MIN_LEVEL = 'minlevel';
            unit = unit || MIN_LEVEL;
        }else if(isValid){
            unit = null;
        }

        var scrollOffset = Math.min(this._scrollOffset, totalWidth - viewportWidth);
        var prevLv = this._ticksAndLabels? this._ticksAndLabels.labelLevel: null;

        // id -> lower bound
        // e.g  weeks_1   -> 20111000
        this._findLevelMemory = this._findLevelMemory || {};

        viewportWidth = viewportWidth || totalWidth;
        this._ticksAndLabels = TimeAxisBodyHelper.getTicksAndLabels({
            dataBound: dataBound,
            domain: domain,
            width: totalWidth,
            offset: scrollOffset,
            limit: [scrollOffset, scrollOffset + viewportWidth],
            levels: statusMgr.get('timeLevels'),
            labelStyle: props.get('label.style'),
            weekConfig: weekConfig,
            config: levelConfig,
            combinationConfig: props.get('combinationConfig'),
            intervalUnit: unit,
            intervalNumber: props.get('interval.number'),
            intervalPivot: props.get('interval.keyLabel'),
            utc: props.origin.get('general.showAsUTC'),
            isColumnLike: this._isColumnLike,
            showFirstLastDataOnly: props.get('label.showFirstLastDataOnly'),
            forceToShowFirstLastData: props.get('label.forceToShowFirstLastData'),
            prevLv: prevLv,
            zoomType: zoomType,
            findLevelMemory: this._findLevelMemory,
            timeBodyCtx: this
        });

        return this._ticksAndLabels;
    };

    TimeAxisBody.prototype.getAvailableLayersNumber = function() {
        var layers = 0;
        if (this._data && this._properties.get('visible') && this._isSpaceEnough()) {
            layers = 1;
        }
        return layers;
    };

    TimeAxisBody.prototype.getActiveLevels = function(){
        return this._ticksAndLabels && this._ticksAndLabels.labels.allLevels;
    };

    TimeAxisBody.prototype.getActiveLabels = function(){
        return this._ticksAndLabels && this._ticksAndLabels.labels;
    };

    TimeAxisBody.prototype.getRange = function(){
        if(this._ticksAndLabels && this._ticksAndLabels.context) {
            return [this._ticksAndLabels.context.start, this._ticksAndLabels.context.end];
        }
    };

    TimeAxisBody.prototype.getTimeValueFormat = function(value){
        //value can be number, string, or date
        var tempV = value;
        if(TypeUtils.isString(value)){
            tempV =  new Date(value).getTime();
        }else if(TimeUtil.isDateValid(value)){
            tempV = value.getTime();
        }

        if( !this._data || isNaN(tempV) || !TypeUtils.isNumber(tempV)){
            return [];
        }
        if (!this._ticksAndLabels) {
            this._getTicksAndLabels(this._realSize.width, this._size.width);
        }

        var tl = this._ticksAndLabels;
        return this.getValueFormatForTooltip(tempV, tl.context, tl.labelLevel ? tl.labelLevel.name : null);
    };

    TimeAxisBody.prototype.getCellPosition = function(cellId){
        var labels = this._ticksAndLabels.labels, ret;
        for(var i = 0; i < labels.length; i++) {
            var layers = labels[i].layers;
            for(var j = 0; j < layers.length; j++) {
                var layer = layers[j];
                if(layer.id === cellId) {
                    var scale = TimeAxisBodyHelper.getScale(this._data.getDomain(), this._realSize.width);
                    if(layer.range) {
                        var min = scale(layer.range.min), max = scale(layer.range.max);
                        ret = {
                                x: min,
                                width: max - min
                            };
                    }
                    break;
                }
            }
            if(ret) {
                break;
            }
        }
        return ret;
    };

    TimeAxisBody.prototype.getScale = function(){
        return this._data;
    };

    TimeAxisBody.prototype.isOnlyShowingFirstAndLastLabel = function() {
        return this._properties.get('label.showFirstLastDataOnly');
    };

    TimeAxisBody.prototype.getValueFormatForTooltip = function (tempV, context, currentLevel) {
        return TimeAxisCommon.getTimeValueFormat(tempV, context, currentLevel, this);
    };

    TimeAxisBody.prototype.fixLevelGap = function (levels) {
        TimeAxisBodyHelper.fixLevelGap(levels, this);
    };

    TimeAxisBody.prototype.isForceCategoryForMinLevel = function (levelName, levelStep, allLevels) {
        var cmp = TimeUtil.levelComparator.bind(this);
        var levels = allLevels;
        if (!levels) {
            var statusMgr = this.runtime().statusManager();
            levels = statusMgr.get('timeLevels');
            if (levels) {
                levels.sort(cmp);
            }
        }

        var isForceCategory = false;
        if (levels && levelName) {
            isForceCategory = (this._isMultiplySeriesColumn && levelStep === 1 &&
                cmp(levelName, levels[0]) === 0);
        }

        return isForceCategory;
    };

    return TimeAxisBody;
});

define('sap/viz/chart/components/axis/sub/FiscalAxisBody',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/TimeAxisBody",
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/chart/components/axis/sub/TimeAxisCommon",
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/format/FormatManager'
], function (
    oo,
    TimeAxisBody,
    Constants,
    ObjectUtils,
    TimeUtil,
    TimeAxisCommon,
    FiscalUtil,
    TypeUtils,
    FormatManager
) {
    var FiscalAxisBody = function (runtime, options) {
        FiscalAxisBody.superclass.constructor.apply(this, arguments);
        this.minCategoryLevel = Constants.FISCAL.PERIOD;

        //use time year step
        var timeMaxLavelStep = this.maxCategoryLevel.step;
        this.maxCategoryLevel = {
            name: Constants.FISCAL.YEAR,
            step: timeMaxLavelStep
        };
        //VBC lines feature does not support fiscal.
        this._isSupportVBCAxisLine = false;
    };
    oo.extend(FiscalAxisBody, TimeAxisBody);

    FiscalAxisBody.prototype.normalizeDomain = function (domain) {
        if (TypeUtils.isArray(domain) && domain.length > 1) {
            var start = domain[0];
            var end = domain[1];
            if (!isNaN(start) && !isNaN(end) &&
                isFinite(start) && isFinite(end)) {
                return start <= end ? [start, end] : [end, start];
            }
        }
        return null;
    };

    FiscalAxisBody.prototype.initLevelList = function(){
        this.levelList = {};
        this.levelList[Constants.FISCAL.PERIOD] =
            ObjectUtils.clone(TimeUtil.levelList[Constants.FISCAL.PERIOD]);
        this.levelList[Constants.FISCAL.YEAR] =
            ObjectUtils.clone(TimeUtil.levelList[Constants.FISCAL.YEAR]);
    };

    FiscalAxisBody.prototype.initLevelStore = function () {
        this.levelStore = [{
            id: 'fiscal_period_1',
            name: 'fiscal_period',
            step: 1
        }, {
            id: 'fiscal_period_2',
            name: 'fiscal_period',
            base: ['fiscal_period_1'],
            step: 2
        }, {
            id: 'fiscal_period_4',
            name: 'fiscal_period',
            base: ['fiscal_period_1', 'fiscal_period_2'],
            step: 4
        }, {
            id: 'fiscal_year_1',
            name: 'fiscal_year',
            step: 1
        }, {
            id: 'fiscal_year_5',
            name: 'fiscal_year',
            base: ['fiscal_year_1'],
            step: 5
        }];
    };

    FiscalAxisBody.prototype.initLevelDict = function () {
        var originProp = this._properties.origin;
        this.levelDict = {
            'fiscal_period': {
                period: Constants.FISCAL.ONE_FISCAL_PERIOD,
                format: function (value, formatOptions) {
                    if (formatOptions && formatOptions.isOriginalFiscalStamp) {
                        return FiscalUtil.fiscalStampToObj(value, originProp).fiscalPeriod;
                    }
                    else {
                        return FiscalUtil.quantityToFiscal(value, originProp).fiscalPeriod;
                    }
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('fiscal_periods', this),
                same: FiscalUtil.isSameFiscalPeriod
            },
            'fiscal_year': {
                period: Constants.FISCAL.ONE_FISCAL_YEAR,
                format: function (value, formatOptions) {
                    if (formatOptions && formatOptions.isOriginalFiscalStamp) {
                        return FiscalUtil.fiscalStampToObj(value, originProp).fiscalYear;
                    }
                    else {
                        return FiscalUtil.quantityToFiscal(value, originProp).fiscalYear;
                    }
                },
                visible: true,
                values: TimeAxisCommon.getValuesFunc('fiscal_years', this),
                same: FiscalUtil.isSameFiscalYear.bind(this)
            }
        };
    };

    FiscalAxisBody.prototype.normalizePadding = function (paddingValue) {
        //do not round padding value for fiscal charts. 
        return paddingValue;
    };

    FiscalAxisBody.prototype.getValueFormatForTooltip = function (value, context, currentLevel) {
        var levels = ObjectUtils.extend(true, [], TimeUtil.normalizeLevels(context.levels, this));
        if(currentLevel){
            currentLevel = TimeUtil.normalizeLevelName(currentLevel); 
            if(currentLevel && levels.indexOf(currentLevel) === -1){ 
                levels.push(currentLevel); 
                levels.sort(TimeUtil.levelComparator.bind(this)); 
            } 
        }

        var prevInfo = TimeAxisCommon.getPrevInfo(null, null);
        var currentInfo;
        var resObj;
        
        var result = [];
        var i;
        for (i = levels.length - 1; i >= 0; i--) {
            currentInfo = TimeAxisCommon.getCurrentInfo(value, levels[i], levels, null);
            resObj = this.formatFiscalLabel(currentInfo, prevInfo, context);
            result.push(resObj.text);
        }

        //fiscal axis has no combined labels.
        return result;
    };

    FiscalAxisBody.prototype.formatFiscalLabel = function (currentInfo, prevInfo, context) {
        //value is "1970001".
        var value = currentInfo.value;
        var levelName = currentInfo.levelName;
        var labelLevels = currentInfo.labelLevels;

        var prevValue = prevInfo && prevInfo.prevValue;
        var config = context.config;

        var userFormat = (config && config[levelName] ? config[levelName][TimeAxisCommon.FORMAT_CONFIG_FIELD] : null);
        var defaultFormat = (context.timeBodyCtx.levelDict[levelName] &&
            context.timeBodyCtx.levelDict[levelName].format);
        var result;
        var text;

        var formatOptions = {};
        formatOptions.isOriginalFiscalStamp = true;

        //fiscal has no combination labels
        //use custom function first, if not working  fallback to built-in format

        //Please note: users format should accept "1970001". (originalFiscalStamp).
        if (TypeUtils.isFunction(userFormat)) {
            text = userFormat(value, prevValue, false, labelLevels.slice());
            if(text){
                result = {
                    format: userFormat,
                    text: text
                };
            }
        } else if (TypeUtils.isString(userFormat)) {
            text = FormatManager.format(value, userFormat);
            if(text){
                if (text instanceof Date) {
                    text = userFormat;
                }
                result = {
                    format: userFormat,
                    text: text
                };
            }
        }

        if (!result) {
            if (TypeUtils.isString(defaultFormat)) {
                text = FormatManager.format(value, defaultFormat);
                if (text instanceof Date) {
                    text = defaultFormat;
                }
                result = {
                    format: defaultFormat,
                    text: text
                };
            } else if (TypeUtils.isFunction(defaultFormat)) {
                var formatResult = defaultFormat(value, formatOptions);
                if (TypeUtils.isPlainObject(formatResult)) {
                    result = formatResult;
                } else {
                    result = {
                        format: defaultFormat,
                        text: formatResult
                    };
                } 
            }
        }  

        //some formater return number
        if (TypeUtils.isString(result)) {
            result = {
                text: result
            };
        }
        result.text = (TypeUtils.isNumber(result.text) ? result.text.toString() : result.text);
        return result;
    };

    FiscalAxisBody.prototype.fixLevelGap = function (levels) {
        //just one or two fiscal levels
        levels.sort(TimeUtil.levelComparator.bind(this));
    };

    return FiscalAxisBody;
});

define('sap/viz/chart/components/accessibility/TimeAxisNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/ChartComponentNavigator",
    "sap/viz/framework/common/util/ObjectUtils"
], function(oo, ChartComponentNavigator, ObjectUtils) {

    function TimeLabelNavigator(options) {
        TimeLabelNavigator.superclass.constructor.apply(this, arguments);
        this._timeLabels = {};
        this._cells = this.label2cells(options.cells);
    }
    
    var THREE_DAYS = 3 * 24 * 3600000;

    oo.extend(TimeLabelNavigator, ChartComponentNavigator);

    var prot = TimeLabelNavigator.prototype;

    prot.label2cells = function(labels) {
        var cells = [], cols = [];
        for(var i = 0; i < labels.length; i++) {
            var layers = labels[i].layers;
            for(var j = 0; j < layers.length; j++) {
                var layer = layers[j];
                if(layer.hasOwnProperty('rectX') && layer.text) {
                    if(!cells[j]) {
                        cells[j] = [];
                        cols[j] = 0;
                    }
                    cells[j].push(layer);
                    layer.index = {row: j, col: cols[j]++};
                    this._timeLabels[layer.id] = {};
                    this._timeLabels[layer.id].index = layer.index;
                }
            }
        }
        return cells;
    };

    prot.init = function() {
    };

    prot.destroy = function() {
        TimeLabelNavigator.superclass.destroy.apply(this, arguments);
        this._cells = null;
        this._categoryLabels = null;
    };

    prot.up = function(id, offset) {
        return this.getFirstChildCell(id, offset);
    };

    prot.down = function(id) {
        return this.getParentCell(id);
    };
    
    prot.left = function(id) {
        return this.getSiblingCell(id, -1);
    };
    
    prot.right = function(id) {
        return this.getSiblingCell(id, 1);
    };

    prot.getCell = function(id){
        if(!this._timeLabels[id]) {
            return null;
        }
        var index = this._timeLabels[id].index;
        return this._cells[index.row][index.col] || null;
    };

    prot.getSiblingCell = function(id, direction) {
        var index;
        if(!this._timeLabels[id]) {
            // Special case for the first label has special look like 'W1, Q1, 2015'
            index = {
                    row : parseInt(id.split('-')[0]),
                    col : 0
                };
            return this._cells[index.row][index.col];
        }
        else {
            index = this._timeLabels[id].index;
        }
        var siblingCell = this._cells[index.row][index.col + direction];
        return siblingCell ? siblingCell : null;
    };

    prot.getFirstChildCell = function(id, offset) {
        if(!this._timeLabels[id]) {
            return null;
        }
        var index = this._timeLabels[id].index;
        var childLayer = this._cells[index.row - 1];
        if (!childLayer){
            return null;
        }
        var getResult = function(cell, childLayer, i) {
            if(childLayer[i].rectX + offset.x >= 0) {
                return childLayer[i];
            }
            else {
                if(childLayer[i + 1] && childLayer[i + 1].range.min < cell.range.max) {
                    return childLayer[i + 1];
                }
                else {
                    return childLayer[i];
                }
            }
        };
        var cell = this._cells[index.row][index.col], ret;
        for (var i = 0; i < childLayer.length; ++i){
            if(childLayer[i].level === 'week') {
                var thursday = childLayer[i].range.min + THREE_DAYS;
                if((cell.range.min <= childLayer[i].range.min && thursday <= cell.range.max) ||
                        (cell.range.min <= thursday && childLayer[i].range.max <= cell.range.max)) {
                    return getResult(cell, childLayer, i);
                }
            }
            else {
                if (childLayer[i].range.min >= cell.range.min && childLayer[i].range.max <= cell.range.max){
                    return getResult(cell, childLayer, i);
                }
            }
        }
    };

    prot.getParentCell = function(id) {
        if(!this._timeLabels[id]) {
            return null;
        }
        var index = this._timeLabels[id].index;
        var parentLayer = this._cells[index.row + 1];
        if (!parentLayer){
            return null;
        }
        var cell = this._cells[index.row][index.col];
        for(var i = 0; i < parentLayer.length; i++) {
            if(cell.level === 'week') {
                var thursday = cell.range.min + THREE_DAYS;
                if((cell.range.min >= parentLayer[i].range.min && thursday <= parentLayer[i].range.max) ||
                        (thursday >= parentLayer[i].range.min && cell.range.max <= parentLayer[i].range.max)) {
                    return parentLayer[i];
                }
            }
            else {
                if(cell.range.min >= parentLayer[i].range.min && cell.range.max <= parentLayer[i].range.max) {
                    return parentLayer[i];
                }
            }
        }
    };

    prot.getFirstStartPoint = function() {
        var row = this._cells[0] ? 0 : 1;
        var len = (this._cells[row] && this._cells[row].length) || 0;
        for(var i = 0; i < len; i++) {
            if(this._cells[row][i] && this._cells[row][i].text) {
                return this._cells[row][i];
            }
        }
        return {id:null};
    };

    prot.updateCells = function(layers) {
        this._timeLabels = {};
        this._cells = this.label2cells(layers);
    };

    prot.findCell = function(ctx, id) {
        if (!(ctx && ctx.id)) {
            return null;
        }
        var temp = ctx.id.split('-');
        var i = temp[0], value = temp[1];
        if(!this._cells[i]) {
            i++;
        }
        if(!this._cells[i]) {
            return null;
        }
        for(var c, j = 0, jLen = this._cells[i].length; j < jLen; j++) {
            c = this._cells[i][j];
            if(ctx.id === c.id || (value >= c.range.min && value < c.range.max)) {
                return c;
            }
        }

        return null;
    };

    return TimeLabelNavigator;
});

define('sap/viz/chart/components/axis/TimeAxis',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/AxisContainer",
    "sap/viz/chart/scales/TimeScale",
    "sap/viz/chart/components/axis/sub/TimeAxisBody",
    "sap/viz/chart/components/axis/sub/FiscalAxisBody",
    'sap/viz/framework/common/util/FiscalUtil',
    "sap/viz/chart/components/scrollbar/Scrollbar",
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/framework/common/util/FunctionUtils',
    'sap/viz/framework/common/format/FormatManager',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/TimeAxisNavigator",
    "sap/viz/chart/components/util/ChartConstants",
], function(
    Constants,
    oo,
    AxisContainer,
    TimeScale,
    TimeAxisBody,
    FiscalAxisBody,
    FiscalUtil,
    Scrollbar,
    LangManager,
    FunctionUtils,
    FormatManager,
    TypeUtils,
    ChartNavigator,
    ItemNavigator,
    ChartConstants
) {

    var MEASURE_NAMES = "measureNames";

    var TimeAxis = function(runtime, options) {
        TimeAxis.superclass.constructor.apply(this, arguments);
        var axisBody;
        if (FiscalUtil.isFiscal(options.rawData)) {
            this._isFiscal = true;
            axisBody = new FiscalAxisBody(runtime, options);
        }
        else {
            axisBody = new TimeAxisBody(runtime, options);
        }
        this.setChild("axisBody",  axisBody, {
            order: 1,
            priority: 2,
            offset: 0
        });
    };
    oo.extend(TimeAxis, AxisContainer);

    TimeAxis.prototype.addARIATag = function(rootElement){
        rootElement.attr('role', 'listbox');
    };

    TimeAxis.prototype._updateSubModules = function (scale){
        var bodyModule = this.getChild("axisBody").module;
        bodyModule.setSize({
            width: this._size.width
        });

        var zoomType;
        if(scale.x === this._prevScaleX  || !this._prevScaleX ){
            zoomType = "noChange";
        }else if(scale.x > this._prevScaleX){
            zoomType = "zoomIn"; 
        }else{
            zoomType = "zoomOut";
        }
        this._prevScaleX = scale.x;

        bodyModule.setRealSize(this._realSize);
        bodyModule.update(zoomType);
    };

    TimeAxis.prototype.setData = function(data, hasNegativeValue) {
        TimeAxis.superclass.setData.call(this, data);
        if (TypeUtils.isExist(hasNegativeValue)) {
            this._hasNegativeValue = hasNegativeValue;
        }
        if (data.scale) {
            var scale = data.scale;
            this._scale = new TimeScale(scale.getDomain(), [0, 1], undefined, {dataBound: scale.getDataBound()});
        }
    };

    TimeAxis.prototype.setHasNegativeValue = function(value){
        this._hasNegativeValue = value;
        var axisBody = this.getChild("axisBody").module;
        axisBody.setHasNegativeValue(this._hasNegativeValue);
        return this;
    };

    TimeAxis.prototype._updateData = function(info) {
        TimeAxis.superclass._updateData.apply(this, arguments);
        if (!this._scale) {
            return;
        }
        if (this._isVertical()) {
            this._scale.setRange([info.height, 0]);
        } else {
            this._scale.setRange([0, info.width]);
        }
        var axisBody = this.getChild("axisBody").module;
        axisBody.setData(this._scale);
        axisBody.setHasNegativeValue(this._hasNegativeValue);
    };

    TimeAxis.prototype._constructTitle = function(header, titleItems) {
        var titleText = header.map(function(o) {
            return o.name || o.id;
        }).join(" / ");

        var itemObj = {};
        itemObj.isHidden = false;
        itemObj.text = titleText;

        titleItems.push(itemObj);
        return titleText;
    };

    TimeAxis.prototype.isVisible = function() {
        var prop = this.properties();
        return prop.visible === true;
    };

    TimeAxis.prototype.isLabelVisible = function() {
        var prop = this.properties();
        return this._bodyLayersNumber > 0 && prop.label.visible;
    };

    TimeAxis.prototype.getFiscalUnitLabels = function () {
        var labels = [];
        if (this._isFiscal) {
            labels.push(LangManager.get("IDS_FISCALYEAR"));
            if(FiscalUtil.extractUnitType(this._properties.origin) === Constants.FISCAL.UNITTYPE_YEARPERIOD) {
                labels.push(LangManager.get("IDS_FISCALPERIOD"));
            }
        }
        return labels;
    };


    TimeAxis.prototype.getFormatTimeValue = function(value){
        var axisBody = this.getChild("axisBody").module;
        var formatedValue = axisBody.getTimeValueFormat(value);
        var valueLevelOne = formatedValue[0] === "" ? null : formatedValue[0];
        var valueLevelTwo = formatedValue[1] === "" ? null : formatedValue[1];
        var reObj = {};
        if (this._isFiscal) {
            reObj.fiscalyear = valueLevelOne;
            reObj.fiscalperiod = valueLevelTwo;
        }
        else {
            reObj.day = valueLevelOne;
            reObj.time = valueLevelTwo;
        }
        return reObj;
    };
    
    TimeAxis.prototype.supportFixedLayout = true;
    
    TimeAxis.prototype._setupLayout = function(info) {
        TimeAxis.superclass._setupLayout.call(this, info);
        var scrollbar = this.getChild(Constants.AXIS.SCROLLBAR_NAME);
        var scrollbarVisible = this._properties.origin.get("plotArea.scrollbar.visible");
        if (scrollbar && scrollbarVisible === false){
            scrollbar.module.isExist(false);
        }
    };
    
    TimeAxis.prototype.isByBound = function() {
        return true;
    };
    ChartNavigator.register(ChartConstants.TIMEAXIS_NAVIGATOR, null, ItemNavigator);
    return TimeAxis;

});

define('sap/viz/chart/components/datalabels/ScatterDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    "sap/viz/chart/components/util/DataPointUtils"
], function(
    oo,
    DataLabels,
    DataPointUtils
) {

    /**
     * To initialize ScatterDataLabels object.
     *
     * @name ScatterDataLabels
     * @constructor
     */
    function ScatterDataLabels(runtime, options) {
        ScatterDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = "up";
    }

    oo.extend(ScatterDataLabels, DataLabels);

    var prot = ScatterDataLabels.prototype;

    prot._hasTimeAxis = function(){
        return !!this._data.timeAxis;
    };

    prot._getDataLabelInfo = function(node) {
        var axisName = this._hasTimeAxis() ? 'valueAxis' : 'valueAxis2';
        var data = this._data;
        var ctx = DataPointUtils.getContextByDataModel(node, data);
        var key = data[axisName].metaData[0].id;
        return {
            key: key,
            value: ctx[key]
        };
    };

    return ScatterDataLabels;
});

define('sap/viz/chart/components/renderers/ScatterRenderer',[
    "sap/viz/framework/common/util/SVG",
    'sap/viz/chart/components/util/DrawUtil'
], function(SVG, DrawUtil) {

    function scatterRenderer(config) {
        var node = SVG.createSVGNode("path");
        var graphic = config.graphic;
        var opacity = graphic.opacity;
        if (opacity > 1 || opacity < 0){
            opacity = 0.8;
        }
        var fillOpacity = graphic.fillOpacity;
        if (fillOpacity > 1 || fillOpacity < 0){
            fillOpacity = 1;
        }

        if (graphic.shape === "circle" && config.isBigData) {
            node = SVG.createSVGNode("circle");
            node.setAttribute("fill", graphic.fill);
            node.setAttribute("r", graphic.width / 2);
            if (graphic.fill !== "transparent") {
                node.setAttribute("stroke-width", graphic.borderWidth);
                node.setAttribute("stroke", graphic.borderColor);
                node.setAttribute("opacity", opacity);
                if (fillOpacity != null) {
                    node.setAttribute("fill-opacity", fillOpacity);
                }
            }
            return node;
        }

        var parameter = {
            drawingEffect: graphic.drawingEffect,
            fillColor: graphic.fill,
            graphType: graphic.shape,
            direction: 'vertical',
            rx: graphic.width / 2,
            ry: graphic.height / 2,
            borderWidth: graphic.borderWidth,
            node: node,
            opacity: opacity,
            fillOpacity: fillOpacity,
            borderColor: graphic.borderColor
        };

        if (config.graphic.pattern) {
            parameter.patternEffect = config.graphic.pattern;
        }

        DrawUtil.drawGraph(parameter, config.effectManager);
        return node;
    }

    scatterRenderer.expose = {
        renderer: scatterRenderer
    };

    return scatterRenderer;
});

define('sap/viz/chart/components/plots/ProjectionHelper',[
    'sap/viz/framework/common/util/oo'
], function(oo){

    var LAYER_LIMIT = 1;
    var VISIBLE_THRESHOLD = 6;
    var math_abs = Math.abs;
    var areaCache = {};

    function Projector(){}

    Projector.prototype.init = function(rx, ry){
        this._rx = rx;
        this._ry = ry;
    };


    // Ellipse ----------------------------------------------------

    function EllipseProjector(){}

    oo.extend(EllipseProjector, Projector);

    EllipseProjector.prototype.init = function(rx, ry){
        this._rxSquare = rx * rx;
        this._rySquare = ry * ry;
        this._rxrySquare = this._rxSquare * this._rySquare;
        this._isCircle = this._rxSquare === this._rySquare;
    };

    // a^2y^2 + b^2x^2 <= a^2b^2
    EllipseProjector.prototype.isInRange = function(x, y){
        return this._isCircle ?
            x * x + y * y <= this._rxSquare :
            x * x * this._rySquare + y * y * this._rxSquare <= this._rxrySquare;
    };

    // Diamond -----------------------------------------------------

    function DiamondProjector(){}

    oo.extend(DiamondProjector, Projector);

    DiamondProjector.prototype.init = function(rx, ry){
        this._rx = rx;
        this._ry = ry;
        this._rxry = rx * ry;
    };

    // a|y| + b|x| <= ab
    DiamondProjector.prototype.isInRange = function(x, y){
        x = math_abs(x);
        y = math_abs(y);
        return this._rx * y + this._ry * x <= this._rxry;
    };

    // TriangleUp -------------------------------------------------------

    function TriangleUpProjector(){}

    oo.extend(TriangleUpProjector, Projector);

    TriangleUpProjector.prototype.init = function(rx, ry){
        this._2ry = ry * 2;
        this._rxry = rx * ry;
        this._rx = rx;
    };

    // ay + 2b|x| <= ab
    TriangleUpProjector.prototype.isInRange = function(x, y){
        x = math_abs(x);
        return this._rx * y + this._2ry * x <= this._rxry;
    };

    // TriangleDown -------------------------------------------------------

    function TriangleDownProjector(){}

    oo.extend(TriangleDownProjector, Projector);

    TriangleDownProjector.prototype.init = function(rx, ry){
        this._2ry = ry * 2;
        this._rxry = rx * ry;
        this._rx = rx;
    };

    // -ay + 2b|x| <= ab
    TriangleDownProjector.prototype.isInRange = function(x, y){
        x = math_abs(x);
        return this._2ry * x - this._rx * y <= this._rxry;
    };

    // TriangleLeft -------------------------------------------------------

    function TriangleLeftProjector(){}

    oo.extend(TriangleLeftProjector, Projector);

    TriangleLeftProjector.prototype.init = function(rx, ry){
        this._2rx = rx * 2;
        this._rxry = rx * ry;
        this._ry = ry;
    };

    // 2a|y| - bx <= ab
    TriangleLeftProjector.prototype.isInRange = function(x, y){
        y = math_abs(y);
        return this._2rx * y - this._ry * x <= this._rxry;
    };

    // TriangleRight -------------------------------------------------------

    function TriangleRightProjector(){}

    oo.extend(TriangleRightProjector, Projector);

    TriangleRightProjector.prototype.init = function(rx, ry){
        this._2rx = rx * 2;
        this._rxry = rx * ry;
        this._ry = ry;
    };

    // 2a|y| + bx <= ab
    TriangleRightProjector.prototype.isInRange = function(x, y){
        y = math_abs(y);
        return this._2rx * y + this._ry * x <= this._rxry;
    };

    // Intersection -------------------------------------------------------

    function IntersectionProjector(){}

    oo.extend(IntersectionProjector, Projector);

    IntersectionProjector.prototype.init = function(rx, ry){
        this._9ry = 9 * ry;
        this._8ry = 8 * ry;
        this._6rx = 6 * rx;
        var rxy = rx * ry;
        this._3rxry = 3 * rxy;
        this._2rxry = 2 * rxy;
    };

    // 9b|x| - 3ab <= 6a|y| <= 8b|x| + 2ab
    IntersectionProjector.prototype.isInRange = function(x, y){
        x = math_abs(x);
        y = math_abs(y);
        var a = this._6rx * y;
        return this._9ry * x - this._3rxry <= a && a <= this._8ry * x + this._2rxry;
    };

    // Cross -------------------------------------------------------------

    function CrossProjector(){}

    oo.extend(CrossProjector, Projector);

    CrossProjector.prototype.init = function(rx, ry){
        this._dx = rx / 3;
        this._dy = ry / 3;
    };

    CrossProjector.prototype.isInRange = function(x, y){
        return math_abs(x) <= this._dx || math_abs(y) <= this._dy;
    };

    function SquareProjector(){}

    oo.extend(SquareProjector, Projector);

    SquareProjector.prototype.isInRange = function(x, y){
        return math_abs(x) <= this._rx && math_abs(y) <= this._ry;
    };

    //negative -------------------------------------------------------------

    function NegativeProjector(clz) {
        this._projectorClz = clz;
    }


    oo.extend(NegativeProjector, Projector);

    NegativeProjector.prototype.init = function(rx, ry, borderWidth) {
        this._outer = new this._projectorClz();
        this._outer.init(rx, ry);
        this._inner = new this._projectorClz();
        this._inner.init(rx - borderWidth, ry - borderWidth);
    };

    NegativeProjector.prototype.isInRange = function(x, y) {
        return !this._inner.isInRange(x, y) && this._outer.isInRange(x, y);
    };


    // TODO: support more shapes

    // --------------------------------------------------------------

    var projectors = {
        circle: new EllipseProjector(),
        diamond: new DiamondProjector(),
        triangleUp: new TriangleUpProjector(),
        triangleDown: new TriangleDownProjector(),
        triangleLeft: new TriangleLeftProjector(),
        triangleRight: new TriangleRightProjector(),
        intersection: new IntersectionProjector(),
        cross: new CrossProjector(),
        square: new SquareProjector(),

        negative_circle: new NegativeProjector(EllipseProjector),
        negative_diamond: new NegativeProjector(DiamondProjector),
        negative_triangleUp: new NegativeProjector(TriangleUpProjector),
        negative_triangleDown: new NegativeProjector(TriangleDownProjector),
        negative_triangleLeft: new NegativeProjector(TriangleLeftProjector),
        negative_triangleRight: new NegativeProjector(TriangleRightProjector),
        negative_intersection: new NegativeProjector(IntersectionProjector),
        negative_cross: new NegativeProjector(CrossProjector),
        negative_square: new NegativeProjector(SquareProjector)
    };

    function getInscribeShape(areaConfig) {
        var shape = areaConfig.shape;
        if(shape == "circle" && !areaConfig.negativeValue) {
            shape = "square";
        }
        shape = areaConfig.negativeValue === true ? "negative_" + shape : shape;
        return shape;
    }

    function getArea(areaConfig, rx, ry) {
        var shape = getInscribeShape(areaConfig);
        var areas = areaCache[shape];
        areas = areas && areas[rx];
        return areas && areas[ry];
    }

    function createArea(areaConfig, rx, ry) {
        var shape = getInscribeShape(areaConfig);
        var areas = areaCache[shape] = areaConfig[shape] || {};
        areas = areas[rx] = areas[rx] || {};
        var pixels = areas[ry] = [];
        return pixels;
    }


    function getValidPixels(areaConfig, rx, ry){
        var shape = getInscribeShape(areaConfig);
        var pixels = getArea(areaConfig, rx, ry);
        if(!pixels){
            var projector = projectors[shape];
            if(projector){
                projector.init(rx, ry, areaConfig.borderWidth);
                pixels = createArea(areaConfig, rx, ry);
                pixels.length = (rx * 2 + 1) * (ry * 2 + 1) * 2;
                var idx = 0;
                for(var i = -rx; i <= rx; ++i){
                    for(var j = -ry; j <= ry; ++j){
                        if(projector.isInRange(i, j)){
                            pixels[idx++] = i;
                            pixels[idx++] = j;
                        }
                    }
                }
                pixels.length = idx;
            }
        }
        return pixels;
    }

    function createPixelBoard(width, height, args){
        var pixelBoard = [];
        args = args || {};
        width = pixelBoard.width = Math.round(width);
        height = pixelBoard.height = Math.round(height);
        pixelBoard.layerLimit = args.layerLimit > 0 ? parseInt(args.layerLimit) : LAYER_LIMIT;
        pixelBoard.visibleThreshold = args.visibleThreshold > 0 ?
                parseInt(args.visibleThreshold) :
                VISIBLE_THRESHOLD;
        var size = pixelBoard.length = width * height;

        for(; size--;){
            pixelBoard[size] = 0;
        }
        return pixelBoard;
    }

    function isAreaVisible(pixelBoard, areaConfig, x, y, rx, ry){
        var width = pixelBoard.width;
        var height = pixelBoard.height;
        var layerLimit = pixelBoard.layerLimit;
        if(areaConfig.shape == "circle" && !!!areaConfig.negativeValue){
            rx = ry = Math.round(ry / Math.SQRT2);
        }

        var pixels = getValidPixels(areaConfig, rx, ry);
        var startX = x - rx;
        var endX = x + rx;
        var startY = y - ry;
        var endY = y + ry;
        var visiblePixels = [];
        var touchBound;
        var i, j, idx;
        var realX, realY;

        if(startX < 0){
            startX = 0;
            touchBound = true;
        }
        if(endX > width){
            endX = width;
            touchBound = true;
        }
        if(startY < 0){
            startY = 0;
            touchBound = true;
        }
        if(endY > height){
            endY = height;
            touchBound = true;
        }
        if(pixels){
            var pixelLength = pixels.length;
            for(i = 0; i < pixelLength; i += 2){
                if(!touchBound){
                    realX = x + pixels[i];
                    realY = y + pixels[i + 1];
                    if(realX >= startX && realX <= endX && realY >= startY && realY <= endY){
                        idx = realX * height + realY;
                        if(pixelBoard[idx] < layerLimit){
                            visiblePixels.push(idx);
                        }
                    }
                }
            }
        } else {
            for(i = startX; i <= endX; ++i){
                var base = i * height;
                var stop = base + endY;
                for(idx = base + startY; idx <= stop; ++idx){
                    if(pixelBoard[idx] < layerLimit){
                        visiblePixels.push(idx);
                    }
                }
            }
        }
        if(visiblePixels.length >= pixelBoard.visibleThreshold){
            for(i = visiblePixels.length; i--;){
                pixelBoard[visiblePixels[i]]++;
            }
            return true;
        }
        return false;
    }

    return {
        createPixelBoard: createPixelBoard,
        isAreaVisible: isAreaVisible
    };
});

define('sap/viz/chart/components/decorator/HitTestDecorator',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/decorator/BaseHitTestDecorator',
    'sap/viz/chart/components/util/HitTestUtils'
], function(
    oo,
    BaseHitTestDecorator,
    HitTestUtils
) {

    var isInCircle = HitTestUtils.isInCircle;
    var isInRect =  HitTestUtils.isInRect;

    var HitTestDecorator = function() {
        HitTestDecorator.superclass.constructor.apply(this, arguments);
        this._decos.hitTest = function(coord) {
            var datas = this._dataPointContext,
                x = coord.left,
                y = coord.top;
            var result;
            var size = this.getSize();
            var offset = this._offset;
            var startXRange = -offset.x;
            var startYRange = -offset.y;
            //Calculate a ratio in case user set a css transform especially scale on root chart div
            var plotBound = this._selection.select(".v-plot-bound").node();
            var ratio = plotBound.getBoundingClientRect().width / size.width;

            if (coord.hasOwnProperty("width") && coord.hasOwnProperty("height")) {
                var width = coord.width, height = coord.height;
                var plotWidth = size.width;
                if (ratio != 1){
                    plotWidth *= ratio;
                    // when big data with scroll bar, also need re-calculate startX/Y with ratio
                    startXRange *= ratio;
                    startYRange *= ratio;
                }
                result = datas.filter(function(e) {
                    var translate = e.data.translate.slice();
                    if (ratio != 1){
                        translate[0] *= ratio;
                        translate[1] *= ratio;
                    }

                    var boundStart = [x + startXRange, y + startYRange];
                    return translate[0] >= startXRange && translate[0] <= plotWidth + startXRange &&
                        isInRect(translate, boundStart, width, height);
                });
            } else {
                result = datas.filter(function(e) {
                    return isInCircle(e.data.translate, [x, y], 4);
                });
            }
            return result;
        };
    };

    oo.extend(HitTestDecorator, BaseHitTestDecorator);

    return HitTestDecorator;
});
define('sap/viz/chart/components/accessibility/ScatterDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator"
], function(
    oo,
    BaseDataPointNavigator
) {

    function ScatterDataPointNavigator() {
        ScatterDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._vSortedDatapoint = [];
        this._hSortedDatapoint = [];
    }

    oo.extend(ScatterDataPointNavigator, BaseDataPointNavigator);

    var prot = ScatterDataPointNavigator.prototype;

    prot.init = function() {
        if (this._series) {
            for (var i = 0; i < this._series.length; i++) {
                for (var j = 0; j < this._series[i].length; j++) {
                    this._vSortedDatapoint.push(this._series[i][j]);
                    this._hSortedDatapoint.push(this._series[i][j]);
                }
            }
            if (this._renderType.match(/^timeseries/)) {
                this._hSortedDatapoint.sort(function (a, b) {
                    return a.timeAxis[0].parsedValue - b.timeAxis[0].parsedValue;
                });
                this._vSortedDatapoint.sort(function (a, b) {
                    return a.valueAxis - b.valueAxis;
                });
            } else {
                this._hSortedDatapoint.sort(function (a, b) {
                    return a.valueAxis - b.valueAxis;
                });
                this._vSortedDatapoint.sort(function (a, b) {
                    return a.valueAxis2 - b.valueAxis2;
                });
            }
        }
    };

    prot.getFirstStartPoint = function() {
        if (this._series) {
            for (var i = 0; i < this._series.length; i++) {
                for (var j = 0; j < this._series[i].length; j++) {
                    if (this._isValidDataItem(this._series[i][j])) {
                        return this._series[i][j].dp;
                    }
                }
            }
        }
        return null;
    };

    prot.up = function(id) {
        return this._move(id, 1);
    };

    prot.down = function(id) {
        return this._move(id, -1);
    };

    prot.left = function(id) {
        return this._move(id, -1, true);
    };

    prot.right = function(id) {
        return this._move(id, 1, true);
    };

    prot.destroy = function() {
        ScatterDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._vSortedDatapoint  = null;
        this._hSortedDatapoint = null;
    };

    // Protected --------------------------------------------------------------

    prot._isValidDataItem = function(item){
        return item && item.valueAxis && (item.valueAxis2 || item.timeAxis);
    };

    prot._move = function(id, step, isHorizontal){
        var sortedDataPoints = isHorizontal ? this._hSortedDatapoint : this._vSortedDatapoint;
        var dp = this.getDataPoint(id);
        var orignalDP = this.locate(dp.address());
        var nextIdx = sortedDataPoints.indexOf(orignalDP) + step;
        var nextDp = sortedDataPoints[nextIdx];
        var len = sortedDataPoints.length;

        while (nextIdx >= 0 && nextIdx < len &&
                !nextDp) {
            nextIdx += step;
            nextDp = sortedDataPoints[nextIdx];
        }

        return nextDp ? nextDp.dp : null;
    };

    return ScatterDataPointNavigator;
});

define('sap/viz/chart/components/trendline/mixin/scatterPlot',[
    "sap/viz/framework/common/util/oo",
    'sap/viz/chart/components/trendline/mixin/columnPlot',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/trendline/Trendline"
], function(
    oo,
    ColumnPlotTrendLine,
    ObjectUtils,
    Trendline
) {
    function ScatterTrendLine(){

    }
    oo.extend(ScatterTrendLine, ColumnPlotTrendLine);
    
    var prot = ScatterTrendLine.prototype;
    prot._rasterizeTrendData = function(trendline, swapXY) {
        var raw = trendline.raw;
        return !swapXY ? raw : raw.map(function(d) {
            return {
                x: d.y,
                y: d.x
            };
        });
    };

    prot._getTrendlineRange = function(trendline, swapXY) {
        var raw = trendline.raw,
            key = swapXY ? "y" : "x",
            numPixels = swapXY ? this._realSize.height : this._realSize.width,
            start = raw[0][key],
            end = raw[0][key];

        raw.forEach(function(d) {
            var val = d[key];
            start = start < val ? start : val;
            end = end > val ? end : val;
        });

        return {
            start: start,
            end: end,
            step: (end - start) / numPixels
        };
    };

    prot._trendlineValueDomain = function(data, xRange) {
        var domains = {
            valueAxis: [],
            valueAxis2: []
        };
        this._getTrendLines(data);
        if(!this._trendlines){
            return [];
        }
        domains = this._trendlines.reduce(function(domains, tl) {
            if(!tl){
                return domains;
            }
            var series = tl.series,
                hasTimeAxis = Trendline.Utils.seriesAxisHasTime(series),
                key = "valueAxis", dom, aggregate, rangeData = tl.raw;
                
            if(xRange){
                rangeData = tl.raw.filter(function(raw){
                    return raw.x >= xRange[0] && raw.x <= xRange[1];
                });
            }
            if(!hasTimeAxis){
                var valueAxis1 = rangeData.map(function(d){
                    return d.x;
                });
                dom = [Math.min.apply(null, valueAxis1), Math.max.apply(null, valueAxis1)];
                aggregate = domains[key].concat(dom);
                domains[key] = [Math.min.apply(null, aggregate), Math.max.apply(null, aggregate)];
                key = "valueAxis2";
                dom = Trendline.domainPerTrendline(tl.fx, rangeData);
                aggregate = domains[key].concat(dom);
                domains[key] = [Math.min.apply(null, aggregate), Math.max.apply(null, aggregate)];
            }else {
                dom = Trendline.domainPerTrendline(tl.fx, rangeData);
                aggregate = domains[key].concat(dom);
                domains[key] = [Math.min.apply(null, aggregate), Math.max.apply(null, aggregate)];
            }
            return domains;
        }, domains);

        if (domains.valueAxis.length === 0) {
            delete domains.valueAxis;
        }
        if (domains.valueAxis2.length === 0) {
            delete domains.valueAxis2;
        }

        return domains;
    };

    prot._val2PosFns = function(seriesId, series, swapXY) {
        var xScale = this._xHandlers[0],
            yScale = this._yHandlers[0],
            w = this._realSize.width,
            h = this._realSize.height,
            xfn = function(val) {
                var percentage = xScale._scale.scale(val);
                return percentage * w;
            },
            yfn = function(val) {
                var percentage = yScale._scale.scale(val);
                return (1 - percentage) * h;

            };

        return swapXY ? {
            x: yfn,
            y: xfn
        } : {
            x: xfn,
            y: yfn
        };
    };

    prot._expandTrendlineXRange = function(timeAxisDomain){
        Trendline.expandTimeAxisDomain(timeAxisDomain, this._trendlines);
    };
    
    return ScatterTrendLine;
});

define('sap/viz/chart/components/plots/ScatterPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/ValueScale',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/components/datalabels/ScatterDataLabels',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/model/DataPointInfo',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/chart/components/renderers/GridlineRenderer',
    'sap/viz/chart/components/renderers/ScatterRenderer',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/plots/ProjectionHelper',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/decorator/HitTestDecorator',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/util/ValueAxisUtils',
    "sap/viz/chart/components/plots/PlotGeometryKeeper",
    'sap/viz/chart/util/PropertyUtils',
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/ScatterDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    'sap/viz/chart/components/trendline/mixin/scatterPlot'
], function(
    oo,
    ValueScale,
    Constants,
    TypeUtils,
    ScatterDataLabels,
    BasePlot,
    ScaleHandler,
    DataPointInfo,
    Series,
    GridlineRenderer,
    ScatterRenderer,
    SVG,
    FiscalUtil,
    ObjectUtils,
    ProjectionHelper,
    DataPointUtils,
    DataHandler,
    HitTestDecorator,
    ContextBuilder,
    ValueAxisUtils,
    PlotGeometryKeeper,
    PropertyUtils,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants,
    ScatterPlotTrendLine
) {

    var DEFAULT_MARK_SIZE = 10,
        MIN_MARK_SIZE = 4,
        MAX_MARK_SIZE = 32,
        DATAPOINT_BORDER_COLOR = '#ffffff',
        DEFAULT_SHAPE = "circle",
        DEFAULT_BORDER_WIDTH = 1,
        BIG_DATA_MAX_AREA = 4000000;
        

    var MathMin = Math.min,
        MathMax = Math.max;

    var CSSCLASS = Constants.CSS.CLASS;
    /**
     * To initialize ScatterPlot object.
     *
     * @name ScatterPlot
     * @constructor
     */
    var ScatterPlot = function(runtime, options) {
        this._renderType = options.renderType;
        ScatterPlot.superclass.constructor.apply(this, arguments);
        this._dataPointRenderer = ScatterRenderer;
        this._markerSize = null;
        this._shapePalette = null;
        this._dpStrokeVisible = null;
        this._dpStrokeColor = null;
        this._dpOpacity = null;
        this._drawingEffect = null;
        this._markerSizeDirty = true;
        this._dpStrokeColorDirty = true;
        this._bigDataThreshold = 10000;
        this._syncHighlightThreshold = 4000;
        this._dataPointContext = [];
    };
    
    oo.extend(ScatterPlot, BasePlot);

    var prot = ScatterPlot.prototype;

    // New Public -----------------------------------------------------------------------

    prot.setLastSeries = function(context, andRefresh) {
        var series = this._series;
        var length = series.length;
        if (!length) {
            return;
        }
        var i = length;
        while (i--) {
            var cur = series[i];
            if (ObjectUtils.deepEqual(context, cur.getContext())) {
                if (i !== length - 1) {
                    //swap the series to the last position
                    var tmp = series[length - 1];
                    series[length - 1] = cur;
                    series[i] = tmp;
                    if (andRefresh) {
                        this.refresh();
                    }
                }
                break;
            }
        }
    };

    //TODO: Not considering data labels here.
    prot.refresh = function() {
        var series = this._series;
        for (var i = series.length; i--;) {
            var dataPoints = series[i].getDataPoints();
            for (var j = dataPoints.length; j--;) {
                var dataPointModel = dataPoints[j];
                if (dataPointModel) {
                    dataPointModel.setNode(null);
                }
            }
        }
        var dpGroupNode = this._selection.node().querySelector("." + CSSCLASS.DATAPOINT_GROUP);
        var opacity = dpGroupNode.getAttribute("fill-opacity");
        var parent = dpGroupNode.parentNode;
        parent.removeChild(dpGroupNode);
        dpGroupNode = SVG.create("g");
        dpGroupNode.setAttribute("class", CSSCLASS.DATAPOINT_GROUP);

        this._showDatapoints(dpGroupNode);
        this._postRender(dpGroupNode);
        if (opacity){
            dpGroupNode.setAttribute("fill-opacity", opacity);
            dpGroupNode.setAttribute("stroke-opacity", opacity);
        }
        parent.appendChild(dpGroupNode);

        var dataLabelNode = this._selection.node().querySelector("." + CSSCLASS.DATALABEL_GROUP);
        if (dataLabelNode) {
            parent = dataLabelNode.parentNode;
            parent.removeChild(dataLabelNode);
        }
        this._drawDataLabels(d3.select(parent), dpGroupNode);
    };

    // Overrided ---------------------------------------------------------------------

    prot.destroy = function() {
        ScatterPlot.superclass.destroy.call(this);
        this._dataPointRenderer = null;
        this._markerSize = null;
        this._shapePalette = null;
        this._dpStrokeVisible = null;
        this._dpStrokeColor = null;
        this._dpOpacity = null;
        this._drawingEffect = null;
        this._markerSizeDirty = true;
        this._dpStrokeColorDirty = true;
        this._timeField = null;
    };

    prot._getDataLabels = function(name, runtime) {
        return new ScatterDataLabels(runtime, {
            name: name
        });
    };

    prot._getXHandlers = function() {
        var bottomAxisName = this._getBottomAxisName();
        var options = {
            isHorizontal: true,
            alignment: "right"
        };
        var handler = this._hasTimeAxis() ?
                ScaleHandler.getTimeScaleHandler(bottomAxisName, options) :
                ScaleHandler.getValueScaleHandler(bottomAxisName, options);
        return [handler];
    };

    prot.isDisableSyncHightlight = function () {
        return (this._hasTimeAxis() && (this.getDataPointCount() >
            this._syncHighlightThreshold));
    };

    prot._getYHandlers = function() {
        var leftAxisName = this._getLeftAxisName();
        return [ScaleHandler.getValueScaleHandler(leftAxisName, {
            isHorizontal: false
        })];
    };

    prot._getAxisPosition = function(handlers, seriesIndex, itemIndex, data) {
        var handler = handlers[0];
        var handlerId = handler.id;
        var scaleOption = {
            index: itemIndex,
            seriesIndex: seriesIndex,
            dataHandler: this._dataHandler[handlerId]
        };
        return handler.scale(data[handlerId], scaleOption);
    };

    prot.getDataPointCount = function () {
        var dataPointCount = 0;
        var series = this._getSeries();
        for (var seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
            var seriesItem = series[seriesIndex];
            dataPointCount += seriesItem ? seriesItem.length : 0;
        }
        return dataPointCount;
    };

    prot._drawDatapoints = function(parent) {
        var series = this._getSeries();

        for (var dhID in this._dataHandler) {
            if (this._dataHandler[dhID].reset) {
                this._dataHandler[dhID].reset();
            }
        }
        var properties = this._properties;
        this._markerSize = properties.get('markerSize');
        this._markerSizeDirty = true;
        this._shapePalette = properties.get("shapePalette");
        this._dpStrokeVisible = properties.get('dataPoint.stroke.visible');
        this._dpStrokeColor = properties.get('dataPoint.stroke.color');
        this._dpStrokeColorDirty = true;
        this._dpOpacity = properties.get('dataPoint.opacity');
        this._drawingEffect = properties.get('drawingEffect');

        var countId = 0;

        var seriesIndex;
        var itemIndex;

        //variables used in loops
        var seriesItem;
        var seriesModel;
        var data;
        var dataPointModel;
        var position;
        var dpConfig;
        var dpData;
        var seiresLength = series.length;
        var itemLength;

        var dataPointCount = this.getDataPointCount();
        //Threshold to define big data mode of scatter chart. If chart size is too big, we should 
        // forbid pixel map, which cause too much memory 
        this._isBigData = (dataPointCount > this._bigDataThreshold) &&
            (this._realSize.width * this._realSize.height < BIG_DATA_MAX_AREA);
        var dpCtxs = this._dataPointContext;
        for (seriesIndex = 0; seriesIndex < seiresLength; seriesIndex++) {
            seriesItem = series[seriesIndex];
            if (!seriesItem) {
                continue;
            }
            seriesModel = null;
            itemLength = seriesItem.length;
            for (itemIndex = 0; itemIndex < itemLength; itemIndex++) {
                data = seriesItem[itemIndex];
                if (!data) {
                    continue;
                }
                position = this._getPosition(seriesIndex, itemIndex, data);
                if (!position) {
                    continue;
                }
                seriesModel = seriesModel || new Series();
                dpConfig = this._buildWrapperConfig(data, position);
                dpData = this._buildData(dpConfig);
                dataPointModel = this._createDataPoint(seriesIndex, itemIndex,
                    dpConfig, dpData, position, countId, data);
                seriesModel.setDataPoint(itemIndex, dataPointModel);
                dpCtxs[data.dp.id] = dpConfig;
                countId++;
            }
            if (seriesModel) {
                seriesModel.setContext(
                    ContextBuilder.buildSeriesContext(this._data, seriesIndex, ["color", "shape"])
                );
            }
            this._series[seriesIndex] = seriesModel;
        }
        if (this._series.every(function(seriesModel) {
                return seriesModel == null;
            })) {
            this._series = [];
        }

        var dataPointG = SVG.create("g");
        dataPointG.setAttribute("class", CSSCLASS.DATAPOINT_GROUP);
        this._showDatapoints(dataPointG);
        this._postRender(dataPointG);
        parent.node().appendChild(dataPointG);
        this._drawDataLabels(parent, dataPointG);
    };

    prot._buildWrapperConfig = function(data, position, context) {
        var dpConfig;
        if (this.isBigDataMode() && context == null) {
            var shape = this._getShape(data);
            var markerSize = this._getMarkerSize();
            dpConfig = {
                rawData: data,
                graphic: {
                    width: markerSize,
                    height: markerSize,
                    borderWidth: DEFAULT_BORDER_WIDTH,
                    shape: shape
                },
                data: {
                    translate: [position.x, position.y]
                }
            };
        } else {
            var ctx = context || data.dp.context();
            dpConfig = ScatterPlot.superclass._buildWrapperConfig.call(this, data, position, ctx);
        }
        if(this._data.timeAxis){
            dpConfig.timeField = this._getTimeField();
        }
        if (this._isBigData) {
            dpConfig.isBigData = true;
        }
        return dpConfig;
    };


    prot._preShowDatapoints = function() {
        var size = this._realSize;
        var series = this._series;
        var props = this._properties;

        // initialize pixel board
        var pixelBoard = ProjectionHelper.createPixelBoard(size.width, size.height, {
            layerLimit: 1,
            visibleThreshold: 6
        });

        // go through data points in reverse order to make sure later datapoints covers the earlier ones
        for (var i = series.length; i--;) {
            var dataPoints = series[i].getDataPoints();

            for (var j = dataPoints.length; j--;) {
                var dataPointModel = dataPoints[j];

                if (dataPointModel) {
                    var position = dataPointModel.getPosition();
                    var x = Math.round(position.x);
                    var y = Math.round(position.y);

                    var gConfig = dataPointModel.getConfig().graphic;
                    var halfBorderWidth = gConfig.borderWidth / 2;
                    var rx = Math.round(gConfig.width / 2 + halfBorderWidth);
                    var ry = Math.round(gConfig.height / 2 + halfBorderWidth);
                    var visible = ProjectionHelper.isAreaVisible(pixelBoard, gConfig, x, y, rx, ry);

                    dataPointModel.setVisible(visible);
                }
            }
        }
    };

    prot._showDatapoints = function(dataPointG) {
        if (this.isBigDataMode()) {
            this._preShowDatapoints();
        }
        this._renderDataPoints(dataPointG);
    };

    prot._renderDataPoints = function(dataPointG) {
        var series = this._series;
        var seriesLength = series.length;
        var dpCtxs = this._dataPointContext;
        for (var seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {
            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
            var seriesItem = series[seriesIndex];
            if(!seriesItem){
                continue;
            }
            var dataPoints = seriesItem.getDataPoints();
            var dataPointsLength = dataPoints.length;
            for (var itemIndex = 0; itemIndex < dataPointsLength; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }

                //rebuild data config and context
                var data = dataPointModel.getConfig().rawData;
                if (data /*this._isBigData*/ ) {
                    var position = dataPointModel.getPosition();
                    var dpConfig = this._buildWrapperConfig(data, position, data.dp.context());
                    var dpData = this._buildData(dpConfig);
                    dataPointModel.setConfig(dpConfig);
                    dataPointModel.setData(dpData);
                    dpCtxs[data.dp.id] = dpConfig;
                }

                if(!dataPointModel.isVisible()){
                    continue;
                }

                var dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                dataPointModel.setNode(dpNode);
                if (dpNode) {
                    dataPointG.appendChild(dpNode);
                }
            }
        }
    };

    prot.isBigDataMode = function() {
        return this._isBigData;
    };

    prot.update = function(scale) {
        this._applyChanges();
        this._dataLabels.setSize(this._realSize);
        var selection = this._selection.select(".v-plot-main");
        this._drawGridlines(this._selection);
        this._updateDatapoints(selection);
    };

    prot._redrawReferenceLine = function (offset) {
        //time series bubble need to redraw reference line.
    };

    prot.scroll = function(offset) {
        this._setOffset(offset);
        if (!this._selection) {
            return;
        }

        if (!this._isInTrellis) {
            var parent = this._selection.select("g.v-plot-main");
            var transformStr = "translate(" + this._offset.x + ", " + this._offset.y + ")";
            parent.node().setAttribute("transform", transformStr);
        }
        // this._applyScroll();
        this._redrawReferenceLine(offset);
        this._repositionReferenceLine();
        this.renderTrendlines(this._selection);
        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };

    prot._updateDatapoints = function(parent) {
        for (var dhID in this._dataHandler) {
            if (this._dataHandler[dhID].reset) {
                this._dataHandler[dhID].reset();
            }
        }
        var series = this._series;
        for (var i = series.length; i--;) {
            var seriesItem = series[i];
            if (!seriesItem) {
                continue;
            }
            var dpRenderer = this._getDataPointRenderer(i);
            if (!dpRenderer) {
                continue;
            }
            var dataPoints = series[i].getDataPoints();
            for (var j = dataPoints.length; j--;) {
                var data = dataPoints[j];
                if (!data) {
                    continue;
                }
                var rawData = data.getRawData();
                if (!rawData) {
                    continue;
                }
                var position = this._getPosition(i, j, rawData);
                if (!position) {
                    continue;
                }
                data.setPosition(position);
                var dpConfig = data.getConfig();
                dpConfig.data.translate = [position.x, position.y];
                if (!data.isVisible()){
                    continue;
                }
                var node = data.getNode();
                if (!node) {
                    continue;
                }
                this._updateDatapoint(node, dpRenderer, dpConfig, position);
            }
        }
        var dataPointNodes = parent.selectAll('.' + CSSCLASS.DATAPOINT)[0];
        this._dataLabels.updatePosition(parent, dataPointNodes);
    };

    prot._updateDatapoint = function(dataPointG, dpRenderer, dpConfig, position) {
        if (dpRenderer.update && TypeUtils.isFunction(dpRenderer.update)) {
            dpRenderer.update(dataPointG, dpConfig);
        }
        if (position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            dataPointG.setAttribute("transform", 'translate(' + position.x + ', ' + position.y +
                ')');
        }
    };

    prot._createDataPoint = function(seriesIndex, itemIndex, dpConfig, dpData, position,
            currentId, data, onlyOneMndIndex) {
        var dataPoint = new DataPointInfo(seriesIndex, itemIndex, null, -1);
        dataPoint.init(dpConfig, currentId, dpData, data && data.dp && data.dp.id ? data.dp.id
                : Constants.NULL_VALUE, onlyOneMndIndex);
        dataPoint.setPosition(position);
        dataPoint.setRawData(data);
        return dataPoint;
    };

    prot._drawGridlines = function(parent) {
        var size = this._realSize;
        var direction = Constants.DIRECTION.HORIZONTAL;
        var props = this._properties.proxy('gridline');
        var range = [size.height, 0];
        var leftAxisName = this._getLeftAxisName();
        var data = this._data[leftAxisName];
        var scale = new ValueScale(data.scale.getDomain(), range);
        scale.setTickHint(data.tickHint);
        GridlineRenderer.drawValueGridline(parent, size.width, size.height, scale, props, direction,
            this.runtime().effectManager());
    };

    prot._getDataHandler = function() {
        return this._hasTimeAxis() ? {
            "valueAxis": DataHandler.getHandler()
        } : {
            "valueAxis": DataHandler.getHandler(),
            "valueAxis2": DataHandler.getHandler()
        };
    };

    prot.getDataPointPosition = function(seriesIndex, itemIndex) {
        var data = this._data.series[seriesIndex][itemIndex];
        var position = this._getPosition(seriesIndex, itemIndex, data);
        position.height = 0;
        return position;
    };

    //TODO: Could merge these two function into one getStyle and use a common flag,
    //      if there's more.
    prot._getMarkerSize = function() {
        if (!this._markerSizeDirty) {
            return this._markerSize;
        }
        var markerSize = this._markerSize;
        if (!(TypeUtils.isExist(markerSize) && MIN_MARK_SIZE <= markerSize && markerSize <= MAX_MARK_SIZE)) {
            markerSize = DEFAULT_MARK_SIZE;
        }
        this._markerSizeDirty = false;
        this._markerSize = markerSize;
        return markerSize;
    };

    prot._getBorderColor = function() {
        if (!this._dpStrokeColorDirty) {
            return this._dpStrokeColor;
        }
        var borderColor;
        if (this._dpStrokeVisible === true) {
            borderColor = this._dpStrokeColor;
        } else {
            borderColor = DATAPOINT_BORDER_COLOR;
        }
        this._dpStrokeColorDirty = false;
        this._dpStrokeColor = borderColor;
        return borderColor;
    };

    prot._getColor = function(data){
        var color = null;
        if(this._data.color){
            var domain = data.color;
            if(domain && domain.length){
                var depth = PropertyUtils.getBubbleDepth(this._properties, "colorDepth", domain);
                domain = domain.slice(0, depth);
            }
            color = this._data.color.scale.scale(domain);
        }
        return color;
    };

    prot._getShape = function(data) {
        var shape;
        if (data.hasOwnProperty("shape")) {
            var domain = data.shape;
            if(domain && domain.length){
                var depth = PropertyUtils.getBubbleDepth(this._properties, "shapeDepth", domain);
                domain = domain.slice(0, depth);
            }
            shape = this._data.shape.scale.scale(domain);
        } else {
            var shapePalette = this._shapePalette || [];
            shape = shapePalette.length ? shapePalette[0] : DEFAULT_SHAPE;
        }
        return shape;
    };

    prot._buildConfig = function(data, position, context) {
        var properties = this._properties;

        var color = this._getColor(data);
        var shape = this._getShape(data);

        var markerSize = this._getMarkerSize();
        var borderColor = this._getBorderColor();

        var config = {
            graphic: {
                drawingEffect: this._drawingEffect,
                fill: color,
                shape: shape,
                width: markerSize,
                height: markerSize,
                borderColor: borderColor,
                borderWidth: DEFAULT_BORDER_WIDTH,
                opacity: this._dpOpacity
            },
            data: {
                color: color,
                shape: shape,
                translate: [position.x, position.y]
            },
            ctx: context,
            effectManager: this._effectManager
        };
        return config;
    };

    prot._buildData = function(dpConfig) {
        var graphic = dpConfig.graphic;
        var ret = {
            color: graphic.fill,
            shape: graphic.shape,
            borderColor: graphic.borderColor
        };
        if(this._data.timeAxis){
            ret.timeField = dpConfig.timeField = this._getTimeField();
        }
        return ret;
    };

    (new HitTestDecorator()).decorate(ScatterPlot);

    //Protected------------------------------------------------------
    prot._hasTimeAxis = function(){
        return /timeseries/.test(this._renderType);
    };

    prot._getBottomAxisName = function(){
        return this._hasTimeAxis() ? 'timeAxis' : 'valueAxis';
    };

    prot._getLeftAxisName = function(){
        return this._hasTimeAxis() ? 'valueAxis' : 'valueAxis2';
    };

    prot._getTimeField = function(){
        if(!this._timeField && this._data && this._data.timeAxis){
            this._timeField = this._data.timeAxis.metaData.map(function(e){
                return e.id;
            });
        }
        return this._timeField;
    };

    prot._recordPlotWindow = function() {
        var oWindow = this._properties.get("window"),
            visibleRange = this.getVisibleRange();

        if (visibleRange.x || visibleRange.y) {
            this.runtime().statusManager().set("plotArea.window", oWindow);
        }
    };

    prot.getVisibleRange = function() {
        var rangeInfo = {};
        var isInteractive = !this._properties.origin.get("interaction.noninteractiveMode");
        if (isInteractive) {
            var start = this._properties.get("window.start") || {},
            end = this._properties.get("window.end") || {},
            domain, xdomain, ydomain;

            var handle = function(prop) {
                if (this._hasTimeAxis()) {
                    xdomain = this._data.timeAxis.scale.getDomain();
                    ydomain = this._data.valueAxis.scale.getDomain();
                }else{
                    xdomain = this._data.valueAxis.scale.getDomain();
                    ydomain = this._data.valueAxis2.scale.getDomain();    
                }

                var result = prop;
                if( prop === Constants.PLOTAREA.FIRST_DATAPOINT){
                    if (this._hasTimeAxis()) {
                        result = {timeAxis: xdomain[0], valueAxis:ydomain[0]};
                    }else{
                        result = {valueAxis: xdomain[0], valueAxis2:ydomain[0]};
                    }
                }else if( prop === Constants.PLOTAREA.LAST_DATAPOINT){
                    if (this._hasTimeAxis()) {
                        result = {timeAxis: xdomain[1], valueAxis:ydomain[1]}; 
                    }else{
                        result = {valueAxis: xdomain[1], valueAxis2:ydomain[1]}; 
                    }
                }
                return result;
            };

            var values = FiscalUtil.startEndConvertor(start, end, this._properties.origin);
            start = handle.call(this, values.start);
            end = handle.call(this, values.end);

            if (this._hasTimeAxis()) {
                if (start.hasOwnProperty("timeAxis") || end.hasOwnProperty("timeAxis")) {
                    domain = this._data.timeAxis.scale.getDomain();
                    rangeInfo.x = ValueAxisUtils.visibleRangeTransform(domain,
                                                                       (new Date(start.timeAxis)).getTime(),
                                                                       (new Date(end.timeAxis)).getTime());
                }
                if (start.hasOwnProperty("valueAxis") || end.hasOwnProperty("valueAxis")) {
                    domain = this._data.valueAxis.scale.getDomain();
                    rangeInfo.y = ValueAxisUtils.visibleRangeTransform(domain, start.valueAxis, end.valueAxis);
                }
            } else {
                if (start.hasOwnProperty("valueAxis") || end.hasOwnProperty("valueAxis")) {
                    domain = this._data.valueAxis.scale.getDomain();
                    rangeInfo.x = ValueAxisUtils.visibleRangeTransform(domain, start.valueAxis, end.valueAxis);
                }
                if (start.hasOwnProperty("valueAxis2") || end.hasOwnProperty("valueAxis2")) {
                    domain = this._data.valueAxis2.scale.getDomain();
                    rangeInfo.y = ValueAxisUtils.visibleRangeTransform(domain, start.valueAxis2, end.valueAxis2);
                }
            }
        }
        return rangeInfo;
    };

    prot.isHorizontal = function() {
        return (this._options.isHorizontal === true);
    };
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.TIMESCATTER, DataPointNavigator);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.SCATTER, DataPointNavigator);
    (new ScatterPlotTrendLine()).inject(ScatterPlot.prototype);
    return ScatterPlot;
});

define('sap/viz/chart/components/datalabels/BubbleDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/ScatterDataLabels',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/lang/LangManager",
    'sap/viz/chart/components/datalabels/DataLabels',
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/DataUtils'
], function(
    oo,
    ScatterDataLabels,
    DataPointUtils,
    LangManager,
    DataLabels,
    TextUtils,
    TypeUtils,
    DataGraphics,
    DataUtils
) {

    /**
     * To initialize BubbleDataLabels object.
     *
     * @name BubbleDataLabels
     * @constructor
     */
    var ID_BUBBLE_WIDTH = "bubbleWidth";
    var ID_REGION_COLOR = "color";
    var ID_REGION_COLOR_OLD = "regionColor";
    var ID_REGION_SHAPE = "shape";
    var ID_REGION_SHAPE_OLD = "regionShape";
    

    var BubbleDataLabels = function(runtime, options) {
        BubbleDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = "inside";
        this._needDateFormat = false;
    };

    oo.extend(BubbleDataLabels, ScatterDataLabels);

    var prot = BubbleDataLabels.prototype;

    prot.destroy = function() {
        BubbleDataLabels.superclass.destroy.call(this);
        this._labelPosition = null;
        this._timeBindingId = null;
        this._datalabel_type = null;
        this._needDateFormat = false;
    };
    
    prot.getBound = function(){
        var bound;

        if (this._isTrellis) {
            bound = {
                left: 0 - this._trellisPadding.left,
                width: this._trellisCellSize.width,
                top: 0 - this._trellisPadding.top,
                height: this._trellisCellSize.height
            };
        } else {
            bound = BubbleDataLabels.superclass.getBound.call(this);
        }
        return bound;
        
    };

    
    prot.setTimeBindingId = function (val) {
        this._timeBindingId = val;
    };

    prot._isPrimary = function(type){
        return this._hasTimeAxis() ? type === 'timeAxis' : type === 'valueAxis';
    };

    prot._isSecondary = function(type){
        return this._hasTimeAxis() ? type === 'valueAxis' : type === 'valueAxis2';
    };

    prot._getDataLabelInfo = function(node) {
        var ctx = DataPointUtils.getContextByDataModel(node, this._data);
        this._datalabel_type = this._properties.get("type");
        //support old feed id
        //TODO move it in chart migration 
        if (this._datalabel_type === ID_REGION_COLOR_OLD){
            this._datalabel_type = ID_REGION_COLOR;
        }else if(this._datalabel_type === ID_REGION_SHAPE_OLD){
            this._datalabel_type = ID_REGION_SHAPE;
        }
        
        var key, value;
        if (this._data.hasOwnProperty(this._datalabel_type) && this._data[this._datalabel_type].metaData) {
            key = this._data[this._datalabel_type].metaData[0].id;
            value = ctx[key];
            if(value === null){
                value = undefined;
            }
            return {
                key: key,
                value: value
            };
        } else {
            if (this._data.hasOwnProperty(ID_BUBBLE_WIDTH) && this._data[ID_BUBBLE_WIDTH].metaData) {
                key = this._data[ID_BUBBLE_WIDTH].metaData[0].id;
                value = ctx[key];
                return {
                    key: key,
                    value: value === null ? undefined : value
                };
            }
            return {key: null, value: undefined};
        }
    };

    prot._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx, isMetaDataFormat) {
        return DataLabels.buildDataLabelText(
            this._properties,
            formatPatterns,
            dataLabelInfo,
            dataLabelCtx,
            isMetaDataFormat,
            getTypes.bind(this),
            mergeDataLabels.bind(this),
            buildDataLabelAdditionalText.bind(this)
        );
    };

    function getTypes(properties) {
        var type = properties.get('type');
        var result;
        if (type === 'color' || type === 'shape') {
            result = [type];
        } else if (this._isPrimary(type) && (this._hasTimeAxis() || this._timeBindingId)) {
            result = ['date'];
            this._needDateFormat = true;
        } else {
            //type is "bubbleWidth", "valueAxis" or "valueAxis2"
            result = ['value'];
        }
        return result;
    }

    function buildDataLabelAdditionalText(ctx, dataLabelInfo) {
        var text = '';
        var metaData, temp, len;
        if (this._data.hasOwnProperty(this._datalabel_type) && this._data[this._datalabel_type].metaData) {
            metaData = this._data[this._datalabel_type].metaData;
            len = metaData ? metaData.length : 0;
        }
        for (var i = 0; i < len; i++) {
            temp = ctx[metaData[i].id + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX] || ctx[metaData[i].id];
            text += TypeUtils.isString(temp) || !TypeUtils.isNaN(temp) ? temp : LangManager.get('IDS_ISNOVALUE');
            if (i < len - 1) {
                text += '-';
            }
        }
        return text;
    }


    function mergeDataLabels(properties, formattedArray, dataLabelInfo) {
        var type = properties.get('type');
        var dataLabelText;
        if (type === "color" || type === "shape") {
            dataLabelText = formattedArray[0];
        } else if ((type === "valueAxis" || type === "valueAxis2" || type === 'bubbleWidth') && this._needDateFormat) {
            dataLabelText = formattedArray[0];
        } else {
            dataLabelText = TypeUtils.isNaN(dataLabelInfo.value) ?
                LangManager.get('IDS_ISNOVALUE') : formattedArray[0];
        }
        return dataLabelText;
    }

	prot._processDataLabelRendererConfig = function(config, dp) {
        var shapeBBox = this._fixBBoxWhenInvisible(dp),
            style = this._properties.get("style"),
            truncatedText;
        var respectShapeWidth = this._properties.get("respectShapeWidth");
        if (respectShapeWidth) {
            if ((this._isPrimary(this._datalabel_type) && !this._timeBindingId) || 
                this._isSecondary(this._datalabel_type) || 
                this._datalabel_type === ID_BUBBLE_WIDTH) {
                var fontSize = style.fontSize;
                if(!TypeUtils.isNaN(fontSize)) {
                    fontSize += 'px';
                }
                var labelSize = TextUtils.fastMeasure(config.text, fontSize, style.fontWeight, style.fontFamily);
                if (labelSize.width > shapeBBox.width) {
                    config.text = '';
                }
                return;
            }

            var ellipsisOptions = {};
            var envManager = this.runtime().envManager();
            ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

            truncatedText = TextUtils.ellipsis(config.text, undefined, shapeBBox.width, config.styles.cssString,
                ellipsisOptions);
            if (truncatedText !== config.text && truncatedText.indexOf('...') >= 0 && truncatedText.length < 6) {
                truncatedText = '';      
            }
            config.text = truncatedText;
        }
	};
	
	// According to UX design, one bubble is covered by others when the other reach center within 3px.
	var CENTER_OFFSET = 3;
	prot.hideConditional = function(dataLabelInfos) {
        var len = dataLabelInfos.length;
        for( var k = 0; k < len; ++k){
            var info = dataLabelInfos[k];
            var curCenter = info.center;
            for ( var t = k + 1; t < len; ++t) {
                var tempCenter = dataLabelInfos[t].center;
                
                var r = DataGraphics.getData(dataLabelInfos[t].dataPoint).width / 2 + CENTER_OFFSET;
                if ((curCenter.x - tempCenter.x) * (curCenter.x - tempCenter.x) +
                        (curCenter.y - tempCenter.y) * (curCenter.y - tempCenter.y) <= r * r ) {
                    info.skip = true;
                    break;
                }
            }
        }
        BubbleDataLabels.superclass.hideConditional.call(this, dataLabelInfos);

     
    };

    prot.sortDataLabelInfos = function(dataLabelInfos) {
        //do not sort bubble by dataID since its datapoint has been already sorted by bubble size
    };

    return BubbleDataLabels;
});

define('sap/viz/chart/scales/SizeScaleUtil',["sap/viz/framework/common/util/NumberUtils"],
    function(NumberUtils) {

        var MIN_MARKER_SIZE = 4;
        var DEFAULT_MARKER_SIZE = 10;

        var Scaler = {

            build: function(minMarkerSize, maxSize, domain) {

                var minSize;
                if (minMarkerSize) {
                    if (minMarkerSize < 0) {
                        minMarkerSize = DEFAULT_MARKER_SIZE;
                    }
                    minSize = minMarkerSize <= maxSize ? minMarkerSize : DEFAULT_MARKER_SIZE;
                }

                var vMin = domain[0],
                    vMax = domain[1];
                var withNoValue = domain.withNoValue ? domain.withNoValue : false;

                return function(value) {
                    if (isNaN(value) || (isNaN(vMax) && isNaN(vMin))) {
                        return minSize ? minSize : MIN_MARKER_SIZE;
                    }
                    if (vMin === vMax) {
                        if (withNoValue) {
                            return maxSize;
                        } else {
                            return DEFAULT_MARKER_SIZE;
                        }
                    }
                    var r;
                    if (minSize) {
                        if (vMax > vMin && value >= vMin && value <= vMax) {
                            r = Math.pow((Math.abs(value) - vMin) / (vMax - vMin), 0.5) * (maxSize - minSize) + minSize;
                        } else {
                            r = minSize;
                        }
                    } else {
                        r = Math.pow(Math.abs(value) / vMax, 0.5) * maxSize;
                    }
                    return r > MIN_MARKER_SIZE ? r : MIN_MARKER_SIZE;
                };
            }
        };

        return Scaler;
    });

define('sap/viz/chart/components/plots/BubblePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/chart/components/plots/ScatterPlot',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/components/plots/model/DataPointInfo',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/chart/components/renderers/ScatterRenderer',
    'sap/viz/chart/components/datalabels/BubbleDataLabels',
    'sap/viz/chart/scales/SizeScaleUtil',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/plots/ProjectionHelper',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/util/BoundingBoxUtils"
], function(
    oo,
    DrawUtil,
    NumberUtils,
    ScatterPlot,
    SVG,
    TypeUtils,
    Constants,
    DataPointInfo,
    Series,
    ScatterRenderer,
    BubbleDataLabels,
    SizeScaleUtil,
    DataGraphics,
    ProjectionHelper,
    ObjectUtils,
    BoundingBoxUtils
) {

    /**
     * To initialize BubblePlot object.
     *
     * @name BubblePlot
     * @constructor
     */
    function BubblePlot(runtime, options) {
        BubblePlot.superclass.constructor.apply(this, arguments);
        this._seletedSeries = [];
        this._semanticMgr.setUseSemanticPattern(true);

        //no big data mode for time bubble
        if(this._renderType && this._renderType.indexOf("time") > -1){
            this._bigDataThreshold = Infinity;
        }
    }

    oo.extend(BubblePlot, ScatterPlot);

    var MIN_MARKER_SIZE = 4;

    var DEFAULT_BORDER_WIDTH = 1;

    var prot = BubblePlot.prototype;

    // New Public ---------------------------------------------------------------------

    prot.setSizeScale = function(sizeScale) {
        this._widthScale = sizeScale;
    };

    prot.getWidthScale = function() {
        return this._widthScale;
    };

    prot._getOrderMap = function() {
        return this._data.orderMap;
    };

    prot.setLastSeries = function(context, andRefresh) {
        var series = this._series;
        var length = series.length;
        if (!length) {
            return;
        }
        var i = length;
        while (i--) {
            var cur = series[i];
            if (ObjectUtils.deepEqual(context, cur.getContext())) {
                var index = this._seletedSeries.indexOf(i);
                if (index !== -1) {
                    this._seletedSeries.splice(index, 1);
                }
                this._seletedSeries.push(i);
                if (andRefresh && length > 1) {
                    this.refresh();
                }
                break;
            }
        }
    };

    // Overrided ---------------------------------------------------------------------

    prot.destroy = function() {
        BubblePlot.superclass.destroy.call(this);
        this._widthScale = null;
        this._seletedSeries = [];
    };

    var sortFunction = function(a, b) {
        return b - a;
    };

    prot._getSortedSeries = function() {
        var orderMap = this._getOrderMap();
        var series = this._series;
        var sortedKeys;

        sortedKeys = Object.getOwnPropertyNames(orderMap);

        sortedKeys.sort(sortFunction);

        return sortedKeys;
    };

    prot._buildConfig = function(data, position, context) {
        var config = BubblePlot.superclass._buildConfig.apply(this, arguments);
        var size = MIN_MARKER_SIZE;
        // data.bubbleWidth === null is also a valid case (null value handling)
        if (data.hasOwnProperty('bubbleWidth')) {
            size = Math.max(MIN_MARKER_SIZE, this._widthScale(data.bubbleWidth));
        }
        config.graphic.width = size;
        config.graphic.height = size;
        config.graphic.opacity = this._dpOpacity;

        return config;
    };

    prot._getFillColorConfig =  function(config, context, options, data){
        var negativeValue = data.bubbleWidth < 0;
        this._semanticMgr.setUseSemanticPattern(!negativeValue);
        BubblePlot.superclass._getFillColorConfig.apply(this, arguments);

        if (negativeValue) {
            config.graphic.fillOpacity = 0;
            config.graphic.opacity = 1;
            config.graphic.borderColor = config.graphic.fill;
        }
        config.data.negativeValue = negativeValue;
        this._semanticMgr.setUseSemanticPattern(true);
        return config;
    };

    prot._buildWrapperConfig = function(data, position, context) {
        var dpConfig;
        if (this._isBigData && context == null) {
            var shape = this._getShape(data);

            var size = MIN_MARKER_SIZE;
            var negativeValue = false;
            if (data.hasOwnProperty("bubbleWidth")) {
                size = Math.max(MIN_MARKER_SIZE, this._widthScale(data.bubbleWidth));
                negativeValue = data.bubbleWidth < 0;
            }

            dpConfig = {
                graphic : {
                    width : size,
                    height : size,
                    borderWidth : DEFAULT_BORDER_WIDTH,
                    shape : shape
                },
                data : {
                    negativeValue : negativeValue,
                    translate: [position.x, position.y]
                }
            };

        } else {
            dpConfig = BubblePlot.superclass._buildWrapperConfig.apply(this, arguments);
        }
        return dpConfig;
    };

    prot._showDatapoints = function(dataPointG) {
        if (this._isBigData) {
            this._renderBigVolumeDataPoints(dataPointG);
        }else{
            this._renderDataPoints(dataPointG);
        }
    };

    prot._renderBigVolumeDataPoints = function(dataPointG) {

        var size = this._realSize;
        var props = this._properties;

        var series = this._series;
        var dpCtxs = this._dataPointContext;
        var i, j, itemIndex;

        // initialize pixel board
        var pixelBoard = ProjectionHelper.createPixelBoard(size.width, size.height, {
            layerLimit : 1,
            visibleThreshold : 6
        });

        var sortedSeries = this._getSortedSeries();
        var orderMap = this._getOrderMap();
        var dlength, slength = sortedSeries.length;
        var showNegativeValues = this._properties.get('showNegativeValues');
        var seriesIndex, seriesModel, indexes;
        var dataPoints, dataPointsLength, dpRenderer, dataPointModel;
        for (i = slength; i >= 0; i--) {
            if (i === slength) {
                indexes = this._seletedSeries;
            } else {
                indexes = orderMap[sortedSeries[i]];
            }
            dlength = indexes.length;
            for (j = dlength - 1; j >= 0; j--) {
                seriesIndex = indexes[j];
                if (i !== slength && this._seletedSeries.length > 0 &&
                        this._seletedSeries.indexOf(seriesIndex) !== -1) {
                    continue;
                }
                seriesModel = series[seriesIndex];
                if (!seriesModel) {
                    continue;
                }
                dpRenderer = this._getDataPointRenderer(seriesIndex);
                if (!dpRenderer) {
                    continue;
                }
                dataPoints = seriesModel.getDataPoints();
                dataPointsLength = dataPoints.length;
                for (itemIndex = 0; itemIndex < dataPointsLength; itemIndex++) {
                    dataPointModel = dataPoints[itemIndex];
                    if (dataPointModel) {
                        var data = dataPointModel.getRawData();
                        if (!data) {
                            continue;
                        }

                        var dpConfig = dataPointModel.getConfig();

                        if ((!showNegativeValues && dpConfig.data.negativeValue) || dpConfig.data.isNoValue) {
                            dataPointModel.setVisible(false);
                        }
                        else {
                            var position = dataPointModel.getPosition();
                            var x = Math.round(position.x);
                            var y = Math.round(position.y);

                            var gConfig = dpConfig.graphic;
                            var rx = Math.round(gConfig.width / 2 + gConfig.borderWidth);
                            var ry = Math.round(gConfig.height / 2 + gConfig.borderWidth);

                            gConfig.negativeValue = dpConfig.data.negativeValue;

                            var visible = ProjectionHelper.isAreaVisible(pixelBoard, gConfig, x, y, rx, ry);

                            dataPointModel.setVisible(visible);
                            if (visible) {
                                dpConfig = this._buildWrapperConfig(data, position, data.dp.context());
                                dataPointModel.setConfig(dpConfig);
                                var dpData = this._buildData(dpConfig);
                                dpCtxs[data.dp.id] = dpConfig;
                                dataPointModel.setData(dpData);

                                var dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                                dataPointModel.setNode(dpNode);
                                if (dpNode) {
                                    dataPointG.insertBefore(dpNode, dataPointG.firstChild);
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    prot._getDataLabels = function(name, runtime) {
        return new BubbleDataLabels(runtime, {
            name: name
        });
    };

    prot.getDataPointPosition = function(seriesIndex, itemIndex) {
        var position = BubblePlot.superclass.getDataPointPosition.apply(this, arguments);
        var data = this._data.series[seriesIndex][itemIndex];
        if (this._widthScale) {
            position.r = this._widthScale(data.bubbleWidth);
        }
        return position;
    };

    prot._drawDataPoint = function(dpRenderer, dataPoint) {
        var showNegativeValues = this._properties.get('showNegativeValues');
        var dpConfig = dataPoint.getConfig();
        if(false === showNegativeValues && dpConfig.data.negativeValue) {
            return null;
        }
        if(true === dpConfig.data.isNoValue) {
            return null;
        }
        return BubblePlot.superclass._drawDataPoint.apply(this, arguments);
    };

    prot._buildData = function(dpConfig) {
        var ret = BubblePlot.superclass._buildData.apply(this, arguments);
        var graphic = dpConfig.graphic;
        ret.width = graphic.width;
        ret.height = graphic.width;
        ret.fillOpacity = graphic.fillOpacity;
        if (graphic.pattern) {
            ret.pattern = graphic.pattern;
        }
        return ret;
    };

    prot._postRender = function(dataPointG) {
        BubblePlot.superclass._postRender.apply(this, arguments);
        if (this._isBigData) {
            return;
        }
        // sort bubble, the bigger draw the first
        var datapoints = dataPointG.querySelectorAll("." + Constants.CSS.CLASS.DATAPOINT);
        var len = datapoints.length;

        var itemArr = [];
        var i = 0;
        for(i = 0; i < len; ++i){
            itemArr.push({index:i, dp: datapoints.item(i)});
        }
        //= Array.prototype.slice.call(datapoints);

        itemArr.sort(function(a, b) {
            var result = DataGraphics.getData(b.dp).width - DataGraphics.getData(a.dp).width;
            if(result === 0){
                result = a.index - b.index;
            }
            return result;
        });

        for (i = 0; i < itemArr.length; ++i) {
            dataPointG.appendChild(itemArr[i].dp);
        }

    };

    prot._updateDatapoint = function(dataPointG, dpRenderer, dpConfig, position) {
        var showNegativeValues = this._properties.get('showNegativeValues');
        if (false === showNegativeValues && dpConfig.data.negativeValue) {
            return;
        }
        if (true === dpConfig.data.isNoValue) {
            return;
        }
        return BubblePlot.superclass._updateDatapoint
            .call(this, dataPointG, dpRenderer, dpConfig, position);
    };

    prot.hitTest = function(coord) {
        var datas = this._dataPointContext, x = coord.x, y = coord.y;
        var result;
        var size = this.getSize();
        var offset = this._offset;
        var startXRange = -offset.x;
        var startYRange = -offset.y;
        //Calculate a ratio in case user set a css transform especially scale on root chart div
        var plotBound = this._selection.select(".v-plot-bound").node();
        var ratio = plotBound.getBoundingClientRect().width / plotBound.getBBox().width;
        var showNegativeValues = this._properties.get('showNegativeValues');

        if (coord.hasOwnProperty("width") && coord.hasOwnProperty("height")) {
            var width = coord.width, height = coord.height;
            var plotWidth = size.width;
            if (ratio != 1) {
                plotWidth *= ratio;
            }

            result = datas.filter(function(e) {
                if(!showNegativeValues && e.data.negativeValue){
                    return false;
                }
                var translate = e.data.translate.slice();
                if (ratio != 1) {
                    translate[0] *= ratio;
                    translate[1] *= ratio;
                }

                var bound1 = {
                    left : translate[0] - e.graphic.width / 2 - e.graphic.borderWidth,
                    top : translate[1] - e.graphic.height / 2 - e.graphic.borderWidth,
                    width : e.graphic.width + 2 * e.graphic.borderWidth,
                    height : e.graphic.height + 2 * e.graphic.borderWidth
                };

                var bound2 = {
                    left : x + startXRange,
                    top : y + startYRange,
                    width : width,
                    height : height
                };

                return BoundingBoxUtils.intersects(bound1, bound2);
            });
        } else {
            result = datas.filter(function(e) {
                if (!showNegativeValues && e.data.negativeValue) {
                    return false;
                }
                var translate = e.data.translate.slice();
                if (ratio != 1) {
                    translate[0] *= ratio;
                    translate[1] *= ratio;
                }
                var bound = {
                    left : translate[0] - e.graphic.width / 2 - e.graphic.borderWidth,
                    top : translate[1] - e.graphic.height / 2 - e.graphic.borderWidth,
                    width : e.graphic.width + 2 * e.graphic.borderWidth,
                    height : e.graphic.height + 2 * e.graphic.borderWidth
                };

                var point = {
                    x : x + startXRange,
                    y : y + startYRange
                };

                return BoundingBoxUtils.contains(bound, point);
            });
        }

        return result;
    };

    return BubblePlot;
});

define('sap/viz/chart/components/renderers/TimeReferenceLineRenderer',[
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/renderers/ReferenceLineRenderer',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/SVG',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Math',
    "sap/viz/chart/components/axis/sub/TimeAxisBodyHelper",
    'sap/viz/framework/common/util/TypeUtils'
], function (ObjectUtils,
    ReferenceLineRenderer,
    Constants,
    SVG,
    DataGraphics,
    Math,
    TimeAxisBodyHelper,
    TypeUtils) {

    var TimeReferenceLineRenderer = ObjectUtils.extend({}, ReferenceLineRenderer);
    var STROKE_DASH = Constants.REF_LINE_DASH_TYPE_ARRAY;
    var TIME_KEY = "timeAxis";

    var buildPathString = function (visibleVarieties, config) {
        //the function will build "M0 0 L100 0 L100 -50 L200 -50 L200 20 L400 20" according to 
        //[{ loc: 100, y: 0 }, { loc: 200, y: -50 }, {loc: 400, y: 20 }]
        var varieties = visibleVarieties;
        var points = [];
        var onePoint;
        var i;
        var j;
        var activeX = (-config.xOffset);
        var activeY = 0;
        for (i = 0; i < varieties.length; i++) {
            for (j = 0; j < 2; j++) {
                if (j < 1) {
                    activeY = varieties[i].y;
                }
                else {
                    activeX = varieties[i].loc;
                }
                onePoint = [activeX, activeY];
                points.push(onePoint);
            }
        }

        return SVG.outputPath(points);
    };

    var normalisePoints = function (changePoints, defaultValue) {
        //input: [{date: "2005-04-01", value: 200}, {date: "2005-07-01", value: 250}], default: 20
        //output: [{timeStamp: "2005-04-01", value: 20}, {timeStamp: "2005-07-01", value: 200}, {value: 250}]
        var resChangePoints = [];
        var i;
        var lastDate = -Number.MAX_VALUE;
        var lastValue = parseFloat(defaultValue);
        for (i = 0; i < changePoints.length; i++) {
            if (changePoints[i] && TypeUtils.isExist(changePoints[i].date) &&
                TypeUtils.isExist(changePoints[i].value)) {
                var currentDate = (new Date(changePoints[i].date)).getTime();
                if (!isNaN(currentDate) && !isNaN(parseFloat(changePoints[i].value)) &&
                    currentDate > lastDate) {
                    resChangePoints.push({ value: lastValue, timeStamp: currentDate });
                    lastValue = parseFloat(changePoints[i].value);
                    lastDate = currentDate;
                }
            }
        }
        resChangePoints.push({ value: lastValue, timeStamp: Number.MAX_VALUE });
        return resChangePoints;
    };

    TimeReferenceLineRenderer._combineConfig = function (config, options, axis) {
        var defaultStyle = options.defaultStyle;
        var width = options.width;
        var height = options.height;
        var isPercentage = options.isPercentage;
        var xHandlers = options.xHandlers;
        var props = options.props;

        var resConfig = ReferenceLineRenderer._combineConfig(config, options);
        if (config.changePoints && TypeUtils.isArray(config.changePoints) &&
            config.changePoints.length > 0) {
            var changePointsArray = normalisePoints(config.changePoints, config.value);
            if (changePointsArray) {
                resConfig.variety = [];
                //should be [{ loc: 100, y: 0 }, { loc: 200, y: -50 }, {loc: 400, y: 20 }]
                var vItem;
                var i;
                var timeDomain = (this._searchAxisHandler(xHandlers, TIME_KEY)).getDomain();
                //we use the same scale as TimeAxis and timePeriodStyle 
                var timeScale = TimeAxisBodyHelper.getScale(timeDomain, resConfig.realWidth);
                var pos = this._calculatePosition(isPercentage, axis, config.value);
                var baseY = (1 - pos) * resConfig.realHeight;
                var lastLoc;
                for (i = 0; i < changePointsArray.length; i++) {
                    vItem = {};
                    pos = this._calculatePosition(isPercentage, axis, changePointsArray[i].value);
                    vItem.y = (1 - pos) * resConfig.realHeight - baseY;
                    vItem.loc = timeScale(changePointsArray[i].timeStamp);

                    if (vItem.loc < 0) {
                        vItem.loc = 0;
                    }
                    else if (vItem.loc > resConfig.realWidth) {
                        vItem.loc = resConfig.realWidth;
                    }
                    if ((resConfig.variety.length === 0 || vItem.loc > lastLoc)) {
                        resConfig.variety.push(vItem);
                        lastLoc = vItem.loc;
                    }
                }
            }
        }
        return resConfig;
    };

    TimeReferenceLineRenderer._isInvisiblePosition = function (pos, config) {
        return (ReferenceLineRenderer._isInvisiblePosition(pos) && (!(config.changePoints &&
            TypeUtils.isArray(config.changePoints) && config.changePoints.length > 0)));
    };

    TimeReferenceLineRenderer._drawReferenceLine = function (config, key, parent, pos,
        isHorizontal, width, height) {
        if (config.variety && TypeUtils.isArray(config.variety) &&
            config.variety.length > 0) {
            var currentLineGroup = SVG.create("g", parent);
            currentLineGroup.setAttribute("class", "v-referenceline v-referenceline-" + key);
            currentLineGroup.setAttribute("transform", "translate(" + config.xOffset + "," + 0 + ")");

            var currentLine = SVG.create("path", currentLineGroup);
            currentLine.setAttribute("stroke", config.strokeColor);
            currentLine.setAttribute("stroke-width", config.strokeWidth);
            currentLine.setAttribute("shape-rendering", "crispEdges");

            var visibleVarieties = getVisibleVarieties(config, width);
            var pathString = buildPathString(visibleVarieties, config);
            //pathString should be "M0 0 L200 0 L200 -100 L300 -100 L300 20 L500 20";
            currentLine.setAttribute("d", pathString);
            currentLine.setAttribute("fill", "none");

            if (Constants.GRIDLINE_TYPE.DASHED === config.lineType ||
                Constants.GRIDLINE_TYPE.DOTTED === config.lineType) {
                var coverLine = currentLine.cloneNode(true);
                //cover line is used for clicking the empty area of dash lines.
                coverLine.setAttribute("stroke", "transparent");
                currentLineGroup.appendChild(coverLine);

                currentLine.setAttribute("stroke-dasharray", STROKE_DASH);
            } else if (Constants.GRIDLINE_TYPE.INCISED === config.lineType) {
                currentLine.setAttribute("stroke", "#ffffff");
            }
        }
        else {
            ReferenceLineRenderer._drawReferenceLine(config, key, parent, pos,
                isHorizontal, width, height);
        }
    };

    var getVisibleVarieties = function (config, width) {
        var visibleVarieties = [];
        var startPosition = (-config.xOffset);
        var endPosition = (startPosition + width);
        var i;
        for (i = 0; i < config.variety.length; i++) {
            if (config.variety[i].loc > startPosition) {
                visibleVarieties.push(config.variety[i]);
            }
            if (config.variety[i].loc >= endPosition) {
                config.variety[i].loc = endPosition;
                break;
            }
        }
        return visibleVarieties;
    };

    var getLabelY = function (isRight, config, options, labelHeight) {
        var textSize = config.label.textSize;

        var visibleVarieties = getVisibleVarieties(config, options.width);
        var aimIndex = 0;
        if (isRight) {
            aimIndex = (visibleVarieties.length - 1);
        }
        var yAdjust = visibleVarieties[aimIndex].y;
        var labelY = (1 - options.pos) * labelHeight + yAdjust - (textSize.height / 2);
        //to add real size check
        var realLabelY = labelY;
        if (config.realHeight) {
            realLabelY = (1 - options.pos) * config.realHeight + yAdjust - (textSize.height / 2);
        }
        if (realLabelY <= 0) {
            labelY += textSize.height / 2;
        }
        else if (realLabelY >= (config.realHeight - textSize.height)) {
            labelY -= textSize.height / 2;
        }
        return labelY;
    };

    TimeReferenceLineRenderer._drawLabel = function (options) {
        var labelObj = ReferenceLineRenderer._buildLabelObj(options);

        var labelHeight = options.height;
        var config = options.combinedConfig;
        //for time reference line label, if the line has variety, we have to move the y 
        //location of label(and rect)
        if (config.variety && TypeUtils.isArray(config.variety) &&
            config.variety.length > 0) {
            var isRight = false;
            if (options.axisLayout[options.key] === "right") {
                isRight = true;
            }
            labelObj.rect.y = getLabelY(isRight, config, options, labelHeight);
            labelObj.candidateRect.y = getLabelY(!isRight, config, options, labelHeight);
        }

        ReferenceLineRenderer._layoutAndUpdateLabelDOM(options, labelObj);
        return labelObj;
    };

    return TimeReferenceLineRenderer;
});


define('sap/viz/chart/components/plots/TimeSeriesPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/renderers/TimeReferenceLineRenderer'
], function(
    oo,
    TimeReferenceLineRenderer
) {
    var TimeSeriesPlot = function(SomePlot) {

        var TimeSeriesSomePlot = function(runtime, options) {
            TimeSeriesSomePlot.superclass.constructor.apply(this, arguments);
        };

        oo.extend(TimeSeriesSomePlot, SomePlot);

        TimeSeriesSomePlot.prototype.getReferenceLineRenderer = function () {
            return TimeReferenceLineRenderer;
        };

        TimeSeriesSomePlot.prototype.zoom = function (offset) {
            this.update(offset);
        };

        TimeSeriesSomePlot.prototype._redrawReferenceLine = function (offset) {
            this._drawReferenceLine(offset);
        };

        TimeSeriesSomePlot.prototype.update = function (offset) {
            if (this._selection) {
                TimeSeriesSomePlot.superclass.update.apply(this, arguments);
                this._drawReferenceLine(offset);
                this._repositionReferenceLine();
            }
        };

        return TimeSeriesSomePlot;
    };

    //time series plot is a functions, whihc is used to create TimeSeriesSomePlot.
    return TimeSeriesPlot;
});

define('sap/viz/chart/components/plots/YYPlotFactory',[
    'jquery',
    'sap/viz/chart/components/plots/BubblePlot',
    'sap/viz/chart/components/plots/ScatterPlot',
    'sap/viz/chart/components/plots/TimeSeriesPlot'
], function($,
    BubblePlot,
    ScatterPlot,
    TimeSeriesPlot
) {

    var plotMapping = {
        'bubble': {
            plotClazz: BubblePlot
        },
        'scatter': {
            plotClazz: ScatterPlot
        },
        'time_bubble' : {
            plotClazz : BubblePlot,
        },
        'timeseries_scatter': {
            plotClazz: TimeSeriesPlot(ScatterPlot),
            options: {}
        },
        'timeseries_bubble': {
            plotClazz: TimeSeriesPlot(BubblePlot),
            options: {}
        },
    };

    return {
        getPlotClazz: function(renderType) {
            var config = plotMapping[renderType];
            return config && config.plotClazz;
        }
    };

});

define('sap/viz/chart/components/axis/sub/TimeValueAxisBody',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/ValueAxisBody",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/scales/ValueScaleUtil",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/chart/components/util/ValueAxisUtils",
    "sap/viz/chart/components/axis/renderer/ValueBodyRenderer",
    "sap/viz/framework/common/format/FormatManager"
], function(
    oo,
    ValueAxisBody,
    TypeUtils,
    ValueScaleUtil,
    LangMgr,
    ValueAxisUtils,
    ValueBodyRenderer,
    FormatManager
) {

    var TimeValueAxisBody = function() {
        TimeValueAxisBody.superclass.constructor.apply(this, arguments);
    };
 
    oo.extend(TimeValueAxisBody, ValueAxisBody);

    TimeValueAxisBody.prototype._getTicksToRender = function() {
        var scale = this._data,
            domain = scale.getDomain();
        return this._getAllLabels(null, scale, true).filter(function(l) {
            return l.value >= domain[0] && l.value <= domain[1];
        }).map(function(l) {
            return l.value;
        });
    };

    TimeValueAxisBody.prototype.drawTicks = function(grp, ticksPos, w, h, pos, props, effectMgr) {
        return ValueBodyRenderer.drawTicks(grp, ticksPos, w, h, pos, props, effectMgr, true);
    };
    
    TimeValueAxisBody.prototype._getFixedTicksLabels = function(fixedTicks, domain) {
        fixedTicks.forEach(function(n) {
            n.text = TypeUtils.isNonEmptyString(n.text) ? n.text : LangMgr.get('IDS_ISNOVALUE');
        });
        return fixedTicks.filter(function(l) {
            return l.value >= domain[0] && l.value <= domain[1];
        });
    };

    TimeValueAxisBody.prototype._getAllLabels = function(placeHolder, scale, unfiltered) {
        var fixedTicks = this._properties.get("axisTick.fixedTicks"),
            domain = scale.getDomain(),
            labels = [];
        if (fixedTicks && fixedTicks.length > 0) {
            labels = this._getFixedTicksLabels(fixedTicks, domain);
        } else {
            var timeUnit = scale.timeUnit,
                timeUnitGap = scale.timeUnitGap,
                tickNum = scale.tickNum,
                startDate = new Date(domain[0]);
            var format = function(val) {
                return FormatManager.format(new Date(val), timeUnit.format);                
            },
                formatD = function(val) {
                    return FormatManager.format(new Date(val), "dd/mm/yyyy hh:mm");                
                };

            startDate.setMinutes(0);
            startDate.setSeconds(0);
            startDate.setMilliseconds(0);

            for (var i = 0, d; i < tickNum; i++) {
                d = new Date(startDate.getTime());
                timeUnit.set.apply(d, [timeUnit.get.apply(startDate, []) + i * timeUnitGap]);
                labels.push({
                    text: format(d),
                    value: d.getTime()
                });
            }

            var domainFixed = scale.getDomainFixed();
            if (domainFixed[0]) {
                labels[0].text = formatD(new Date(labels[0].value));
            }
            if (domainFixed[1]) {
                labels.push({
                    value: domain[1],
                    text: formatD(new Date(domain[1]))
                });
            }
        }
        this._setLabelsPosition(labels, scale);
        if (!unfiltered) {
            return this._filterLabels(labels);
        }
        return labels;
    };

    TimeValueAxisBody.prototype._filterLabels = function(all) {
        var toDraw = [];

        if (all.length > 1) {
            toDraw = ValueAxisUtils.calculateLabelsToDrawHelper(all);
            //When the height/width of vertical/horizontal axis is small that can only hold one axis label, 
            //the label should be hidden.
            if (toDraw.length <= 1 || (toDraw.length === 2 && ValueAxisUtils.isOverLapped(toDraw[0], toDraw[1]))) {
                toDraw = [];
            }
        } else if (all.length === 1) {
            toDraw = all;
        }
        return toDraw;
    };

    TimeValueAxisBody.prototype.formatTickValue = function(val, isPercentMode, properties, scale) {
        var formattedVal = val;
        var domainFixed = scale.getDomainFixed();
        if(domainFixed[0]) {
            formattedVal = FormatManager.format(new Date(val), "dd/mm/yyyy hh:mm");
        }
        else {
            formattedVal = FormatManager.format(new Date(val), scale.timeUnit.format);
        }
        return formattedVal;
    };

    return TimeValueAxisBody;
});

define('sap/viz/chart/components/axis/TimeValueAxis',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/ValueAxis",
    "sap/viz/chart/components/axis/sub/TimeValueAxisBody",
    "sap/viz/chart/components/scrollbar/Scrollbar"
], function(
    Constants,
    oo,
    ValueAxis,
    TimeValueAxisBody,
    Scrollbar
) {

    var TimeValueAxis = function(runtime, options) {
        ValueAxis.superclass.constructor.apply(this, arguments);

        this.setChild("axisBody", new TimeValueAxisBody(runtime, options), {
            order: 1,
            priority: 2,
            offset: 0
        });
        this.setChild(Constants.AXIS.SCROLLBAR_NAME, new Scrollbar(runtime, {
            name: 'plotArea.scrollbar'
        }), {
            order: 2,
            priority: 0,
            offset: 0
        });
        this._isPercentageMode = false;
    };

    oo.extend(TimeValueAxis, ValueAxis);

    TimeValueAxis.prototype.setData = function(data) {
        TimeValueAxis.superclass.setData.apply(this, arguments);
        if (data && data.scale) {
            this._scale.tickNum = data.scale.tickNum;
            this._scale.timeUnit = data.scale.timeUnit;
            this._scale.timeUnitGap = data.scale.timeUnitGap;
        }
    };
    return TimeValueAxis;
});

define('sap/viz/chart/components/zoom/YYZoomer',[
    "sap/viz/chart/components/zoom/XYZoomer",
    "sap/viz/chart/components/zoom/ZoomLimit",
    'sap/viz/framework/common/util/oo'
], function(
    XYZoomer,
    ZoomLimit,
    oo
) {
    function YYZoomer() {
        YYZoomer.superclass.constructor.apply(this, arguments);
    }
    oo.extend(YYZoomer, XYZoomer);
    YYZoomer.prototype.direction = function() {
        return "xy";
    };

    YYZoomer.prototype._calcZoomLimit = function(mod, dir) {
        var perRule = ZoomLimit.Regular(mod, dir),
            perWindow = mod.plot.getVisibleRange(),
            xWindow = perWindow.x ? perWindow.x.ratio : 0,
            yWindow = perWindow.y ? perWindow.y.ratio : 0;
        var min = perRule[0],
            max = Math.max(perRule[1], xWindow, yWindow);
        return {
            x: {
                min: min,
                max: max
            },
            y: {
                min: min,
                max: max
            }
        };
    };

    return YYZoomer;
});

define('sap/viz/chart/components/zoom/TimeYZoomer',[
    "sap/viz/chart/components/zoom/XYZoomer",
    "sap/viz/chart/components/zoom/ZoomLimit",
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/TimeUtil",
    "sap/viz/framework/common/util/Constants"
], function(
    XYZoomer,
    ZoomLimit,
    oo,
    TypeUtils,
    TimeUtil,
    Constants
) {
    function TimeYZoomer() {
        TimeYZoomer.superclass.constructor.apply(this, arguments);
    }

    oo.extend(TimeYZoomer, XYZoomer);

    TimeYZoomer.prototype.direction = function() {
        var renderType = this._modules.main._renderType;
        if (!this.enabled()) {
            return "";
        } else {
            switch (renderType) {
                case "timeseries_waterfall":
                case "timeseries_line":
                case "timeseries_column":
                case "timeseries_stacked_column":
                case "timeseries_100_stacked_column":
                case "timeseries_combination":
                case "timeseries_bullet":
                    return this._modules.isHorizontal ? "y" : "x";
                case "timeseries_bubble":
                case "timeseries_scatter":
                    return "xy";
                default:
                    return TimeYZoomer.superclass.direction.call(this);
            }
        }
    };

    TimeYZoomer.prototype.zoom = function(ratio, pos, nSteps, minOffset) {
        this._status.set("zooming", true);
        return TimeYZoomer.superclass.zoom.call(this, ratio, pos, nSteps, minOffset);
    };

    TimeYZoomer.prototype._calcZoomLimit = function(modules, dir) {
        
        if (!(modules.main.isColumnLike && modules.main.isColumnLike())) {
            var pla = modules.main,
                plot = modules.plot,
                timeAxis = pla.getChild("timeAxis").module,
                zoomDomain = pla._properties.get("plotArea.window"),
                domain = pla.getData().timeAxis.scale.getDomain(),
                domainOffset = domain[1] - domain[0],
                scale,
                TIME_TICK_INTERVAL_MAX_WIDTH = Math.min(plot.getSize().width * 0.7, 250);
            if (zoomDomain) {
                var startTmp = domain[0],
                    endTmp = domain[1];
                if (TypeUtils.isExist(zoomDomain.start)) {
                    if (TypeUtils.isNumber(zoomDomain.start)) {
                        startTmp = Number(zoomDomain.start);
                    } else if (TypeUtils.isNumber(new Date(zoomDomain.start).getTime())) {
                        startTmp = new Date(zoomDomain.start).getTime();
                    }
                }
                if (TypeUtils.isExist(zoomDomain.end)) {
                    if (TypeUtils.isNumber(zoomDomain.end)) {
                        endTmp = Number(zoomDomain.end);
                    } else if (TypeUtils.isNumber(new Date(zoomDomain.end).getTime())) {
                        endTmp = new Date(zoomDomain.end).getTime();
                    }
                }
                if (endTmp > startTmp) {
                    scale = domainOffset / (endTmp - startTmp); //respect interaction initialized scale first
                }
            }
            var levels = timeAxis.getChild("axisBody").module.getActiveLevels(),
                level = (levels && levels.length > 0) ? levels[0] : "day",
                width = plot.getSize().width;
            var levelInterval = TimeUtil['ONE_' + level.toUpperCase()];
            if (!levelInterval) {
                if (level === Constants.FISCAL.PERIOD) {
                    levelInterval = Constants.FISCAL.ONE_FISCAL_PERIOD;
                }
                else if (level === Constants.FISCAL.YEAR) {
                    levelInterval = Constants.FISCAL.ONE_FISCAL_YEAR;
                }
            }

            var tempScale = TIME_TICK_INTERVAL_MAX_WIDTH / levelInterval * domainOffset / width;
            if (!TypeUtils.isExist(scale) || scale < tempScale) {
                scale = tempScale;
            }
            return {
                x: {
                    min: 1,
                    max: scale
                },
                y: {
                    min: 1,
                    max: scale
                }
            };
        } else {
            var limit = {
                x: {},
                y: {}
            },
            perRule = ZoomLimit.Bar(modules, dir);
            limit.x.min = perRule[0];
            limit.x.max = perRule[1];
            limit.y.min = perRule[0];
            limit.y.max = perRule[1];
            return limit;
        }
    };

    return TimeYZoomer;
});

define('sap/viz/chart/components/plotareas/YYPlotArea',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/container/XYContainer',
    'sap/viz/chart/components/axis/ValueAxis',
    'sap/viz/chart/components/axis/TimeAxis',
    'sap/viz/chart/components/scrollbar/Scrollbar',
    'sap/viz/chart/components/plots/YYPlotFactory',
    'sap/viz/chart/components/plots/PlotHelper',
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/chart/components/axis/TimeValueAxis",
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/scales/TimeScale',
    'sap/viz/chart/components/zoom/YYZoomer',
    'sap/viz/chart/components/zoom/TimeYZoomer',
    'sap/viz/chart/components/util/ZoomUtil',
    "sap/viz/chart/components/plots/PlotGeometryKeeper",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/trendline/Trendline'
], function(
    oo,
    XYContainer,
    ValueAxis,
    TimeAxis,
    Scrollbar,
    PlotFactory,
    PlotHelper,
    ValueScale,
    NumberUtils,
    TimeValueAxis,
    ValueAxisUtils,
    UADetector,
    Constants,
    DataUtils,
    TimeScale,
    YYZoomer,
    TimeYZoomer,
    ZoomUtil,
    PlotGeometryKeeper,
    TypeUtils,
    FiscalUtil,
    TimeUtil,
    ObjectUtils,
    Trendline
) {
    function offsetInValue(me) {
        var h, v,
            plot = me._plot;
        if (plot._hasTimeAxis()) {
            h = "timeAxis";
            v = "valueAxis";
        } else {
            h = "valueAxis";
            v = "valueAxis2";
        }
        function get() {
            return PlotGeometryKeeper.offsetInValue({
                h: me._data[h].scale,
                v: me._data[v].scale
            }, me.getOffset(), plot.getRealSize());   
        }
        function set(val) {
            var hscale = me._data[h].scale,
                vscale = me._data[v].scale,
                size = plot.getRealSize(),
                offset = {};
            if(!isNaN(val.x)) {
                offset.x = -hscale.scale(val.x) * size.width;
            }
            if(!isNaN(val.y)) {
                offset.y = -(1 - vscale.scale(val.y)) * size.height;
            }
            me.scroll(offset);
        }
        return {
            get: get,
            set: set
        };
    }
    
    function YYPlotArea(runtime, options) {
        this._rawData = (options && options.rawData && options.rawData.dataModel &&
            options.rawData.dataModel._rawData);
        YYPlotArea.superclass.constructor.apply(this, arguments);
        this._init();
        runtime.statusManager().add("plot.offsetInValue", {
            serializable: false,
            get: offsetInValue(this).get,
            set: offsetInValue(this).set
        });
    }

    oo.extend(YYPlotArea, XYContainer);

    var prot = YYPlotArea.prototype;

    prot._init = function(plot) {
        var runtime = this.runtime();
        this._plot = PlotHelper.create(this._renderType, PlotFactory.getPlotClazz(this._renderType), runtime);
        this._plot.getDispatch().on("reRenderComplete.plotarea", this._reRenderComplete.bind(this));
        this.setChild("plot", this._plot, {
            position: "center"
        });

        this.setLayoutSequence(['left', 'right', 'bottom', 'top']);
        var isInteractive = !this._properties.get("interaction.noninteractiveMode");
        if (this._hasTimeAxis()) {
            this._bottomAxis = new TimeAxis(runtime, {
                name: 'timeAxis',
                allowInterval: false,
                hasScrollbar: isInteractive,
                rawData: this._rawData
            });
            this._leftAxis = new ValueAxis(runtime, {
                name: "valueAxis"
            });
            this.setChild("timeAxis", this._bottomAxis, {
                position: "bottom"
            });
            this.setChild("valueAxis", this._leftAxis, {
                position: "left"
            });
        } else {
            if (this.isTimeBased()) {
                this._bottomAxis = new TimeValueAxis(runtime, {
                    name: "valueAxis"
                });
                this._plot._dataLabels.setTimeBindingId("valueAxis");
            } else {
                this._bottomAxis = new ValueAxis(runtime, {
                    name: "valueAxis",
                    hasScrollbar: isInteractive
                });
            }
            this._leftAxis = new ValueAxis(runtime, {
                name: "valueAxis2"
            });
            this.setChild("valueAxis", this._bottomAxis, {
                position: "bottom"
            });
            this.setChild("valueAxis2", this._leftAxis, {
                position: "left"
            });
        }

        if (isInteractive) {
            this._hScrollbar = this._bottomAxis.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
            this._vScrollbar = new Scrollbar(runtime, {
                name: "plotArea.scrollbar"
            });
            this.setChild("scrollbar", this._vScrollbar, {
                position: "right"
            });
        }

        this.getZoomer().init({
            main: this,
            plot: this._plot,
            axisByDirection: {
                x: [this._bottomAxis],
                y: [this._leftAxis]
            }
        });
    };

    prot._preRender = function() {
        YYPlotArea.superclass._preRender.apply(this, arguments);
        this._setValueAxisRange();
    };

    prot._reRenderComplete = function(){
        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };

    /**
     * Time Bubble and Time Scatter are using this YYPlotArea instead of TimeYPlotArea.
     * This function return displayed time axis domain which may be different from
     * the whole time axis domain(when scroll).
     */
    prot.getDisplayedTimeDomain = function() {
        if (this._bottomAxis.getName() === "timeAxis") {
            var centerModule = this.getChildrenByPosition("center")[0];
            var realSize = centerModule.getRealSize();
            var size = centerModule.getSize();
            var isHorizontal = false;
            var translate = this._plot.getOffset();

            var isFiscal = false;
            if (this._data.rawData && this._data.rawData.dataModel &&
                this._data.rawData.dataModel._rawData) {
                isFiscal = FiscalUtil.isFiscal(this._data.rawData.dataModel._rawData);
            }
            return ValueAxisUtils.getTimeAxisDomain(size, translate, realSize,
                    this.getData().timeAxis.scale.getDomain(), isHorizontal, isFiscal);
        }
        // this function is used for time series charts only, so if non time series chart,
        // return null value;
        return null;
    };

    /**
     * Set visible range
     */
    prot._setValueAxisRange = function() {
        var size = this._plot.getSize();
        var realSize = this._plot.getRealSize();
        var rangeTrans = this._plot.getVisibleRange();
        if (!rangeTrans.x && !rangeTrans.y) {
            return;
        }
        var scale = {},
            offset = {};
        if (rangeTrans.x) {
            scale.x = rangeTrans.x.ratio;
            offset.x = rangeTrans.x.delta * size.width * scale.x;
        }
        if (rangeTrans.y) {
            scale.y = rangeTrans.y.ratio;
            offset.y = -(size.height * (scale.y - 1) + rangeTrans.y.delta * size.height * scale.y);
        }
        this.zoom(scale);
        this.scroll(offset);
    };
    
    prot.destroy = function() {
        var data = this._data;
        var statusMgr = this.runtime().statusManager();
        if (statusMgr.get("valueAxisScaleDomain")) {
            if (data && data.valueAxis &&
                !data.valueAxis.scale.isFixed() &&
                data.valueAxis.scale.getDomainChanged()) {
                data.valueAxis.scale.setDomain(statusMgr.get("valueAxisScaleDomain"));
            }
            statusMgr.remove("valueAxisScaleDomain");
        }
        if (statusMgr.get("valueAxis2ScaleDomain")) {
            if (data && data.valueAxis2 &&
                !data.valueAxis2.scale.isFixed() &&
                data.valueAxis2.scale.getDomainChanged()) {
                data.valueAxis2.scale.setDomain(statusMgr.get("valueAxis2ScaleDomain"));
            }
            statusMgr.remove("valueAxis2ScaleDomain");
        }

        YYPlotArea.superclass.destroy.call(this);
        this._plot = null;
        this._bottomAxis = null;
        this._leftAxis = null;
    };
    
    prot.getPlot = function() {
        return this._plot;
    };

    prot.isTimeBased = function() {
        return this._renderType === "time_bubble";
    };

    prot._hasTimeAxis = function(){
        return /timeseries/.test(this._renderType);
    };

    prot.isScatter = function() {
        return this._renderType === "scatter";
    };

    prot.setData = function(data) {
        YYPlotArea.superclass.setData.apply(this, arguments);
        this.updateValueScale();
        this._plot.setData(this._data);
    };

    function updateSingleValueScale(data, size, axis, isTimeBased){
        // enlarge value axis so that bubbles can be fully shown
        var valueAxisData = ValueAxisUtils.updateScatterValueAxis(data, [0, size * 0.8],
                Constants.BUBBLE.DEFAULT_WIDTH_RATIO, isTimeBased);

        valueAxisData.scale.setRange([0, 1]);
        data.scale = valueAxisData.scale;
        data.tickHint = valueAxisData.tickHint;
        axis.setData(data);
    }

    function updateTimeScale(data, size, axis, minLevel){
        // enlarge time axis so that bubbles can be fully shown.
        var sizeRatio = Constants.BUBBLE.DEFAULT_WIDTH_RATIO;
        var scale = data.scale;
        var domain = scale.getDomain().slice();
        var domainFixed = scale.getDomainFixed();
        var buff;
        if(domain[1] === domain[0]){
            //special handle when there is only one value
            buff = TimeUtil.getPeriod(minLevel)/2;
        }else{
            buff = (domain[1] - domain[0]) * sizeRatio;
        }

        
        if(!domainFixed[0]){
            domain[0] -= buff;
        }
        if(!domainFixed[1]){
            domain[1] += buff;
        }
        data.scale = new TimeScale(domain, scale.getRange(), scale.getDomainFixed(), {dataBound:scale.getDataBound()});
        axis.setData(data);
    }

    prot._adjustScale = function () {
        var data = this._data;
        var isTimeSeries = this._hasTimeAxis();
        var valueAxis = data.valueAxis;
        var valueAxis2 = data.valueAxis2;
        var statusMgr = this.runtime().statusManager();

        var resetScaleFlag = function(scale) {
            scale.setZeroAdjusted(true);
            scale.setDomainChanged(false);
        };

        if ((valueAxis && valueAxis.scale.isFixed()) ||
            (valueAxis2 && valueAxis2.scale.isFixed())) {
            resetScaleFlag(valueAxis.scale);
            if (!isTimeSeries) {
                resetScaleFlag(valueAxis2.scale);      
            }
            return;
        }

        var needAdjustScalue = this._properties.get("plotArea.adjustScale");
        if (!TypeUtils.isExist(needAdjustScalue) || !needAdjustScalue) {
            resetScaleFlag(valueAxis.scale);
            if (!isTimeSeries) {
                resetScaleFlag(valueAxis2.scale);   
            }
            return;
        }

        valueAxis.scale.setZeroAdjusted(false);
        if (!isTimeSeries) {
            valueAxis2.scale.setZeroAdjusted(false);            
        }

        var width = this._roughSize.width;
        var height = this._roughSize.height;
        var renderType = this._renderType;
        var hDomainFixed = null;
        var vDomainFixed = null;
        var oldValueAxisDomain = statusMgr.get("valueAxisScaleDomain");
        if (!oldValueAxisDomain) {
            return;
        }
        var oldValueAxis2Domain;
        if (!isTimeSeries) {
            hDomainFixed = valueAxis.scale.getDomainFixed();
            vDomainFixed = valueAxis2.scale.getDomainFixed();
            oldValueAxis2Domain = statusMgr.get("valueAxis2ScaleDomain");
            if (!oldValueAxis2Domain) {
                return;
            }
        } else {
            vDomainFixed = valueAxis.scale.getDomainFixed();
        }


        var modifyScale = function (valueAxis, range, oldDomain, offset, ratio) {
            var valueAxisData = ValueAxisUtils.updateScatterValueAxis(valueAxis, range, 
                Constants.BUBBLE.DEFAULT_WIDTH_RATIO, false);
            var valueScale = valueAxis.scale;
            var oldRange = valueScale.getRange();
            var previousDomain = valueScale.getDomain().slice();
            valueScale.setRange(range);
            var niceDomain = valueAxisData.scale.getDomain().slice();
            valueScale.setDomain(niceDomain);
            var adjustOffset;
            var centerPoint = oldDomain[1] <= 0 ?
                Math.round(valueScale.scale(niceDomain[1])) :
                Math.round(valueScale.scale(niceDomain[0]));
            var isCutted = false;
            //If pos minus offset is negative, bubble or sactter is definitley cutted by boundary.
            //But it is positive and result is less than offset * 0.25, we also need to adjust scale.
            //Because we use rough plot size and markser size to calculate the central point of bubble
            //or scatter, it is not precise. 
            //To avoid boundary error effect, the scale need to be modified for this case.
            var empiricalValue = 1.2;
            if (oldDomain[0] < 0 && oldDomain[1] <= 0) {
                if (Math.round(valueScale.scale(oldDomain[1])) + offset >= centerPoint) {
                    isCutted = true;
                }
            } else {
                if (Math.round(valueScale.scale(oldDomain[0])) - centerPoint <= offset * empiricalValue) {
                    isCutted = true;
                }
            }

            var pixel2Domain = function(value, range, domain) {
                if (range && domain) {
                    return (value/(range[1] - range[0])) * (domain[1] - domain[0]);
                }
                return value;
            };

            if (isCutted) {
                if (oldDomain[1] > 0) {
                    if (oldDomain[0] !== 0) {
                        adjustOffset = niceDomain[0] - pixel2Domain(offset * ratio, range, niceDomain);
                    } else {
                        adjustOffset = pixel2Domain(-offset * ratio, range, oldDomain);
                    }

                    //If domain difference is very short and close to adjustOffset,
                    //to use size legend width ratio to adjust scale. 
                    if (valueScale.scale(oldDomain[1] - oldDomain[0]) <
                        valueScale.scale(Math.abs(adjustOffset))) {
                        adjustOffset = -niceDomain[1] * 1 / 8;
                    }
                    valueScale.setDomain([adjustOffset, oldDomain[1]]);
                } else if(oldDomain[0] === 0 && oldDomain[1] === 0){
                    adjustOffset = -niceDomain[1] * 1 / 8;
                    valueScale.setDomain([adjustOffset, niceDomain[1]]);
                } else {
                    adjustOffset = niceDomain[1] + offset * ratio;
                    valueScale.setDomain([oldDomain[0], adjustOffset]);
                }
                valueScale.setDomainChanged(true);
            } else {
                valueScale.setDomain(previousDomain);
            }
            valueScale.setRange(oldRange);
        };

        var range;
        var ratio = 0;
        if (renderType.indexOf("scatter") > -1) {
            var DEFAULT_MARK_SIZE = 10;
            ratio = 1;
            if (!isTimeSeries && !hDomainFixed[0]) {
                range = [0, width];
                modifyScale(valueAxis, range, oldValueAxisDomain, DEFAULT_MARK_SIZE, ratio);
            }

            if (!vDomainFixed[0]) {
                range = [0, height];
                modifyScale(isTimeSeries ? valueAxis : valueAxis2,
                    range, isTimeSeries ? oldValueAxisDomain : oldValueAxis2Domain, DEFAULT_MARK_SIZE, ratio);
            }                
        } else if (renderType.indexOf("bubble") > -1) {
            var maxSize;
            maxSize = Math.min(height, width);
            maxSize *= Constants.BUBBLE.DEFAULT_WIDTH_RATIO;
            var bubbleRadius = Math.pow(1, 0.5) * maxSize / 2;
            ratio = 2;

            if (!isTimeSeries && !hDomainFixed[0]) {
                range = [0, width * 0.8];
                modifyScale(valueAxis, range, oldValueAxisDomain, bubbleRadius, ratio);
            }

            if (!vDomainFixed[0]) {
                range = [0, height];
                modifyScale(isTimeSeries ? valueAxis : valueAxis2,
                    range, isTimeSeries ? oldValueAxisDomain : oldValueAxis2Domain, bubbleRadius, ratio);
            }
        }
    };

    prot.updateValueScale = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        var statusMgr = this.runtime().statusManager();

        if (data && width > 0 && height > 0) {
            if (!statusMgr.get("valueAxisScaleDomain")) {
                statusMgr.add("valueAxisScaleDomain", data.valueAxis.scale.getDomain().slice());
            }

            if (!this._hasTimeAxis() && !statusMgr.get("valueAxis2ScaleDomain")) {
                statusMgr.add("valueAxis2ScaleDomain", data.valueAxis2.scale.getDomain().slice());   
            }

            this._adjustScale();
            var hasTimeAxis = this._hasTimeAxis();
            var levels = this.runtime().statusManager().get('timeLevels');
            var minLevel = levels? levels[0]: "day";
            if (hasTimeAxis) {
                updateTimeScale(data.timeAxis, width, this._bottomAxis, minLevel);
                updateSingleValueScale(data.valueAxis, height, this._leftAxis);
            } else {
                var isTimeBased = this.isTimeBased();
                updateSingleValueScale(data.valueAxis, width, this._bottomAxis, isTimeBased);
                updateSingleValueScale(data.valueAxis2, height, this._leftAxis);
            }
            var MARGIN_RATE = 0.8;
            var rangeCfg = {
                valueAxis: [0, width * MARGIN_RATE],
                valueAxis2:  [0, height * MARGIN_RATE]
            };
            var updatedByTrendline = Trendline.updateValueScale(this._plot, rangeCfg, data);
            if (updatedByTrendline) {
                Object.keys(updatedByTrendline).forEach(function(k){
                    if(hasTimeAxis){
                        updateSingleValueScale({
                            values: data.valueAxis.values,
                            scale: updatedByTrendline[k].scale
                        }, height, this._leftAxis);
                    }else if(k === "valueAxis"){
                        var isTimeBased = this.isTimeBased();
                        updateSingleValueScale({
                            values: data.valueAxis.values,
                            scale: updatedByTrendline[k].scale
                        }, width, this._bottomAxis, isTimeBased);
                    }else {
                        updateSingleValueScale({
                            values: data.valueAxis2.values,
                            scale: updatedByTrendline[k].scale
                        }, height, this._leftAxis);
                    }
                    data[k] = ObjectUtils.extend(true, {}, data[k], updatedByTrendline[k]);
                }, this);
            }
            if(hasTimeAxis && data && data.timeAxis && data.timeAxis.scale){
                var scale = data.timeAxis.scale;
                var oriDomain = scale.getDomain();
                var domain = ObjectUtils.extend(true, [], oriDomain);
                this._plot._expandTrendlineXRange(domain);
                if(oriDomain && oriDomain[1] < domain[1]){
                    data.timeAxis.scale = new TimeScale(domain, scale.getRange(), 
                                                scale.getDomainFixed(), {dataBound:scale.getDataBound()});
                    updateTimeScale(data.timeAxis, width, this._bottomAxis, minLevel);
                }
            }
            
        }
    };

    prot._configLayout = function() {
        var scrollbarExistence = this._scrollbarExistence();
        if (this._vScrollbar) {
            this._vScrollbar.isExist(scrollbarExistence.v);
        }
        if (this._hScrollbar) {
            this._hScrollbar.isExist(scrollbarExistence.h);
        }
        return YYPlotArea.superclass._configLayout.apply(this, arguments);
    };

    prot._scrollbarExistence = function() {
        var bEnabled = this.getZoomer().enabled();
        var zoomDirection = this.getZoomer().direction() || "",
            xScrollbar = bEnabled && zoomDirection.indexOf("x") !== -1,
            yScrollbar = bEnabled && zoomDirection.indexOf("y") !== -1;
        var start = this._properties.get("plotArea.window.start") || {},
            end = this._properties.get("plotArea.window.end") || {},
            hasTimeAxis = this._hasTimeAxis();

        var values = FiscalUtil.startEndConvertor(start, end, this._properties.origin);
        start = values.start;
        end = values.end;

        if (!xScrollbar) {
            if (hasTimeAxis) {
                xScrollbar = start.hasOwnProperty("timeAxis") || end.hasOwnProperty("timeAxis");
            } else {
                xScrollbar = !(isNaN(start.valueAxis) && isNaN(end.valueAxis));
            }
        }
        if (!yScrollbar) {
            if (hasTimeAxis) {
                yScrollbar = !(isNaN(start.valueAxis) && isNaN(end.valueAxis));
            } else {
                yScrollbar = !(isNaN(start.valueAxis2) && isNaN(end.valueAxis2));
            }
        }
        return {
            h: xScrollbar,
            v: yScrollbar
        };
    };

    prot._getZoomer = function(){
        if (this._hasTimeAxis()) {
            return new TimeYZoomer(this);
        }else{
            return new YYZoomer(this);
        }
    };
    
    
    return YYPlotArea;
});

define('sap/viz/chart/chains/YYChains',[
    'sap/viz/chart/chains/ChainUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/binding/BindingManager',
    'sap/viz/chart/chains/SeriesContext'
], function Setup(
    ChainUtils,
    TypeUtils,
    BaseChains,
    ArrayUtils,
    BindingManager,
    SeriesContextFunc
) {
    var yyChains = {};
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];
    yyChains = BaseChains.extend('yy', defaultChains);

    var getBindingSeries = function(rawData, dimensions, measures, bindingResults, trellisInfo, 
        options) {
        var series = [],
            seriesBinds = [],
            seriesMeta = [],
            measureBinds = [],
            measureMeta = [];
        var allowEmpty = options && options.allowEmptyMeasure;

        var contextMeta = 'context';
        var additionMeta = "addition";
        var orderMap = {};

        dimensions.forEach(function(d){
            if (bindingResults[d]){
                seriesBinds.push(bindingResults[d]);
                seriesMeta.push(d);
            }
        });

        measures.forEach(function(m){
            if (bindingResults[m]){
                measureBinds.push(bindingResults[m]);
                measureMeta.push(m);
            }
        });

        var initDp = ChainUtils.dpInitializer(trellisInfo);

        var arrayLength = ChainUtils.getArrayLength(seriesBinds);
        var indexArray = ChainUtils.generateIndexArray(arrayLength);
        var dp, i, iLength, j, jLength, k, kLength, temp;
        iLength = indexArray.length;
        kLength = measureBinds.length;
        var emptyPossibleMeasures = measures.filter(function (e){
            return e !== 'bubbleWidth';
        });
        for (i = 0; i < iLength; i++) {
            var row = indexArray[i];
            if (! TypeUtils.isExist(row)) {
                continue;
            }
            dp = initDp();
            jLength = row.length;
            for (j = 0; j < jLength; j++) {
                dp[seriesMeta[j]] = seriesBinds[j].rowArray[row[j]];
            }
            var match;
            for (k = 0; k < kLength; k++) {
                temp = measureBinds[k].values;
                if (!TypeUtils.isExist(temp)) {
                    dp[measureMeta[k]] = undefined;
                    continue;
                }
                match = 0;
                for (j = 0; j < jLength; j++) {
                    if (allowEmpty || TypeUtils.isExist(temp[row[j]])) {
                        temp = temp[row[j]];
                        match++;
                    }
                }
                dp[measureMeta[k]] = temp;
            }
            var context = ChainUtils.processYYSeriesContext(bindingResults.context, row);
            if(context) {
                dp[contextMeta] = context;
            }
            
            var additionInfo = ChainUtils.processYYSeriesContext(bindingResults.additionInfo, row);
            if(additionInfo) {
                dp[additionMeta] = additionInfo;
            }
           
            if (match === jLength || row === 0) { //zero for no series binding
                var seriesIndex = ChainUtils.generateNum(arrayLength, row);
                series[seriesIndex] = series[seriesIndex] || [];
                if (TypeUtils.isArray(dp[measureMeta[0]])) {
                    for (j = 0, jLength = dp[measureMeta[0]].length; j < jLength; ++j){
                        var e = {};
                        var hasEmpty = false;
                        for (var key in dp) {
                            if (TypeUtils.isExist(dp[key])) {
                                if (measures.indexOf(key) > -1){
                                    e[key] = dp[key][j];
                                } else if(key === contextMeta) {
                                    e[key] = e[key] || [];
                                    var tempContext = dp[key];
                                    for(var t = 0; t < tempContext.length; ++t){
                                        e[key].push(tempContext[t][j]);
                                    }
                                } else {
                                    e[key] = dp[key];
                                }
                                if (emptyPossibleMeasures.indexOf(key) > -1 && !TypeUtils.isExist(e[key])){
                                    hasEmpty = true;
                                }
                            }
                        }
                        if (allowEmpty || !hasEmpty) {
                            series[seriesIndex].push(e);
                            //This is for volume bubble chart sorting.
                            if (e.hasOwnProperty("bubbleWidth") && TypeUtils.isNumber(e.bubbleWidth)) {
                                orderMap[e.bubbleWidth] = orderMap[e.bubbleWidth] || [];
                                orderMap[e.bubbleWidth].push(seriesIndex);
                            }
                        }
                    }

                } else if (allowEmpty || emptyPossibleMeasures.every(function(measure, i){
                    return TypeUtils.isExist(dp[measure]);
                })) {
                    series[seriesIndex].push(dp);
                }
            }
        }

        bindingResults.series = series.filter(function (e){
            return e;
        });

        bindingResults.seriesContext = SeriesContextFunc(series, seriesMeta, seriesBinds, measureBinds);
        bindingResults.orderMap = orderMap;
    };

    yyChains.yyGetBindingSeries = ChainUtils.generateSeriesGetter(getBindingSeries);

    yyChains.yyGetMeasuresFromFlattable = function(rawData, fields, mnd, bindings, duplicated, 
        bindingName) {
        yyChains.parsedData = ChainUtils.getData(rawData, bindings, yyChains.parsedData);
        var ignorePlusMinus = /bubbleWidth/.test(bindingName);

        var returnArray = ChainUtils.handleMeasure(rawData, fields, mnd, yyChains.parsedData, 
            yyChains.multiDimensionIndex, {enableDuplicated : duplicated});
        var array = ArrayUtils.transpose(returnArray.measureArray);

        var x = 0, xLen = array.length;
        var domain = Array(xLen);
        for (; x < xLen; ++x) {
            var row = array[x];
            var min = Infinity, max = -Infinity;
            for (var y = 0, yLen = row.length; y < yLen; ++y) {
                var ele = row[y];
                if (ele == null){
                    if (ignorePlusMinus){
                        ele = 0;
                    } else {
                        continue;
                    }
                }
                if (ignorePlusMinus && ele < 0) {
                    ele = row[y] = -ele;
                }
                min = Math.min(min, ele);
                max = Math.max(max, ele);
            }
            domain[x] = [min, max];
        }
        var metaData = ChainUtils.buildMetaData(rawData, fields);
        var result = {
            values: returnArray.multiArray,
            range: domain,
            metaData: metaData
        };
        return result;
    };
    Object.keys(yyChains).forEach(function(key) {
        BindingManager.registerChain(key, yyChains[key]);
    });
    return yyChains;
});

define('sap/viz/chart/scales/ShapeScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/BaseScale',
    'sap/viz/framework/common/util/DataUtils'
], function(oo, BaseScale, DataUtils) {

    /*
     * Used for shape scale
     */
    var ShapeScale = function(domain, range) {
        ShapeScale.superclass.constructor.apply(this, arguments);
        this.__className = "sap.viz.scale.ShapeScale";
        this._name = null;
        this._type = "shape";
        this._initScale();
    };

    oo.extend(ShapeScale, BaseScale);

    ShapeScale.prototype._initScale = function() {
        if (this._scale === undefined) {
            this._scale = d3.scale.ordinal();
            var domain = [];
            for (var i = 0, len = this._domain.length; i < len; i++) {
                domain.push(DataUtils.valuesToString(this._domain[i]));
            }
            var range = [].concat(this._range);
            this._range = range.splice(0, domain.length > 0 ? domain.length : 1);
            this._scale.domain(domain).range(this._range);
        }
    };

    ShapeScale.prototype.scale = function(value) {
        if (value) {
            return this._scale(DataUtils.valuesToString(value));
        } else {
            return this._scale(value);
        }
    };

    return ShapeScale;
});
define('sap/viz/chart/scales/ShapeScaleProcessor',[ 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/scale/ScaleRepository',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/scales/ShapeScale',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/util/PropertyUtils',
    'sap/viz/chart/scales/ScaleUtil'
],function(
    TypeUtils,
    ScaleRepository,
    Constants,
    ShapeScale,
    ArrayUtils,
    DataUtils,
    PropertyUtils,
    ScaleUtil)
    {
        var rotateArray = ArrayUtils.transpose;
        var generateUniqueDomain = ScaleUtil.generateUniqueDomain;
        var shapeScale = function(data, name, scaleMgr, propMgr, option,  dataModel) {
            option = option || {};
            var seriesType = option.seriesType, role = option.role;
            var props = scaleMgr.get(name);
            var shapePalette = props ? props.palette : null;
            if (!TypeUtils.isExist(data)) {
                return new ShapeScale([], shapePalette);
            }
            if (!TypeUtils.isExist(scaleMgr.getDefault(name))) {
                scaleMgr.add(name, {
                    serializable: true,
                    defaultValue: {
                        "feed": name,
                        "type": "shape",
                        "palette": Constants.SHAPE
                    }
                });
            }
            var domain = [];
            if (data.values) {
                if (seriesType === 'yy') { //for bubble and scatter, only use first binding
                    var depth = PropertyUtils.getBubbleDepth(propMgr.origin, "plotArea.shapeDepth", data.values);
                    var ignoreNoValue = propMgr.get("legend.ignoreNoValue");
                    domain = generateUniqueDomain(data.values, depth, data.metaData,
                            data.rowArray, dataModel, ignoreNoValue, "shape");
                } else {
                    domain = rotateArray(data.values);
                }
            }
            if (!shapePalette) {
                shapePalette = Constants.SHAPE;
            }
            propMgr.origin.add('plotArea.shapePalette', {
                defaultValue: Constants.SHAPE,
                serializable: false,
                get: function() {
                    return shapePalette;
                }
            });
            if (domain != null) {
                return new ShapeScale(domain, shapePalette);
            }
        };

        ScaleRepository["shapeScale"] = shapeScale;
      
    });
define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForScatter',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/ChartTypeUtils",
    'sap/viz/chart/components/util/DataPointUtils',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler',
    "sap/viz/framework/interaction/BehaviorManager"
], function(
    Constants,
    TypeUtils,
    HighlightHelper,
    DataGraphics,
    ChartTypeUtils,
    DataPointUtils,
    DOM,
    DPBhvrHdlr,
    BehaviorManager
) {
    var timeCharts = [ "info/timeseries_scatter", "info/timeseries_bubble"];
    var scatterType = ["info/bubble", "info/scatter", "info/time_bubble"].concat(timeCharts);

    scatterType = ChartTypeUtils.addTrellisType(scatterType);
    var CSS_CLASS = Constants.CSS.CLASS;

    function strokeRatioOfElement(e) {
        var ratio = 1,
            marker;
        if (isDataPoint(e) && /scale/.test(e.getAttribute("transform"))) {
            //since marker is applied scale transform, eliminate the scale effect for stroke
            marker = e.querySelector("circle") ||
                e.querySelector("rect") ||
                e.querySelector("ellipse") ||
                e.querySelector("line") ||
                e.querySelector("polyline") ||
                e.querySelector("polygon") ||
                e.querySelector("path");
            if (marker) {
                var rect = marker.getBoundingClientRect();
                var bbox = marker.getBBox();
                ratio = bbox.width / rect.width;
            }
        }
        return ratio;
    }

    function isNegativeDataPoint(e) {
        return (DataGraphics.getData(e).fillOpacity === 0);
    }


    function isDataPoint(node) {
        return DOM.hasClass(node, 'v-datapoint') || DOM.hasClass(node, 'v-datapoint-marker') ||
            DOM.hasClass(node, 'v-lines');
    }

    var getColor = function(effectMgr, e, prop, drawingEffect){
        var defaultColor = DataGraphics.getData(e).color;
        var color;
        if(TypeUtils.isFunction(prop)){
            color = prop(defaultColor);
        } else if(TypeUtils.isString(prop)){
            color = effectMgr.parseColorProperty(prop, defaultColor);
        }
        color = color || defaultColor;
        if (drawingEffect){
            var data = DataGraphics.getData(e);
            color = effectMgr.register({
                drawingEffect : drawingEffect,
                fillColor : color,
                direction : "vertical",
                graphType : data.shape,
                radius : data.r,
                patternEffect : data.pattern
            });
        }
        return color;
    };

    function drawStroke(effectMgr, e, prop, defaultWidth, radio) {
        var stroke, strokeWidth;
        if (prop.stroke.visible === true || isNegativeDataPoint(e)) {
            if (isNegativeDataPoint(e)) {
                stroke = getColor(effectMgr, e, prop.color);
            } else {
                stroke = getColor(effectMgr, e, prop.stroke.color);
            }
            strokeWidth =
                HighlightHelper.getWidth(prop.stroke.width, defaultWidth, radio);
        } else {
            stroke = DataGraphics.getData(e).borderColor;
            strokeWidth = 1;
        }
        var child = e.querySelector('path') || e.querySelector("circle");
        if(child){
            child.setAttribute("stroke", stroke);
            child.setAttribute("stroke-width", strokeWidth);
        }
        var highNode = e.querySelector('rect.v-highlight-bound');
        if (highNode) {
            highNode.removeAttribute("stroke");
            highNode.removeAttribute("stroke-width");
            highNode.removeAttribute("stroke-dasharray");
            highNode.removeAttribute("shape-rendering");
        }
    }

    function drawFill(effectMgr, e, prop, hasMarkerRenderer, drawingEffect) {
        var opacity = prop.opacity;
        if (!TypeUtils.isExist(prop.opacity)){
            opacity = 1;
        }
        e.setAttribute("fill-opacity", opacity);
        var child = e.querySelector("path") || e.querySelector("circle");
        if(child){
            child.setAttribute("stroke-opacity", opacity);
            if(!hasMarkerRenderer) {
                var color = getColor(effectMgr, e, prop.color, drawingEffect);
                child.setAttribute('fill', color);
            }
        }
    }

    var scatter = [{
        "id": "selectDataPoint_scatter",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": scatterType
        },
        "handler": function(event, service) {
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop = {
                color: properties.get('interaction.selected.color'),
                opacity: properties.get('interaction.selected.opacity'),
                stroke: properties.get('interaction.selected.stroke')
            };
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var drawingEffect = properties.get('plotArea.drawingEffect');
            var effMgr = service.getEffectManager();
            if (service.isBigDataMode()) {
                var dataPointNodes = service.getNodes(service.NodeType.DATA_POINT, false);
                elements = DataPointUtils.findByDataPointIds(dataPointNodes, elements);
            }
            var evt = {
                name: event.name,
                data: {
                    targets: elements
                }
            };
            service.fireEvent(evt, true);
            for(var i = elements.length; i--;){
                var e = elements[i];
                var ratio = strokeRatioOfElement(e);
                drawStroke(effMgr, e, prop, 1, ratio);
                drawFill(effMgr, e, prop, isMarkerRendererExist, drawingEffect);
            }
        }
    }, {
        "id": "deselectDataPoint_scatter",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": scatterType
        },
        "handler": function(event, service) {
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop;
            if (event.data.isAnyOtherSelected) {
                prop = {
                    color: properties.get('interaction.deselected.color'),
                    opacity: properties.get('interaction.deselected.opacity'),
                    stroke: properties.get('interaction.deselected.stroke')
                };
            } else {
                prop = {
                    color: properties.get('plotArea.dataPoint.color'),
                    stroke: properties.get('plotArea.dataPoint.stroke')
                };
            }
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var drawingEffect = properties.get('plotArea.drawingEffect');
            var effMgr = service.getEffectManager();
            if (service.isBigDataMode()) {
                var dataPointNodes = service.getNodes(service.NodeType.DATA_POINT, false);
                elements = DataPointUtils.findByDataPointIds(dataPointNodes, elements);
                elements = [].slice.call(elements);
            }
            var evt = {
                name: event.name,
                data: {
                    targets: elements
                }
            };
            service.fireEvent(evt, true);
            elements.forEach(function(e) {
                var ratio = strokeRatioOfElement(e);
                drawStroke(effMgr, e, prop, 1, ratio);
                drawFill(effMgr, e, prop, isMarkerRendererExist, drawingEffect);
            });
        }
    }, {
        "id": "hoverOnDataPoint_scatter",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": scatterType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop = properties.get('interaction.hover');
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var drawingEffect = properties.get('plotArea.drawingEffect');
            var effMgr = service.getEffectManager();
            elements.forEach(function(e) {
                var ratio = strokeRatioOfElement(e);
                if (!event.data.byKeyboard) {
                    drawStroke(effMgr, e, prop, 2, ratio);
                }
                drawFill(effMgr, e, prop, isMarkerRendererExist, drawingEffect);
            });
        }
    }, {
        "id": "unhoverOnDataPoint_scatter",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": scatterType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var properties = service.getProperties();
            var prop;
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var drawingEffect = properties.get('plotArea.drawingEffect');
            var effMgr = service.getEffectManager();
            elements.forEach(function(e) {
                var ratio = strokeRatioOfElement(e);
                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    prop = properties.get('interaction.selected');
                } else {
                    if (service.shouldUseDeselectedColor()) {
                        prop = properties.get('interaction.deselected');
                    } else {
                        prop = properties.get('plotArea.dataPoint');
                        delete prop.opacity;
                    }
                }
                drawStroke(effMgr, e, prop, 1, ratio);
                drawFill(effMgr, e, prop, isMarkerRendererExist, drawingEffect);
            });
        }
    }, {
        "id": "hover_range_selection_scatter",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeCharts,
            "targets": "v-m-action-layerrange"
        },
        "handler": function(event, service) {
            DPBhvrHdlr.showDetailForRangeSelectionWhenHover(event, service);
        }
    }, {
        "id": "clearPlot_scatter",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": scatterType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);

            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if (!mainNode || !mainNode.length) {
                return;
            }
            var properties = service.getProperties();
            var prop;
            var rangeSelection = event.data.rangeSelection;
            var bUseRange = rangeSelection && rangeSelection !== "clear";

            if (event.data.isGray || bUseRange) {
                prop = {
                    color: properties.get('interaction.deselected.color'),
                    stroke: properties.get('interaction.deselected.stroke')
                };

                if(!bUseRange){
                    prop.opacity = properties.get('interaction.deselected.opacity');
                }
            } else {
                prop = {
                    color: properties.get('plotArea.dataPoint.color'),
                    stroke: properties.get('plotArea.dataPoint.stroke')
                };
            }
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var drawingEffect = properties.get('plotArea.drawingEffect');
            var effMgr = service.getEffectManager();
            mainNode.forEach(function(e) {
                var ratio = strokeRatioOfElement(e);
                drawStroke(effMgr, e, prop, 1, ratio);
                drawFill(effMgr, e, prop, isMarkerRendererExist, drawingEffect);
            });
        }
    }, {
        "id": "click_on_non_selection_scatter",
        "triggerEvent": {
            "name": "click",
            "supportedChartTypes": scatterType,
            "excludeTargets": HighlightHelper.getDeselAllExTargets(),
        },
        "handler": function(event, service) {
            DPBhvrHdlr.clickOnNonSelection(event, service, timeCharts);
        }
    },{
        "id": "clearPlot_time_scatter",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": timeCharts
        },
        "handler": function(event, service) {
            DPBhvrHdlr.clearForTime(event, service);
        }
    },{
        "id": "update_range_selection_effect_scatter",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "down",
            "supportedChartTypes": timeCharts
        },
        "handler": function(event, service) {
            DPBhvrHdlr.updateRangeEffect(event, service);
        }
    }, {
        "id": "recover_range_selection_effect_scatter",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "up",
            "supportedChartTypes": timeCharts
        },
        "handler": function(event, service) {
            DPBhvrHdlr.recoverRangeEffect(event, service);
        }
    }];
    BehaviorManager.registerAll(scatter);
});

define('sap/viz/chart/views/YYChartView',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/views/ChartView",
    "sap/viz/chart/components/legend/ColorLegend",
    "sap/viz/chart/components/legend/SizeLegend",
    "sap/viz/chart/components/plotareas/YYPlotArea",
    "sap/viz/chart/scales/SizeScaleUtil",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/chains/YYChains",
    "sap/viz/chart/scales/FrameScaleProcessor",
    "sap/viz/chart/scales/ShapeScaleProcessor",
    "sap/viz/chart/behavior/config/DataPointBehaviorConfigForScatter"
], function(
    oo,
    ChartView,
    ColorLegend,
    SizeLegend,
    YYPlotArea,
    SizeScaleUtil,
    NumberUtils,
    Constants,
    TextUtils,
    TypeUtils
) {

    function YYChartView(runtime, option) {
        YYChartView.superclass.constructor.apply(this, arguments);
        this._supportLazyRender = true;
    }

    oo.extend(YYChartView, ChartView);

    var prot = YYChartView.prototype;

    prot.setSize = function() {
        if (this._plotArea && this._plotArea.setRoughSize) {
            this._plotArea.setRoughSize.apply(this._plotArea, arguments);
        }
        YYChartView.superclass.setSize.apply(this, arguments);
    };

    prot._isBubble = function() {
        return /bubble/.test(this._renderType);
    };

    prot._getLegendDefinition = function() {
        if (this._isBubble()) {
            return [SizeLegend, ColorLegend];
        }
        return [ColorLegend];
    };

    prot._getLegendModuleKey = function() {
        if (this._isBubble()) {
            return ["sizeLegend", "legend"];
        }
        return ["legend"];
    };

    prot._getDataItems = function() {
        return [
            "valueAxis",
            "timeAxis",
            "valueAxis2",
            "bubbleHeight",
            "bubbleWidth",
            "color",
            "shape",
            "dataFrame",
            "series",
            "transparent",
            "trellisRow",
            "trellisColumn",
            "orderMap",
            "seriesContext"
        ];
    };

    prot._createPlotContainer = function(isTrellis) {

        this._plotArea = new YYPlotArea(this.runtime(), {
            renderType: this._renderType,
            rawData: this._rawData,
        });

        this._plotArea.setRoughSize(this._size);
        this._plot = this._plotArea.getPlot();

        this.setChild("main", this._plotArea, {
            priority: 3
        });
    };

    prot._configLayout = function() {
        if(this._isBubble()) {
            this._applySizeScale();
        }
        return YYChartView.superclass._configLayout.apply(this, arguments);
    };

    prot._applySizeScale = function(plotArea) {

        var widthScale = this._data.bubbleWidth.scale;
        var widthDomainValues = widthScale.getDomain();
        var min = widthDomainValues[0],
            max = widthDomainValues[1];
        var labels;
        /*
         * The rules for size legend labels
         * Plot(x,y,z != null && x,y,z != 0)    Size Legend
         * [null]                               [no value]
         * [x]                                  [max]
         * [x, null]                            [max, no value]
         * [x, y]                               [max, min]
         * [x, 0, null]                         [max, 0]
         * [x, y, null]                         [max, (max+min)/2, no value]
         * [x, y, z]                            [max, (max+min)/2, min]
         * [x, y, z, null]                      [max, (max+min)/2, no value]
         * [x, y, 0, null]                      [max, (max+0)/2, 0]
         */
        if(NumberUtils.isNoValue(max) && NumberUtils.isNoValue(min)) {
            labels = [null];
        }
        else if(max === min) {
            if(!widthDomainValues.withNoValue) {
                labels = [max];
            }
            else {
                labels = [max, null];
            }
        }
        else {
            if(!widthDomainValues.withNoValue && !widthDomainValues.withMiddleValue) {
                labels = [max, min];
            }
            else if(!widthDomainValues.withNoValue && widthDomainValues.withMiddleValue) {
                labels = [max, (max + min) / 2, min];
            }
            else if(widthDomainValues.withNoValue && 
                    !widthDomainValues.withMiddleValue && widthDomainValues.withZeroValue) {
                labels = [max, min];
            }
            else if(widthDomainValues.withNoValue && 
                    !widthDomainValues.withMiddleValue && !widthDomainValues.withZeroValue) {
                labels = [max, (max + min) / 2, null];
            }
            else {
                labels = [max, (max + min) / 2, widthDomainValues.withZeroValue ? 0 : null];
            }
        }
        
        // calculate max size
        var minMarkerSize = parseInt(this._properties.get("plotArea.minMarkerSize"));
        var maxSize = null;
        
        var legendGroup = this.getChild(Constants.LEGEND_GROUP.KEY).module;
        
        maxSize = Math.min(this._size.height, this._size.width);
        maxSize *= Constants.BUBBLE.DEFAULT_WIDTH_RATIO;
        
        var sizeScale = SizeScaleUtil.build(minMarkerSize, maxSize, widthDomainValues);

        var sizeLegend = legendGroup.getChild("sizeLegend").module;
        
        sizeLegend.setData({
            labels: labels,
            scale: sizeScale
        });
        
        this._plot.setSizeScale(sizeScale);
    };

    prot.calculatePaddingInPX = function(prop){
        var paddings = YYChartView.superclass.calculatePaddingInPX.apply(this, arguments);
        if((prop.get("title.visible") === false) && (prop.get("valueAxis.visible") === true)){
            //If padding < textheight/2 and title is invisible, add half value label's height 
            //by default to avoid cut the latest value axis label.   
            this.changePaddingTop(prop, paddings);
        }     
        return paddings;
    };
    
    return YYChartView;
});

define('sap/viz/chart/metadata/bindings/YYBindings',[], function Setup() {
    var feeds = [{
        "id": "dataFrame",
        "name": "IDS_DATA_FRAME",
        "type": "Dimension",
        "min": 0,
        "max": 1,
        "acceptMND": false,
        "role": "frame.data"
    }, {
        "id": "trellisColumn",
        "name": "IDS_TRELLIS_COLUMN",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "trellis.columnCategory"
    }, {
        "id": "trellisRow",
        "name": "IDS_TRELLIS_ROW",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "trellis.rowCategory"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "mark.color"
    }, {
        "id": "shape",
        "name": "IDS_SHAPE",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "mark.shape"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": 1,
        "role": "layout.value"
    }, {
        "id": "valueAxis2",
        "name": "IDS_VALUE_AXIS2",
        "type": "Measure",
        "min": 1,
        "max": 1,
        "role": "layout.secondValue"
    }, {
        "id": "bubbleWidth",
        "name": "IDS_BUBBLESIZE",
        "type": "Measure",
        "min": 1,
        "max": 1,
        "role": "mark.size"
    }];
    return feeds;
});

define('sap/viz/chart/components/plotareas/XYYPlotArea',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plotareas/XYPlotArea',
    'sap/viz/chart/components/axis/ValueAxis',
    'sap/viz/chart/components/axis/CategoryAxis',
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/datalabels/BarDataLabels',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/chart/components/plotareas/UpdateByTrendlineUtil'
], function Setup(Constants, oo, XYPlotArea, ValueAxis, CategoryAxis, ValueScale, ValueScaleUtil, TextUtils,
        UnitFormat, TypeUtils, DataLabels, BarDataLabels, NumberUtils, updatedByTrendline) {
           
    var XYYPlotArea = function(runtime, options) {
        XYYPlotArea.superclass.constructor.apply(this, arguments);
    };

    oo.extend(XYYPlotArea, XYPlotArea);

    XYYPlotArea.prototype._getPlotOptions = function() {
        return {
            isDualValueAxis: true
        };
    };

    XYYPlotArea.prototype.setData = function(data) {
        XYYPlotArea.superclass.setData.apply(this, arguments);
        this._applyDefaultProperties(data);
    };

    XYYPlotArea.prototype._applyDefaultProperties = function(data) {
        var semanticMgr = this.runtime().semanticManager();
        if (semanticMgr.isOverrideMode() && semanticMgr.shouldChangeColor()) {
            var categoryAxisColor = this._properties.get("categoryAxis.title.style.color", "templateValue");
            if (!this._properties.has("valueAxis.title.style.color", "value")) {
                this._properties.set("valueAxis.color",  categoryAxisColor, true, "templateValue");
            }
            if (!this._properties.has("valueAxis2.title.style.color", "value")) {
                this._properties.set("valueAxis2.color",  categoryAxisColor, true, "templateValue");
            }
        } else {
            this._properties.setDefault("valueAxis.color", data.color.scale.getRange()[0]);
            this._properties.setDefault("valueAxis2.color", data.color2.scale.getRange()[0]);
            /*For dual chart, valueAxis title will apply lineColor. But by default the property applyAxislineColor of 
            combination chart is false. So set applyAxislineColor to true for dual combination chart.*/
            this._properties.setDefault("valueAxis.title.applyAxislineColor", true);
        }
    };
    
    XYYPlotArea.prototype._init = function() {
        var config = {};
        config.valueAxisScrollbar = false;
        config.valueAxisPosition = "top";
        
        XYYPlotArea.superclass._init.apply(this, [config]);
        var isHorizontal = this._plot.isHorizontal();
        var isInteractive = !this._properties.get("interaction.noninteractiveMode");
        if (isHorizontal) {
            this.setLayoutSequence(['bottom', 'top', this.allOrNone.bind(this), 'left', 'right']);
            
            //value axis is created in XYPlotArea. It has no scroll bar.             
            this._valueAxis2 = new ValueAxis(this.runtime(), {
                name: "valueAxis2",
                hasScrollbar:isInteractive,
                valueAxes: this._valueAxes
            });
            this.setChild("valueAxis2", this._valueAxis2, {
                position: "bottom"
            });
            if (isInteractive) {
                this._hScrollbar = this._valueAxis2.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
            }
        } else {
            this.setLayoutSequence(['left', 'right', this.allOrNone.bind(this), 'bottom', 'top']);
            this._valueAxis2 = new ValueAxis(this.runtime(), {
                name: "valueAxis2",
                hasScrollbar:isInteractive,
                valueAxes: this._valueAxes
            });
            this.setChild("valueAxis2", this._valueAxis2, {
                position: "right"
            });
            if (isInteractive) {
                this._vScrollbar = this._valueAxis2.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
                this.getChild("scrollbar").module.destroy();
                this.removeChild("scrollbar");
            }
            
        }

        if (this._isPercentageChart()) {
            this._valueAxis.setPercentageMode(true);
            this._valueAxis2.setPercentageMode(true);
        }

        this._zoomer.init({
            main: this,
            plot: this._plot,
            axisByDirection: {
                x: isHorizontal ? [this._valueAxis, this._valueAxis2] : [this._categoryAxis],
                y: isHorizontal ? [this._categoryAxis] : [this._valueAxis, this._valueAxis2]
            },
            isHorizontal: isHorizontal
        });
    };

    XYYPlotArea.prototype.updateValueScale = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        if (!data || width <= 0 || height <= 0) {
            return data;
        }
        var range = [0, 1];
        var isHorizontal = this._plot.isHorizontal(); 
        if (isHorizontal) {
            range[1] = width;
        } else {
            range[1] = height;
        }
        range[1] *= 0.8;
        var valueAxisData, valueAxisData2, newData = data;
        if (this._isPercentageChart()) {
            valueAxisData = this._calcPercentageValueAxisScale(range);
            ["", "2"].forEach(function(e) {
                var key = "valueAxis" + e;
                valueAxisData.metaData = data[key].metaData;
                data[key].tickHint = valueAxisData.tickHint;
                this["_" + key].setData(valueAxisData);
            }, this);
        } else {
            if (this._isAdjustValueScaleForTopLabel()){
                var dataLabelOpt = this._properties.get('plotArea.dataLabel');
                var fixedRangeOpt = this._properties.get('plotArea.primaryScale.fixedRange');
                var valueScale = this._data.valueAxis.scale;
                var valueScale2 = this._data.valueAxis2.scale;
                var domain = valueScale.getDomain().slice();
                var domain2 = valueScale2.getDomain().slice();

                var formatPatterns = dataLabelOpt.formatString;
                var formatPattern, measureName, metaDataFormat;

                if (this._data && this._data.valueAxis && this._data.valueAxis.metaData) {
                    measureName = this._data.valueAxis.metaData[0].id;
                    metaDataFormat = this._data.valueAxis.metaData[0].formatString;
                }

                formatPatterns = formatPatterns ? formatPatterns : metaDataFormat;
                
                var dataLabelInfo = {
                    key: measureName
                };

                valueAxisData = this._calcValueAxisScale("valueAxis", range);
                valueAxisData2 = this._calcValueAxisScale("valueAxis2", range);
                if((!(fixedRangeOpt || valueScale.getDomainFixed()[1] || valueScale2.getDomainFixed()[1])) && 
                        (dataLabelOpt.visible || dataLabelOpt.showTotal) && (domain || domain2)){
                    var sizes = [null, null];
                    if(this._isStackedChart() && dataLabelOpt.showTotal) {
                        if(this._plot.isHorizontal()) {
                            formatPattern = DataLabels.getFirstFormatPattern(formatPatterns, dataLabelInfo);
                        }
                        var labelText;
                        var options = {
                            decimalFormatString: 
                            UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.DATALABEL)
                        };
                        if(domain[1] > 0) {
                            labelText = UnitFormat.format(NumberUtils.preciseSimple(domain[1]), formatPattern,
                                    dataLabelOpt.unitFormatType, options);
                            sizes[1] = TextUtils.fastMeasure(labelText, dataLabelOpt.style.fontSize,
                                    dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                                    dataLabelOpt.style.fontStyle);                            
                        }
                        if(domain[0] < 0) {
                            labelText = UnitFormat.format(NumberUtils.preciseSimple(domain[0]), formatPattern,
                                    dataLabelOpt.unitFormatType, options);
                            sizes[0] = TextUtils.fastMeasure(labelText, dataLabelOpt.style.fontSize,
                                    dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                                    dataLabelOpt.style.fontStyle);
                        }
                        valueAxisData = this._calcValueAxisScale("valueAxis", range, 
                                ValueScaleUtil.extendDomainForDataLabel(domain, range, sizes, 
                                        this._plot.isHorizontal()));
                        
                        sizes = [null, null];
                        if(domain2[1] > 0) {
                            labelText = UnitFormat.format(NumberUtils.preciseSimple(domain2[1]), formatPattern,
                                    dataLabelOpt.unitFormatType, options);
                            sizes[1] = TextUtils.fastMeasure(labelText, dataLabelOpt.style.fontSize,
                                    dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                                    dataLabelOpt.style.fontStyle);                            
                        }
                        if(domain2[0] < 0) {
                            labelText = UnitFormat.format(NumberUtils.preciseSimple(domain2[0]), formatPattern,
                                    dataLabelOpt.unitFormatType, options);
                            sizes[0] = TextUtils.fastMeasure(labelText, dataLabelOpt.style.fontSize,
                                    dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                                    dataLabelOpt.style.fontStyle);
                        }
                        valueAxisData2 = this._calcValueAxisScale("valueAxis2", range, 
                                ValueScaleUtil.extendDomainForDataLabel(domain2, range, sizes, 
                                        this._plot.isHorizontal()));
                    }
                    if(!this._isStackedChart() && dataLabelOpt.visible && 
                            ((domain && (domain[1] > 0 || domain[0] < 0))|| 
                                (domain2 && (domain2[1] > 0 || domain2[0] < 0)))) {
                        if(this._isColumnChart()){
                            var tSize = TextUtils.fastMeasure('M', dataLabelOpt.style.fontSize, 
                                dataLabelOpt.style.fontWeight, dataLabelOpt.style.fontFamily, 
                                dataLabelOpt.style.fontStyle);
                            if(domain[1] > 0) {
                                sizes[1] = tSize;
                            }
                            if(domain[0] < 0) {
                                sizes[0] = tSize;
                            }        
                            valueAxisData = this._calcValueAxisScale("valueAxis", range, 
                                 ValueScaleUtil.extendDomainForDataLabel(domain, range, sizes, isHorizontal));
                            
                            sizes = [null, null];
                            if(domain2[1] > 0) {
                                sizes[1] = tSize;
                            }
                            if(domain2[0] < 0) {
                                sizes[0] = tSize;
                            }
                            valueAxisData2 = this._calcValueAxisScale("valueAxis2", range, 
                                 ValueScaleUtil.extendDomainForDataLabel(domain2, range, sizes, isHorizontal));
                        }else{
                            if(domain[1] > 0){
                                sizes[1] = BarDataLabels.getLabelSize(this._data.series, domain[1],  this._properties,
                                    formatPatterns);
                            }
                            if(domain[0] < 0){
                                sizes[0] = BarDataLabels.getLabelSize(this._data.series, domain[0], this._properties,
                                    formatPatterns);
                            }
                            valueAxisData = this._calcValueAxisScale("valueAxis", range, 
                                    ValueScaleUtil.extendDomainForDataLabel(domain, range, sizes, isHorizontal));
                            sizes = [null, null];
                            
                            if(domain2[1] > 0){
                                sizes[1] = BarDataLabels.getLabelSize(this._data.series, domain2[1], 
                                        this._properties, formatPatterns, "valueAxis2");
                            }
                            if(domain2[0] < 0){
                                sizes[0] = BarDataLabels.getLabelSize(this._data.series, domain2[0],
                                        this._properties, formatPatterns, "valueAxis2");
                            }
        
                            valueAxisData2 = this._calcValueAxisScale("valueAxis2", range, 
                                    ValueScaleUtil.extendDomainForDataLabel(domain2, range, sizes, isHorizontal));
                        }
                    }
                }
            }else{
                valueAxisData = this._calcValueAxisScale("valueAxis", range);
                valueAxisData2 = this._calcValueAxisScale("valueAxis2", range);
            }

            ValueScaleUtil.syncTicks(valueAxisData.scale, valueAxisData2.scale);
            var autoScale = valueAxisData.autoScale;
            var autoScale2 = valueAxisData2.autoScale;
            ValueScaleUtil.syncTicks(autoScale, autoScale2);
            valueAxisData.scale.setAutoDomain(autoScale.getDomain());
            valueAxisData2.scale.setAutoDomain(autoScale2.getDomain());
            var replacedData = {
                valueAxis: valueAxisData,
                valueAxis2: valueAxisData2
            };

            [valueAxisData, valueAxisData2].forEach(function(e, i) {
                var key = "valueAxis" + (i ? "2" : "");
                data[key].scale = e.scale;
                e.tickHint = data[key].tickHint = e.scale._tickHint;
                data[key].scale.setRange([0, 1]);
                var currentAxisData = replacedData[key];
                currentAxisData.metaData = data[key].metaData;
                this["_" + key].setData(currentAxisData);
            }, this);

            newData = this._cloneData(replacedData);
        }
        
        newData = updatedByTrendline.call(this, newData, range);
        
        return newData;
    };
    
    function updateDomain() {
        
    }

    return XYYPlotArea;
});

define('sap/viz/chart/chains/XYYChains',[
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/framework/binding/BindingManager'
], function Setup(
    BaseChains,
    BindingManager
) {
    var xyyChains = {};
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetMeasuresFromFlattable',
        'GetBindingSeries',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];
    xyyChains = BaseChains.extend('xyy', defaultChains);
    Object.keys(xyyChains).forEach(function(key) {
        BindingManager.registerChain(key, xyyChains[key]);
    });
    return xyyChains;
});
define('sap/viz/chart/views/XYYChartView',[
        "jquery",
        "sap/viz/framework/common/util/oo",
        "sap/viz/chart/views/XYChartView",
        "sap/viz/chart/components/plotareas/XYYPlotArea",
        "sap/viz/chart/components/util/TextUtils",
        "sap/viz/framework/common/util/TypeUtils",
        "sap/viz/chart/chains/XYYChains",   
        "sap/viz/chart/scales/FrameScaleProcessor"
    ],
    function Setup($, oo, XYChartView, PlotArea, TextUtils, TypeUtils) {

        var XYYChartView = function(runtime, option) {
            XYYChartView.superclass.constructor.apply(this, arguments);
        };

        oo.extend(XYYChartView, XYChartView);

        XYYChartView.prototype._getDataItems = function() {
            return ["valueAxis", "valueAxis2", "categoryAxis", "color", "color2", "dataFrame", "series", "trellisRow",
                "trellisColumn", "seriesContext"
            ];
        };

        XYYChartView.prototype._createPlotContainer = function(isTrellis) {

            this._plotArea = new PlotArea(this.runtime(), {
                renderType: this._renderType,
                valueAxisIndex: this._valueAxisIndex
            });

            this._plotArea.setRoughSize(this._size);

            this.setChild("main", this._plotArea, {
                priority: 3
            });
        };

        XYYChartView.prototype.changePaddingTop = function(prop, paddings){
            var propStyle1 = prop.get("valueAxis.label.style");
            var valueLabelTextHeight1 = TextUtils.canvasMeasure('', propStyle1['fontSize'], 
                propStyle1['fontWeight'], propStyle1['fontFamily']).height;
            var propStyle2 = prop.get("valueAxis2.label.style");
            var valueLabelTextHeight2 = 0;
            if(propStyle2){
                valueLabelTextHeight2 = TextUtils.canvasMeasure('', propStyle2['fontSize'], 
                propStyle2['fontWeight'], propStyle2['fontFamily']).height;
            }
            if(TypeUtils.isExist(paddings.propertyPaddingInPX) && 
                paddings.propertyPaddingInPX < Math.min(valueLabelTextHeight1, valueLabelTextHeight2) / 2) {
                paddings.propertyPaddingTopInPX = Math.max(valueLabelTextHeight1, valueLabelTextHeight2) / 2;
            }
            if(TypeUtils.isExist(paddings.propertyPaddingTopInPX) && 
                paddings.propertyPaddingTopInPX < Math.min(valueLabelTextHeight1, valueLabelTextHeight2) / 2) {
                paddings.propertyPaddingTopInPX = Math.max(valueLabelTextHeight1, valueLabelTextHeight2) / 2;
            }
        };

        XYYChartView.prototype._getSeriesSettings = function() {
            var settings = XYYChartView.superclass._getSeriesSettings.call(this);
            if (settings) {
                settings.forEach(function(srSettings, i) {
                    if (this._renderType.match(/stacked/)) {
                        srSettings.stack = "stacked_" + this._data.series[i].measureMeta[0];
                    }
                }.bind(this));
            }
            return settings;
        };

        return XYYChartView;
    });

define('sap/viz/chart/metadata/bindings/XYYBindings',[], function Setup() {
    var feeds = [{
        "id": "dataFrame",
        "name": "IDS_DATA_FRAME",
        "type": "Dimension",
        "min": 0,
        "max": 1,
        "acceptMND": false,
        "role": "frame.data"
    }, {
        "id": "trellisColumn",
        "name": "IDS_TRELLIS_COLUMN",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.columnCategory"
    }, {
        "id": "trellisRow",
        "name": "IDS_TRELLIS_ROW",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.rowCategory"
    }, {
        "id": "categoryAxis",
        "name": "IDS_CATEGORY_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "layout.category"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }, {
        "id": "valueAxis2",
        "name": "IDS_VALUE_AXIS2",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.secondValue"
    }];

    return feeds;
});
define('sap/viz/chart/scales/RGBA',[],
    function Setup() {
        function rgba(r_, g_, b_, a_, signForOpacity_) {
            this.r = r_;
            this.g = g_;
            this.b = b_;
            this.a = a_;
            this.signForOpacity = signForOpacity_;
        }

        rgba.prototype.clone = function() {
            return new rgba(this.r, this.g, this.b, this.a, this.signForOpacity);
        };

        rgba.prototype.toHex = function() {
            return d3.rgb(this.r, this.g, this.b).toString();
        };

        rgba.prototype.toString = function() {
            if (this.a <= 1 && this.signForOpacity === true) {
                return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
            } else if (this.a < 1) {
                return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
            } else {
                return this.toHex();
            }
        };

        rgba.prototype.from = function(color, a) {
            var nc = d3.rgb(0, 0, 0),
                na = 1,
                signForOpacity;
            if (a) {
                na = a;
                signForOpacity = true;
            }
            if (color !== undefined && typeof(color) === 'object') {
                if (color.rgb) {
                    nc = color.rgb();
                } else {
                    nc = color;
                }
            } else if (typeof(color) === 'string') {
                color = color.toLowerCase();
                var temp, i, j;
                if (color.indexOf('rgba') >= 0) {
                    temp = color.substring(color.indexOf('(') + 1);

                    i = temp.lastIndexOf(',');
                    j = temp.indexOf(')');
                    if (i >= 0 && j >= 0) {
                        var rgbStr = 'rgb(' + temp.substring(0, i) + ')';
                        na = parseFloat(temp.substring(i + 1, j));
                        nc = d3.rgb(rgbStr);
                    }
                } else if (color.indexOf('hsla') >= 0) {
                    temp = color.substring(color.indexOf('(') + 1);

                    i = temp.lastIndexOf(',');
                    j = temp.indexOf(')');
                    if (i >= 0 && j >= 0) {
                        var hslStr = 'hsl(' + temp.substring(0, i) + ')';
                        na = parseFloat(temp.substring(i + 1, j));
                        nc = d3.hsl(hslStr).rgb();
                    }
                } else if (color.indexOf('hsl') >= 0) {
                    nc = d3.hsl(color).rgb();
                } else if (color.indexOf('#') >= 0) {
                    var r, g, b;
                    if (color.length === 4) {
                        r = color.charAt(1);
                        r += r;
                        g = color.charAt(2);
                        g += g;
                        b = color.charAt(3);
                        b += b;
                    } else if (color.length === 7) {
                        r = color.substring(1, 3);
                        g = color.substring(3, 5);
                        b = color.substring(5, 7);
                    }
                    r = parseInt(r, 16);
                    g = parseInt(g, 16);
                    b = parseInt(b, 16);
                    nc = d3.rgb(r, g, b);
                } else {
                    nc = d3.rgb(color);
                }
            }
            this.r = nc.r;
            this.g = nc.g;
            this.b = nc.b;
            this.a = na;
            this.signForOpacity = signForOpacity;

            return this;
        };

        rgba.prototype.toGray = function() {
            var r = this.r,
                g = this.g,
                b = this.b,
                gc, result;
            if ((r === g) && (g === b)) {
                gc = Math.round(r + (255 - r) * 0.6);
            } else {
                gc = Math.round((r * 299 + g * 587 + b * 114 + 500) / 1000);
            }
            result = this.clone();
            result.r = gc;
            result.g = gc;
            result.b = gc;

            return result;
        };

        rgba.prototype.increaseBrightness = function(percent) {
            var r = this.r,
                g = this.g,
                b = this.b,
                nr, ng, nb, result;
            if (!isNaN(percent)) {
                if (percent >= 0) {
                    nr = Math.round(r + (255 - r) * percent / 100);
                    ng = Math.round(g + (255 - g) * percent / 100);
                    nb = Math.round(b + (255 - b) * percent / 100);
                } else {
                    nr = Math.round(r * (100 + percent) / 100);
                    ng = Math.round(g * (100 + percent) / 100);
                    nb = Math.round(b * (100 + percent) / 100);
                }
                result = this.clone();
                result.r = nr;
                result.g = ng;
                result.b = nb;
            }
            return result;
        };

        return rgba;
    });
define('sap/viz/chart/components/util/FillPatternUtils',[ 'sap/viz/framework/common/util/SVG','sap/viz/chart/scales/RGBA' ], function Setup(SVG, RGBA) {
    var CLASS_DEFS_CONTAINER = "v-m-root";
    var DEFS_ID = "defs-diagonalHatch";
    var PREFIX = "diagonalHatch-";
    var Utils = {};
    
    Utils.getPatternId = function(color){
        var rgba = new RGBA();
        color = rgba.from(color).toHex();
        return  "url(#" + PREFIX + color.replace(/#/, "") + ")";
    };
    // we always put defs under 'v-m-root'
    Utils.patternize = function(color, node, url) {
        var root = node;
        while(!root.getAttribute("class") || root.getAttribute("class").indexOf(CLASS_DEFS_CONTAINER) === -1){
            root = root.parentNode;
        }
        var defs = root.querySelector("#"+ DEFS_ID);
        if (!defs) {
            defs = SVG.create("defs");
            defs.setAttribute("id", DEFS_ID);
            root.appendChild(defs);
        }
        var patternId;
        if(color){
            var rgba = new RGBA();
            color = rgba.from(color).toHex();
            patternId = PREFIX + color.replace(/#/, "");
        }else{
            color = url.substr(("url(#" + PREFIX).length, 6);
            patternId = PREFIX + color;
            color = "#" + color;
            
        }
        
        var pattern = root.querySelector("#" + patternId);

        if (!pattern) {
            var path = SVG.create("path");
            pattern = SVG.create("pattern");

            path.setAttribute("d", "M2,0L5,0L0,5L0,2L2,0 M7,2L7,5L5,7L2,7L7,2");
            path.setAttribute("fill", color);
            path.setAttribute("fill-opacity", 1);

            pattern.setAttribute("id", patternId);
            pattern.setAttribute("patternUnits", "userSpaceOnUse");
            pattern.setAttribute("width", 7);
            pattern.setAttribute("height", 7);

            pattern.appendChild(path);
            defs.appendChild(pattern);
        }

        return "url(#" + patternId + ")";
    };

    return Utils;
});
define('sap/viz/chart/scales/BulletColorScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/ColorScale',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/scale/ScaleOptionFactory',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ArrayUtils'
],
    function(
    oo,
    ColorScale,
    DataUtils,
    ObjectUtils,
    ScaleOptionFactory,
    Constants,
    TypeUtils,
    ArrayUtils
) {
    var _PALETTE_PROPS = {
        actualValues: "plotArea.actualColor",
        additionalValues: "plotArea.additionalColor",
        forecastValues: "plotArea.forecastColor",
        targetValues: "plotArea.target.valueColor"
    };

    function BulletColorScale(data, propMgr, options, scaleMgr) {
        handleBulletColorScale(options, scaleMgr, propMgr);
        this._metaIds = options.metaData && options.metaData.map(function(item){
            return item.id;
        }).concat("measureNames") || ["measureNames"];
        options.sharedRuntimeColorScale = _groupSharedClrScale(
                options.sharedRuntimeColorScale, "type", this._metaIds);
        this._scales = buildSubColorScales(data.rowArray, options, propMgr);    
        this._scaleMap = {};
        for(var i = 0; i < this._scales.length; i++){
            var id = this._scales[i].id;
            this._scaleMap[id] = this._scales[i].scale;
        } 

        BulletColorScale.superclass.constructor.apply(this, arguments);
    }

    oo.extend(BulletColorScale, ColorScale);

    BulletColorScale.prototype.scale = function(key, type){
        if(arguments.length === 1 || !type){
            return  BulletColorScale.superclass.scale.apply(this, arguments);
        }else{
            return this._scaleMap[type].scale(key);
        }
    };

    BulletColorScale.prototype._initScale = function() {
        var domain = [],
            range = [];
        this._scales.forEach(function(obj) {
            var scale = obj.scale;
            scale.getDomain().forEach(function(dmn) {
                domain.push(dmn);
                range.push(scale.scale(dmn));
            });
        });

        this._domain = domain;
        this._range = range;
        this._scale = d3.scale.ordinal();
        this._scale.domain(this._domain.map(DataUtils.valuesToString)).range(this._range);
        this._constructRuntimeColorScale();
    };
    BulletColorScale.prototype.getDomain = function(id){
        if(id){
            return this._scaleMap[id] && this._scaleMap[id].getDomain();
        }  else {
            return BulletColorScale.superclass.getDomain.apply(this, arguments);
        }
    };
    BulletColorScale.prototype._constructRuntimeColorScale = function() {
        var scales = this._scales;

        function addTypeToResult(fn) {
            var results = [];
            for(var i = 0; i < scales.length; ++i){
                var scaleResults = scales[i].scale[fn]().results;
                for(var j = 0; j < scaleResults.length; ++j){
                    var newResult =  ObjectUtils.extend(true, {
                        type: scales[i].id
                    }, scaleResults[j]);
                    results.push(newResult);
                }
            }
            return results;
        }

        this._runtimeColorScale = {
            feed: "color",
            fields: this._metaIds,
            results: addTypeToResult("runtimeColorScale")
        };

        this._mergedRuntimeColorScale = {
            feed: "color",
            fields: this._metaIds,
            results: addTypeToResult("mergedRuntimeColorScale")
        };
    };

    function buildSubColorScales(color, options, props) {
        var mnds = options.mnds;
        var nMnds = mnds.actualValues.length;
        return Object.keys(mnds).map(function(key) {
            var msrs = mnds[key];
            var palette = props.get(_PALETTE_PROPS[key]);
            if(!TypeUtils.isArray(palette)){
                palette = [palette];
            }
            var sharedClrScale = options.sharedRuntimeColorScale[key];
            return {
                id: key,
                scale: _createScaleFor(key, color, msrs, palette, nMnds, sharedClrScale, options.noValueIndex)
            };
        });
    }
       
    function _groupSharedClrScale(sharedClrScale, keyProp, metaIds) {
        var mappings = ColorScale.findMatchRuntimeScale(sharedClrScale, metaIds);
        if (!mappings) {
            return {};
        } else {
            return mappings.results.reduce(function(map, item) {
                var key = item[keyProp] || "actualValues";
                if (!map[key]) {
                    map[key] = {
                        feed: "color",
                        results: []
                    };
                }
                map[key].results.push(item);
                return map;
            }, {});
        }
    }
    //If bullet has 2 colors: "UK", "USA". And only one binding for actualValues("Profit"),
    // the real series index for actualValues will be 0("UK/Profit"), 5("USA/Profit"),
    // even if other measure feed has no binding. It will be easy to find color index from series index
    var NAMES= ["actualValues", "additionalValues", "forecastValues", "targetValues"];
    var MNUMBER = NAMES.length;
    function _hasSeriesValue(i, noValueIndex){
        return (!noValueIndex || noValueIndex.indexOf(i) === -1 ||  noValueIndex.indexOf(i + 1) === -1 ||
            noValueIndex.indexOf(i + 2) === -1  || noValueIndex.indexOf(i + 3) === -1);
    }
    function handleBulletColorScale(option, scaleMgr, propMgr, name){
        if(!scaleMgr){
            return;
        }
        if (!scaleMgr.getDefault("color")) {
            var item = {
                serializable: true,
                defaultValue: {
                    "feed": "color",
                    "type": "color",
                    "actualColor": Constants.COLOR.BULLET.ActualColor,
                    "additionalColor": Constants.COLOR.BULLET.AdditionalColor,
                }
            };

            if(!option.isTime){
                item["defaultValue"]["forecastColor"] = Constants.COLOR.BULLET.ForecastColor;
            }
            scaleMgr.add("color", item);
        }   

        
        function addToPropMgr(key, defaultValue){
            var fullKey = "plotArea." + key;
            if (propMgr.origin.has(fullKey)) {
                //only rewrite property when it is an orginal property
                propMgr.origin.add(fullKey, {
                    defaultValue: defaultValue,
                    serializable: false,
                    get: function() {
                        var props = scaleMgr.get("color");
                        if (props && props[key]) {
                            return props[key];
                        } else { 
                            var templateProps = scaleMgr.get("color", "templateValue");
                            return templateProps && templateProps[key] || defaultValue;
                        }
                    }
                });
            }
        }

        addToPropMgr("actualColor", Constants.COLOR.BULLET.ActualColor);
        addToPropMgr("additionalColor", Constants.COLOR.BULLET.AdditionalColor);
        addToPropMgr("forecastColor", Constants.COLOR.BULLET.ForecastColor);
    }

    function _createScaleFor(type, colors, msrs, palette, len, sharedClrScale, noValueIndex) {
        var domain = [],
            range = [];
        var reIndex;
        var currLen = 0;
        var sharedPalette = [];
        if (sharedClrScale && sharedClrScale.results) {
            sharedClrScale.results.forEach(function(r) {
                var i = r.scaleResult.index % palette.length;
                sharedPalette[i] = palette[i];
                currLen = i + 1;
            });
        }
        if (!colors) {
            for(var kk = 0; kk < len; ++kk){
                if(_hasSeriesValue(kk * MNUMBER, noValueIndex)){
                    reIndex = kk * MNUMBER + NAMES.indexOf(type);
                    if(!noValueIndex || noValueIndex.indexOf(reIndex) === -1){
                        domain.push([msrs[kk]]);
                        range.push(palette[currLen % palette.length]);
                        
                    }
                    currLen++;
                }
            } 
        } else {
           
            colors.forEach(function(clr, index) {
                for (var i = 0; i < len; i++) {
                    // If current series has no value at all, we should ignore the whole series,
                    // should not occupy one color palette
                    if(_hasSeriesValue((index * len + i) * MNUMBER, noValueIndex)){
                        reIndex = (index * len + i) * MNUMBER + NAMES.indexOf(type);
                        if ((!noValueIndex || noValueIndex.indexOf(reIndex) === -1) && msrs[i] ) {
                            domain.push(clr.concat(msrs[i]));
                            range.push(palette[currLen % palette.length]);
                        }
                        currLen++;
                    }
                }
            });

        }
        range = sharedPalette.concat(range);

        return new ColorScale(domain, range, {
            needRuntimeColorScales: true,
            sharedRuntimeColorScale: sharedClrScale
        });
    }
    ScaleOptionFactory.register("bullet", "color", function(option, dataModel, runtime,
                                                            propertyMgr, valueAxes, chartType){
        var colorKeys = [
            "actualValues",
            "additionalValues",
            "targetValues"
        ];

        if(chartType.indexOf("time") === -1){
            colorKeys.push("forecastValues");
        }

        option.mnds = colorKeys.reduce(function(mnds, type) {
            mnds[type] = (dataModel[type]().metaData || []).map(function(mtd) {
                return mtd.id;
            });
            return mnds;
        }, {});
    });
 
    return BulletColorScale;
});

define('sap/viz/chart/components/legend/BulletLegend',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/ColorScale',
    'sap/viz/chart/components/legend/ColorLegend',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/FillPatternUtils',
    'sap/viz/framework/scale/ColorShapeScaleMerger',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/lang/LangManager',
    "sap/viz/chart/scales/BulletColorScale"
], function(oo, 
        ColorScale, 
        ColorLegend, 
        TypeUtils, 
        ObjectUtils,
        FillPatternUtils, 
        ColorShapeScaleMerger, 
        Constants, 
        NameColorUtils,
        LangManager,
        BulletColorScale
) {
    var INTERACTION_CLASS = Constants.CSS.CLASS.LEGENDITEM;
    var BULLET_LEGEND_CALSS = Constants.CSS.CLASS.BULLETLEGENDITEM;
    var DEFAULT_PATTERN_COLOR = "#aaaaaa";

    var BulletLegend = function() {
        BulletLegend.superclass.constructor.apply(this, arguments);
    };
    var COLORNAMES = ["actualColor", "additionalColor", "forecastColor"],
        HANDLEPATTERN = [true, true, false];
    oo.extend(BulletLegend, ColorLegend);

    BulletLegend.prototype.setData = function(val) {
        this._data = val;
        this._series = val.color || this._createSeries(val);
        this._colorShapeScale = null;
        return this;
    };
    
    function hasSemanticColor(ranges, name){
        for(var i = 0; i < ranges.length; ++i){
            if(ranges[i].color.hasOwnProperty(name) && ranges[i].color[name]){
                return true;
            }
        }    
        return false;
    }

    BulletLegend.prototype._createSeries = function(data) {
        var mnd = 'actualValues,additionalValues,forecastValues,targetValues'.split(',').reduce(function(mnds, feed) {
            if (data[feed]) {
                mnds[feed] = data[feed].metaData.map(function(meta) {
                    return meta.name || meta.id;
                });
            }
            return mnds;
        }, {});
        return {
            scale: new BulletColorScale([], this._properties.parentLevel, {
                mnds: mnd
            })
        };
    };

    BulletLegend.prototype._createColorScale = function() {
        var propRoot = this._properties.parentLevel;
        var semanticMgr = this.runtime().semanticManager();
        var semColorScale = semanticColorScale(semanticMgr);
        var dataPointColorScale = semColorScale.scale;
        var measureNum = this._data.actualValues.metaData.length;
        var hasOther = semanticMgr.isOverrideMode() &&
                                     dataPointColorScale && dataPointColorScale._others && 
                                     dataPointColorScale._others.properties &&
                                     dataPointColorScale._others.properties.color;

        var hasPrimaryCondition = hasSemanticColor(semColorScale.range, "actualColor") || 
                                        (hasOther && !!dataPointColorScale._others.properties.color["actualColor"]);
        var hasAdditionalCondition = hasSemanticColor(semColorScale.range, "additionalColor") || 
                                      (hasOther && !!dataPointColorScale._others.properties.color["additionalColor"]);
        var hasForecastCondition = hasSemanticColor(semColorScale.range, "forecastColor") ||
                                 (hasOther && !!dataPointColorScale._others.properties.color["forecastColor"]);
        
        var i;
        for (i = 0; i < semColorScale.range.length; i++) {
            var rangeItem = semColorScale.range[i];
            if (rangeItem.color && rangeItem.pattern) {
                if (!rangeItem.color["actualColor"] && rangeItem.pattern["actualColor"]) {
                    rangeItem.color["actualColor"] = DEFAULT_PATTERN_COLOR;
                }
                if (!rangeItem.color["additionalColor"] && rangeItem.pattern["additionalColor"]) {
                    rangeItem.color["additionalColor"] = DEFAULT_PATTERN_COLOR;
                }
                if (!rangeItem.color.hasOwnProperty("forecastColor") &&
                    rangeItem.pattern["forecastColor"]) {
                    delete rangeItem.pattern["forecastColor"];
                    delete semColorScale.domain[i]["forecastColor"];
                }
            }
        }
        
        if(!semanticMgr.isOverrideMode()) {
            //if it is not OverrideMode, we keep all original legend items.
            hasPrimaryCondition = false;
            hasAdditionalCondition = false;
            hasForecastCondition = false;
        }
        
        var valueAxis, additional, forecast;
        var series = this._series;

        var target = dataColorScale(this._data.targetValues, 
                    series.scale, series,measureNum, "targetValues"),
            gaps = gapColorScale(propRoot, target),
            config;
       
        valueAxis = dataColorScale(this._data.actualValues,
                    series.scale, series, measureNum, "actualValues");
        
        if(!hasAdditionalCondition){
            additional = dataColorScale(this._data.additionalValues,
                    series.scale, series, measureNum, "additionalValues");
        }
        if(!hasForecastCondition){
            forecast = dataColorScale(this._data.forecastValues,
                    series.scale, series, measureNum, "forecastValues");
        }
        
        var cfg = {domain:[], range:[]};
        for(i = 0; i < valueAxis.domain.length; ++i){
            if(!hasPrimaryCondition && valueAxis.domain[i]){
                cfg.domain.push(valueAxis.domain[i]);
                cfg.range.push(valueAxis.range[i]);
            }
            if(!hasAdditionalCondition && additional && additional.domain[i]){
                cfg.domain.push(additional.domain[i]);
                cfg.range.push(additional.range[i]);
            }
            if(!hasForecastCondition && forecast && forecast.domain[i]){
                cfg.domain.push(forecast.domain[i]);
                cfg.range.push(forecast.range[i]);
            }

        }
        
        var semSplitIndex = -1, tempDomain = [], tempRange = [];

        if (semColorScale.scale && !semColorScale.scale._hideSemanticLegend) {
            for(i = 0; i < semColorScale.domain.length; ++i) {
                for(var j = 0; j < COLORNAMES.length; ++j) {
                    if(semColorScale.domain[i].hasOwnProperty(COLORNAMES[j])){
                        var cfgDomian = cfg.domain, cfgRange = cfg.range;
                        if(!semanticMgr.isOverrideMode()) {
                            cfgDomian = tempDomain;
                            cfgRange = tempRange;
                            semSplitIndex++;
                        }

                        cfgDomian.push([semColorScale.domain[i][COLORNAMES[j]]]);
                        if (semColorScale.range[i].pattern &&
                            semColorScale.range[i].pattern[COLORNAMES[j]] &&
                            HANDLEPATTERN[j]) {
                            cfgRange.push({
                                color: semColorScale.range[i].color[COLORNAMES[j]],
                                pattern: semColorScale.range[i].pattern[COLORNAMES[j]]
                            });
                        } else {
                            cfgRange.push(semColorScale.range[i].color[COLORNAMES[j]]);
                        }
                    }
                    
                }
            }
        }
        
        if(!semanticMgr.isOverrideMode()) {
            cfg.domain = tempDomain.concat(cfg.domain);
            cfg.range = tempRange.concat(cfg.range);
        }
          
        cfg.domain = cfg.domain.concat(gaps.domain);
        cfg.range = cfg.range.concat(gaps.range);
         
        var targetDomain = this._series.scale.getDomain("targetValues");
        var targetValues = this._data.targetValues;
        if(targetValues && targetValues.metaData && targetValues.metaData.length &&
            targetDomain && targetDomain.length > 0){
            var targetText = propRoot.get("legend.label.text.target");
            if(targetText === null || targetText === ''){
                targetText = LangManager.get("IDS_TARGET");
            }
            if(this._data.targetValues.metaData.length > 1 ){
                cfg.domain.push(targetText);
            }else{
                cfg.domain.push(this._data.targetValues.metaData[0].name || this._data.targetValues.metaData[0].id);
            }
            cfg.range.push( propRoot.get("plotArea.target.valueColor"));
             
        }    
        var scale = new ColorScale(cfg.domain, cfg.range);
        var metaData = [];
        if(series && series.metaData){
            metaData = metaData.concat(series.metaData);
        }
        
        // Add mnd to make legend title show correctly
        metaData.push({
            id: "measureNames",
            type: "Dimension",
            values:[{id:"id", name:"name"},{id:"id1", name:"name1"}] // Just put 2 items for title display correct
        });
        return {
            semSplitIndex : semSplitIndex,
            metaData: metaData,
            scale: scale,
            rowArray: cfg.domain
        };
    };

    BulletLegend.prototype.render = function(selection, loadMore) {
        // Process fill pattern here, because fillpattern need DOM node 
        if(this._colorShapeScale && this._colorShapeScale._colorScales){
            var colorScale = this._colorShapeScale._colorScales;
            if(colorScale && colorScale[0] && colorScale[0].scale){
                var ranges = colorScale[0].scale.getRange();
                var len = ranges.length;
                for(var i = 0; i < len; ++i){
                    if(ranges[i] &&
                        !TypeUtils.isPlainObject(ranges[i]) &&
                        ranges[i].indexOf("url") !== -1){
                        ranges[i] = FillPatternUtils.patternize(null, selection.node(), ranges[i]);
                    }
                }
            }
        }
        
        BulletLegend.superclass.render.apply(this, arguments);
        selection.selectAll("g." + INTERACTION_CLASS).classed(BULLET_LEGEND_CALSS, true).
            classed(INTERACTION_CLASS, false);
    };

    var name2class = {  "actualValues": "v-primary",
                        "additionalValues": "v-additional",
                        "forecastValues": "v-forecast",
                        "targetValues": "v-target"
                     };

    function _isSameColor(arr1, arr2){
        //the last element is always the measure 
        //one is the display name, the other is the id
        if(arr1.length !== arr2.length){
            return false;
        }
        for(var i = 0; i < arr1.length-1; i++){
            if(!ObjectUtils.deepEqual(arr1[i], arr2[i])){
                return false;
            }
        }
        return true;
    }

    BulletLegend.prototype._calcDomain = function(items, hideNoValueLabel){
        var result = BulletLegend.superclass._calcDomain.apply(this, arguments);
        var mergedScales = this._series.scale._mergedRuntimeColorScale.results;
        var usedIndex = {};
        for (var i = 0; i < result.length; i++) {
            var item = result[i];
            delete item.bulletClass;

            if(item.ctx.measureNamesId){
                //find the bullet class for each item, used only by UVB
                for (var j = 0; j < mergedScales.length; j++) {
                    if(usedIndex[j]){
                        continue;
                    }

                    var tempItem  = mergedScales[j];
                    var itemMeasure = tempItem.dataContext[tempItem.dataContext.length-1];
                    var isSameMeasure = item.ctx.measureNamesId === itemMeasure;  
                    
                    if(isSameMeasure && _isSameColor(item.val, tempItem.dataContext)){
                        var typeId = tempItem.type;
                        item.bulletClass = name2class[typeId]; 
                        usedIndex[j] = true;
                        break;
                    }
                }    
            }else if(i === result.length -1){
                //target context is a string and its item position is always the last one
                item.bulletClass = "v-target";
            }
        }
        return result;
    };

    BulletLegend.prototype._initColorShapeScale = function() {
        if (this._colorShapeScale) {
            return;
        }

        var markMgr = this.runtime().markManager(),
            colorScale = this._createColorScale(),
            merger = new ColorShapeScaleMerger(markMgr);

        merger._isBullet = true;
        merger._bindingInfo = {
            actualValues: this._data.actualValues,
            forecastValues: this._data.forecastValues,
            additionalValues: this._data.additionalValues,
            targetValues: this._data.targetValues
        };

        merger.addColorScale(colorScale);
        merger.merge();
        // If targetVlues has all null value and ignoreNoValue is true, should not show it
        var tDomains = this._series.scale.getDomain("targetValues");
        var tMetaData = this._data.targetValues.metaData;
        for (var item, i = 0, len = merger.getLength(); i < len; i++) {
            item = merger.getItem(i);
            if(i <= colorScale.semSplitIndex) {
                item.isSemanticItem = true;
            }
            
            if (i === len - 1 && tDomains && tDomains.length > 0 && tMetaData && tMetaData.length > 0) {
                item.shape =  this._options && this._options.options && 
                              this._options.options["targetLineDirection"] === Constants.DIRECTION.HORIZONTAL ? 
                              "horizontal-target-line": "vertial-target-line";
            } else {
                item.shape = "square";
            }
        }
        this._colorShapeScale = merger;
        this.setBindingFields(merger.getBindingFields());
    };

    function semanticColorScale(semanticMgr) {
        if (semanticMgr.hasDataPointColorStyle()) {
            var dataPointColorScale = semanticMgr.getDataPointColorScale(true);
            
            if(TypeUtils.isArray(dataPointColorScale) && dataPointColorScale.length === 0){
                //a useless empty array
                return {
                    domain: [],
                    range: [],
                    scale: null
                };
            } else if(dataPointColorScale.hasValidOthers()){
                // remove others domain element which name is null
                var domains = dataPointColorScale.getDomain();
                var ranges = dataPointColorScale.getRange();
                var visibleDomains = [];
                var visibleRanges = [];
                var num = domains.length;
                for(var i = 0; i < num - 1; ++i){
                    visibleDomains.push(domains[i]);
                    visibleRanges.push(ranges[i]);
                }
                
            
                var othersDomains = {};
                var othersRanges = {color: {}, pattern: {}};
                var hasOther = false;
                for(var prop in domains[num - 1]){
                    if(domains[num - 1][prop] !== null){
                        hasOther = true;
                        othersDomains[prop] = domains[num-1][prop];
                        othersRanges.color[prop]= ranges[num -1].color[prop];
                        if (ranges[num -1].pattern) {
                            othersRanges.pattern[prop] = ranges[num -1].pattern[prop];
                        }
                    }
                }
                
                if(hasOther){
                    visibleDomains.push(othersDomains);
                    visibleRanges.push({color: othersRanges.color, pattern: othersRanges.pattern});
                }
                
                return {
                    domain: visibleDomains,
                    range: visibleRanges,
                    scale: dataPointColorScale
                };
                
            }
            else{
                return {
                    domain: dataPointColorScale.getDomain(),
                    range: dataPointColorScale.getRange(),
                    scale: dataPointColorScale
                };
            }
        } else {
            return {
                domain: [],
                range: [],
                scale: null
            };
        }
    }

    function dataColorScale(model, scale, series, measureNum, type) {
        var domain = [],
            range = [];
        
        var realNum = 0;
        var t;
        function processOneItem(base, k, names){
            if(k < model.metaData.length && scale.hasDomain(base.concat(model.metaData[k].id))){
                domain.push( names.concat(model.metaData[k].name ||  model.metaData[k].id));
                range.push(scale.scale(base.concat(model.metaData[k].id), type));
            }else{
                ++domain.length;
                range.push(undefined);
            }
        }
        if (model && model.metaData) {
            if(series && series.metaData && series.metaData.length > 0){
                var rowArray = series.rowArray;
                
                for(var i = 0; i < rowArray.length; ++i){
                    var names = [];
                    names.push(rowArray[i][0] === null ? LangManager.get("IDS_ISNOVALUE") :rowArray[i][0]) ;
                    for(var j = 1; j < rowArray[i].length; ++j){
                        names.push(rowArray[i][j] === null? LangManager.get("IDS_ISNOVALUE") :rowArray[i][j]);
                    }
                    for(t = 0; t < measureNum; ++t){
                        processOneItem(rowArray[i], t , names);
                        ++ realNum;
                    }
                }
                
            }else{
                for( t = 0; t < measureNum; ++t){
                    processOneItem([], t, []);
                }
            }
        }
        
        // for no color binding case
        var dLength = domain.length;
        var rLength = range.length;
        while(rLength < dLength){
            range.push(range[dLength % rLength]);
            rLength++;
        }
      
        return {
            domain: domain,
            range: range.slice(0, domain.length)
        };
    }

    function gapColorScale(props, target) {
        var visible = props.get("plotArea.gap.visible"),
            type = props.get("plotArea.gap.type"),
            positiveText = props.get("legend.label.text.positiveGap"),
            positiveColor = props.get("plotArea.gap.positiveColor"),
            negativeText = props.get("legend.label.text.negativeGap"),
            negativeColor = FillPatternUtils.getPatternId(
                    NameColorUtils.convertColor(props.get("plotArea.gap.negativeColor"))),

            domain = [],
            range = [];
        if(positiveText === null || positiveText === ''){
            positiveText = LangManager.get("IDS_ABOVE_IS_GOOD");
        }
        if(negativeText === null || negativeText===''){
            negativeText = LangManager.get("IDS_BELOW_IS_BAD");
        }
        if (visible && target.domain.length > 0) {
            if (type === "both") {
                domain.push([positiveText]);
                domain.push([negativeText]);
                range.push(positiveColor);
                range.push(negativeColor);
            } else if (type === "positive") {
                domain.push([positiveText]);
                range.push(positiveColor);
            } else if (type === "negative") {
                domain.push([negativeText]);
                range.push(negativeColor);
            }
        }
        return {
            domain: domain,
            range: range
        };
    }

    BulletLegend.prototype._adjustRendererOption = function(rendererOption) {
        rendererOption.isBullet = true;
    };

    BulletLegend.prototype.destroy = function() {
        BulletLegend.superclass.destroy.call(this);
        this._data = null;
        this._colorShapeScale = null;
    };
    
    return BulletLegend;
});

define('sap/viz/chart/components/accessibility/BulletDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator"
], function(oo, ArrayUtils, BaseDataPointNavigator) {

    function BulletDataPointNavigator() {
        BulletDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._dataPointIndexTable = [];
        this._setupDataPointsMap();
    }

    oo.extend(BulletDataPointNavigator, BaseDataPointNavigator);

    var prot = BulletDataPointNavigator.prototype;

    prot._setupDataPointsMap  = function() {
        if (!this._series || !this._series[0]) {
            return;
        }

        var ii, jj, item, ts;
        var categoryNum = this._series[0].length;
        var allSeriesSameLength = this._series.every(function(s){
                return s === categoryNum;
            });


        if(this._isTimeBullet && !allSeriesSameLength){
            //we want sort dps by time stamp
            var timeMatrix = {};
            var timeStamps = [];
            for (ii = 0; ii < this._series.length; ii++) {
                var series = this._series[ii];
                for (jj = 0; jj < series.length; jj++) {
                    item = this._series[ii][jj];
                    if(item && item.dp){
                        ts = item.timeAxis[0].parsedValue;
                        if(!timeMatrix[ts]){
                            timeMatrix[ts] = [];
                            timeStamps.push(ts);
                        }
                        timeMatrix[ts].push(item.dp);
                    }
                }
            }

            timeStamps.sort();
            for (ii = 0; ii < timeStamps.length; ii++) {
                ts = timeStamps[ii];
                var dps = timeMatrix[ts];
                for(jj = 0; dps && jj < dps.length; jj++){
                    this._dataPointIndexTable.push(dps[jj]);
                }
            }
        } else{
            //non-time bullet chain creates series such all series always have the same length
            for (var categoryIndex = 0; categoryIndex < categoryNum; categoryIndex++) {
                for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
                    item = this._series[seriesIndex][categoryIndex];
                    if (item && item.dp) {
                        this._dataPointIndexTable.push(item.dp);
                    }
                }
            }
        }  
    };

    prot.destroy = function() {
        BulletDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._dataPointIndexTable = null;
    };

    prot.left = function(id) {
        return this._isVerticalRender ?
            this.getPrevDataPointInSeries(id) : this.getPrevDataPointInSeries(id);
    };

    prot.right = function(id) {
        return this._isVerticalRender ?
            this.getNextDataPointInSeries(id) : this.getNextDataPointInSeries(id);
    };

    prot.up = function(id) {
        return this._isVerticalRender ?
            this.getPrevDataPointInSeries(id) : this.getPrevDataPointInSeries(id);
    };

    prot.down = function(id) {
        return this._isVerticalRender ?
            this.getNextDataPointInSeries(id) : this.getNextDataPointInSeries(id);
    };

    prot.getPrevDataPointInSeries = function(id) {
        var dp = null;
        if (this._dataPointIndexTable) {
            var curIdx = this._dataPointIndexTable.indexOf(this.getDataPoint(id));
            curIdx--;
            dp = this._dataPointIndexTable[curIdx];
            while (!dp && --curIdx > -1) {
                dp = this._dataPointIndexTable[curIdx];
            }
        }
        return dp;
    };

    prot.getNextDataPointInSeries = function(id) {
        var dp = null;
        if (this._dataPointIndexTable) {
            var curIdx = this._dataPointIndexTable.indexOf(this.getDataPoint(id));
            curIdx++;
            dp = this._dataPointIndexTable[curIdx];
            while (!dp && ++curIdx < this._dataPointIndexTable.length) {
                dp = this._dataPointIndexTable[curIdx];
            }
        }
        return dp;
    };

    prot.getFirstStartPoint = function() {
        if (this._series) {
            return this._dataPointIndexTable[0];
        } else {
            return null;
        }
    };


    return BulletDataPointNavigator;
});

define('sap/viz/chart/components/plots/BulletPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/DataHandler',
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/renderers/BarRenderer',
    'sap/viz/chart/components/util/FillPatternUtils',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/scales/ValueScale',
    'sap/viz/chart/components/renderers/GridlineRenderer',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/chart/components/util/ColorUtil",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/BulletDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants"
], function(
    oo, 
    SVG, 
    BasePlot, 
    DataHandler, 
    DataGraphics, 
    DataPointUtils, 
    NameColorUtils, 
    BarRenderer, 
    FillPatternUtils, 
    NumberUtils,
    Constants, 
    ValueScale, 
    GridlineRenderer, 
    TypeUtils, 
    UADetector,
    ObjectUtils,
    ColorUtil,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants
) {

    var BARPERCENTAGE = {
        PRIMARYONLY : 0.7143,
        PRIMARYWIDTH : 0.5714
    };
    var MIN_FILL_SIZE = Constants.MIN_FILL_SIZE;

    var BulletPlot = function(context, options) {
        options = options || {
            isHorizontal: true
        };
        BulletPlot.superclass.constructor.apply(this, arguments);
        this._semanticMgr.setUseSemanticPattern(true);
    };

    oo.extend(BulletPlot, BasePlot);

    BulletPlot.prototype._getCategoryWidth = function() {
        return this._data.categoryAxis.scale.getRangeBand() *
          (this.isHorizontal() ? this._realSize.height : this._realSize.width);

    };

    BulletPlot.prototype._getScaleValue = function(value) {
        return this._data.actualValues.scale.scale(value) * 
          (this.isHorizontal() ? this._realSize.width : this._realSize.height);
    };

    BulletPlot.prototype.isHorizontal = function() {
        return (this._options.isHorizontal === true);
    };
 
    BulletPlot.prototype.update = function(scale) {
        this._applyChanges();
        var selection = this._selection.select(".v-plot-main");
        this._drawGridlines(selection);
        this._updateDatapoints(selection);
    };

    function determineGap(type, actualVal, targetVal) {

        if (NumberUtils.isNoValue(actualVal) || NumberUtils.isNoValue(targetVal)) {
            return false;
        }
        if (type === 'both' && actualVal != targetVal) {
            return true;
        } else if (type === 'positive' && actualVal > targetVal) {
            return true;
        } else if (type === 'negative' && actualVal < targetVal) {
            return true;
        } else {
            return false;
        }
    }

    BulletPlot.prototype._categoryCount = function() {
        return this._data.categoryAxis.rowArray.length;
    };
    
    BulletPlot.prototype.getPreferredSize = function () {
        var props = this._properties;
        var isHorizontal = this.isHorizontal();
        var ranges = this._getCategoryRange() || this._getTimeRange();
        var seriesLength = this._data.series.length;
        var aspect = {
                size: isHorizontal ? 'height' : 'width',
                pos: isHorizontal ? 'y' : 'x'
            };
        var isTimeChart = !!this._data.timeAxis;
        var isRangeIncompleteFn = this._isRangeIncomplete;
        var isInterative = !props.origin.get("interaction.noninteractiveMode");

        function useFullRangeAlgo(){
            return !isTimeChart && ranges && !isRangeIncompleteFn(ranges) && isInterative;
        }

        var fullRangeCase = isInterative && (!useFullRangeAlgo()) && 
                                (props.get('isFixedDataPointSize') || isRangeIncompleteFn(ranges));

        if(fullRangeCase || useFullRangeAlgo()){
            var fixedBarSize = this.__fixedBarSize();
            var maxBarWidth = fixedBarSize.max;
            var minWidth = fixedBarSize.min;
            var barSizeRatio = this.__barSizeRatio();
            var maxCategoryWidth = fixedBarSize.max * barSizeRatio;
            var allCategoryNum = this._categoryCount();
            var overviewCategoryWidth = this._size[aspect.size] / allCategoryNum;

            if (fullRangeCase) {
                var minCategoryWidth = minWidth * ((seriesLength - 1) / 8 + seriesLength + 2/3);
                if(overviewCategoryWidth < minCategoryWidth){
                    this._realSize[(isHorizontal ? 'height' : 'width')] = 
                        minCategoryWidth * allCategoryNum;
                }
                //time implement _shiftOffsetForIncompleteRange as empty function
                if(isRangeIncompleteFn(ranges) &&  
                    this._shiftOffsetForIncompleteRange(ranges, allCategoryNum)){
                    return this._realSize;
                }
            }
            if (useFullRangeAlgo()) {
                var nCatVisible = ranges[1] - ranges[0] + 1;
                var curCategoryWidth = (isHorizontal ? this._size.height : this._size.width) / nCatVisible;
                if (curCategoryWidth > maxCategoryWidth) {
                    if (overviewCategoryWidth < maxCategoryWidth) {
                        // calculate max visible category numbers
                        var maxVisibleCount = this._size[aspect.size] / maxCategoryWidth;
                        // set start position fitting in poltArea
                        if (maxVisibleCount > allCategoryNum - ranges[0]) {
                            ranges[0] = allCategoryNum - maxVisibleCount;
                        }
                        this._realSize[aspect.size] = maxCategoryWidth * allCategoryNum;
                    } else {
                        ranges[0] = 0;
                    }
                } else {
                    this._realSize[aspect.size] = this._size[aspect.size] * allCategoryNum / nCatVisible;
                }
                this._offset[aspect.pos] = -ranges[0] / allCategoryNum * this._realSize[aspect.size];
            }
        }
        
        return this._realSize;
    };

    BulletPlot.prototype._generatePath = function(size, val) {
        var points = [];
        //When path stroke width is 3, it is 1.5. If storke width is 2, it is 1.
        var strokePadding = 1.5;
        if (this.isHorizontal()) {
            if (size.width === 0) {
                strokePadding = 0;
            }

            if(val >= 0){
                points.push([0, strokePadding]);
                points.push([size.width-strokePadding, strokePadding]);
                points.push([size.width-strokePadding, size.height-strokePadding]);
                points.push([0, size.height-strokePadding]); 
            }else{
                points.push([size.width, strokePadding]);
                points.push([strokePadding, strokePadding]);
                points.push([strokePadding, size.height-strokePadding]); 
                points.push([size.width, size.height-strokePadding]);
            }
        } else {
            if (size.height === 0) {
                strokePadding = 0;
            }

            if(val >= 0){
                points.push([strokePadding, size.height]);
                points.push([strokePadding, strokePadding]);
                points.push([size.width-strokePadding, strokePadding]);
                points.push([size.width-strokePadding, size.height]);
            }else{
                points.push([strokePadding, 0]);
                points.push([strokePadding, size.height - strokePadding]);
                points.push([size.width-strokePadding, size.height- strokePadding]);
                points.push([size.width-strokePadding, 0]);
            }
        }
        return SVG.generatePath({points : points});       
    };

    BulletPlot.prototype._pathStrokeWidth = function(context) {
        //Now path stroke width is 3 for noFill pattern, 
        //but it should be 0 when bar height or width is 0.
        if (context && context[context.measureNames] === 0) {
            return 0;
        }
        return 3;
    };

    BulletPlot.prototype._drawGridlines = function(parent) {
        var size = this._realSize;
        var isHorizontal = this.isHorizontal();
        var direction = isHorizontal ? Constants.DIRECTION.VERTICAL : Constants.DIRECTION.HORIZONTAL;
        var props = this._properties.proxy('gridline');
        var range = isHorizontal ? [0, size.width] : [size.height, 0];
        var scale = this._gridlineScale = new ValueScale(this._data.actualValues.scale.getDomain(), range);
        scale.setTickHint(this._data.actualValues.tickHint);
        GridlineRenderer.drawValueGridline(parent, size.width, size.height,
                scale, props, direction, this._effectManager);
    };

    BulletPlot.prototype._updateBulletBar = function(barNode, config) {
        var width = config.width < 1 && config.width !== 0 ? 1 : config.width;
        var height = config.height < 1 && config.height !== 0 ? 1 : config.height;
        barNode.setAttribute("width", width);
        barNode.setAttribute("height", height);
        if(config.stroke) {
            var minSize = this.isHorizontal() ? height : width;
            var strokeWidth = minSize > config.strokeWidth + 1 ? config.strokeWidth : minSize - 1;
            if(strokeWidth >= 1){
                barNode.setAttribute('stroke', config.stroke);
                barNode.setAttribute('stroke-width', config.strokeWidth);
            }else{
                barNode.removeAttribute('stroke');
                barNode.removeAttribute('stroke-width');
            }
        }
        return barNode;
    };

    BulletPlot.prototype._updateBulletNoFillBar = function(barNode, config, path) {
        barNode.setAttribute("stroke", config.fill);
        barNode.setAttribute('stroke-width', 
            isNaN(config.pathStrokeWidth) ? 3 : config.pathStrokeWidth);
        barNode.setAttribute("d", path);
        return barNode;
    };

    BulletPlot.prototype._updateBulletLine = function(lineNode, config) {
        lineNode.setAttribute("x1", "" + config.x1);
        lineNode.setAttribute("x2", "" + config.x2);
        lineNode.setAttribute("y1", "" + config.y1);
        lineNode.setAttribute("y2", "" + config.y2);
        lineNode.setAttribute("stroke-width", config.width);
        return lineNode;
    };

    BulletPlot.prototype._getDefaultZeroLineColor = function() {
        return this._properties.origin.get("categoryAxis.color");
    };

    BulletPlot.prototype._drawZeroLine = function(parent){
        var size = this._realSize;
        var direction = this.isHorizontal() ? Constants.DIRECTION.VERTICAL : Constants.DIRECTION.HORIZONTAL;
        GridlineRenderer.drawZeroLine(parent, 
                size.width, size.height, this._gridlineScale,
                this._properties, direction, this._getDefaultZeroLineColor());
    };

    BulletPlot.prototype._drawDatapoints = function (parent){
        this._renderDatapoints(parent, false);
        this._drawZeroLine(parent);
    };

    BulletPlot.prototype._updateDatapoints = function (parent){
        this._renderDatapoints(parent, true);
        this._drawZeroLine(parent);
    };

    function calcColor(semProps, scale, colorDomain, msr) {
        var color = semProps[msr + "Color"] || scale.scale(colorDomain.color.concat(colorDomain[msr]), msr + "Values");
        return NameColorUtils.convertColor(color);
    }

    BulletPlot.prototype._adjustColorDomain = function(currCate,  internalSeries,  colorDomain){
        var actVal = currCate.actualValues;
        var addVal = currCate.additionalValues;
        var fctVal = currCate.forecastValues;

        if (!NumberUtils.isNoValue(actVal)) {
            colorDomain.actual = this._data.actualValues.metaData[internalSeries].id;
        }
        
        if (!NumberUtils.isNoValue(addVal)) {
            colorDomain.additional = this._data.additionalValues.metaData[internalSeries].id;
        }
        
        if (!NumberUtils.isNoValue(fctVal)) {
            colorDomain.forecast = this._data.forecastValues.metaData[internalSeries].id;
        }

        return colorDomain;
    };

    //TODO: this code can be optimizied by only using currCate.dp.context
    //but it return null now
    BulletPlot.prototype._getInitialColorDomain = function (color, colorDomain, sIndex) {
        if (color && color.metaData) {
            colorDomain.color = color.rowArray[parseInt(sIndex / this._data.actualValues.metaData.length)];
        }
        return colorDomain;
    };

    var NEGGAPOFFSET = 2.5, POSGAPOFFSET= 0.5;
    BulletPlot.prototype._renderOnePoint = function(currCate, colorDomain, extra_data, 
                                                    config, currentDp, minMax){
        var ctxSemantic = currCate.dp && currCate.dp.context();
        var additionCtx = currCate.dp && currCate.dp.additionCtx();
        var semColors ;
        var semColorProps;
        var pattern;
        var pos;
        var colorScale = this._data.color.scale;
        var dataNode, noFillActNode;
        var shadowColor = this._properties.get("target.shadowColor");
        var actualPos = 0, path;
        var isUpdate = config.isUpdate;
        var dpRenderer =  this._properties.get("markerRenderer") || BarRenderer;
        var realSize = this._realSize;
        var minSize = MIN_FILL_SIZE;

        if (config.horizontal) {
            config.x = 0;
        } else {
            config.y = 0;
        }

        //the distance from bottom to the zeroLine
        var zeroPos = this._getScaleValue(0);
        var lowPos = zeroPos;

        function getSize(){
            var result = Math.abs(pos - lowPos);
            //have a min size
            if(result < minSize && val !== 0){
                result = minSize;
                if (val > 0 && !config.horizontal) {
                    pos = lowPos + minSize;
                } else if (val < 0 && config.horizontal) {
                    pos = lowPos - minSize;
                }
            }
            return result;
        }

        function getHorizontalX(){
            return val > 0 ? lowPos : pos;
        }

        function getVerticalY(){
            return val > 0 ? realSize.height - pos: 
                             realSize.height - lowPos;
        }

        function updateMinMax(){
            minMax.max = Math.max( minMax.max, pos);
            minMax.min = Math.min( minMax.min, pos);

            minMax.max = Math.max( minMax.max, lowPos);
            minMax.min = Math.min( minMax.min, lowPos);
        }

        //draw or update forecast value
        var val = currCate.forecastValues;
        if (!NumberUtils.isNoValue(val)) {
            pos = this._getScaleValue(val);
            if (config.horizontal) {
                config.width = getSize();
                config.height = config.realBarSize;
                config.x = getHorizontalX();
                config.y = config.categoryPos;
            } else {
                config.height = getSize();
                config.width = config.realBarSize;
                config.x = config.categoryPos;
                config.y = getVerticalY();
            }

            updateMinMax();
            semColors = this._semanticMgr.analyzeDataPoint(["color","forecastColor"], ctxSemantic, true, additionCtx);
            semColorProps = ((semColors || {}).properties || {}).color || {};
            config.fill = calcColor(semColorProps, colorScale, colorDomain, "forecast");

            if (isUpdate) {
                dataNode = currentDp.querySelector(".v-forecast");
                dataNode = this._updateBulletBar(dataNode, config);
            } else {
                dataNode = dpRenderer({
                    ctx:ctxSemantic,
                    graphic: config,
                    effectManager: this._effectManager,
                    horizontal : config.horizontal,
                    defaultRender:{render:BarRenderer},  //default render is for uvb custom render,
                    currCate: currCate,
                    bulletType: "forecastValue",
                    bulletClass: "v-forecast",
                    measures: colorDomain
                });
                dataNode.setAttribute("class", "v-forecast");
                currentDp.appendChild(dataNode);
            }
            dataNode.setAttribute("transform", 'translate(' + config.x + ', ' + config.y + ')');
            extra_data.color['v-forecast'] = {
                color: config.fill
            };
        }

        if (this._strokeProp && this._strokeProp.visible) {
            config.stroke = this._strokeProp.color;
            config.strokeWidth = '1px';
        }
        // darw actual values


        if (config.horizontal) {
            config.y = config.categoryPos + config.primaryOffset;
            config.height = config.primaryPercentage * config.realBarSize;
            config.width = 0;
        } else {
            config.x = config.categoryPos + config.primaryOffset;
            config.width = config.primaryPercentage * config.realBarSize;
            config.height = 0;
        }

        val = currCate.actualValues;
        if (!NumberUtils.isNoValue(val)) {
            pos = this._getScaleValue(val);
            if (config.horizontal) {
                config.width = getSize();
                config.x = getHorizontalX();
            } else {
                config.height = getSize();
                config.y = getVerticalY();
            }
            semColors = this._semanticMgr.analyzeDataPoint(["color","actualColor"], ctxSemantic, true, additionCtx);
            pattern = this._semanticMgr.analyzeDataPoint(["pattern","actualColor"], ctxSemantic, true, additionCtx);
            semColorProps = ((semColors || {}).properties || {}).color || {};
            config.fill = calcColor(semColorProps, colorScale, colorDomain, "actual");
            config.pattern = pattern && pattern.properties &&
                pattern.properties.pattern&& pattern.properties.pattern.actualColor;

            if (config.pattern === "noFill") {
                path = this._generatePath(config, val);
                config.pathStrokeWidth = this._pathStrokeWidth(ctxSemantic);
                config.bgColor =  this._getBackgroundColor();
            }

            if (isUpdate) {
                dataNode = currentDp.querySelector(".v-primary");
                if (config.pattern === 'noFill') {
                    noFillActNode = currentDp.querySelector(".v-primary-noFill");
                    noFillActNode = this._updateBulletBar(noFillActNode, config);
                    dataNode = this._updateBulletNoFillBar(dataNode, config, path);
                } else {
                    dataNode = this._updateBulletBar(dataNode, config);        
                }                 
            } else {
                dataNode = dpRenderer({
                    ctx:ctxSemantic,
                    graphic: config,
                    path : path,
                    effectManager: this._effectManager,
                    horizontal : config.horizontal,
                    defaultRender: {render:BarRenderer}, //default render is for uvb custom render 
                    currCate: currCate,
                    bulletType: "actualValue",
                    bulletClass: "v-primary",
                    measures: colorDomain
                });
                dataNode.setAttribute("class", "v-primary");     
                currentDp.appendChild(dataNode);

                if(config.pattern === 'noFill'){
                    var clonedGraphic = ObjectUtils.clone(config);
                    delete clonedGraphic.bgColor;
                    delete clonedGraphic.drawingEffect;
                    delete clonedGraphic.pattern;
                    clonedGraphic.fill = "transparent";
                    noFillActNode = dpRenderer({graphic: clonedGraphic});
                    if (noFillActNode) {
                        currentDp.appendChild(noFillActNode);
                    }
                    noFillActNode.setAttribute("class", "v-primary-noFill");     
                }           
            }
            dataNode.setAttribute("transform", 'translate(' + config.x + ', ' + config.y + ')');
            if(noFillActNode){    
                noFillActNode.setAttribute("transform", 'translate(' + config.x + ', ' + config.y + ')');
            }

            extra_data.color['v-primary'] = {
                color: config.fill,
                strokeWidth: dataNode.getAttribute("stroke-width"),
                pathStrokeWidth : config.pathStrokeWidth,
                pattern : config.pattern
            };
            if (extra_data.color['v-primary']["pattern"]) {
                extra_data.color['v-primary']["patternURL"] = dataNode.getAttribute("fill");
            }

            actualPos = pos;
            updateMinMax();
        }

        // draw additonal values
        val = currCate.additionalValues;
        if (!NumberUtils.isNoValue(val)) {
            val = +val;
            //the same sign(both + or both -)

            if (!NumberUtils.isNoValue(currCate.actualValues) &&
                currCate.additionalValues * currCate.actualValues > 0) {
                val += +currCate.actualValues;
                lowPos = actualPos;
            }

            //BITSDC2-5988 to keep the regression behavior
            if(currCate.actualValues === 0){
                minSize += MIN_FILL_SIZE;
            }
            
            pos = this._getScaleValue(val);
            updateMinMax();

            if (config.horizontal) {
                config.width = getSize();
                config.x = getHorizontalX();
            } else {
                config.height = getSize();
                config.y =  getVerticalY();
            }
            semColors = this._semanticMgr.analyzeDataPoint(["color","additionalColor"], ctxSemantic, true, additionCtx);
            pattern = this._semanticMgr.analyzeDataPoint(["pattern","additionalColor"], ctxSemantic, true, additionCtx);
            semColorProps = ((semColors || {}).properties || {}).color || {};
            config.fill = calcColor(semColorProps, colorScale, colorDomain, "additional");
            config.pattern = pattern && pattern.properties &&
                pattern.properties.pattern&& pattern.properties.pattern.additionalColor;
            if (isUpdate) {
                dataNode = currentDp.querySelector(".v-additional");
                dataNode = this._updateBulletBar(dataNode, config);
            } else {
                dataNode = dpRenderer({
                    ctx:ctxSemantic,
                    graphic: config,
                    effectManager: this._effectManager,
                    horizontal : config.horizontal,
                    defaultRender: {render:BarRenderer}, //default render is for uvb custom render 
                    currCate: currCate,
                    bulletType: "additionalValue",
                    bulletClass: "v-additional",
                    measures: colorDomain
                });
                dataNode.setAttribute("class", "v-additional");
                currentDp.appendChild(dataNode);
            }
            dataNode.setAttribute("transform", 'translate(' + config.x + ', ' + config.y + ')');
            extra_data.color['v-additional'] = {
                color: config.fill,
                strokeWidth: dataNode.getAttribute("stroke-width"),
                pattern : config.pattern
            };
            if (extra_data.color['v-additional']["pattern"]) {
                extra_data.color['v-additional']["patternURL"] = dataNode.getAttribute("fill");
            }
        }

        // draw target related shapes
        var targetPos;
        if (!NumberUtils.isNoValue(currCate.targetValues)) {
            pos = targetPos = this._getScaleValue(currCate.targetValues);
            updateMinMax();

            //draw or update gap value
            if (this._properties.get("gap.visible") && 
                    determineGap(this._properties.get("gap.type"), actualPos, targetPos) &&
                    !NumberUtils.isNoValue(currCate.actualValues)) {
                var isGreater = currCate.targetValues > currCate.actualValues;
                if (config.pattern) {
                    delete config.pattern;
                }
                if (config.horizontal) {
                    config.width = isGreater ? targetPos - actualPos - NEGGAPOFFSET : actualPos - targetPos;
                    config.height = config.realBarSize * config.primaryPercentage;
                    config.x = isGreater ? actualPos : targetPos + POSGAPOFFSET;
                    config.y = config.categoryPos + config.primaryOffset;
                } else {
                    config.width = config.realBarSize * config.primaryPercentage;
                    config.height = isGreater ? targetPos - actualPos - NEGGAPOFFSET :
                        actualPos - targetPos - POSGAPOFFSET;
                    config.x = config.categoryPos + config.primaryOffset;
                    config.y = isGreater ? this._realSize.height - targetPos + NEGGAPOFFSET :
                        this._realSize.height - actualPos;
                }
                var positiveColor = NameColorUtils.convertColor(this._properties.get("gap.positiveColor"));
                var negativeColor = NameColorUtils.convertColor(this._properties.get("gap.negativeColor"));
                if (isUpdate) {
                    dataNode = currentDp.querySelector(".v-gap");
                    dataNode = this._updateBulletBar(dataNode, config);

                } else {
                    config.fill = isGreater ?
                        FillPatternUtils.patternize(negativeColor,
                                                    config.parent) : positiveColor;
                    dataNode = BarRenderer({
                        graphic: config,
                        effectManager: isGreater? null : this._effectManager,
                        horizontal: config.horizontal
                    });
                    dataNode.setAttribute("class", "v-gap");

                    currentDp.appendChild(dataNode);
                }
                dataNode.setAttribute("transform", 'translate(' + config.x + ', ' + config.y + ')');
                extra_data.color['v-gap'] = {
                    color:isGreater ?
                        negativeColor : positiveColor,
                    strokeWidth: dataNode.getAttribute("stroke-width")
                };
                if (Math.abs(actualPos - targetPos) <= 2) {
                    dataNode.style.display = "none";
                } else {
                    dataNode.style.display = null;
                }
            }
            var lineWidth = 2;
            var lineConfig = {};
            var shadowWidth = 0;
            if (shadowColor !== "") {
                shadowWidth = 1;
            }
            if (targetPos >= 0 && targetPos < (lineWidth + shadowWidth)) {
                targetPos = (lineWidth + shadowWidth);
            }
            //draw or update shadow value
            if (shadowWidth > 0) {

                if (config.horizontal) {
                    lineConfig.x1 = targetPos - lineWidth - shadowWidth / 2;
                    lineConfig.x2 = lineConfig.x1;
                    lineConfig.y1 = config.categoryPos;
                    lineConfig.y2 = config.categoryPos;
                } else {
                    lineConfig.y1 = this._realSize.height - targetPos + lineWidth;
                    lineConfig.y2 = lineConfig.y1;
                    lineConfig.x1 = config.categoryPos;
                    lineConfig.x2 = config.categoryPos;
                }
                lineConfig.width = shadowWidth;
                if (isUpdate) {
                    dataNode = currentDp.querySelector(".v-target-shadow");
                    dataNode = this._updateBulletLine(dataNode, lineConfig);
                } else {
                    dataNode = SVG.create("line");
                    dataNode = this._updateBulletLine(dataNode, lineConfig);
                    dataNode.setAttribute("stroke", shadowColor);
                    if (!UADetector.isMobile()) {
                        dataNode.setAttribute("shape-rendering", "crispEdges");
                    }
                    dataNode.setAttribute("class", "v-target-shadow");
                    currentDp.appendChild(dataNode);
                }
            }

            //draw or update target value
            if (config.horizontal) {
                lineConfig.x1 = targetPos - lineWidth / 2;
                lineConfig.x2 = lineConfig.x1;
                lineConfig.y1 = config.categoryPos;
                lineConfig.y2 = config.categoryPos + config.realBarSize;
            } else {
                lineConfig.y1 = this._realSize.height - targetPos + lineWidth / 2;
                lineConfig.y2 = lineConfig.y1;
                lineConfig.x1 = config.categoryPos;
                lineConfig.x2 = config.categoryPos + config.realBarSize;
            }
            lineConfig.width = lineWidth;

            if (isUpdate) {
                dataNode = currentDp.querySelector(".v-target");
                dataNode = this._updateBulletLine(dataNode, lineConfig);
            } else {
                dataNode = SVG.create("line");
                dataNode = this._updateBulletLine(dataNode, lineConfig);
                dataNode.setAttribute("stroke", this._properties.get("target.valueColor"));
                dataNode.setAttribute("class", "v-target");
                //  tgtNode.setAttribute("stroke-opacity", "1");
                if (!UADetector.isMobile()) {
                    dataNode.setAttribute("shape-rendering", "crispEdges");
                }
                currentDp.appendChild(dataNode);
            }
        }
    };
    
    BulletPlot.prototype._getDataLabels = function(parent){
        return null;
    };

    function addGroup2parent(parent, className){
        var result = SVG.create("g");
        result.setAttribute("class", className);
        parent.node().appendChild(result);
        return result;
    }

    BulletPlot.prototype._renderDatapoints = function(parent, isUpdate) {
        var isHorizontal = this.isHorizontal();
        var series = this._data.series;
        var color    = this._data.color;

        var extra_data;
        var primaryPercentage = BARPERCENTAGE.PRIMARYONLY;
        if(this._data.forecastValues  &&  this._data.forecastValues.metaData &&
                this._data.forecastValues.metaData.length > 0 ){
            primaryPercentage = BARPERCENTAGE.PRIMARYWIDTH;
        }

        var dataPointGroup;
        if(isUpdate){
            dataPointGroup = parent.select("." + Constants.CSS.CLASS.DATAPOINT_GROUP).node();
        }else{
            dataPointGroup = addGroup2parent(parent, Constants.CSS.CLASS.DATAPOINT_GROUP);
        }

        //For performance: variables used in the loop
        var hasData;
        var currentDp;
        var config;

        var colorDomain = {color:[]};

        var i = 0;
        var dataNode, dp;
        var  currSeries, currCate;

        var catePosFn = this._categoryPosFn();
        var realBarSize  = this.__barSize();
        var primaryOffset = realBarSize * (1 - primaryPercentage) / 2;
        var minMax ;
        var zeroPos = this._getScaleValue(0);
        var eventPadding = 0.15 * realBarSize;
        var domain = this._data.actualValues.scale.getDomain();
        var hasNeg = Number(domain[0] < 0);
        var hasPos = Number(domain[1] > 0);

        for (var sIndex = 0; sIndex < series.length; ++sIndex) {
            currSeries = series[sIndex];

            // Process null value series case   
            var rIndex = currSeries.rIndex == null ? sIndex : currSeries.rIndex;
            var internalSeries = rIndex % this._data.actualValues.metaData.length;
            colorDomain = this._getInitialColorDomain(color, colorDomain, rIndex);

            for (i = 0; i < currSeries.length; ++i) {
                extra_data = this._getExtraData(sIndex, i);
                currCate = currSeries[i] || {};
                hasData = !NumberUtils.isNoValue(currCate.actualValues) || 
                !NumberUtils.isNoValue(currCate.additionalValues) || !NumberUtils.isNoValue(currCate.targetValues) ||
                !NumberUtils.isNoValue(currCate.forecastValues);
                minMax  = {min: zeroPos, max:Number.NEGATIVE_INFINITY};

                if (isUpdate) {
                    currentDp = DataPointUtils.find(dataPointGroup, i);
                } else {
                    currentDp = SVG.create("g");
                    currentDp.setAttribute("class", Constants.CSS.CLASS.DATAPOINT + ' ' +
                                           Constants.CSS.CLASS.MORPHABLEDATAPOINT + ' ' +
                                           Constants.CSS.CLASS.DATAPOINTDEFAULT);
                }
                config = {horizontal: isHorizontal, realBarSize: realBarSize, isUpdate:isUpdate,
                        primaryOffset: primaryOffset, primaryPercentage: primaryPercentage, parent:parent.node()};
                config.categoryPos = catePosFn(sIndex, i);
              
                colorDomain = this._adjustColorDomain(currCate, internalSeries, colorDomain);
                extra_data.actual = colorDomain.actual;
                extra_data.additional = colorDomain.additional;
                extra_data.forecast = colorDomain.forecast;
                extra_data.target = this._data.targetValues && this._data.targetValues.metaData && 
                                    this._data.targetValues.metaData.id;
                this._renderOnePoint(currCate, colorDomain, extra_data, config, currentDp, minMax);
              
                delete config.stroke;
                delete config.strokeWidth;
                //draw or update event area
                if (hasData && minMax.max !== Number.NEGATIVE_INFINITY) {

                    var numMinMax = this._getItemMinMax(i, sIndex, true);
                    var realPos = minMax.max;

                    var totalSize = realPos - minMax.min;
                    totalSize += ( hasNeg + hasPos) * eventPadding;
                    
                    if (isHorizontal) {
                        if (realPos > this._realSize.width) {
                            realPos = this._realSize.width;
                        }
                        config.width = totalSize;
                        config.height = realBarSize;
                        config.y = config.categoryPos;
                        config.x = minMax.min - hasNeg * eventPadding;
                    } else {
                        if (realPos > this._realSize.height) {
                            realPos = this._realSize.height;
                        }
                        config.width = realBarSize;
                        config.height = totalSize;
                        config.x = config.categoryPos;
                        config.y = this._realSize.height - realPos  - hasPos * eventPadding;
                    }

                    config.fill = "transparent";

                    if (isUpdate) {
                        dataNode = currentDp.querySelector(".v-eventArea");
                        dataNode = this._updateBulletBar(dataNode, config);
                    } else {
                        dataNode = BarRenderer({
                            graphic: config,
                            effectManager: this._effectManager
                        });
                        dataNode.setAttribute("class", "v-eventArea");
                        dataNode.setAttribute("stroke", "transparent");
                        currentDp.appendChild(dataNode);
                    }
                    dataNode.setAttribute("transform", 'translate(' +
                                               config.x + ', ' + config.y + ')');
                    dp = currCate.dp;
                    DataPointUtils.setDataPointId(currentDp, dp.id);
                    DataPointUtils.setDataId(currentDp, i);
                    DataGraphics.setContext(currentDp, dp.context());
                    DataGraphics.setAdditionCtx(currentDp, dp.additionCtx());
                    DataGraphics.setData(currentDp, extra_data);

                    dataPointGroup.appendChild(currentDp);
                }
            }
        }
    };

    BulletPlot.prototype.getRealSizeByFixedDPSize = function(dpSize) {
        return dpSize * this.__barSizeRatio() * this._categoryCount();
    };

    BulletPlot.prototype._getItemMinMax = function(categoryIndex, sIndex, includeTarget){
        var item = (this._data.series[sIndex] || [])[categoryIndex];

        var act = item["actualValues"];
        var add = item["additionalValues"];
        var fore = item["forecastValues"];
        //!! in JS, null + null = 0, 0 + undefined = NaN
        var sum = TypeUtils.isNumber(act) && TypeUtils.isNumber(add)? add + act : undefined;
        var candidates = [act, add, sum, fore, 0];
        if(includeTarget){
            candidates.push(item["targetValues"]);
        }
        candidates = candidates.filter(TypeUtils.isNumber);

        var min = Math.min.apply(null, candidates);
        var max = Math.max.apply(null, candidates);

        return {max:max, min:min};
    };

    BulletPlot.prototype.getDataPointPosition = function(seriesIndex, itemIndex) {
        seriesIndex = seriesIndex || 0;

        var minMax = this._getItemMinMax(itemIndex, seriesIndex);
        var upPos = this._getScaleValue(minMax.max);
        var lowPos = this._getScaleValue(minMax.min);
        var barHeight = upPos - lowPos;
        var categoryPos = this._categoryPosFn()(seriesIndex, itemIndex);
        var barSize = this.__barSize();
        if(this.isHorizontal()){
            return {
                x: lowPos,
                y: categoryPos,
                height: barSize,
                width : barHeight
            };
        } else {
            return {
                y: this._realSize.height - upPos,
                width: barSize,
                x: categoryPos,
                height : barHeight
            };
        }
    };

    BulletPlot.prototype._categoryPosFn = function() {
        var barSzRatio = this.__barSizeRatio();
        var catSz   = this._getCategoryWidth(),
            barSz = this.__barSize(catSz, barSzRatio),
            extra = (catSz - barSz * barSzRatio) / 2,
            catOffset = barSz / 3;
        return function(seriesIdx, cateIdx) {
            return seriesIdx * (barSz * 9 / 8) + catOffset + cateIdx * catSz + extra;
        };
    };

    BulletPlot.prototype.__barSize = function(categorySize, barSizeRatio) {
        var cateSize = categorySize || this._getCategoryWidth(),
            ratio = barSizeRatio || this.__barSizeRatio(),
            fixedBarSize = this.__fixedBarSize();
        return Math.min(cateSize / ratio, fixedBarSize.max);
    };

    BulletPlot.prototype.__barSizeRatio = function() {
        return (this._data.series.length - 1) / 8 + this._data.series.length + 2 / 3;
    };

    BulletPlot.prototype.__fixedBarSize = function() {
        var props = this._properties;
        var min = props.get("dataPointSize.min") || props.getDefault("dataPointSize.min"),
            max = props.get("dataPointSize.max") || props.getDefault("dataPointSize.max");

        if(min > max) {
            max = props.getDefault("dataPointSize.max");
            min = props.getDefault("dataPointSize.min");
        }

        return {
            min: Math.min(min, max),
            max: max
        };
    };

    BulletPlot.prototype._getExtraData = function(seriesIdx, categoryIdx) {
        return {color: {}};
    };

    BulletPlot.prototype.getZoomLevel = function() {
        if (this.isHorizontal()) {
            return this._realSize.height / this._size.height;
        } else {
            return this._realSize.width / this._size.width;
        }
    };
    BulletPlot.prototype.destroy = function() {
        BulletPlot.superclass.destroy.call(this);
        this._gridlineScale = null;
        this._realSize = null;
    };
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR, ChartConstants.BULLET, DataPointNavigator);
    return BulletPlot;
});

define('sap/viz/chart/components/plotareas/BulletPlotArea',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/oo',
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/chart/components/plotareas/XYPlotArea',
    'sap/viz/chart/components/axis/ValueAxis',
    'sap/viz/chart/components/axis/CategoryAxis',
    'sap/viz/chart/components/plots/PlotHelper',
    'sap/viz/chart/components/plots/BulletPlot',
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/chart/components/scrollbar/Scrollbar',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/util/TextUtils'
], function Setup(Constants, oo, ValueScale, ValueScaleUtil, XYPlotArea, ValueAxis, 
    CategoryAxis, PlotHelper, BulletPlot, ValueAxisUtils, Scrollbar, UADetector,
    DataUtils, TextUtils) {
    var BulletPlotArea = function(runtime, options) {
        this._valueAxisPosition = runtime.propertyManager().get('valueAxis.layout.position');
        if (['top', 'bottom'].indexOf(this._valueAxisPosition) === -1) {
            this._valueAxisPosition = runtime.propertyManager().getDefault('valueAxis.layout.position');
        }
        BulletPlotArea.superclass.constructor.apply(this, arguments);
    };

    oo.extend(BulletPlotArea, XYPlotArea);

    BulletPlotArea.prototype._init = function() {
        this._plot = PlotHelper.create(this._renderType, BulletPlot, this.runtime(), this._getPlotOptions());
        this.setChild("plot", this._plot, {
            position: "center"
        });
        this._plot.getDispatch().on("reRenderComplete.plotarea", this._reRenderComplete.bind(this));
        var isHorizontal = this._plot.isHorizontal();
        var isInteractive = !this._properties.get("interaction.noninteractiveMode");
        if (isHorizontal) {
            this.setLayoutSequence(['bottom', 'top', 'left', 'right']);

            this._categoryAxis = new CategoryAxis(this.runtime(), {
                name: "categoryAxis"
            });
            this.setChild("categoryAxis", this._categoryAxis, {
                position: "left"
            });

            this._valueAxis = new ValueAxis(this.runtime(), {
                name: "valueAxis"
            });
            this.setChild("valueAxis", this._valueAxis, {
                position: this._valueAxisPosition
            });

            if (isInteractive) {
                this._hScrollbar = new Scrollbar(this.runtime(), {
                    name : "plotArea.scrollbar"
                });
                this.setChild("scrollbar2", this._hScrollbar, {
                    position : "bottom"
                });
            }
        } else {
            this.setLayoutSequence(['left', 'right', 'bottom', 'top']);

            this._categoryAxis = new CategoryAxis(this.runtime(), {
                name: "categoryAxis",
                hasScrollbar:isInteractive
            });
            this.setChild("categoryAxis", this._categoryAxis, {
                position: "bottom"
            });

            if (isInteractive) {
                this._hScrollbar = this._categoryAxis.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
            }

            this._valueAxis = new ValueAxis(this.runtime(), {
                name: "valueAxis"
            });
            this.setChild("valueAxis", this._valueAxis, {
                position: "left"
            });
        }

        if (isInteractive) {
            this._vScrollbar = new Scrollbar(this.runtime(), {
                name: "plotArea.scrollbar"
            });
            this.setChild("scrollbar", this._vScrollbar, {
                position: "right"
            });
        }

        this.getZoomer().init({
            main: this,
            plot: this._plot,
            axisByDirection: {
                x: isHorizontal ? [this._valueAxis] : [this._categoryAxis],
                y: isHorizontal ? [this._categoryAxis] : [this._valueAxis]
            },
            isHorizontal: isHorizontal
        });
    };

    BulletPlotArea.prototype.updateValueScale = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        if (!data || width <= 0 || height <= 0) {
            return data;
        }
        var range = [0, 1];
        if (this._plot.isHorizontal()) {
            range[1] = width;
        } else {
            range[1] = height;
        }
        range[1] *= 0.8;
        var valueAxisData;
        var newData = data;

        var options = [this._data.actualValues.minValue, this._data.actualValues.maxValue];
        if(options[0] === 0 && options[1] === 0){
            options = null;
        }
        valueAxisData = this._calcValueAxisScale("actualValues", range, options);
        data.actualValues.scale = valueAxisData.scale;
        data.actualValues.tickHint = valueAxisData.tickHint;
        data.actualValues.scale.setRange([0, 1]);
        this._valueAxis.setData(data.actualValues);
        
        return newData;
    };

    BulletPlotArea.prototype._isHorizontal = function(){
        return this._plot.isHorizontal();
    };

    return BulletPlotArea;
});

define('sap/viz/chart/chains/BulletChains',[
    "sap/viz/chart/chains/BaseChains",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ArrayUtils",
    "sap/viz/framework/binding/BindingManager",
    "sap/viz/framework/common/util/BulletUtils",
    "sap/viz/chart/chains/ChainUtils",
], function(
    BaseChains,
    NumberUtils,
    TypeUtils,
    ArrayUtils,
    BindingManager,
    BulletUtils,
    ChainUtils
) {
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];

    var bulletChains = BaseChains.extend('bullet', defaultChains);
    // Follow the sequence of the feeding definition, data[][][][]

    function getBindingSeries(rawData, dimensions, measures, bindingResults, trellisInfo) {
        var clrNum = bindingResults.color ? bindingResults.color.rowArray.length : 1,
            valNum = bindingResults.actualValues.metaData.length,
            catNum = bindingResults.categoryAxis.rowArray.length;
        var series = [];

        for (var i = 0; i < clrNum; i++) {
            for (var j = 0; j < valNum; j++) {
                var sr = [];
                series.push(sr);
                for(var k = 0; k < catNum; k++) {
                    var points = measures.reduce(function(elem, msr) {
                        //values may look like: [category][clrNum][valNum] or: [category][valNum]
                        var vals;
                        if(!bindingResults.color){  //no color binding
                            vals = bindingResults[msr].values[k][j];
                        }else{
                            vals = bindingResults[msr].values[k][i];
                        }

                        if (!TypeUtils.isExist(vals)) {
                            elem[msr] = undefined;
                        } else if (TypeUtils.isArray(vals)) {
                            elem[msr] = vals[j];
                        } else {
                            elem[msr] = vals;
                        }
                        return elem;
                    }, {});
                    sr.push(points);
                }
            }
        }

        if (trellisInfo) {
            series.trellisRow = trellisInfo.trellisRow;
            series.trellisColumn = trellisInfo.trellisColumn;
        }

        bindingResults.series = series;
        BulletUtils.bulletSetMinMax(bindingResults);
    }

    bulletChains.bulletGetBindingSeries = ChainUtils.generateSeriesGetter(getBindingSeries);

    //actualValues, additionalValues and etc for binding result
    bulletChains.bulletGetMeasuresFromFlattable = function(rawData, fields, mnd, bindings, duplicated, bindingName) {
        var metadata = ChainUtils.getMetadata(rawData).fields;
        bulletChains.parsedData = ChainUtils.getData(rawData, bindings, bulletChains.parsedData);
        for (var i = 0; i < fields.length; i++) {
            for (var j = 0; j < metadata.length; j++) {
                if (fields[i] === metadata[j].id) {
                    var returnArray = ChainUtils.handleMeasure(rawData, fields, mnd, bulletChains.parsedData,
                        bulletChains.multiDimensionIndex, {isBullet : true});
                    var rowArray = returnArray.measureArray;
                    var array = ArrayUtils.transpose(rowArray);
                    var domain = array.map(function(e) {
                        return ArrayUtils.extent(e);
                    });
                    var metaData = ChainUtils.buildMetaData(rawData, fields);
                    var multiArray = returnArray.multiArray;
                    var result = {
                        values: multiArray,
                        categorySum: ChainUtils.sumByCategory(multiArray),
                        range: domain,
                        metaData: metaData
                    };
                    return result;
                }
            }
        }
        return null;
    };
    Object.keys(bulletChains).forEach(function(key) {
        BindingManager.registerChain(key, bulletChains[key]);
    });

    return bulletChains;
});

define('sap/viz/chart/dynamicScales/BulletDyScaleProcessor',[ 
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/scale/DynamicScaleRepository',
    "sap/viz/chart/dynamicScales/StackedDyScaleProcessor"
],function(
    oo,
    TypeUtils,
    DynamicScaleRepository,
    StackedDyScaleProcessor
){

    function BulletDyScaleProcessor(type, propertyMgr, dataModel, runtime){
        BulletDyScaleProcessor.superclass.constructor.apply(this, arguments);
        this._mainValue = "actualValues";
    }
    oo.extend(BulletDyScaleProcessor, StackedDyScaleProcessor);
    ["bullet","vertical_bullet","timeseries_bullet"].forEach(function(type){
        DynamicScaleRepository[type] = BulletDyScaleProcessor;
    });

    BulletDyScaleProcessor.prototype.getValue = function(dp){
        var values = [dp.actualValues, dp.additionalValues,
                     dp.forecastValues, dp.targetValues].filter(TypeUtils.isNumber);
        return Math.min.apply(null, values);
    };

    return BulletDyScaleProcessor;  
});
define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForBullet',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/ColorUtils",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler',
    "sap/viz/framework/interaction/BehaviorManager",
    "sap/viz/chart/components/util/ChartTypeUtils"
], function(
    Constants,
    TypeUtils,
    HighlightHelper,
    DataGraphics,
    ColorUtils,
    ObjectUtils,
    DPBhvrHdlr,
    BehaviorManager,
    ChartTypeUtils) {

    var regularBullets = [
        "info/bullet",
        "info/vertical_bullet",
        "info/trellis_bullet",
        "info/trellis_vertical_bullet"
    ];

    var timeCharts = ["info/timeseries_bullet"];

    var bulletType = regularBullets.concat(timeCharts);

    var ZERO_VALUE_HOVER_SIZE = 4;
    var CSS_CLASS = Constants.CSS.CLASS;

    var changeBulletEffect = function(service, node, props) {
        var extra_data, width;
        var data = DataGraphics.getData(node);
        var color = data.color;
        var forecastNode = node.querySelector(".v-forecast");
        var isZeroValue = data.isZeroValue;
        var renderType = service._getRenderType();
        var isVerticalRender = ChartTypeUtils.getChartTypeProperty(renderType).isVerticalRender;
        var effectNode, i, settings = {};
        ObjectUtils.extend(true, settings, service.getProperties().get('interaction.' + props.bStatus));
        settings.name = 'interaction.' + props.bStatus;
        var prop = service.getProperties().get(settings.name);
        var attr = service.isHorizontal() ? "width" : "height";
                                    
        if (props.bShow) {
            if(settings.stroke.visible === true || props.bKeyboard){
                var highlightProps = service.getProperties().get("interaction.keyboard");
                highlightProps.color = service.getEffectManager().register({
                    fillColor: highlightProps.color
                });
                highlightProps.isZeroValue = isZeroValue;
                highlightProps.isVerticalRender = isVerticalRender;
                highlightProps.isAllValueNegative = data.isAllValueNegative;
                highlightProps.isZeroOnFirstTab = data.isZeroOnFirstTab;
                if (forecastNode) {
                    if (props.bKeyboard) {
                        drawStrokeDasharray(service, node, forecastNode, highlightProps, color);
                    } else {
                        drawStroke(service, node, forecastNode, prop, "#999999", props.bSelected);
                    }
                }
                // When tab to axis, if all feeds are zero, do not draw the border.
                var isAllZero = true;
                for (i in color) {
                    if (color.hasOwnProperty(i)) {
                        var d3Node = d3.select(node).select("." + i);
                        var _extra_data_ = DataGraphics.getData(d3Node.node()) || {};
                        if (parseFloat(d3Node.attr(attr)) !== 0 && !_extra_data_.reshaped) {
                            isAllZero = false;
                            break;
                        }
                    }
                }
                for (i in color) {
                    //color did not have v-forecast, for backward-compatibility reason
                    if (color.hasOwnProperty(i) && i !== "v-forecast") {
                        extra_data = color[i];
                        if(extra_data.pattern === 'noFill'){
                            effectNode = node.querySelector("." + i + "-noFill");
                        } else {
                            effectNode = node.querySelector("." + i);
                        }

                        if(effectNode){
                            if (props.bKeyboard || isAllZero) {
                                drawStrokeDasharray(service, node, effectNode, highlightProps, color);
                            } else {
                                var effectColor = ColorUtils.fromCSSColor(color[i].color.toLowerCase());
                                //if user set invalid color, skip
                                if(effectColor){
                                    effectColor.r = parseInt(effectColor.r * 0.7, 10);
                                    effectColor.g = parseInt(effectColor.g * 0.7, 10);
                                    effectColor.b = parseInt(effectColor.b * 0.7, 10);
                                    drawStroke(service, node, effectNode, prop,
                                        effectColor.toString(), props.bSelected);
                                }
                            }
                        }
                    }
                }
            }
        } else {
            var strokeProp = service.getProperties().get('plotArea.dataPoint.stroke');
            if (forecastNode) {
                forecastNode.removeAttribute("stroke");
                forecastNode.removeAttribute("stroke-width");
                forecastNode.removeAttribute("stroke-dasharray");
                forecastNode.removeAttribute("shape-rendering");
            }

            for (i in color) {
                if (color.hasOwnProperty(i)) {
                    extra_data = color[i];
                    if(extra_data.pattern === 'noFill'){
                        effectNode = node.querySelector("." + i + "-noFill");
                        width = 1;
                    } else {
                        effectNode = node.querySelector("." + i);
                        width = color[i].strokeWidth;
                    }
                    if(effectNode){
                        var d = DataGraphics.getData(effectNode) || {};
                        if (d.reshaped) {
                            effectNode.setAttribute(attr, "0");
                        }
                        effectNode.removeAttribute("stroke-dasharray");
                        effectNode.removeAttribute("shape-rendering");
                        if(extra_data.strokeWidth){
                            if(strokeProp && strokeProp.visible === true) {
                                effectNode.setAttribute("stroke", strokeProp.color);
                            }
                            else {
                                effectNode.setAttribute("stroke", "#ffffff");
                            }
                            effectNode.setAttribute("stroke-width", width);
                        }else{
                            effectNode.removeAttribute("stroke");
                            effectNode.removeAttribute("stroke-width");
                        }
                    }
                }
            }
        }
        node.setAttribute("fill-opacity",
                TypeUtils.isExist(prop) && TypeUtils.isExist(prop.opacity) ? prop.opacity : 1);
        node.setAttribute("stroke-opacity",
                TypeUtils.isExist(prop) && TypeUtils.isExist(prop.opacity) ? prop.opacity : 1);
    };

    function drawStroke(service, e, node, prop, defaultColor, selected) {
        var colors = HighlightHelper.getColors(service, e, prop.stroke.color, defaultColor);
        if(colors.customizedColor) {
            node.setAttribute("stroke", colors.customizedColor);
        }else {
            node.setAttribute('stroke', colors.defaultColor);
        }
        node.setAttribute("stroke-width", selected ?
            HighlightHelper.getWidth(prop.stroke.width, 1) :
            HighlightHelper.getWidth(prop.stroke.width, 2));
        node.removeAttribute("stroke-dasharray");
        node.removeAttribute("shape-rendering");
    }

    function reShapeHorizontalHelper(node, scale, prop) {
        var data = DataGraphics.getData(node) || {};
        if (data.reshaped) {
            node.setAttribute('width', 0);
        }
        if (prop.isZeroOnFirstTab) {
            if (parseFloat(node.getAttribute('width')) === 0) {
                node.setAttribute('width', ZERO_VALUE_HOVER_SIZE);
                data.reshaped = true;
                scale.x = prop.isAllValueNegative ? -1 : 1;
            }
        }
        DataGraphics.setData(node, data);
        return scale;
    }

    function reShapeVerticalHelper(node, scale, prop) {
        var data = DataGraphics.getData(node) || {};
        if (data.reshaped) {
            node.setAttribute('height', 0);
        }
        if (prop.isZeroOnFirstTab) {
            if (parseFloat(node.getAttribute('height')) === 0) {
                node.setAttribute('height', ZERO_VALUE_HOVER_SIZE);
                data.reshaped = true;
                scale.y = prop.isAllValueNegative ? 1 : -1;
            }
        }
        DataGraphics.setData(node, data);
        return scale;
    }

    function trimBrackets(str) {
        var left = str.lastIndexOf('(');
        var right = str.lastIndexOf(')');
        return str.substr(left + 1, right - left - 1);
    }

    function reShapeSizeInfoHelper(node, prop, color) {
        var transform = node.getAttribute('transform').split('scale')[0];
        var scale = {
            x: 1,
            y: 1
        };
        if (TypeUtils.isExist(node.getAttribute('transform').split('scale')[1])) {
            var scaleArr = trimBrackets(node.getAttribute('transform').split('scale')[1]);
            // in IE, it will appear "scale(1)" instead of "scale(1,1)"
            if (scaleArr.indexOf(",") < 0) {
                scale = {
                    x: parseFloat(scaleArr),
                    y: parseFloat(scaleArr)
                };
            } else {
                scale = {
                    x: parseFloat(scaleArr.split(",")[0]),
                    y: parseFloat(scaleArr.split(",")[1])
                };
            }
        }
        var fn = prop.isVerticalRender ? reShapeVerticalHelper : reShapeHorizontalHelper;
        scale = fn(node, scale, prop);
        var prevNode = getValidSibling(node, color);
        var hasValidSibling = TypeUtils.isExist(getValidSibling(node, color));
        if (hasValidSibling) {
            if (TypeUtils.isExist(prevNode)) {
                if (prevNode.getAttribute('transform').indexOf('scale') < 0) {
                    node.setAttribute('transform', transform + 'scale' + '(' + scale.x + ',' + scale.y + ')');
                }
            }
            var data = DataGraphics.getData(node) || {};
            if (data.reshaped) {
                node.setAttribute('fill', 'none');
            }
        }
        return node;
    }

    function getValidSibling(node, color) {
        var siblingNode = node.previousSibling || node.nextSibling;
        if (color) {
            if (d3.select(siblingNode).attr("class") in color) {
                return siblingNode;
            } 
        }
        return node;
    }

    function reShapeSizeInfo(node, prop, color) {
        if (prop.isZeroValue) {
            var bForecastNode = d3.select(node).attr("class") === 'v-forecast';
            if (!bForecastNode) {
                var attr = prop.isVerticalRender ? "height" : "width";
                var data = DataGraphics.getData(node) || {};
                if (parseFloat(getValidSibling(node, color).getAttribute(attr)) === 0 ||
                    data.reshaped) {
                    reShapeSizeInfoHelper(node, prop, color);
                }
            }
        }
        return node;
    }

    function drawStrokeDasharray(service, e, node, prop, color) {
        var colors = HighlightHelper.getColors(service, e, prop.color);
        reShapeSizeInfo(node, prop, color);
        node.setAttribute("stroke", colors.customizedColor);
        node.setAttribute("stroke-width", HighlightHelper.getWidth(prop.width, 1));
        node.setAttribute("stroke-dasharray", "1, 1");
        node.setAttribute("shape-rendering", "crispEdges");
    }

    var bullet = [{
        "id": "selectDataPoint_bullet",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": bulletType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            elements.forEach(function(e) {
                if(service.getProperties().get('interaction.selected.stroke.visible') === true) {
                    changeBulletEffect(service, e, {
                        bShow: true,
                        bSelected: true,
                        bStatus: 'selected'
                    });
                }
                else {
                    changeBulletEffect(service, e, {
                        bShow: false,
                        bSelected: false,
                        bStatus: 'default'
                    });
                }
            });
        }
    }, {
        "id": "deselectDataPoint_bullet",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": bulletType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            elements.forEach(function(e) {
                if(event.data.isAnyOtherSelected) {
                    if(service.getProperties().get('interaction.deselected.stroke.visible') === true){
                        changeBulletEffect(service, e, {
                            bShow: true,
                            bSelected: true,
                            bStatus: 'deselected'
                        });
                    }else{
                        changeBulletEffect(service, e, {
                            bShow: false,
                            bSelected: true,
                            bStatus: 'deselected'
                        });
                    }
                }else{
                    changeBulletEffect(service, e, {
                        bShow: false,
                        bSelected: true,
                        bStatus: 'default'
                    });
                }
            });
        }
    }, {
        "id": "hoverOnDataPoint_bullet",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": bulletType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            elements.forEach(function(e) {
                changeBulletEffect(service, e, {
                    bShow: true,
                    bSelected: false,
                    bStatus: 'hover',
                    bKeyboard: !!event.data.byKeyboard
                });
            });
        }
    }, {
        "id": "unhoverOnDataPoint_bullet",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": bulletType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            elements.forEach(function(e) {
                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    var strokeProps = service.getProperties().get('interaction.selected.stroke.visible');
                    if(strokeProps === true){
                        changeBulletEffect(service, e, {
                            bShow: true,
                            bSelected: true,
                            bStatus: 'selected'
                        });
                    }else{
                        changeBulletEffect(service, e, {
                            bShow: false,
                            bSelected: true,
                            bStatus: 'selected'
                        });
                    }
                } else {
                    var selectedDataPoints = service.getStatus("selectedDataPoints");
                    if(selectedDataPoints.length) {
                        if(service.getProperties().get('interaction.deselected.stroke.visible') === true){
                            changeBulletEffect(service, e, {
                                bShow: true,
                                bSelected: true,
                                bStatus: 'deselected'
                            });
                        }else{
                            changeBulletEffect(service, e, {
                                bShow: false,
                                bSelected: true,
                                bStatus: 'deselected'
                            });
                        }
                    } else {
                        changeBulletEffect(service, e, {
                            bShow: false,
                            bSelected: true,
                            bStatus: 'default'
                        });
                    }
                }
            });
        }
    }, {
        "id": "clearPlot_bullet",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": bulletType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if(!mainNode || !mainNode.length){
                return;
            }

            var gray = event.data.isGray;
            mainNode.forEach(function(e) {
                if(gray){
                    changeBulletEffect(service, e, {
                        bShow: true,
                        bSelected: true,
                        bStatus: 'deselected'
                    });
                }else{
                    changeBulletEffect(service, e, {
                        bShow: false,
                        bSelected: false,
                        bStatus: 'default'
                    });
                }
            });
        }
    }, {
        "id": "click_on_non_selection_bullet",
        "triggerEvent": {
            "name": "click",
            "supportedChartTypes": bulletType,
            "excludeTargets": HighlightHelper.getDeselAllExTargets(),
        },
        "handler": function(event, service) {
            DPBhvrHdlr.clickOnNonSelection(event, service, timeCharts);
        }
    },{
        "id": "clearPlot_time_bullet",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": timeCharts
        },
        "handler": function(event, service) {
            DPBhvrHdlr.clearForTime(event, service);
        }
    }, {
        "id": "hover_range_selection_bullet",
        "triggerEvent": {
            "name": "hover",
            "supportedChartTypes": timeCharts,
            "targets": "v-m-action-layerrange"
        },
        "handler": function(event, service) {
            DPBhvrHdlr.showDetailForRangeSelectionWhenHover(event, service);
        }
    },{
        "id": "update_range_selection_effect_bullet",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "down",
            "supportedChartTypes": timeCharts
        },
        "handler": function(event, service) {
            DPBhvrHdlr.updateRangeEffect(event, service);
        }
    }, {
        "id": "recover_range_selection_effect_bullet",
        "triggerEvent": {
            "targets": "v-m-action-layerrange",
            "name": "up",
            "supportedChartTypes": timeCharts
        },
        "handler": function(event, service) {
            DPBhvrHdlr.recoverRangeEffect(event, service);
        }
    }];
    BehaviorManager.registerAll(bullet);
    return bullet;
});
define('sap/viz/chart/views/BulletChartView',[ "sap/viz/framework/common/util/oo", 
         "sap/viz/framework/common/util/Constants",
         "sap/viz/chart/views/ChartView",
         "sap/viz/chart/components/legend/BulletLegend",
         "sap/viz/chart/components/plotareas/BulletPlotArea",
         "sap/viz/chart/components/util/TextUtils",
         "sap/viz/framework/common/util/TypeUtils",
         "sap/viz/chart/scales/ScalesFactory",
         "sap/viz/chart/scales/BulletColorScale",
         "sap/viz/chart/chains/BulletChains",
         "sap/viz/chart/dynamicScales/BulletDyScaleProcessor",
         "sap/viz/chart/behavior/config/DataPointBehaviorConfigForBullet"],
  function Setup(oo,
          Constants,
          ChartView,
          BulletLegend,
          PlotArea,
          TextUtils, 
          TypeUtils,
          ScalesFactory,
          BulletColorScale,
          BulletChains) {
    
    ScalesFactory.register("bullet", "color", BulletColorScale);

    var BulletChartView = function(runtime, option) {
        BulletChartView.superclass.constructor.apply(this, arguments);
        this._supportLazyRender = true;
    };

    oo.extend(BulletChartView, ChartView);

    BulletChartView.prototype.setSize = function() {
        if (this._plotArea && this._plotArea.setRoughSize) {
            this._plotArea.setRoughSize.apply(this._plotArea, arguments);
        }
        BulletChartView.superclass.setSize.apply(this, arguments);
    };

    BulletChartView.prototype._getDataItems = function() {
        return [ "actualValues", "additionalValues", "color", "categoryAxis", "targetValues", "forecastValues", 
          "series","trellisRow", "trellisColumn" ];
    };

    BulletChartView.prototype._createPlotContainer = function(isTrellis) {

        this._plotArea = new PlotArea(this.runtime(), {
            renderType: this._renderType
        });

        this._plotArea.setRoughSize(this._size);

        this.setChild("main", this._plotArea, {
            priority : 3
        });
    };
            
    BulletChartView.prototype._getLegendDefinition = function() {
        return [BulletLegend];
    };

    BulletChartView.prototype._getLegendInitOptions = function() {
        return [{
            noFillSupport : true,
            "targetLineDirection" : /vertical_bullet|timeseries_bullet/.test(this._options.renderType) ?
                                  Constants.DIRECTION.HORIZONTAL : Constants.DIRECTION.VERTICAL
        }];
    };

    BulletChartView.prototype.calculatePaddingInPX = function(prop){
            var paddings = BulletChartView.superclass.calculatePaddingInPX.apply(this, arguments);
            if((prop.get("title.visible") === false) && this._plotArea && 
                (this._plotArea._isHorizontal && 
                    TypeUtils.isExist(this._plotArea._isHorizontal()) && 
                    this._plotArea._isHorizontal() !== true) &&
                (prop.get("valueAxis.visible") === true)){
                //If padding with pixel less than value axis label hegiht / 2 and 
                //title is invisible, add half value label's height 
                //to avoid cut the latest value axis label.  
                this.changePaddingTop(prop, paddings);
            }
            return paddings;
        };
            
    return BulletChartView;
});

define('sap/viz/chart/metadata/bindings/BulletBindings',[ ], function Setup() {

    var feeds = [ {
        "id": "trellisColumn",
        "name": "IDS_TRELLIS_COLUMN",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.columnCategory"
    }, {
        "id": "trellisRow",
        "name": "IDS_TRELLIS_ROW",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.rowCategory"
    }, {
        "id" : "categoryAxis",
        "name" : "IDS_CATEGORY_AXIS",
        "type" : "Dimension",
        "min" : 1,
        "max" :  Number.POSITIVE_INFINITY,
        "acceptMND" : false,
        "role" : "layout.category"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "mark.color"
    },
    {
        "id" : "actualValues",
        "name" : "IDS_PRIMARY_VALE",
        "type" : "Measure",
        "min" : 1,
        "max" :  Number.POSITIVE_INFINITY,
        "role" : "layout.value"
    },{
        "id" : "additionalValues",
        "name" : "IDS_ADDITIONAL_VALE",
        "type" : "Measure",
        "min" : 0,
        "max" :  Number.POSITIVE_INFINITY,
        "role" : "layout.value"
    },{
        "id" : "targetValues",
        "name" : "IDS_TARGETVALUES",
        "type" : "Measure",
        "min" : 0,
        "max" : Number.POSITIVE_INFINITY,
        "role" : "mark.target"
    }, {
        "id" : "forecastValues",
        "name" : "ID_FORECAST_VALUES",
        "type" : "Measure",
        "min" : 0,
        "max" : Number.POSITIVE_INFINITY,
        "role" : "mark.forecast",
        "description": "This is deprecated"
    } ];

    return feeds;
});
define('sap/viz/chart/components/datalabels/PieDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/framework/common/util/DataUtils',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/GeometryUtils",
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/SVG',
    "sap/viz/framework/common/util/ArrayUtils"
], function Setup(oo, DataLabels, DataPointUtils, DataUtils, TypeUtils, TextUtils, GeometryUtils,
    UnitFormat,
    Constants,
    DataGraphics,
    SVG,
    ArrayUtils) {
    var MND = "measureNames";
    /**
     * To initialize PieDataLabels object.
     *
     * @name PieDataLabels
     * @constructor
     */
    var PieDataLabels = function(runtime, options) {
        PieDataLabels.superclass.constructor.apply(this, arguments);
    };

    oo.extend(PieDataLabels, DataLabels);

    PieDataLabels.prototype._getDataLabelInfo = function(node) {
        var pathData = d3.select(node.childNodes[0]).datum();
        var percentage = (pathData.endAngle - pathData.startAngle) / (2 * Math.PI);
        var ctx = DataPointUtils.getContext(node);

        //for multiple pie, the measure id may not be the 1st item.
        //we should use ctx["measureNames"]
        var metaData = this._data.size.metaData;
        var infoKey = ctx[MND] || metaData[0].id;
        var name;

        for(var i = 0; i < metaData.length; ++i){
            if(metaData[i].id === infoKey){
                name = metaData[i].name;
                break;
            }
        }
        return {
            key: infoKey,
            value: ctx[infoKey],
            name: name,
            //BITSDC2-2971 if digitial is more than 6, it will become scientific notation
            percentage:  percentage < 0.000001 ? 0 : percentage
        };
    };

    PieDataLabels.prototype._showProperty = function(property) {
        if(!this._data || !this._data.color || !this._data.color.metaData){
            return false;
        }
        var metaData = this._data.color.metaData;
        for(var i=0; i<metaData.length; i++){
            if(property === metaData[i].id && !metaData[i].hidden){
                return true;
            }
        }
        return false;
    };

    PieDataLabels.prototype._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx,
        isMetaDataFormat, dp) {
        if (dataLabelInfo.value === 0 && !this.drawZero(dp)) {
            return null;
        }
        return DataLabels.buildDataLabelText(
            this._properties,
            formatPatterns,
            dataLabelInfo,
            dataLabelCtx,
            isMetaDataFormat,
            getTypes,
            mergeDataLabels,
            buildDataLabelAdditionalText.bind(this)
        );
    };

    function getTypes(properties) {
        var type = properties.get('type');
        var result;
        if (type === 'color') {
            result = ['color'];
        } else if (type === 'value') {
            result = ['value'];
        } else if (type === 'percentage') {
            result = ['percentage'];
        } else {
            //default is "colorAndPercentage"
            result = ['color', 'percentage'];
        }
        return result;
    }

    function mergeDataLabels(properties, formattedArray) {
        var type = properties.get('type');
        var dataLabelText;
        if (type === 'color' || type === 'value' || type === 'percentage') {
            dataLabelText = formattedArray[0];
        } else {
            dataLabelText = formattedArray[1] ?
                formattedArray[0] + "   (" + formattedArray[1] + ")" : formattedArray[0];
        }
        return dataLabelText;
    }

    function buildDataLabelAdditionalText(ctx, measureLabelInfo) {
        var ret = null;
        if(ctx && measureLabelInfo) {
            if(measureLabelInfo.key) {
                var measureKey = measureLabelInfo.key;
                if(ctx.hasOwnProperty(measureKey)) {
                    var count = 0, val;
                    for(var property in ctx) {
                        if(ctx.hasOwnProperty(property) && property !== measureKey &&
                           this._showProperty(property)) {
                            if(property === MND ){
                                if(!measureLabelInfo.keepMND){
                                    continue;
                                }
                                val = measureLabelInfo.name ||  ctx[property];
                            }else{
                                val = ctx[property + DataUtils.DIMENSION_DISPLAYNAME_SUFFIX] || 
                                    ctx[property];
                            }
                            if(count === 0) {
                                ret = val;
                            } else {
                                ret = ret + "/" + val;
                            }
                            count++;
                            
                        }
                    }
                }
            }

        }
        return ret;
    }

    PieDataLabels.prototype.removeExtraDataOfDataPoint = function(DataGraphics, dataPoint) {
        var ret = dataPoint;
        if (DataGraphics && dataPoint) {
            if (DataGraphics.getData && DataGraphics.setData) {
                var data = DataGraphics.getData(dataPoint);
                if (data && data.decoras) {
                    delete data.decoras;
                    DataGraphics.setData(dataPoint, data);
                    ret = dataPoint;
                }
            }
        }
        return ret;
    };
     
    PieDataLabels.prototype._isKeepMND = function(){
        var metaData = this._data.color.metaData;
        var values = this._data.color.values;
        var bOneMNDValue = false;
        var visibleNums = 0;
      
        for(var i = 0; i < metaData.length; ++i){
            if(!metaData[i].hidden){
                ++visibleNums;
            }      
            if(metaData[i].id === MND){
                var uVals = ArrayUtils.unique(values[i], function(a) {
                    return a ? a.toString() : false;
                });
                if(uVals && uVals.length < 2){
                    bOneMNDValue = true;
                }
                
            }
        }
        
        return !(visibleNums > 1 && bOneMNDValue); 
    };
    PieDataLabels.prototype.setExtraDataOfDataPoint = function(DataGraphics, dataPoint, decoras) {
        var ret = dataPoint;
        if (DataGraphics && dataPoint && decoras) {
            if (DataGraphics.getData && DataGraphics.setData) {
                var data = DataGraphics.getData(dataPoint);
                if (!data || TypeUtils.isPlainObject(dataPoint)) {
                    data = {};
                }
                data.decoras = decoras;
                DataGraphics.setData(dataPoint, data);
                ret = dataPoint;
            }
        }
        return ret;
    };

    PieDataLabels.prototype.getLabelLineOffset = function (outRadius) {
        return outRadius * Constants.DATALABEL.PIE_LINE_LABEL_OFFSET;
    };

    PieDataLabels.prototype._reverseLineModeLocation = function (mAngle, outRadius, labelBBox) {
        var labelOffset = this.getLabelLineOffset(outRadius) +
            Constants.DATALABEL.PIE_LINE_OFFSET;
        var adjustResult = {};
        adjustResult.x = labelBBox.x;
        adjustResult.y = labelBBox.y + labelBBox.height / 2;

        if (mAngle > 0 && mAngle <= Math.PI) {
            adjustResult.x -= labelOffset;
        }
        else {
            adjustResult.x += labelBBox.width;
            adjustResult.x += labelOffset;
        }

        return adjustResult;
    };

    PieDataLabels.prototype._adjustLineModeLocation = function (mAngle, labelCenterX, outerRadius,
        labelCenterY, labelBBox) {
        //for outside line mode, we have to adjust "center" location
        var labelOffset = this.getLabelLineOffset(outerRadius) +
            Constants.DATALABEL.PIE_LINE_OFFSET;
        var adjustLocation = {};
        adjustLocation.x = labelCenterX;
        adjustLocation.y = labelCenterY;

        if (mAngle > 0 && mAngle <= Math.PI) {
            adjustLocation.x += labelBBox.width / 2;
            adjustLocation.x += labelOffset;
        }
        else {
            adjustLocation.x -= labelBBox.width / 2;
            adjustLocation.x -= labelOffset;
        }

        return adjustLocation;
    };

    PieDataLabels.prototype._adjustOutsideLocation = function (mAngle, outerRadius, labelCenterX,
        labelCenterY, labelBBox) {
        //for outside mode, we have to adjust "center" location
        var adjustLocation = {};
        adjustLocation.x = labelCenterX;
        adjustLocation.y = labelCenterY;

        if ( (mAngle >= 0 && mAngle <= (Math.PI / 8)) ||
             (mAngle > (Math.PI / 8 * 15) && mAngle <= (2 * Math.PI)) ) {
            adjustLocation.y -= labelBBox.height / 2;
        }
        else if (mAngle > (Math.PI / 8) && mAngle <= (Math.PI / 4)) {
            adjustLocation.y -= labelBBox.height / 2;
            adjustLocation.x += labelBBox.width / 2;
        }
        else if(mAngle > (Math.PI / 4) && mAngle <= (Math.PI / 4 * 3)) {
            adjustLocation.x += labelBBox.width / 2;
        }
        else if(mAngle > (Math.PI / 4 * 3) && mAngle <= (Math.PI / 8 * 7)) {
            adjustLocation.y += labelBBox.height / 2;
            adjustLocation.x += labelBBox.width / 2;
        }
        else if(mAngle > (Math.PI / 8 * 7) && mAngle <= (Math.PI / 8 * 9)) {
            adjustLocation.y += labelBBox.height / 2;
        }
        else if(mAngle > (Math.PI / 8 * 9) && mAngle <= (Math.PI / 4 * 5)) {
            adjustLocation.y += labelBBox.height / 2;
            adjustLocation.x -= labelBBox.width / 2;
        }
        else if(mAngle > (Math.PI / 4 * 5) && mAngle <= (Math.PI / 4 * 7)) {
            adjustLocation.x -= labelBBox.width / 2;
        }
        else {
            adjustLocation.y -= labelBBox.height / 2;
            adjustLocation.x -= labelBBox.width / 2;
        }

        adjustLocation.x += this.getLabelLineOffset(outerRadius) *
            Math.sin(mAngle);
        adjustLocation.y -= this.getLabelLineOffset(outerRadius) *
            Math.cos(mAngle);

        return adjustLocation;
    };

    PieDataLabels.prototype.renderDataLabelLine = function (dataLabelInfos) {
        var outRadius;
        if (dataLabelInfos.length > 0) {
            var dataObj;
            dataObj = DataGraphics.getData(dataLabelInfos[0].dataPoint);
            outRadius = dataObj.r;

            if (this.getLocationMode(outRadius) === Constants.DATALABEL.LOCATIONMODE_LINE) {
                var iInfo;
                for (iInfo = 0; iInfo < dataLabelInfos.length; iInfo++) {
                    var lineJoinX = 0;
                    var lineJoinY = 0;
                    dataObj = DataGraphics.getData(dataLabelInfos[iInfo].dataPoint);

                    var labelText = d3.select(dataLabelInfos[iInfo].node).text();
                    if (!labelText || labelText.length <= 0) {
                        //we do not need to draw label line if labal text is empty.
                        continue;
                    }

                    var labelBBox = GeometryUtils.getBBox(dataLabelInfos[iInfo].node);
                    //join point means the middle of the line
                    var joinPoint = this._reverseLineModeLocation(dataObj.midAngle, outRadius, labelBBox);

                    //center point means the center of the circle
                    var centerPoint = {};
                    centerPoint.x = -dataLabelInfos[iInfo].originalCenterX + joinPoint.x;
                    centerPoint.y = -dataLabelInfos[iInfo].originalCenterY + joinPoint.y;

                    //start point means the point in the edge of the circle
                    var startPoint = {};
                    startPoint.x = centerPoint.x + dataObj.r * Math.sin(dataObj.midAngle);
                    startPoint.y = centerPoint.y - dataObj.r * Math.cos(dataObj.midAngle);

                    var endPoint = {};
                    endPoint.y = joinPoint.y;
                    endPoint.x = joinPoint.x;
                    if (dataObj.midAngle > 0 && dataObj.midAngle <= Math.PI) {
                        endPoint.x += Constants.DATALABEL.PIE_LINE_OFFSET;
                    }
                    else {
                        endPoint.x -= Constants.DATALABEL.PIE_LINE_OFFSET;
                    }

                    var pathString = "M" + startPoint.x + " " + startPoint.y;
                    pathString += " L" + joinPoint.x + " " + joinPoint.y;
                    pathString += " L" + endPoint.x + " " + endPoint.y;
                    //draw the line
                    var lineColor = this._properties.get("line.color");
                    d3.select(dataLabelInfos[iInfo].node).append("path")
                        .attr("d", pathString)
                        .attr("stroke", lineColor)
                        .attr("fill", "none")
                        .attr("stroke-width", "1");

                    //for debug 
                    //d3.select(dataLabelInfos[iInfo].node).append("circle")
                    //    .attr("r", "3")
                    //    .attr("fill", "red")
                    //    .attr("cx", joinPoint.x)
                    //    .attr("cy", joinPoint.y);
                }
            }
        }
    };

    PieDataLabels.prototype.getRadiusPercentage = function (outerRadius) {
        var labelDistance = this._properties.get('distance');
        var radiusPercentage = this._properties.getDefault('distance') + 1;
        var INSIDE_RATIO = 0.5;
        var isPixelMode = false;
        if (TypeUtils.isString(labelDistance) && labelDistance.indexOf("px") >= 0) {
            isPixelMode = true;
        }
        labelDistance = parseFloat(labelDistance);
        if (TypeUtils.isNumber(labelDistance)) {
            radiusPercentage = INSIDE_RATIO;
            if (labelDistance >= 0) {
                if (isPixelMode) {
                    radiusPercentage = (outerRadius + labelDistance) / outerRadius;                    
                }
                else {
                    radiusPercentage = 1 + labelDistance;
                }
            }
        }
        return radiusPercentage;
    };
    
    PieDataLabels.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var labelDistance = this._properties.get('distance');
        labelDistance = parseFloat(labelDistance);
        return labelDistance >= 0;
    };

    PieDataLabels.prototype._computeDataLabelTranslate = function(node, ctm, labelPosition,
        labelBBox) {
        var pathData = d3.select(node.childNodes[0]).datum();
        var startAngle = pathData.startAngle;
        var endAngle = pathData.endAngle;

        var innerRadius = pathData.innerRadius;
        var outerRadius = pathData.outerRadius;

        var radiusPercentage = this.getRadiusPercentage(outerRadius);

        var mAngle = (startAngle + endAngle) / 2;
        var sinLabelAngle = Math.sin(mAngle - Math.PI / 2);
        var cosLabelAngle = Math.cos(mAngle - Math.PI / 2);
        var labelCenterX, labelCenterY;

        if (this._options.isDonut) {
            var baseRadius;
            if (radiusPercentage < 1) {
                baseRadius = innerRadius + radiusPercentage *
                    (outerRadius - innerRadius);
            }
            else {
                baseRadius = radiusPercentage * outerRadius;
            }
            labelCenterX = baseRadius * cosLabelAngle;
            labelCenterY = baseRadius * sinLabelAngle;
        } else {
            labelCenterX = (radiusPercentage * outerRadius) * cosLabelAngle;
            labelCenterY = (radiusPercentage * outerRadius) * sinLabelAngle;
        }
        var locationArray = [];
        locationArray.originalCenterX = labelCenterX;
        locationArray.originalCenterY = labelCenterY;
        
        var adjustedLocation;
        if (this.getLocationMode(outerRadius) === Constants.DATALABEL.LOCATIONMODE_OUTSIDE) {
            adjustedLocation = this._adjustOutsideLocation(mAngle, outerRadius, labelCenterX,
                labelCenterY, labelBBox);
            labelCenterX = adjustedLocation.x;
            labelCenterY = adjustedLocation.y;
        }
        else if(this.getLocationMode(outerRadius) === Constants.DATALABEL.LOCATIONMODE_LINE) {
            adjustedLocation = this._adjustLineModeLocation(mAngle, labelCenterX, outerRadius,
                labelCenterY, labelBBox);
            labelCenterX = adjustedLocation.x;
            labelCenterY = adjustedLocation.y;
        }
        labelCenterX += ctm.e;
        labelCenterY += ctm.f;

        locationArray[0] = labelCenterX - (labelBBox.x + labelBBox.width / 2);
        locationArray[1] = labelCenterY - (labelBBox.y + labelBBox.height / 2);

        return locationArray;
    };

    PieDataLabels.prototype.getLocationMode = function (outerRadius) {
        var radiusPercentage = this.getRadiusPercentage(outerRadius);
        var lineVisible = this._properties.get('line.visible');
        var locationMode = Constants.DATALABEL.LOCATIONMODE_INSIDE;
        if (radiusPercentage >= 1) {
            if (lineVisible) {
                locationMode = Constants.DATALABEL.LOCATIONMODE_LINE;
            }
            else {
                locationMode = Constants.DATALABEL.LOCATIONMODE_OUTSIDE;
            }
        }
        return locationMode;
    };

    PieDataLabels.prototype.sortDataLabelInfos = function(dataLabelInfos) {
        dataLabelInfos.sort(function(a, b) {
            var result = (a.info.value - b.info.value);
            return result;
        });
    };    

    PieDataLabels.prototype.truncateText = function (dataLabelInfos) {
        var outRadius;
        if (dataLabelInfos.length > 0) {
            var dataObj;
            dataObj = DataGraphics.getData(dataLabelInfos[0].dataPoint);
            outRadius = dataObj.r;

            if (this.getLocationMode(outRadius) === Constants.DATALABEL.LOCATIONMODE_INSIDE) {
                var type = this._properties.get('type');
                if (type === 'percentage' || type === 'value') {
                    return;
                }
                for (var i = (dataLabelInfos.length - 1) ; i >= 0; i--) {
                    var dataPointNode = dataLabelInfos[i].dataPoint;
                    var dataLabelNode = dataLabelInfos[i].node;
                    var dataPointBBox = dataPointNode.getBoundingClientRect();
                    var textNode = dataLabelNode.getElementsByTagName('text');
                    if (!textNode || textNode.length === 0) {
                        continue;
                    }
                    textNode = textNode[0];
                    var labelText = textNode.textContent;
                    var dataLabelStyle = this._getStyle(dataPointNode);

                    var ellipsisOptions = {};
                    var envManager = this.runtime().envManager();
                    ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

                    if (type === 'color') {
                        TextUtils.ellipsis(labelText, textNode, dataPointBBox.width,
                                dataLabelStyle.cssString, ellipsisOptions);
                    }
                    else {
                        var colorText = labelText.split(' ')[0];
                        var minText = colorText.substr(0, 3) + '...';
                        var valueText = labelText.substring(colorText.length);
                        var valueTextLength = TextUtils.canvasMeasure(valueText,
                                dataLabelStyle['font-size'], dataLabelStyle['font-weight'],
                                dataLabelStyle['font-family']).width;
                        var minTextLength = TextUtils.canvasMeasure(minText,
                                dataLabelStyle['font-size'], dataLabelStyle['font-weight'],
                                dataLabelStyle['font-family']).width;
                        var availableLength = dataPointBBox.width - valueTextLength;
                        var truncatedText = TextUtils.ellipsis(colorText, textNode,
                                availableLength > minTextLength ? availableLength : minTextLength,
                                dataLabelStyle.cssString, ellipsisOptions);
                        textNode.textContent = truncatedText + valueText;
                    }
                    var labelBBox = GeometryUtils.getBBox(dataLabelNode);
                    var ctm = SVG.getTransformToElement(dataPointNode, dataPointNode.parentNode.parentNode);
                    var labelTranslate = this._computeDataLabelTranslate(dataPointNode, ctm, this._labelPosition,
                            labelBBox);
                    dataLabelNode.setAttribute("transform", "translate(" + labelTranslate[0] + "," +
                        labelTranslate[1] + ")");
                    //update dataLabelInfos location
                    var x = labelTranslate[0], y = labelTranslate[1];
                    dataLabelInfos[i].left = x + labelBBox.x;
                    dataLabelInfos[i].right = x + labelBBox.x + labelBBox.width;
                }
            }
        }
    };

    return PieDataLabels;
});

define('sap/viz/chart/components/renderers/PieRenderer',[
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DataGraphics'
], function(SVG, DataGraphics) {
        var pieRenderer = function(config) {
            var graphic = config.graphic;
            var sectors = SVG.create("path");

            var innerRadius = 0;
            if (graphic.innerRadius) {
                innerRadius = graphic.innerRadius;
            }

            var path = d3.svg.arc().innerRadius(innerRadius).outerRadius(graphic.outerRadius).
                    startAngle(graphic.startAngle).endAngle(graphic.endAngle)();

            var fill = config.effectManager.register({
                drawingEffect : graphic.drawingEffect,
                graphType : 'sector',
                direction : 'vertical',
                radius : graphic.outerRadius,
                fillColor: graphic.color
            });
            sectors.setAttribute("fill", fill);
            sectors.setAttribute("d", path);
            if(graphic.stroke) {
                sectors.setAttribute('stroke', graphic.stroke);
                sectors.setAttribute('stroke-width', graphic.strokeWidth);
            }
            DataGraphics.setContext(sectors, {
                innerRadius: graphic.innerRadius,
                outerRadius: graphic.outerRadius,
                startAngle: graphic.startAngle,
                endAngle: graphic.endAngle
            });
            return sectors;
        };

        pieRenderer.expose = {
            renderer: pieRenderer
        };

        return pieRenderer;
    });

define('sap/viz/chart/components/util/ContextUtil',["sap/viz/framework/common/util/Constants"], function Setup(Constants) {

    var ContextUtil = {

        isEqualArray: function(src, target) {
            if (!src || !target) {
                return false;
            }
            var equal = true;
            if (src.length === target.length && target.length > 0) {
                for (var i = 0; i < src.length; i++) {
                    if (src[i] !== target[i]) {
                        equal = false;
                        break;
                    }
                }

            } else {
                equal = false;
            }
            return equal;

        },
        getUniqueFieldName: function(fieldObj) {
            if (!fieldObj) {
                return null;
            }
            var fieldName = null;
            if (fieldObj.hasOwnProperty("id")) {
                fieldName = fieldObj.id;

            } else if (fieldObj.hasOwnProperty("name")) {
                fieldName = fieldObj.name;
            }
            return fieldName;
        },
        getContextObjByFieldsArray: function(contextArray, fieldsArray) {
            if (!contextArray || !fieldsArray || (contextArray && contextArray.length < 1) || (fieldsArray &&
                fieldsArray.length < 1)) {
                return null;
            }
            var contextObj = null;

            if (contextArray && fieldsArray) {
                var contextLength = contextArray.length;
                var fieldsLength = fieldsArray.length;

                if (contextLength >= fieldsLength && fieldsLength > 0) {
                    for (var i = 0; i < contextLength; i++) {
                        var context = contextArray[i];
                        if (context && context.length > 0) {
                            var found = false;
                            for (var j = 0; j < context.length; j++) {
                                var contextDetail = context[j];
                                if (contextDetail && contextDetail.length > 0 && contextDetail.length ===
                                    fieldsLength) {
                                    if (ContextUtil.isEqualArray(contextDetail, fieldsArray)) {
                                        found = true;
                                    } else {
                                        if (found) {
                                            for (var m = 0; m < fieldsLength; m++) {
                                                if (!contextObj) {
                                                    contextObj = {};
                                                }
                                                if (fieldsArray[m]) {
                                                    contextObj[fieldsArray[m]] = context[j][m];
                                                }
                                            }
                                            break;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                            if (found) {
                                break;
                            }

                        } else {
                            break;
                        }
                    }
                }

            }
            return contextObj;

        },
        filterDimensionContext: function(array, context) {
            if (!array || !context) {
                return null;
            }

            var ret = null;
            if (array.length > 0) {
                for (var key in context) {
                    if (context.hasOwnProperty(key)) {
                        if (!ret) {
                            ret = {};
                        }
                        var isDimension = true;
                        for (var i = 0; i < array.length; i++) {
                            if (key === array[i]) {
                                array.splice(i, 1);
                                isDimension = false;
                                break;
                            }
                        }
                        if (!isDimension) {
                            continue;
                        }
                        ret[key] = context[key];
                    }
                }
            }
            return ret;

        },

        getDimensionKeyAndValueString: function(dimensionObj) {
            if (!dimensionObj) {
                return null;
            }
            var ret = null;
            if (dimensionObj && typeof dimensionObj === 'object') {
                var count = 0;
                for (var propertyName in dimensionObj) {
                    if (dimensionObj.hasOwnProperty(propertyName)) {
                        var item = propertyName + "=" + dimensionObj[propertyName];
                        if (item) {
                            ++count;
                            if (count > 1) {
                                ret = ret + "&" + item;
                            } else {
                                ret = item;
                            }
                        }
                    }
                }
            }
            return ret;
        },

        getDimensionKeyAndValueStringFromAxes: function(axes, index) {
            if (!axes || !axes._data || !axes._fields) {
                return null;
            }
            var ret = null;
            if (axes._data.length > 0 && axes._fields.length > 0 && index < axes._data.length) {

                var fLength = axes._fields.length;
                var fields = axes._fields;
                var data = axes._data;
                if (data[index] && data[index].val) {
                    var i = 0;
                    var propertyValue = null;
                    var propertyName = null;
                    var fieldUniqueName = ContextUtil.getUniqueFieldName(fields[i]);
                    for (; i < fLength; i++) {
                        if (fields[i] && fieldUniqueName) {
                            if (!ret) {
                                ret = {};
                            }

                            propertyName = fieldUniqueName;
                            propertyValue = data[index].val[i];
                            ret[propertyName] = propertyValue;
                        }

                    }
                }
            }

            return ret;
        },

        isEmptyObj: function(obj) {
            if (!obj) {
                return true;
            }
            var ret = true;
            if (obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        ret = false;
                        break;
                    }
                }
            }
            return ret;
        },
        getHighlightContextIndexOfAxes: function(axes, highlightContext) {
            if (!axes || !highlightContext || ContextUtil.isEmptyObj(highlightContext)) {
                return -1;
            }
            var index = -1;
            if (axes && axes._data && axes._data.length > 0 && axes._fields && axes._fields.length > 0) {
                var fields = axes._fields;
                var fLength = fields.length;
                var i = 0;
                var data = axes._data;


                var highlightcontextString = this.getDimensionKeyAndValueString(highlightContext);

                var getContextString = function(axes, index) {
                    var ret = null;
                    for (var i = 0; i < fLength; i++) {
                        var fieldUniqueName = ContextUtil.getUniqueFieldName(axes._fields[i]);
                        if (fieldUniqueName) {
                            var tmpString = fieldUniqueName + "=" + axes._data[index].val[i];
                            if (i > 0) {
                                ret = ret + "&" + tmpString;
                            } else {
                                ret = tmpString;
                            }
                        }
                    }
                    return ret;
                };

                if (data && data.length > 0 && fLength) {
                    for (; i < data.length; i++) {
                        if (highlightcontextString === getContextString(axes, i)) {
                            index = i;
                            break;
                        }

                    }
                }

            }
            return index;
        },

        equalCtx: function(ctx1, ctx2) {
            var keys1 = Object.keys(ctx1),
                keys2 = Object.keys(ctx2);
            return (keys1.length > 0) && keys1.every(function(key) {
                return ctx1[key] === ctx2[key];
            });
        },

        match: function(configCtx, dpCtx) {
            if (!configCtx) {
                return false;
            }
            if (!Array.isArray(configCtx)) {
                configCtx = [configCtx];
            }

            return configCtx.some(function(ctx) {
                if (!ctx) {
                    return true;
                }

                return ContextUtil.equalCtx(ctx, dpCtx);
            });
        },

        getContextInfo: function(context, configs) {
            // var ctx = context.ctx;
            var ctx = context;

            if (!Array.isArray(configs)) {
                configs = [configs];
            }

            var defaultResult;
            for (var j = 0, length = configs.length; j < length; j++) {
                var configItem = configs[j],
                    configItemCtx = configItem.ctx,
                    defaultParas = configItem.paras;
                if (!configItemCtx) {
                    defaultResult = defaultParas;
                }
            }

            var currentParas = this._parameters,
                isUpdated, contextNum = -1,
                number, paraNum;
            for (var i = 0, len = configs.length; i < len; i++) {
                var config = configs[i],
                    configCtx = config.ctx,
                    paras = config.paras;
                if (!configCtx) { // Handle ctx undefined case
                    paraNum = i;
                } else if (ContextUtil.match(configCtx, ctx)) {
                    number = 0;
                    for (var m in configCtx) { // Get context key number
                        if (configCtx.hasOwnProperty(m)) {
                            number++;
                        }
                    }
                    if (contextNum < number) { // Get most detailed context
                        contextNum = number;
                        paraNum = i;
                    }
                }
            }
            if (configs[paraNum]) {
                return configs[paraNum].paras;
            }
            return defaultResult;
        },

        getContextDisplayKey :function(dimensionId){
            return dimensionId + ".d";
        },
        getContextValueKey :function(dimensionId){
            return dimensionId + ".v";
        },

        // {v:china, d:china_id}
        getContextDisplayValue :function(dimension){
            return dimension && dimension.hasOwnProperty('d') ? dimension["d"] :
                    (dimension && dimension.hasOwnProperty('v') ? dimension["v"] : undefined);
        },
        // {v:china, d:china_id}
        getContextValue :function(dimension){
            return dimension && dimension.hasOwnProperty('v') ? dimension["v"] : undefined;
        },

        enableDisplayContext:function(ctx){
            var enabled = false;
            if(ctx){
                for(var item in ctx){
                    if(ctx.hasOwnProperty(item) && ctx.hasOwnProperty(item+".d")){
                        enabled =  true;
                        break;
                    }
                }
            }
            return enabled;
        },
        enableObjectContext:function(ctx){
            var enabled = false;
            if(ctx){
                for(var item in ctx){
                    if(ctx.hasOwnProperty(item) &&
                    (ctx.hasOwnProperty(item+".d") || ctx.hasOwnProperty(item+".parsedValue"))){
                        enabled =  true;
                        break;
                    }
                }
            }
            return enabled;
        },
        equalCtxWithoutDisplayName: function(ctx, colorCtx, metaData) {
            var ret = true;
            for(var key in ctx) {
                if(ctx.hasOwnProperty(key)) {
                    for(var i = 0 ; i < metaData.length; i++) {
                        if(key === metaData[i].id) {
                            if(ctx[key] !== colorCtx[i]) {
                                ret = false;
                            }
                            break;
                        }
                    }
                    if(i >= metaData.length) {
                        ret = false;
                        break;
                    }
                }
            }
            return ret;
        },

        equalCtxWithColorDomain: function(colorCtx, ctx, metaData) {
            var ret = true;
            var length = colorCtx.length;
            var matchCount = 0;
            for(var key in ctx) {
                if(ctx.hasOwnProperty(key)) {
                    for(var i = 0 ; i < metaData.length; i++) {
                        if(key === metaData[i].id) {
                            if(ctx[key] === colorCtx[i]) {
                                matchCount ++;
                            }
                            break;
                        }
                    }
                }
            }
            return length === matchCount;
        },


        // extend equal function to adapt the 'd, v' data format in FlatTableDataSet
        // 'd' - display
        // 'v' - value
        // This function is only for pie/donut chart
        equalCtxExtend : function(ctx, colorCtx, metaData){
            if(!ContextUtil.enableObjectContext(ctx)){
                //ctx should be a subset of colorCtx
                return ContextUtil.equalCtxWithColorDomain(colorCtx, ctx, metaData);
            }
            var ret  =false;
            if(ctx && colorCtx && metaData && metaData.length === colorCtx.length){
                if(colorCtx.length>0){
                    var metadata_id =null;
                    var metadata_type = null;
                    var context_dim_display = null; // context dimension value
                    var context_dim_id = null; // context dimension id
                    var index = -1;
                    var colorCtxObj = {};
                    var contextKey = null;

                    var color_context_dim_display = null;
                    var color_context_dim_id = null;
                    ret = metaData.every(function(data){
                        metadata_id = data.id;
                        metadata_type = data.type;
                        var equal = false;
                        if(metadata_type === "Dimension"){
                            index++;
                            contextKey = ContextUtil.getContextDisplayKey(metadata_id);
                            if(ctx.hasOwnProperty(metadata_id)){
                                context_dim_id = ctx[metadata_id];
                                colorCtxObj = colorCtx[index];
                                color_context_dim_id = ContextUtil.getContextValue(colorCtxObj);
                                if(context_dim_id !== undefined && color_context_dim_id !== undefined &&
                                    context_dim_id !== null && color_context_dim_id !== null){
                                    equal = context_dim_id === color_context_dim_id;
                                }
                            }
                        }
                        return equal;
                    });
                }
            }
            return ret;
        },

        getContextDisplayNames : function(metaData){
            var name = [];
            if(metaData && metaData.length){
                metaData.forEach(function(data){
                    if(data && data.hasOwnProperty('id') && data.hasOwnProperty('type') && data.type === "Dimension"){
                        name.push(ContextUtil.getContextDisplayKey(data.id));
                    }
                });
            }
            return name;
        },
        getContextRawValue: function(context){
            var ret = null;
            if(context){
                for(var key in context){
                    if(context.hasOwnProperty(key) && key !== Constants.BINDING.CONTEXT_ID_NAME){
                        if(!ret){
                            ret = context[key];
                        }else{
                            ret += "/" + context[key];
                        }
                    }
                }
            }
            return ret;

        },
        getDisplayValueOfContext:function(context, metaData){
            if(!ContextUtil.enableObjectContext(context)){
                return ContextUtil.getContextRawValue(context);
            }
            var displayValue = null;
            if(context && metaData && metaData.length>0){
                metaData.forEach(function(data){
                    var metadata_id = data.id;
                    var contextKey = ContextUtil.getContextDisplayKey(metadata_id);
                    var value = context[metadata_id];
                    if (context.hasOwnProperty(contextKey)) {
                        value = context[contextKey];
                    }
                    if(value != null){
                        displayValue = !displayValue ? value : displayValue + "/" + value;
                    }
                });
            }
            return displayValue;
        }
    };
    return ContextUtil;
});
define('sap/viz/chart/components/accessibility/PieDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/ColumnDataPointNavigator"
], function(oo, ColumnDataPointNavigator) {

    function PieDataPointNavigator() {
        PieDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._isAllValueNegative = false;
        this._allDataPoints = [];
        this._setupDataPointsMap();
    }

    oo.extend(PieDataPointNavigator, ColumnDataPointNavigator);

    var prot = PieDataPointNavigator.prototype;

    prot._setupDataPointsMap = function() {
        if (this._series) {
            var negValueNum = 0;
            var pieceNum = this._series.length;
            for (var i = 0; i < pieceNum; i++) {
                if (this._series[i][0].size < 0) {
                    negValueNum++;
                }
            }
            this._isAllValueNegative = (negValueNum === pieceNum);

            for (var j = 0; j < pieceNum; j++) {
                if (!this._isAllValueNegative && this._series[j][0].size < 0) {
                    continue;
                } else {
                    this._allDataPoints.push(this._series[j][0].dp);
                }
            }
        }
    };

    prot.getFirstStartPoint = function() {
        for (var i = 0; i < this._series.length; i++) {
            if (!this._isAllValueNegative && this._series[i][0].size < 0) {
                continue;
            } else {
                return this._series[i][0].dp;
            }
        }
    };

    return PieDataPointNavigator;
});

define('sap/viz/chart/components/plots/PiePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/datalabels/PieDataLabels',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/renderers/PieRenderer',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/components/util/ContextUtil',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/framework/common/format/FormatManager',
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/PieDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants"
], function Setup(oo, 
        SVG,
        DataLabels,
        PieDataLabels,
        BasePlot,
        ScaleHandler,
        PieRenderer,
        ObjectUtils, 
        NumberUtils,
        DataGraphics,
        TypeUtils,
        ContextUtil,
        DataPointUtils,
        TextUtils,
        FormatManager,
        ChartNavigator,
        DataPointNavigator,
        Constants) {
    /**
     * To initialize PiePlot object.
     *
     * @name PiePlot
     * @constructor
     */
    var PiePlot = function(runtime, options) {
        PiePlot.superclass.constructor.apply(this, arguments);
        this._dataPointRenderer = PieRenderer;
    };

    oo.extend(PiePlot, BasePlot);

    PiePlot.prototype.destroy = function() {
        PiePlot.superclass.destroy.call(this);
        this._dataPointRenderer = null;
        this._padding = null;
        this._outerRadius = null;
        this._innerRadius = null;
        this._dataSeries = null;
        this._pieLayout = null;
    };
    
    PiePlot.prototype._getDataHandler = function () {
        return {
            "size": new PieDataHandler()
        };
    };

    PiePlot.prototype._getDataLabels = function (name, runtime) {
        var options = ObjectUtils.extend({}, this._options);
        options.name = name;
        return new PieDataLabels(runtime, options);
    };

    PiePlot.prototype._applyChanges = function () {
        var width = this._size.width,
            height = this._size.height;
        this._padding = calculatePadding(width, height);
        this._outerRadius = this.calculateOuterRadius(width, height, null);
        this._innerRadius = this._options.isDonut ? 
                calculateInnerRadius(this._outerRadius, this._properties.get('innerRadiusRatio')) : 0;

        var isAllNegative = true, values = [];
        var rawValues = [];
        this._dataSeries = [];
        for(var i=0; i< this._data.series.length; i++){
            if(this._data.series[i] && this._data.series[i][0]){
                rawValues[i] = this._data.series[i][0].size;
                if(rawValues[i] > 0){
                    isAllNegative = false;
                }
            }
        }
        for(i=0; i< rawValues.length; i++) {
            var value = rawValues[i];
            if(NumberUtils.isNoValue(value) || (value < 0 && !isAllNegative)) {
                continue;
            }
            values.push(value);
            this._dataSeries.push(this._data.series[i]);
        }

        this._pieLayout = d3.layout.pie().sort(null)(values);
    };
    
    PiePlot.prototype._getSeries = function() {
        return this._dataSeries;
    };
    
    PiePlot.prototype._applyDataPointRenderer = function(dpRenderer, dpConfig){
        var markerRenderer = this._properties.get('markerRenderer');
        if (markerRenderer) {
            return markerRenderer(dpConfig, PieRenderer.expose);
        } else {
            return PiePlot.superclass._applyDataPointRenderer.apply(this, arguments);
        }
    };
    
    PiePlot.prototype._drawDataPoint = function(dpRenderer, dataPoint) {
        var dataPointG = PiePlot.superclass._drawDataPoint.apply(this, arguments);
        var dpConfig = dataPoint.getConfig();
        if (dpConfig.isMatchedHighlightContext !== undefined && dpConfig.isMatchedHighlightContext !== true) {
            dataPointG.setAttribute("fill-opacity", 1);
            dataPointG.setAttribute("class", '');
        }
        return dataPointG;
    };

    PiePlot.prototype.isFlexibleLayout = function () {
        //In flexibleLayout, we will change current Pie radius and location.
        return true;
    };

    PiePlot.prototype._postRender = function (dataPointG) {
        var x = (this._size.width / 2);
        var inTrellis = this._options && this._options.inTrellis;
        var isLegendHorizontal = this.runtime().statusManager().get('legendGroup.isHorizontal');

        var y = (inTrellis || isLegendHorizontal) ? (this._size.height / 2) : 
            (this._outerRadius * DEFAULT_OFFSET_FOR_SELECT_DATA + this._padding);

        if (this.isFlexibleLayout()) {
            y = this._size.height / 2;
            if( y > x && !(isLegendHorizontal &&
                    this._properties.get("alignment.vertical") === "center"))
            {
                y = x;
            }
        }

        dataPointG.setAttribute("transform", 'translate(' + x + ', ' + y + ')');
        if(this._options.isDonut && this._highlightContext) {
            var centerName = ContextUtil.getDisplayValueOfContext(this._highlightContext, 
                this._data.color.metaData);
            var value = (this._highlightContextPosition.endAngle -
                    this._highlightContextPosition.startAngle) / (2 * Math.PI);

            var formatPatterns = this._properties.get('dataLabel.formatString');
            var type = this._properties.get('dataLabel.type');

            var measureName, metaDataFormat;
            var isMetaDataPercentageFormat = false;

            if (this._data && this._data.size && this._data.size.metaData) {
                measureName = this._data.size.metaData[0].id;
                metaDataFormat = this._data.size.metaData[0].formatString;
            }

            if (!formatPatterns) {
                formatPatterns = metaDataFormat;
                if (TypeUtils.isArray(formatPatterns) && type === 'percentage') {
                    formatPatterns = formatPatterns[1];
                }
            }

            var dataLabelInfo = {
                key: measureName,
                value: value
            };

            var formatPattern = DataLabels.getFirstFormatPattern(formatPatterns, dataLabelInfo);

            formatPattern = formatPattern ? formatPattern : FormatManager.getPercentagePattern(1);

            var centerValue = FormatManager.format(value, formatPattern);
            var centerRendererConfig = {
                    centerName : centerName,
                    centerValue : centerValue,
                    properties : this._properties.get(),
                };
            dataPointG.appendChild(renderCenter.call(this, centerRendererConfig, this._highlightContext));
        }
    };

    PiePlot.prototype._computeDataLabelTranslate = function (node, ctm, labelPosition,
        labelBBox) {
        var pathData = d3.select(node.childNodes[0]).datum();
        var startAngle = pathData.startAngle;
        var endAngle = pathData.endAngle;

        var innerRadius = pathData.innerRadius;
        var outerRadius = pathData.outerRadius;
        var mAngle = (startAngle + endAngle) / 2;
        var sinLabelAngle = Math.sin(mAngle - Math.PI / 2);
        var cosLabelAngle = Math.cos(mAngle - Math.PI / 2);
        var labelCenterX, labelCenterY;

        if (this._options.isDonut) {
            labelCenterX = (innerRadius + outerRadius) / 2 * cosLabelAngle;
            labelCenterY = (innerRadius + outerRadius) / 2 * sinLabelAngle;
        } else {
            labelCenterX = 0.5 * outerRadius * cosLabelAngle;
            labelCenterY = 0.5 * outerRadius * sinLabelAngle;
        }

        labelCenterX += ctm.e;
        labelCenterY += ctm.f;

        return [labelCenterX - (labelBBox.x + labelBBox.width / 2),
            labelCenterY - (labelBBox.y + labelBBox.height / 2)
        ];
    };

    PiePlot.prototype._getPosition = function (seriesIndex, itemIndex, data) {
        var layout = this._pieLayout[seriesIndex];
        // if all data set is empty<0, null, undefined>, the layout from D3.pie will set NaN for Angle.
        if(isNaN(layout.startAngle) || isNaN(layout.endAngle) ){
            layout = null;
        }
        return layout;
    };

    PiePlot.prototype._buildData = function (dpConfig) {
        var graphic = dpConfig.graphic;
        var percentage;
        if(this._data.size.totalSum === 0){
            percentage = 1;
        }else{
            percentage = dpConfig.rawData.size / this._data.size.totalSum;
        }

        return {
            color: graphic.color,
            midAngle: graphic.startAngle / 2 + graphic.endAngle / 2,
            startAngle: graphic.startAngle,
            endAngle: graphic.endAngle,
            innerRadius: graphic.innerRadius,
            r: graphic.outerRadius,       
            shape:'sector',
            percentage: percentage
        };
    };

    PiePlot.prototype._buildConfig = function (data, position, context) {
        var color = this._data.color.scale.scale(data.color);
        var isMatchedHighlightContext;
        if(this._options.isDonut) {
            var highlightContext = this._properties.get('highlight.highlightContext');
            if(highlightContext && highlightContext.length > 0) {
                highlightContext = highlightContext[0];
                isMatchedHighlightContext = ContextUtil.equalCtx(highlightContext, context);
        
                if (isMatchedHighlightContext === true) {
                    this._highlightContext = highlightContext;
                    if(this._highlightContextPosition)
                    {
                        this._highlightContextPosition.data += position.data;
                        this._highlightContextPosition.value += position.value;
                        this._highlightContextPosition.endAngle = position.endAngle;
                    }
                    else
                    {
                        this._highlightContextPosition = position;
                    }
                } else {
                    color = this._properties.get('highlight.unhighlightSliceColor');
                }
            }                
        }

        return {
            graphic: {
                startAngle: position.startAngle,
                endAngle: position.endAngle,
                innerRadius: this._innerRadius,
                outerRadius: this._outerRadius,
                color: color,
                drawingEffect: this._properties.get('drawingEffect')
            },
            ctx: context,
            isMatchedHighlightContext : isMatchedHighlightContext,
            effectManager: this._effectManager
        };
    };

    var defaultPaddingValue = 6,
        horizontalMarginRatio = 2.414;
    
    // for sectorMoveOffset in PieBehaviorHelper.js when select data point event occurs
    var DEFAULT_OFFSET_FOR_SELECT_DATA = 1.08;
    
    var calculatePadding = function(w, h) {
        var padding;
        var boundary = Math.min(w, h);
        if (boundary < defaultPaddingValue * 2) {
            if (boundary < (defaultPaddingValue / 4) * 2) {
                if (boundary < (defaultPaddingValue / 8) * 2) {
                    padding = 0;
                } else {
                    padding = defaultPaddingValue / 8;
                }
            } else {
                padding = defaultPaddingValue / 4;
            }
        } else {
            padding = defaultPaddingValue;
        }
        return padding;
    };

    var calculateOuterRadiusByHeight = function (h, padding) {
        return (h / 2 - padding) / DEFAULT_OFFSET_FOR_SELECT_DATA;
    };

    var calculateOuterRadiusByWidth = function (w, padding) {
        var rCandidate = Math.max(w / 2 / (1 + 1 / horizontalMarginRatio), padding * horizontalMarginRatio);
        return Math.min(rCandidate, w / 2 - padding);
    };

    PiePlot.prototype.calculateOuterRadius = function (w, h, maxRadius) {
        var padding = this._padding;
        if (this.isFlexibleLayout()) {
            //outside data label
            var rPercentage = this._properties.get('radius');
            if (!(TypeUtils.isNumber(rPercentage) && rPercentage >= 0 && rPercentage <= 0.5)) {
                rPercentage = this._properties.getDefault('radius');
            }
            return Math.min(h * rPercentage, w * rPercentage);
        }
        else {
            if (maxRadius) {
                return Math.min(h / 2, w / 2);
            }
            return Math.min(calculateOuterRadiusByHeight(h, padding), calculateOuterRadiusByWidth(w, padding));
        }
    };

    var calculateInnerRadius = function (outerRadius, innerRadiusRatio) {
        if(!TypeUtils.isNaN(innerRadiusRatio)) {
            return outerRadius * innerRadiusRatio;
        }
        return outerRadius / horizontalMarginRatio;
    };
    
    var createHighlightTextNode = function(parent, text, property, styleName) {
        var DEFAULT_LINE_HEIGHT = 20;
        var data = document.createTextNode(text);
        var tspan = SVG.create("tspan");
        var offset = property && property.hasOwnProperty("fontSize") ? 
                parseFloat(property["fontSize"]) / 2 : DEFAULT_LINE_HEIGHT/2;
        tspan.setAttribute("class", styleName);
        tspan.appendChild(data);
        parent.appendChild(tspan);
        
        return {"node": tspan, "offset": offset};
    };
    
    var renderCenter = function(config, highlightContext) {
        var DONUT_CENTER_NAME_CLASS = "v-donut-centername",
        DONUT_CENTER_VALUE_CLASS = "v-donut-centervalue",
        DONUT_CENTER_NAME = "centerName",
        DONUT_CENTER_VALUE = "centerValue",
        DONUT_HIGHLIGHT = "highlight";
        var LINE_SPACE = 6;
        var props = config.properties;
        var text = SVG.create("text");
        var centerNameNode, centerValueNode, centerNameOffset = 0, centerValueOffset = 0;
        var ret, property;
        var customizedColor, contextInfos = props.highlight.contextInfos;
        if(contextInfos && contextInfos.length > 0) {
            for(var i = 0; i < contextInfos.length; i++) {
                if(ContextUtil.equalCtx(contextInfos[i].ctx, highlightContext)) {
                    customizedColor = contextInfos[i].paras.color;
                    break;
                }
            }
        }

        var centerNameSize = 0;
        var centerValueSize = 0;
        if (props.highlight.centerName.visible) {
            property = props[DONUT_HIGHLIGHT][DONUT_CENTER_NAME]['style'];
            ret = createHighlightTextNode(text, config.centerName, property, DONUT_CENTER_NAME_CLASS);
            if (ret) {
                centerNameNode = ret.node;
                centerNameOffset = ret.offset;
                centerNameSize = TextUtils.fastMeasure(config.centerName, property["fontSize"],
                    property["fontWeight"], property["fontFamily"], property["fontStyle"]).width;

                centerNameNode.style.fill = property["color"] || customizedColor;
                centerNameNode.style.fontFamily =  property["fontFamily"];
                centerNameNode.style.fontSize =  property["fontSize"];
                centerNameNode.style.fontWeight =  property["fontWeight"];
                centerNameNode.style.fontStyle = property["fontStyle"];
            }
        }
        if (props.highlight.centerValue.visible) {
            property = props[DONUT_HIGHLIGHT][DONUT_CENTER_VALUE]['style'];
            ret = createHighlightTextNode(text, config.centerValue, property, DONUT_CENTER_VALUE_CLASS);
            if (ret) {
                centerValueNode = ret.node;
                centerValueOffset = ret.offset;
                centerValueSize = TextUtils.fastMeasure(config.centerValue, property["fontSize"],
                    property["fontWeight"], property["fontFamily"], property["fontStyle"]).width;

                centerValueNode.style.fill = property["color"] || customizedColor;
                centerValueNode.style.fontFamily =  property["fontFamily"];
                centerValueNode.style.fontSize =  property["fontSize"];
                centerValueNode.style.fontWeight =  property["fontWeight"];
                centerValueNode.style.fontStyle =  property["fontStyle"];
            }
        }
        if (centerNameNode) {
            centerNameNode.setAttribute("x", -centerNameSize/2);
            centerNameNode.setAttribute("y", centerNameOffset - centerValueOffset - LINE_SPACE/2);
        }
        if (centerValueNode) {
            centerValueNode.setAttribute("x", -centerValueSize/2);
            centerValueNode.setAttribute("y", centerNameOffset + centerValueOffset + LINE_SPACE/2);
        }
        
        var textAnchor = null;
        var envManager = this.runtime().envManager();
        if (envManager) {
            textAnchor = envManager.textAnchor();
        }
        text.setAttribute("text-anchor", textAnchor);
        return text;
    };

    var PieDataHandler = function () {};

    PieDataHandler.prototype.reset = function () {
        this._sum = 0;
    };

    PieDataHandler.prototype.getBase = function (index, value) {
        return this._sum;
    };

    PieDataHandler.prototype.add = function (index, value) {
        this._sum += value;
        return this._sum;
    };

    PieDataHandler.prototype.destroy = function() {
        this._sum = null;
    };
    ChartNavigator.register(Constants.DATAPOINT_NAVIGATOR,Constants.PIE, DataPointNavigator);
    return PiePlot;
});

define('sap/viz/chart/chains/PieChains',[
    'sap/viz/chart/chains/BaseChains',
    "sap/viz/chart/chains/YYChains",
    "sap/viz/framework/binding/BindingManager"
], function Setup(
    BaseChains,
    YYChains,
    BindingManager
) {
    var pieChains = {};
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetMeasuresFromFlattable',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];
    pieChains = BaseChains.extend('pie', defaultChains);

    pieChains.pieGetBindingSeries = YYChains.yyGetBindingSeries;
    Object.keys(pieChains).forEach(function(key) {
        BindingManager.registerChain(key, pieChains[key]);
    });
    return pieChains;
});
define('sap/viz/chart/dynamicScales/PieDyScaleProcessor',[ 
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/scale/DynamicScaleRepository',
    "sap/viz/chart/dynamicScales/BaseColumnDyScaleProcessor"
],function(
    oo,
    DynamicScaleRepository,
    BaseColumnDyScaleProcessor
){

    function PieDyScaleProcessor(type, propertyMgr, dataModel, runtime){
        PieDyScaleProcessor.superclass.constructor.apply(this, arguments);
        this._mainValue = "size";
    }

    DynamicScaleRepository["pie"] = PieDyScaleProcessor; 
    DynamicScaleRepository["donut"] = PieDyScaleProcessor; 
    oo.extend(PieDyScaleProcessor, BaseColumnDyScaleProcessor);

    return PieDyScaleProcessor;  
});
define('sap/viz/chart/behavior/config/PieBehaviorHelper',[
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/DataGraphics"
], function(TypeUtils, DataGraphics) {

    function decorasSetting(decoras, dx, dy, isDeselect, disableAnimation) {
        decoras = d3.select(decoras);
        var trans = d3.transform(decoras.attr("transform"));
        if (!decoras.attr("inPos")) {
            decoras.attr("inPos", trans.translate.join(","));
        }
        if (!decoras.attr("outPos")) {
            decoras.attr("outPos", [trans.translate[0] + dx, trans.translate[1] + dy].join(","));
        }

        var dest = isDeselect ? decoras.attr("inPos") : decoras.attr("outPos");
        if (!disableAnimation) {
            decoras = decoras.transition();
        }
        decoras.attr("transform", "translate(" + dest + ")");
    }

    var selectFun = function(elements, disableAnimation) {
        if (!TypeUtils.isArray(elements)) {
            elements = [elements];
        }
        elements.forEach(function(e) {
            if (e.parentNode.childNodes.length > 1) {
                    
                var d3Node = d3.select(e);
                var d = DataGraphics.getData(d3Node.node());
                if (d) {
                    var decoras = d.decoras;
                    var dx = 0,
                        dy = 0;
                    var a = d.midAngle;
                    var r = d.r;
                    var sectorMoveOffset;

                    sectorMoveOffset = 0.05 * r;

                    dx = sectorMoveOffset * Math.sin(a);
                    dy = -sectorMoveOffset * Math.cos(a);
                    d3Node.attr('transform', "translate(" + dx + "," + dy + ")");
                    d3Node.attr('translateOffsetX', dx);
                    d3Node.attr('translateOffsetY', dy);
                    if (decoras && (!d3Node.attr('offsetDone') || d3Node.attr('offsetDone') === "false")) {
                        decorasSetting(decoras, dx, dy, false, disableAnimation);
                    }
                    d3Node.attr('offsetDone', true);
                }
            }
        });
    };

    var PieBehaviorHelper = {
        selectDataPoint: selectFun,
        deselectDataPoint: function(elements) {
            if (!TypeUtils.isArray(elements)) {
                elements = [elements];
            }
            elements.forEach(function(e) {
                var d3Node = d3.select(e);
                if (d3Node) {
                    if (d3Node.attr('offsetDone') === "true") {
                        d3Node.attr('transform', "translate(0,0)");
                        var offsetX = d3Node.attr('translateOffsetX');
                        var offsetY = d3Node.attr('translateOffsetY');

                        var d = DataGraphics.getData(d3Node.node());
                        var decoras = d.decoras;
                        if (decoras && offsetX && offsetY) {
                            if (TypeUtils.isNumber(offsetX) && TypeUtils.isNumber(offsetY)) {
                                decorasSetting(decoras, -Number(offsetX), -Number(offsetY), true);
                            }
                        }
                        d3Node.attr('offsetDone', false);
                    }

                }
            });
        }
    };
    return PieBehaviorHelper;
});

define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForPie',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/behavior/config/PieBehaviorHelper",
    "sap/viz/chart/components/util/ChartTypeUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/framework/interaction/InteractionUtils",
    "sap/viz/framework/common/util/SVG",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/interaction/BehaviorManager"
], function (
    Constants,
    TypeUtils,
    HighlightHelper,
    PieBehaviorHelper,
    ChartTypeUtils,
    SelectionUtil,
    InteractionUtils,
    SVG,
    DataGraphics,
    BehaviorManager) {
    var pieType = [
        "info/pie", "info/donut"
    ];
    pieType = ChartTypeUtils.addTrellisType(pieType);
    var CSS_CLASS = Constants.CSS.CLASS;

    var pie = [{
        "id": "selectDataPoint_pie",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": pieType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop = service.getProperties().get('interaction.selected');
            elements.forEach(function(e) {
                d3.select(e).selectAll("." + CSS_CLASS.PIE_HOVER_STROKE).remove();
                var extraData = DataGraphics.getData(e);
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'path', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });
            PieBehaviorHelper.selectDataPoint(elements, event.data.disableAnimation);
        }
    }, {
        "id": "deselectDataPoint_pie",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": pieType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            elements.forEach(function(e) {
                if(event.data.isAnyOtherSelected) {
                    prop = service.getProperties().get('interaction.deselected');
                }else{
                    prop = service.getProperties().get('plotArea.dataPoint');
                }
                var extraData = DataGraphics.getData(e);
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'path', prop,
                        TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });

            PieBehaviorHelper.deselectDataPoint(elements);
        }
    }, {
        "id": "hoverOnDataPoint_pie",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": pieType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            //we have to unhighlight last data point, because
            //we do not use unhover event of color legend to handle it
            var isHoveringLegend = service.getStatus("hoveringLegend");
            if (!isHoveringLegend) {
                service.fireEvent("processUnhighlight");
            }

            var elements = HighlightHelper.turnToArray(event.data.targets);
            var propMgr = service.getProperties();
            var prop = propMgr.get('interaction.hover');
            var hoverPaddingWidth = 2;
            var hoverBorderWidth = parseFloat(HighlightHelper.getWidth(prop.stroke.width, 2));
            elements.forEach(function(e) {
                HighlightHelper.drawFill(service, e, 'path', prop,
                        TypeUtils.isExist(propMgr.get('plotArea.markerRenderer')));

                if ((d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED) && !DataGraphics.getData(e).isZeroValue) ||
                    !prop.stroke.visible || hoverBorderWidth === 0) {
                    return;
                }

                var dataConfig = DataGraphics.getData(e);
                var outerRadius = dataConfig.r;
                var startAngle = dataConfig.startAngle;
                var endAngle = dataConfig.endAngle;

                var extraRadius = 1/(2 * outerRadius);
                var hoverInnerRadius = outerRadius + hoverPaddingWidth;
                var hoverOutRadius = hoverInnerRadius + hoverBorderWidth;

                var highlightProps, fillColor;
                if (event.data.byKeyboard) {
                    highlightProps = propMgr.get("interaction.keyboard");
                    highlightProps.color = service.getEffectManager().register({
                        fillColor: highlightProps.color
                    });
                } else {
                    fillColor = HighlightHelper.getColors(service, e, prop.stroke.color);
                }

                d3.select(e.parentNode).selectAll('.' + CSS_CLASS.ZEROVALUEHOVER).remove();
                if (dataConfig.isZeroValue && dataConfig.isZeroOnFirstTab) {
                    var newline = SVG.create("path");
                    if (event.data.byKeyboard) {
                        newline.setAttribute("stroke", highlightProps.color);
                    } else {
                        newline.setAttribute("stroke", fillColor.customizedColor || fillColor.defaultColor);
                    }
                    var digitalWidth = parseFloat(prop.stroke.width / 2) || 1;
                    var dasharray = digitalWidth + ', ' + digitalWidth;
                    // append to the last
                    var zeroValueHoverNode = SVG.create("g");
                    zeroValueHoverNode.setAttribute('class', CSS_CLASS.ZEROVALUEHOVER);
                    newline.setAttribute('class', CSS_CLASS.PIE_HOVER_STROKE);
                    var innerRadius = dataConfig.innerRadius;
                    var d = [{
                        x: innerRadius * Math.sin(endAngle), 
                        y: -innerRadius * Math.cos(endAngle)
                    }, {
                        x: outerRadius * Math.sin(endAngle),
                        y: -outerRadius * Math.cos(endAngle)
                    }];
                    var pathL = d3.svg.line().x(function(d) {
                        return d.x;
                    }).y(function(d) {
                        return d.y;
                    })(d);
                    newline.setAttribute("d", pathL);
                    newline.setAttribute("stroke-width", parseFloat(prop.stroke.width) / 2 + "px");
                    newline.setAttribute("stroke-dasharray", dasharray);
                    zeroValueHoverNode.appendChild(newline);
                    e.parentNode.appendChild(zeroValueHoverNode);
                } else {
                    var newPath = SVG.create("path");
                    if (event.data.byKeyboard) {
                        newPath.setAttribute("fill", highlightProps.color);
                    } else {
                        newPath.setAttribute("fill", fillColor.customizedColor || fillColor.defaultColor);
                    }
                    newPath.setAttribute("class", CSS_CLASS.PIE_HOVER_STROKE);

                    var pathD;
                    if (!propMgr.get('plotArea.dataPoint.stroke.visible')) {
                        pathD = d3.svg.arc().innerRadius(hoverInnerRadius).outerRadius(hoverOutRadius).
                            startAngle(startAngle).endAngle(endAngle)();
                    } else {
                        pathD = d3.svg.arc().innerRadius(hoverInnerRadius).outerRadius(hoverOutRadius).
                            startAngle(startAngle + extraRadius).endAngle(endAngle - extraRadius)();
                    }
                    newPath.setAttribute("d", pathD);
                    e.appendChild(newPath);
                }
            });
            if (!service.isTrellis() && !isHoveringLegend) {
                //highlight one legend item
                service.fireEvent("cleanLegendHoverEffect");

                var legendItemTarget = SelectionUtil.getCorrespondingLegendItem(event.data.targets, service);
                if (legendItemTarget) {
                    service.fireEvent("highlightLegendItem", {
                        currentTarget: legendItemTarget
                    });
                }
            }
        }
    }, {
        "id": "unhoverOnDataPoint_pie",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": pieType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var targetNode = TypeUtils.isArray(event.data.targets) ? event.data.targets[0] : event.data.targets;
            var parentNode = TypeUtils.isExist(targetNode) ? targetNode.parentNode : undefined;
            d3.select(parentNode).selectAll('.' + CSS_CLASS.ZEROVALUEHOVER).remove();
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            elements.forEach(function(e) {
                d3.select(e).selectAll("." + CSS_CLASS.PIE_HOVER_STROKE).remove();

                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    prop = service.getProperties().get('interaction.selected');
                } else {
                    var selectedDataPoints = service.getStatus("selectedDataPoints");
                    if(selectedDataPoints.length) {
                        prop = service.getProperties().get('interaction.deselected');
                    } else {
                        prop = service.getProperties().get('plotArea.dataPoint');
                    }
                }
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'path', prop,
                        TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });
        }
    }, {
        "id": "clearPlot_pie",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": pieType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if(!mainNode || !mainNode.length){
                return;
            }
            var prop;
            var gray = event.data.isGray;
            mainNode.forEach(function(e) {
                d3.select(e).selectAll("." + CSS_CLASS.PIE_HOVER_STROKE).remove();
                if(gray){
                    prop = service.getProperties().get('interaction.deselected');
                }else{
                    prop = service.getProperties().get('plotArea.dataPoint');
                }
                var extraData = DataGraphics.getData(e);
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1, undefined, extraData);
                HighlightHelper.drawFill(service, e, 'path', prop,
                        TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });
        }
    },
    InteractionUtils.getDeselectEvent("click_on_non_selection_pie", pieType,
         HighlightHelper.getDeselAllExTargets())];
    BehaviorManager.registerAll(pie);
    return pie;
});
define('sap/viz/chart/views/PieChartView',["sap/viz/framework/common/util/oo",
        "sap/viz/chart/views/ChartView",
        "sap/viz/chart/components/plots/PiePlot",
        "sap/viz/chart/components/plots/PlotHelper",
        "sap/viz/framework/common/util/PropertyZoneUtil",
        "sap/viz/framework/common/util/FeedingZoneUtil",
        "sap/viz/chart/components/util/ContextUtil",
        "sap/viz/chart/chains/PieChains",
        "sap/viz/chart/scales/FrameScaleProcessor",
        "sap/viz/chart/dynamicScales/PieDyScaleProcessor",
        "sap/viz/chart/behavior/config/DataPointBehaviorConfigForPie"
    ],
    function Setup(oo,
            ChartView,
            PiePlot,
            PlotHelper,
            PropertyZoneUtil,
            FeedingZoneUtil,
            ContextUtil) {

        var PieChartView = function(runtime, option) {
            PieChartView.superclass.constructor.apply(this, arguments);
            this._supportLazyRender = true;
        };

        oo.extend(PieChartView, ChartView);

        PieChartView.prototype._getDataItems = function() {
            return ["size", "categoryAxis", "color", "dataFrame", "series", "trellisRow", "trellisColumn"];
        };

        PieChartView.prototype._createPlotContainer = function(isTrellis) {
            var runtime = this.runtime();
            this._plotArea = PlotHelper.create(this._renderType, PiePlot, runtime, null);
            runtime.zoneManager().add(PropertyZoneUtil.plot(this._plotArea));
            runtime.zoneManager().add(FeedingZoneUtil.plot(this._plotArea));

            this.setChild("plot", this._plotArea, {
                priority: 3
            });
        };
        
        PieChartView.prototype.render = function(rootElement){
            //Update the color scale if there is contextInfos
            var contextInfos = this._properties.get('plotArea.highlight.contextInfos');
            if(contextInfos && contextInfos.length > 0) {
                for(var i = 0; i < contextInfos.length; i++) {
                    for(var j = 0; j < this._data.color.scale._domain.length; j++) {
                        if(ContextUtil.equalCtxExtend(contextInfos[i].ctx, this._data.color.scale._domain[j], 
                                this._rawData.dataModel._color.metaData)) {
                            this._data.color.scale._range[j] = contextInfos[i].paras.color;
                        }
                    }
                }
            }
            //Update the color scale if there is highlightContext
            if(this._options.chartType.indexOf('donut') >= 0) {
                var highlightContext = this._properties.get('plotArea.highlight.highlightContext');
                if(highlightContext && highlightContext.length > 0) {
                    highlightContext = highlightContext[0];
                    var color = this._properties.get('plotArea.highlight.unhighlightSliceColor');
                    for(var k = 0; k < this._data.color.scale._domain.length; k++) {
                        if(!ContextUtil.equalCtxExtend(highlightContext, this._data.color.scale._domain[k], 
                                this._rawData.dataModel._color.metaData)) {
                            this._data.color.scale._range[k] = color;
                        }
                    }
                }
            }
            PieChartView.superclass.render.apply(this, arguments);
        };

        return PieChartView;
    });

define('sap/viz/chart/metadata/bindings/PieBindings',[], function Setup() {
    var PieBindings = [{
        "id": "dataFrame",
        "name": "IDS_DATA_FRAME",
        "type": "Dimension",
        "min": 0,
        "max": 1,
        "acceptMND": false,
        "role": "frame.data"
    }, {
        "id": "size",
        "name": "IDS_SIZE",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "mark.color",
        "acceptMND": true
    }];


    return PieBindings;
});

define('sap/viz/chart/components/renderers/TreeMapDimensionLabelRenderer',["sap/viz/framework/common/util/SVG",
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/util/ColorUtil',
    "sap/viz/framework/common/util/NameColorUtils",
    'sap/viz/framework/common/util/Constants'
], function(SVG,
    DataGraphics,
    TextUtils,
    ColorUtil,
    NameColorUtils,
    Constants) {
    var textLength = function(config) {
        var data = config.data;
        var labelStyle = config.styles;
        var props = config.props;
        var textSize = TextUtils.superFastMeasure(data.label, data.fontSize ||
            labelStyle.fontSize, labelStyle.fontWeight,
            labelStyle.fontFamily);
        if (data.tempLabelsSize) {
            textSize = data.tempLabelsSize;
        }
        var textHeight = textSize.height;
        var textWidth = textSize.width;
        var textLength = 0;
        if (textHeight > data.height) {
            textLength = -1;
            //do not show text
        } else {
            if (props.labelPosition === 'topleft') {
                var minSize = TextUtils.superFastMeasure('M...', data.fontSize ||
                    labelStyle.fontSize, labelStyle.fontWeight,
                    labelStyle.fontFamily);
                textLength = data.width -
                    (2 * Constants.TREE_MAP.LEFT_PADDING + 2 *
                        (data.levelNum - data.level - 1) * config.borderWidth);
                if (textLength <= minSize.width) {
                    textLength = data.width - (Constants.TREE_MAP.LEFT_PADDING +
                        (data.levelNum - data.level - 1) * config.borderWidth);
                }
            } else {
                textLength = data.width;
            }
        }

        return textLength;
    };

    var xLocation = function(config) {
        var d = config.data;
        var padding = config.padding;
        if (config.props.labelPosition === 'topleft') {
            return (config.isLeafItem) ? (Constants.TREE_MAP.LEFT_PADDING + 2 * (d.levelNum - d.level - 1) * padding) :
                (d.left + padding + Constants.TREE_MAP.LEFT_PADDING + 2 * (d.levelNum - d.level - 1) * padding);
        } else {
            // default dataLabelPosition is center, we have to adjust location
            return (config.isLeafItem) ? (d.width / 2 - d.realLabelWidth / 2) :
                (d.left + d.width / 2 - d.realLabelWidth / 2);
        }
    };

    var yLocation = function(config) {
        var d = config.data;
        var props = config.props;
        var labelStyle = config.styles;
        var labelHeight;
        if (d.labelHeight !== undefined) {
            labelHeight = d.labelHeight;
        } else {
            labelHeight = TextUtils.fastMeasure(d.label, labelStyle.fontSize, labelStyle.fontWeight,
                labelStyle.fontFamily).height;
        }

        if (d.children.length === 0) {
            if (props.labelPosition === 'topleft') {
                var dataLabelSize = TextUtils.superFastMeasure(d.label, d.fontSize ||
                    labelStyle.fontSize, labelStyle.fontWeight, labelStyle.fontFamily);
                var minHeight = props.dataLabel.visible ?
                    dataLabelSize.height + d.labelHeight : dataLabelSize.height;
                var top = config.isLeafItem ? 0 : d.top;
                if (Constants.TREE_MAP.TOP_PADDING + minHeight > d.height) {
                    if (minHeight > d.height) {
                        /*
                         * If the data point height can not cover the min height,
                         * then show the label from the top
                         */
                        return -d.labelYPos;
                    } else {
                        /*
                         * If the data point height can not cover the min height but not the top padding,
                         * then show the label from the buttom
                         */
                        return top - d.labelYPos + d.height - minHeight;
                    }
                } else {
                    return top + Constants.TREE_MAP.TOP_PADDING - d.labelYPos;
                }

            }
            // default dataLabelPosition is center
            return (config.isLeafItem) ? (d.height / 2 - (labelHeight / 2 + d.labelYPos)) : (d.top + d.height /
                2 + labelHeight / 2 - d.labelYPos / 2);
        } else {
            return d.top + labelHeight / 2 - d.labelYPos / 2;
        }
    };

    var getText = function(config) {
        var d = config.data;
        var labelStyle = config.styles;
        var styleStr = "font-size:" + labelStyle.fontSize + ";";
        styleStr += "font-weight:" + labelStyle.fontWeight + ";";
        styleStr += "font-family:" + labelStyle.fontFamily + ";";

        var text = "";
        d.realLabelWidth = 0;
        if (d.showLabel) {
            if (!d.label) {
                d.label = "";
            }
            var textObj = TextUtils.ellipsis(d.label, SVG.create("text"), textLength(config),
                styleStr, config.ellipsisOptions);
            d.realLabelWidth = textObj.realLength;
            text = textObj.text;

            if (!config.isLeafItem && (text !== d.label)) {
                var labelAreaNode = d3.select(this.parentNode).select(".v-labelarea");
                if (labelAreaNode.select("title").empty()) {
                    labelAreaNode.append("title").text(d.label);
                }
            }
        }
        return text;
    };

    var textColor = function(config) {
        var tColor;
        var d = config.data;
        if (d.children.length === 0) {
            tColor = "white";
        } else {
            if (d.level === (d.levelNum - 1)) //leaf
            {
                tColor = "white";
            } else if ((d.levelNum - d.level) === 6) {
                tColor = "white";
            } else if ((d.levelNum - d.level) === 5) {
                tColor = "white";
            } else if ((d.levelNum - d.level) === 4) {
                tColor = "white";
            } else if ((d.levelNum - d.level) === 3) {
                tColor = "#595959";
            } else //((d.levelNum - d.level) === 2)
            {
                tColor = "#464646";
            }
        }

        return tColor;
    };

    var locateLabels = function(labels, config) {
        var x = xLocation(config);
        var y = yLocation(config);
        if (config.isLeafItem) {
            labels.setAttribute("x", x);
            labels.setAttribute("y", y);
            labels.setAttribute('class', 'v-treemapdatalabel v-dimensionlabel v-treemapdimensionlabel');
            //ie does not support this property
            //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
            labels.setAttribute("text-anchor", config.textAnchor); // text-align
        } else {
            labels.setAttribute("x", x);
            labels.setAttribute("y", y);
            //ie does not support this property
            //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
            labels.setAttribute("text-anchor", config.textAnchor); // text-align
            labels.setAttribute('class', 'v-dimensionlabel v-treemapdimensionlabel v-nonLeafDimensionLabel');
        }
    };

    var getLabelColor = function(config) {
        var color, fill;
        var d = config.data;
        var bgColor = NameColorUtils.convertColor(d.color) || '0x000000';
        var props = config.props;
        if (props.dimensionLabel.style.color) {
            color = props.dimensionLabel.style.color;
        } else {
            if (config.isLeafItem) {
                if (props.dataLabel.visible && props.dataLabel.style.color) {
                    if(props.dataLabel.style.colorRange === 'outside'){
                        color = ColorUtil.getDataLabelColor(bgColor);
                    }else{
                        color = props.dataLabel.style.color;
                    }
                } else {
                    color = ColorUtil.getDataLabelColor(bgColor);
                }
            } else {
                color = textColor(config);
            }
        }
        return color;
    };

    var treeMapDimensionLabelRenderer = function(config) {
        var label = SVG.create("text");
        var labelStyle = config.styles;
        var fill = labelStyle.color ? labelStyle.color : getLabelColor(config);
        label.setAttribute("fill", fill);
        label.setAttribute("font-size", labelStyle.fontSize);
        label.setAttribute("stroke", "none");
        label.setAttribute('font-weight', labelStyle.fontWeight);
        label.setAttribute('font-style', labelStyle.fontStyle);
        label.setAttribute("font-family", labelStyle.fontFamily);
        label.setAttribute('fill-opacity', 1);
        label.setAttribute('aria-hidden','true');
        label.value = config.data.label;
        label.textContent = getText(config);
        locateLabels(label, config);
        return label;
    };

    treeMapDimensionLabelRenderer.getPreferedSize = function(config) {
        var labelStyle = config.styles;
        var result = TextUtils.fastMeasure(config.minLabel, labelStyle.fontSize, labelStyle.fontWeight,
            labelStyle.fontFamily);
        return result;
    };

    treeMapDimensionLabelRenderer.expose = {
        renderer: treeMapDimensionLabelRenderer,
        getPreferedSize: treeMapDimensionLabelRenderer.getPreferedSize
    };

    return treeMapDimensionLabelRenderer;
});
define('sap/viz/chart/components/plots/treemap/DataHandler',[
    "sap/viz/chart/components/util/TextUtils",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/renderers/TreeMapDimensionLabelRenderer'
], function Setup(TextUtils, ObjectUtils, DataUtils, TreeMapDimensionLabelRenderer) {

    //----------------layout function: squarifiedTreeMapLayout-----------------------------------------------
    //please refer to http://www.win.tue.nl/~vanwijk/stm.pdf
    var squarifiedTreeMapLayout = function(rectObjs, size, labelStyle, padding, cusRenderer) {
        var squarifiedLayout = function(rectObjs, baseRect, isCurrentLevelShowLabel, cusRenderer) {
            //the function will set
            //item.left
            //item.top
            //item.height
            //item.width
            //item.labelHeight
            //item.labelWidth
            //item.showLabel
            //item.needMoreHeightToShowLabel
            //for all rectObjs items, and may change items order
            var allWeight = 0;
            var i;
            for (i = 0; i < rectObjs.length; i++) {
                allWeight += rectObjs[i].val;
            }

            //to make the sort stable, we must use a stable sort. But Javascript sort may not stable in
            //Chrome. So using bubble sort here (do not use rectObjs.sort)
            //sort it!
            var weightOrder = function(objA, objB) {
                var compareObjs = 0;
                if (objB.val !== objA.val) {
                    compareObjs = objA.val - objB.val;
                }
                return compareObjs;
            };
            var tmpObj;
            for (var time = 0; time < rectObjs.length - 1; time++) {
                for (i = rectObjs.length - 1; i > time; i--) {
                    if (weightOrder(rectObjs[i], rectObjs[i - 1]) > 0) {
                        tmpObj = rectObjs[i - 1];
                        rectObjs[i - 1] = rectObjs[i];
                        rectObjs[i] = tmpObj;
                    }
                }
            }

            //the current row rectangle
            var currentRowRect = {
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                weight: 0,
                items: [], //indexs of items
                worstRadio: 0
            };

            //currentRow rect + space rect
            var currentLiveRect = {
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                weight: 0,
                vertical: false
            };

            //layout this level
            for (i = 0; i < rectObjs.length; i++) {
                squarify(rectObjs, i, allWeight, currentRowRect, currentLiveRect, baseRect);
            }

            var itemIndex;
            //Now some additional work.
            for (itemIndex = 0; itemIndex < rectObjs.length; itemIndex++) {
                //make sure no "NaN"
                if (!rectObjs[itemIndex].left) {
                    rectObjs[itemIndex].left = 0;
                }

                if (!rectObjs[itemIndex].top) {
                    rectObjs[itemIndex].top = 0;
                }

                if (!rectObjs[itemIndex].width || rectObjs[itemIndex].width < 0) {
                    rectObjs[itemIndex].width = 0;
                }

                if (!rectObjs[itemIndex].height || rectObjs[itemIndex].height < 0) {
                    rectObjs[itemIndex].height = 0;
                }

                //draw label or not
                var temp, miniLabel = "",
                    strBegin;
                if (rectObjs[itemIndex].label) {
                    temp = rectObjs[itemIndex].label.toString();
                    if (temp.length > 0) {
                        strBegin = temp[0];
                        miniLabel = strBegin.concat("...");
                    }
                }

                var measureSize;
                var _isLeafItem = (rectObjs[itemIndex].children.length === 0);

                var renderer = (cusRenderer && cusRenderer.renderer) || TreeMapDimensionLabelRenderer;
                var ctx = rectObjs[itemIndex].ctx;
                ctx.level = rectObjs[itemIndex].level;
                var config = {
                    minLabel: miniLabel,
                    ctx: ctx,
                    styles: labelStyle
                };
                measureSize = renderer.getPreferedSize(config, TreeMapDimensionLabelRenderer.expose);
                if (!measureSize) {
                    measureSize = TreeMapDimensionLabelRenderer.getPreferedSize(config);
                }
                
                rectObjs[itemIndex].labelHeight = measureSize.height;
                rectObjs[itemIndex].labelWidth = measureSize.width;
                rectObjs[itemIndex].labelYPos = measureSize.y;

                rectObjs[itemIndex].needMoreHeightToShowLabel = false;

                if ((rectObjs[itemIndex].labelHeight < rectObjs[itemIndex].height) && (rectObjs[itemIndex].labelWidth <
                    rectObjs[itemIndex].width)) {
                    rectObjs[itemIndex].showLabel = true;
                } else {
                    rectObjs[itemIndex].showLabel = false;
                    if (rectObjs[itemIndex].labelHeight >= rectObjs[itemIndex].height && rectObjs[itemIndex]
                        .val > 0) {
                        rectObjs[itemIndex].needMoreHeightToShowLabel = true;
                    }
                }
            }

            var isLeafNodeNeedMoreHeight = true;
            //check each leaf
            for (itemIndex = 0; itemIndex < rectObjs.length; itemIndex++) {
                if (rectObjs[itemIndex].level === (rectObjs[itemIndex].levelNum - 1)) {
                    if (!rectObjs[itemIndex].needMoreHeightToShowLabel) {
                        isLeafNodeNeedMoreHeight = false;
                        break;
                    }
                } else {
                    isLeafNodeNeedMoreHeight = false;
                }
            }

            var hideLabelFun = function(i) {
                if (rectObjs[i].level !== (rectObjs[i].levelNum - 1)) {
                    rectObjs[i].showLabel = false;
                }

                //adjust base rect for children
                baseRectForChild.top = rectObjs[i].top + padding * 2;
                baseRectForChild.left = rectObjs[i].left + padding * 2;
                baseRectForChild.width = rectObjs[i].width - padding * 2 - padding;
                baseRectForChild.height = rectObjs[i].height - padding * 2 - padding;
            };
            if (!isLeafNodeNeedMoreHeight) {
                for (i = 0; i < rectObjs.length; i++) {
                    if (rectObjs[i].children.length > 0) {
                        var showLabelForChildren = true;
                        if (!isCurrentLevelShowLabel) {
                            showLabelForChildren = false;
                        }

                        var labelHeight = rectObjs[i].labelHeight;

                        var baseRectForChild = {};
                        baseRectForChild.top = rectObjs[i].top + padding * 2 + labelHeight;
                        baseRectForChild.left = rectObjs[i].left + padding * 2;
                        baseRectForChild.width = rectObjs[i].width - padding * 2 - padding;
                        baseRectForChild.height = rectObjs[i].height - padding * 2 - padding - labelHeight;

                        if (!showLabelForChildren) {
                            hideLabelFun(i);
                        }
                        isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild,
                            showLabelForChildren, cusRenderer);
                        if ((isLeafNodeNeedMoreHeight || !rectObjs[i].showLabel) && showLabelForChildren) //relayout
                        {
                            hideLabelFun(i);
                            isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children,
                                baseRectForChild, false, cusRenderer);
                        }
                    }
                }
            }

            return isLeafNodeNeedMoreHeight;
        };
        var rectAspectRatio = function(rect) {
            //radio >= 1
            var radio;
            if (rect.height > rect.width) {
                radio = rect.height / rect.width;
            } else {
                radio = rect.width / rect.height;
            }
            radio = Math.floor(radio * 1000);
            return radio;
        };
        var worstAspectRatio = function(rectObjs, newItemWeight, isInCurrentRow, currentRowRect,
            currentLiveRect) {
            //return the worst AspectRatio in the (changed) currentRow and the new item.
            var worstRadio = 0;

            var newItemRect = {};
            if (isInCurrentRow) {
                //if currentLiveRect is vertical,
                //it means items in currentRow is horizontal.
                if (currentLiveRect.vertical) {
                    newItemRect.width = currentLiveRect.width * (newItemWeight / (currentRowRect.weight +
                        newItemWeight));
                    newItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) /
                        currentLiveRect.weight);
                } else {
                    newItemRect.height = currentLiveRect.height * (newItemWeight / (currentRowRect.weight +
                        newItemWeight));
                    newItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) /
                        currentLiveRect.weight);
                }
                worstRadio = rectAspectRatio(newItemRect);

                //adjust items in currentRowRect, count the worstRadio
                for (var i = 0; i < currentRowRect.items.length; i++) {
                    var objIndex = currentRowRect.items[i];
                    var currentItemRect = {};
                    if (currentLiveRect.vertical) {
                        currentItemRect.width = currentRowRect.width * (rectObjs[objIndex].val / (
                            currentRowRect.weight + newItemWeight));
                        currentItemRect.height = currentLiveRect.height * ((currentRowRect.weight +
                            newItemWeight) / currentLiveRect.weight);
                    } else {
                        currentItemRect.height = currentRowRect.height * (rectObjs[objIndex].val / (
                            currentRowRect.weight + newItemWeight));
                        currentItemRect.width = currentLiveRect.width * ((currentRowRect.weight +
                            newItemWeight) / currentLiveRect.weight);
                    }

                    //current item radio
                    var currentItemRadio = rectAspectRatio(currentItemRect);

                    //update the worst
                    if (worstRadio < currentItemRadio) {
                        worstRadio = currentItemRadio;
                    }
                }
            } else {
                worstRadio = currentRowRect.worstRadio;
            }

            return worstRadio;
        };
        var getCurrentSpaceRect = function(currentRowRect, currentLiveRect) {
            var currentSpaceRect = {};
            currentSpaceRect.weight = currentLiveRect.weight - currentRowRect.weight;

            if (currentLiveRect.width === currentRowRect.width) {
                currentSpaceRect.left = currentLiveRect.left;
                currentSpaceRect.top = currentRowRect.top + currentRowRect.height;
                currentSpaceRect.width = currentLiveRect.width;
                currentSpaceRect.height = currentLiveRect.height - currentRowRect.height;
            } else {
                currentSpaceRect.left = currentRowRect.left + currentRowRect.width;
                currentSpaceRect.top = currentLiveRect.top;
                currentSpaceRect.width = currentLiveRect.width - currentRowRect.width;
                currentSpaceRect.height = currentLiveRect.height;
            }

            return currentSpaceRect;
        };
        var squarify = function(rectObjs, itemIndex, allWeight, currentRowRect, currentLiveRect, baseRect) {
            //itemIndex : const
            //allWeight : const
            //currentRowRect : be changed
            //currentLiveRect : be changed
            if (itemIndex === 0) {
                rectObjs[itemIndex].left = baseRect.left;
                rectObjs[itemIndex].top = baseRect.top;

                if (baseRect.width > baseRect.height) {
                    //layout the item
                    rectObjs[itemIndex].height = baseRect.height;
                    rectObjs[itemIndex].width = baseRect.width * (rectObjs[itemIndex].val / allWeight);
                    currentLiveRect.vertical = false;
                } else {
                    //layout the item
                    rectObjs[itemIndex].width = baseRect.width;
                    rectObjs[itemIndex].height = baseRect.height * (rectObjs[itemIndex].val / allWeight);
                    currentLiveRect.vertical = true;
                }

                //adjust currentRowRect
                currentRowRect.left = baseRect.left;
                currentRowRect.top = baseRect.top;
                currentRowRect.width = rectObjs[itemIndex].width;
                currentRowRect.height = rectObjs[itemIndex].height;
                currentRowRect.weight = rectObjs[itemIndex].val;
                currentRowRect.items.push(itemIndex);
                currentRowRect.worstRadio = rectAspectRatio(currentRowRect);

                //adjust currentLiveRect
                currentLiveRect.left = baseRect.left;
                currentLiveRect.top = baseRect.top;
                currentLiveRect.width = baseRect.width;
                currentLiveRect.height = baseRect.height;
                currentLiveRect.weight = allWeight;
            } else if (itemIndex === (rectObjs.length - 1)) {
                //just put it into the space
                var currentSpaceRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                rectObjs[itemIndex].left = currentSpaceRect.left;
                rectObjs[itemIndex].top = currentSpaceRect.top;
                rectObjs[itemIndex].width = currentSpaceRect.width;
                rectObjs[itemIndex].height = currentSpaceRect.height;
            } else {
                var inRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, true,
                    currentRowRect, currentLiveRect));
                var newRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, false,
                    currentRowRect, currentLiveRect));

                if (inRowWorstRadio < newRowWorstRadio) {
                    //update the worstRadio
                    currentRowRect.worstRadio = inRowWorstRadio;

                    //adjust currentRowRect
                    currentRowRect.items.push(itemIndex);
                    currentRowRect.weight += rectObjs[itemIndex].val;

                    if (currentLiveRect.vertical) {
                        currentRowRect.height = currentLiveRect.height * (currentRowRect.weight /
                            currentLiveRect.weight);
                    } else {
                        currentRowRect.width = currentLiveRect.width * (currentRowRect.weight /
                            currentLiveRect.weight);
                    }

                    //adjust items in currentRowRect
                    for (var i = 0; i < currentRowRect.items.length; i++) {
                        var objIndex = currentRowRect.items[i];
                        if (currentLiveRect.vertical) {
                            rectObjs[objIndex].width = currentRowRect.width * (rectObjs[objIndex].val /
                                currentRowRect.weight);
                            rectObjs[objIndex].height = currentLiveRect.height * (currentRowRect.weight /
                                currentLiveRect.weight);

                            rectObjs[objIndex].top = currentRowRect.top;

                            if (i === 0) //for the first item in the row
                            {
                                rectObjs[objIndex].left = currentRowRect.left;
                            } else {
                                rectObjs[objIndex].left = rectObjs[objIndex - 1].left + rectObjs[objIndex -
                                    1].width;
                            }
                        } else {
                            rectObjs[objIndex].height = currentRowRect.height * (rectObjs[objIndex].val /
                                currentRowRect.weight);
                            rectObjs[objIndex].width = currentLiveRect.width * (currentRowRect.weight /
                                currentLiveRect.weight);

                            rectObjs[objIndex].left = currentRowRect.left;

                            if (i === 0) //for the first item in the row
                            {
                                rectObjs[objIndex].top = currentRowRect.top;
                            } else {
                                rectObjs[objIndex].top = rectObjs[objIndex - 1].top + rectObjs[objIndex - 1]
                                    .height;
                            }
                        }
                    }

                    //do not need to adjust currentLiveRect.
                } else {
                    //make a new currentLiveRect
                    var newCurrentLiveRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);

                    currentLiveRect.left = newCurrentLiveRect.left;
                    currentLiveRect.top = newCurrentLiveRect.top;
                    currentLiveRect.width = newCurrentLiveRect.width;
                    currentLiveRect.height = newCurrentLiveRect.height;
                    currentLiveRect.weight = newCurrentLiveRect.weight;

                    if (currentLiveRect.width > currentLiveRect.height) {
                        currentLiveRect.vertical = false;
                    } else {
                        currentLiveRect.vertical = true;
                    }

                    //make a new currentRowRect
                    currentRowRect.left = currentLiveRect.left;
                    currentRowRect.top = currentLiveRect.top;
                    currentRowRect.weight = rectObjs[itemIndex].val;
                    if (currentLiveRect.vertical) {
                        currentRowRect.width = currentLiveRect.width;
                        currentRowRect.height = currentLiveRect.height;
                        if(currentLiveRect.weight >= rectObjs[itemIndex].val){
                            currentRowRect.height *= (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }
                    } else {
                        currentRowRect.height = currentLiveRect.height;
                        currentRowRect.width = currentLiveRect.width;
                        if(currentLiveRect.weight >= rectObjs[itemIndex].val){
                            currentRowRect.width *= (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }
                    }

                    currentRowRect.worstRadio = rectAspectRatio(currentRowRect);
                    currentRowRect.items = [];
                    currentRowRect.items.push(itemIndex);

                    //layout the item
                    rectObjs[itemIndex].width = currentRowRect.width;
                    rectObjs[itemIndex].height = currentRowRect.height;
                    rectObjs[itemIndex].top = currentRowRect.top;
                    rectObjs[itemIndex].left = currentRowRect.left;
                }
            }
        };
        //the entry of squarifiedTreeMapLayout
        var baseRect = {};
        baseRect.top = 0;
        baseRect.left = 0;
        baseRect.width = size.width;
        baseRect.height = size.height;

        var isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs, baseRect, true, cusRenderer);
        if (isLeafNodeNeedMoreHeight) //relayout
        {
            squarifiedLayout(rectObjs, baseRect, false, cusRenderer);
        }
    };
    //----------------end of layout function: squarifiedTreeMapLayout-----------------------------------------------

    var AXIS_COLORS = ["#f9f9f9", "#e3e3e3", "#bfbfbf", "#989898", "#717171"], maxLevel;

    function getAxisFillColor(maxTreeLevel, currentLevel) {
        // previous code caculate the axis fill color from the innerest axis, so need get color from back to forth.
        return AXIS_COLORS[maxTreeLevel - currentLevel - 1];
    }

    function buildTreeData(items, level, data, parentCtx, stroke) {
        if (!items) {
            return [];
        }
        var result = [], key, context, i=0, item;
        maxLevel = level;
        for (key in items) {
            if (items.hasOwnProperty(key)) {
                item = items[key];
                context = item.dp.context();
                result[i] = {
                    colorValue: item.color,
                    ctx: context,
                    children: buildTreeData(item.children, level + 1, data, context, stroke),
                    label: DataUtils.getLabelText(item.title),
                    val: +item.weight > 0 ? +item.weight : 0,
                    level: level,
                    rawdata: item
                };
                // get the color after the recursion 
                // because the original color assignment start from the innerest datapoint.
                result[i].color = item.children ? getAxisFillColor(maxLevel, level) : data.color.scale.scale(
                    item.color);
                result[i].levelNum = maxLevel + 1;
                if(stroke && stroke.visible === true) {
                    result[i].stroke = stroke.color;
                    result[i].strokeWidth = '1px';
                }
                i++;
            }
        }
        return result;
    }

    function adjustValues(rectObjArray) {
        var i;
        for (i = 0; i < rectObjArray.length; i++) {
            var valArray = [];
            valArray.push(rectObjArray[i].val);
            valArray.push(rectObjArray[i].colorVal);

            rectObjArray[i].val = valArray;

            if (rectObjArray[i].children.length > 0) {
                adjustValues(rectObjArray[i].children);
            }
        }
    }

    return function(data, size, labelStyle, padding, cusRenderer, stroke) {
        var treeData = buildTreeData(data.series, 0, data, {}, stroke);
        squarifiedTreeMapLayout(treeData, size, labelStyle, padding, cusRenderer);
        adjustValues(treeData);

        return treeData;
    };
});
define('sap/viz/chart/components/datalabels/TreeMapDataLabels',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/chart/components/datalabels/DataLabels',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/GeometryUtils",
    "sap/viz/framework/common/util/Constants",
    'sap/viz/framework/common/util/DataGraphics',
    "sap/viz/chart/components/util/TextUtils",
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/ObjectUtils'
], function Setup(
    oo,
    DOM,
    DataLabels,
    DataPointUtils,
    GeometryUtils,
    Constants,
    DataGraphics,
    TextUtils,
    SVG,
    ObjectUtils
    ) {

    /**
     * To initialize TreeMapDataLabels object.
     *
     * @name TreeMapDataLabels
     * @constructor
     */
    var TreeMapDataLabels = function(runtime, options) {
        TreeMapDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = options.labelPosition;
        this._borderWidth = options.borderWidth;
        this._enableTextCallback = false;
    };

    oo.extend(TreeMapDataLabels, DataLabels);

    TreeMapDataLabels.prototype._getDataLabelInfo = function(node) {
        var ctx = DataPointUtils.getContext(node);
        var key = this._data.weight.metaData[0].id;
        return {
            key: key,
            value: ctx[key]
        };
    };

    TreeMapDataLabels.prototype._computeDataLabelTranslate = function(node, ctm,
        labelPosition, labelBBox, config) {
        var hasDimensionLabel = false;
        if(node.childNodes[1] && node.childNodes[1].textContent){
            hasDimensionLabel = true;
            var bBox = GeometryUtils.getBBox(node.childNodes[1]);
            if(labelPosition === 'topleft') {
                ctm.f += bBox.y + bBox.height;
            }
            else {
                ctm.f += bBox.height/2;
            }
            
        }
        return this._computeDataLabelPosition(ctm, this._fixBBoxWhenInvisible(node), labelPosition, labelBBox,
            config, hasDimensionLabel);
    };


    TreeMapDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox, 
        config, hasDimensionLabel) {
        if(config.val <= 0){
            return null;
        }

        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;
        
        if(labelPosition === 'topleft') {
            x = nodeX + Constants.TREE_MAP.LEFT_PADDING + 
                2 * (config.ctx.levelNum - config.ctx.level - 1) * this._borderWidth;
            if(hasDimensionLabel) {
                y = nodeY - labelBBox.y;
            }
            else {
                if(Constants.TREE_MAP.TOP_PADDING + labelBBox.height > shapeBBox.height) {
                    if(labelBBox.height > shapeBBox.height) {
                        /*
                         * If the data point height can not cover the min height, 
                         * then show the label from the top
                         */
                        y = nodeY - labelBBox.y;
                    }
                    else {
                        /*
                         * If the data point height can not cover the min height but not the top padding,
                         * then show the label from the buttom
                         */
                        y = nodeY - labelBBox.y  + shapeBBox.height - labelBBox.height;
                    }
                }
                else {
                    y = nodeY + Constants.TREE_MAP.TOP_PADDING - labelBBox.y;
                }                
            }
        }
        else {
            // default labelPosition is center
            x = (nodeX + shapeBBox.width/2) - (labelBBox.x + labelBBox.width/2);
            if(hasDimensionLabel){
                y = (nodeY + shapeBBox.height/2) - labelBBox.y;
            }else{
                y = nodeY + shapeBBox.height/2 - labelBBox.y / 2;
            }
        }

        return [x, y];
    };

    TreeMapDataLabels.prototype.hideConditional = function(dataLabelInfos) {
        var i;
        for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
            var dataPointNode = dataLabelInfos[i].dataPoint;
            var dataLabelNode = dataLabelInfos[i].node;

            var dataLabelBBox = dataLabelNode.getBoundingClientRect();
            var dataPointBBox = dataPointNode.getBoundingClientRect();

            var width = this._labelPosition === 'topleft' ? dataPointBBox.width - Constants.TREE_MAP.LEFT_PADDING :
                dataPointBBox.width;
            if ((dataLabelInfos[i].textRealWidth > width) ||
                (dataLabelBBox.bottom > dataPointBBox.bottom) ||
                (dataLabelBBox.top < dataPointBBox.top) ||
                (dataLabelBBox.left < dataPointBBox.left) ||
                (dataLabelBBox.right > dataPointBBox.right) ) {
                DOM.remove(dataLabelNode);
                dataLabelInfos.splice(i, 1);
            }

        }
        return TreeMapDataLabels.superclass.hideConditional.apply(this, arguments);
    };

    TreeMapDataLabels.prototype.isTextTruncated = function() {
        return (this._enableTextCallback && 
            this._properties.get('truncationBehavior') === "truncate");
    };

    TreeMapDataLabels.prototype.isDataLabelOutOfDataPoint = function(dataLabelNode, item) {
        var outOfDataPoint = false;
        if (!this.isTextTruncated()) {
            outOfDataPoint = TreeMapDataLabels.superclass.isDataLabelOutOfDataPoint.apply(this, arguments);
        }
        return outOfDataPoint;
    };
    
    TreeMapDataLabels.prototype._buildDataLabelText = function(formatPatterns, dataLabelInfo, dataLabelCtx,
                                                        isMetaDataFormat, dp) {
        var units = this.runtime().statusManager().get("data.unit") || {};
        
        var textCallback = this._properties.get('text');
        if(textCallback){
            this._enableTextCallback = true;
            var retResult = ObjectUtils.extend(true, {}, {'units': units}, dataLabelCtx);
            delete retResult.level;
            delete retResult.levelNum;
            delete retResult.realLabelWidth;
            return this._properties.get('text').call(this, retResult);
        } else {
            return TreeMapDataLabels.superclass._buildDataLabelText.apply(this, arguments);
        }
    };
    
    TreeMapDataLabels.prototype.truncateText = function(dataLabelInfos) {
        var i;
        if (this.isTextTruncated()){
            for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
                var dataPointNode = dataLabelInfos[i].dataPoint;
                var dataLabelNode = dataLabelInfos[i].node;
                var textNode = dataLabelNode.firstChild;
                
                var dataLabelStyle = this._getStyle(dataPointNode);
                var ellipsisOptions = {};
                var envManager = this.runtime().envManager();
                ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());
                ellipsisOptions.needRealLength = true;
    
                var dataPointBBox = dataPointNode.getBoundingClientRect();
                var labelText = dataLabelNode.textContent;

                var width = this._labelPosition === 'topleft' ? dataPointBBox.width - Constants.TREE_MAP.LEFT_PADDING :
                    dataPointBBox.width;
    
                dataLabelInfos[i].textRealWidth = TextUtils.ellipsis(labelText, textNode,
                    width, dataLabelStyle.cssString, ellipsisOptions).realLength;
    
                //update dataLabelInfos location
                var labelBBox = GeometryUtils.getBBox(dataLabelNode);
                var ctm = SVG.getTransformToElement(dataPointNode, dataPointNode.parentNode);
                var config = {
                    val: dataLabelInfos[i].info.value,
                    ctx: DataPointUtils.getContext(dataPointNode)
                };
                var labelTranslate = this._computeDataLabelTranslate(dataPointNode, ctm, this._labelPosition,
                    labelBBox, config);
                dataLabelNode.setAttribute("transform", "translate(" + labelTranslate[0] + "," +
                    labelTranslate[1] + ")");
                dataLabelInfos[i].left = labelTranslate[0];
                dataLabelInfos[i].right = dataLabelInfos[i].left + dataLabelInfos[i].textRealWidth;
            }
        }
    };

    return TreeMapDataLabels;
});

define('sap/viz/chart/components/accessibility/HeatMapDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator"
], function(
    oo,
    BaseDataPointNavigator
) {

    function HeatMapDataPointNavigator() {
        HeatMapDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._datapointMap = [];
    }

    oo.extend(HeatMapDataPointNavigator, BaseDataPointNavigator);

    var prot = HeatMapDataPointNavigator.prototype;

    prot.init = function() {
        if (this._series) {
            var rows = [];
            var i = 0;
            for (i = 0; i < this._series.length; i++) {
                for (var j = 0; j < this._series[i].length; j++) {
                    if (this._series[i][j]) {
                        rows.push(this._series[i][j]);
                    }
                }
            }

            if (rows.length > 0) {
                rows.sort(function(a, b) {
                    return (a.y - b.y);
                });

                var startDp = rows[0];
                var endDp = null;
                var rowNum = 0;
                var start = 0;
                var end = 0;
                for (i = 1; i < rows.length + 1; i++) {
                    endDp = rows[i];
                    if (endDp && (Math.floor(startDp.y) === Math.floor(endDp.y))) {
                        end++;
                        continue;
                    } else {
                        end++;
                        this._datapointMap[rowNum] = rows.slice(start, end);
                        rowNum++;
                        start = end;
                        startDp = endDp;
                    }
                }

                for (i = 0; i < this._datapointMap.length; i++) {
                    this._datapointMap[i].sort(function (a, b) {
                        return (a.x - b.x);
                    });
                }
            }
        }
    };

    prot.getFirstStartPoint = function() {
        if (this._series) {
            for (var i = 0; i < this._series.length; i++) {
                for (var j = 0; j < this._series[i].length; j++) {
                    if (this._series[i][j]) {
                        return this._series[i][j].dp;
                    }
                }
            }
        }
        return null;
    };

    prot.up = function(id) {
        return this._move(id, -1);
    };

    prot.down = function(id) {
        return this._move(id, 1);
    };

    prot.left = function(id) {
        return this._move(id, -1, true);
    };

    prot.right = function(id) {
        return this._move(id, 1, true);
    };

    prot.destroy = function() {
        HeatMapDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._datapointMap = null;
    };

    // Protected --------------------------------------------------------------

    prot._move = function(id, step, isHorizontal){
        var dp = this.getDataPoint(id);
        var orignalDP = this.locate(dp.address());
        var x = -1, y = -1;
        for (var i = 0; i < this._datapointMap.length; i++) {
            x = this._datapointMap[i].indexOf(orignalDP);
            if (x > -1) {
                y = i;
                break;
            }
        }

        if (isHorizontal) {
            x += step;
        } else {
            y += step;
        }
        return (this._datapointMap[y] && this._datapointMap[y][x]) ?
            this._datapointMap[y][x].dp : null;
    };

    return HeatMapDataPointNavigator;
});

define('sap/viz/chart/components/accessibility/TreeMapDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/HeatMapDataPointNavigator"
], function(
    oo,
    HeatMapDataPointNavigator
) {
    // suppose up = 1, down = -1, right = 2, left = -2
    var UP = 1;
    var DOWN = -1;
    var RIGHT = 2;
    var LEFT = -2;
    
    var oppositeDirection = function (num) {
        return -num;
    };
    
    var toArray = function (obj, datapointMap) {
        for (var i = 0; i < obj.length; i++) {
            if (obj[i].children.length > 0) {
                toArray(obj[i].children, datapointMap);
            }
            if(obj[i].val[0] !== 0){
                datapointMap.push(obj[i]);
            }
        }
    };
    
    function TreeMapDataPointNavigator(options) {
        TreeMapDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._datapointMap = [];
        this._borderWidth = options.borderWidth;
        this.previousDpID = 0;
        this.previousOperation = 0;
        toArray(options.treeRect, this._datapointMap);
    }
    
    oo.extend(TreeMapDataPointNavigator, HeatMapDataPointNavigator);
    
    var prot = TreeMapDataPointNavigator.prototype;
    
    prot.init = function () {
        var adjustLevelBorder;
        for (var i = 0; i < this._datapointMap.length; i++) {
            if(this._datapointMap[i].children.length > 0){
                this._datapointMap[i].height = this._datapointMap[i].labelHeight;
                adjustLevelBorder = this._datapointMap[i].levelNum - this._datapointMap[i].level - 1;
                if (this._borderWidth === 1) {
                    this._datapointMap[i].left += 2 * adjustLevelBorder;
                    this._datapointMap[i].width -= 3 * adjustLevelBorder;
                }
            }
        }
    };
    
    prot.getFirstStartPoint = function() {
        for(var i = 0;i<this._datapointMap.length;i++){
            if(this._datapointMap[i].children.length === 0){
                return this._datapointMap[i].rawdata.dp;
            }
        }
    };
    
    prot.getDataPointInfo = function (id) {
        for (var i = 0; i < this._datapointMap.length; i++) {
            var dpID = this._datapointMap[i].rawdata.dp.id;
            if (dpID === parseInt(id)) {
                return this._datapointMap[i];
            }
        }
    };
    
    prot.getDataPoint = function (id) {
        return this.getDataPointInfo(id).rawdata.dp;
    };
    
    prot.getCandidate = function (currentDp, candidates1, candidates2, direction) {
        for (var i = 0; i < this._datapointMap.length; i++) {
            if (this._datapointMap[i].showLabel === true ||
                this._datapointMap[i].levelNum - this._datapointMap[i].level == 1)
            {
                // up or down situation
                if (direction === UP || direction ===DOWN){
                    if (this._datapointMap[i].left <= currentDp.left &&
                        currentDp.left < this._datapointMap[i].left + this._datapointMap[i].width) {
                        candidates1.push(this._datapointMap[i]);
                    }
                    if (this._datapointMap[i].left > currentDp.left &&
                        this._datapointMap[i].left < currentDp.left + currentDp.width) {
                        candidates2.push(this._datapointMap[i]);
                    }
                }
                else{
                    if (this._datapointMap[i].top <= currentDp.top &&
                        currentDp.top < this._datapointMap[i].top + this._datapointMap[i].height) {
                        candidates1.push(this._datapointMap[i]);
                    }
                    if (this._datapointMap[i].top > currentDp.top &&
                        this._datapointMap[i].top < currentDp.top + currentDp.height) {
                        candidates2.push(this._datapointMap[i]);
                    }
                }
            }
        }
    };
    
    // calculate distance between currentDp and candidate dp
    prot.getDistance = function(candidate, currentDp, direction){
        var distance;
        if(direction === DOWN){
            distance = candidate.top - (currentDp.top + currentDp.height);
        }
        else if(direction === UP){
            distance = currentDp.top - (candidate.top + candidate.height);
        }
        else if(direction === LEFT){
            distance = currentDp.left - (candidate.left + candidate.width);
        }
        else if(direction === RIGHT){
            distance = candidate.left - (currentDp.left + currentDp.width);
        }
        return distance;
    };
    
    prot.getMinDistanceAndDp = function (candidates, minDis, currentDp, direction) {
        var currentMinDistance = minDis;
        // var closestCandidate = null;
        var closestDp = null;
        var distance;
        for (var i = 0; i < candidates.length; i++) {
            distance = this.getDistance(candidates[i], currentDp, direction);
            if (distance >= 0 && distance < currentMinDistance) {
                currentMinDistance = distance;
                closestDp = candidates[i].rawdata.dp;
            }
        }
        return {minDistance: currentMinDistance, closestDp: closestDp};
    };
    
    prot.move = function (id, direction) {
        var targetDp;
        // if the previousOperation is down(opposite to up), return the previousDataPoint
        if(this.previousOperation === oppositeDirection(direction)){
            targetDp = this.getDataPoint(this.previousDpID);
        }
        else{
            var currentDp = this.getDataPointInfo(id);
            var candidates1 = [];
            var candidates2 = [];
            var minDis;
            if (direction === UP || direction === DOWN){
                minDis = currentDp.height + currentDp.top;
            }
            else{
                minDis = currentDp.width + currentDp.left;
            }
            this.getCandidate(currentDp, candidates1, candidates2, direction);
            var minDisAndDp1 = this.getMinDistanceAndDp(candidates1, minDis, currentDp, direction);
            var minDisAndDp2 = this.getMinDistanceAndDp(candidates2, minDis, currentDp, direction);
            if (minDisAndDp1.minDistance <= minDisAndDp2.minDistance){
                targetDp = minDisAndDp1.closestDp;
            }
            else {
                targetDp = minDisAndDp2.closestDp;
            }
            
        }
        if(targetDp){
            this.previousDpID = id;
            this.previousOperation = direction;
        }
        
        return targetDp;
    };
    
    prot.up = function(id) {
        return this.move(id, UP);
    };
    
    prot.down = function(id) {
        return this.move(id, DOWN);
    };
    
    prot.left = function(id) {
        return this.move(id, LEFT);
    };
    
    prot.right = function(id) {
        return this.move(id, RIGHT);
    };
    
    prot.destroy = function() {
        TreeMapDataPointNavigator.superclass.destroy.apply(this, arguments);
        this._datapointMap = null;
    };
    
    return TreeMapDataPointNavigator;
});

define('sap/viz/chart/components/plots/treemap/TreeMapPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/treemap/DataHandler',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/PropertyZoneUtil',
    'sap/viz/framework/common/util/FeedingZoneUtil',
    'sap/viz/chart/components/datalabels/TreeMapDataLabels',
    'sap/viz/chart/components/util/ColorUtil',
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/framework/common/util/SVG",
    'sap/viz/chart/components/renderers/TreeMapDimensionLabelRenderer',
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/TreeMapDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants"
], function Setup(oo,
    TypeUtils,
    TextUtils,
    DataPointUtils,
    BasePlot,
    DataHandler,
    ObjectUtils,
    DataGraphics,
    Constants,
    PropertyZoneUtil,
    FeedingZoneUtil,
    TreeMapDataLabels,
    ColorUtil,
    NameColorUtils,
    SVG,
    TreeMapDimensionLabelRenderer,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants) {

    var m_className = "v-treemap", 
        m_classNameItem = "v-treemapitem", 
        LABEL_STYLE = {
            fontSize : "12px",
            fontWeight : "normal",
            fontFamily : "'Open Sans', Arial, Helvetica, sans-serif"
            // color : "#ffffff"
        };

    /**
     * To initialize TreeMapPlot object.
     * 
     * @name TreeMapPlot
     * @constructor
     */
    var TreeMapPlot = function(runtime, options) {
        TreeMapPlot.superclass.constructor.apply(this, arguments);        
        this._redrawAll = true;
        this._rects = null;

        runtime.zoneManager().add(PropertyZoneUtil.plot(this));
        runtime.zoneManager().add(FeedingZoneUtil.plot(this));
        this._borderWidth = 1;
        // this._dimensionLabels = this._getDataLabels(this._name + '.dimensionLabel', runtime);
        this.runtime().statusManager().add("treeRect");
    };

    oo.extend(TreeMapPlot, BasePlot);

    TreeMapPlot.prototype.destroy = function() {
        TreeMapPlot.superclass.destroy.call(this);
        this._redrawAll = null;
        this._properties = null;
        this._borderWidth = null;
        this._rects = null;
        if (this._dimensionLabels && this._dimensionLabels.destroy) {
            this._dimensionLabels.destroy();
        }
        this._dimensionLabels = null;
    };
    
    TreeMapPlot.prototype._applyChanges = function() {
        this._redrawAll = true;
        this._borderWidth = this._properties.get("border.visible") ? 1 : 0;
        var label = this._properties.get().dimensionLabel;
        if (label && label.style) {
            LABEL_STYLE = label.style;
            this._labelVisibility = label.visible;
        } 
        if (label && label.renderer) {
            this._dimensionLabels = label;
        }
        var stroke = this._properties.get('dataPoint.stroke');
        var fontSize = LABEL_STYLE["fontSize"];
        var fontWeight = LABEL_STYLE["fontWeight"];
        var fontFamily =  LABEL_STYLE["fontFamily"];
        var fontStyle = LABEL_STYLE["fontStyle"];
        var fontColor = LABEL_STYLE["color"];
        var styles = {
            fontSize : fontSize,
            fontWeight : fontWeight,
            fontFamily : fontFamily,
            fontStyle : fontStyle,
            color: fontColor
        };
        this._rects = DataHandler(this._data, this._size, styles, this._borderWidth, label, stroke);
        var treeRect = ObjectUtils.extend(true, [], this._rects);
        this.runtime().statusManager().set("treeRect",treeRect);
    };

    TreeMapPlot.prototype._drawDatapoints = function(selection) {
        var rectObjs = this._rects;
        if (this._redrawAll) {
            selection.selectAll("*").remove();
        }

        var treeLevelRoot = selection;

        var datashapesgroup = selection.selectAll('g.' + Constants.CSS.CLASS.DATAPOINT_GROUP);
        if (!TypeUtils.isExist(datashapesgroup[0][0])) {
            datashapesgroup = selection.append('g').attr('class', Constants.CSS.CLASS.DATAPOINT_GROUP);
        }

        var props = this._properties.get();
        this._drawTreeMapItems(datashapesgroup, rectObjs, this._redrawAll, 0, this._borderWidth, 
            this._effectManager, this._randomSuffix, props);

        var m_HLElement;
        //the HLCell Rectange
        if (this._redrawAll) {
            m_HLElement = selection.append('g').attr('class', 'v-element').attr("visibility", "hidden");
            m_HLElement.append('line').attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).attr(
                "shape-rendering", "crispEdges").attr("stroke", "#6c6c6c");
            m_HLElement.append('line').attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).attr(
                "shape-rendering", "crispEdges").attr("stroke", "#6c6c6c");
            m_HLElement.append('line').attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).attr(
                "shape-rendering", "crispEdges").attr("stroke", "#6c6c6c");
            m_HLElement.append('line').attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).attr(
                "shape-rendering", "crispEdges").attr("stroke", "#6c6c6c");
        } else {
            if (m_HLElement) {
                m_HLElement.attr("visibility", "hidden");
            }
        }
        this._redrawAll = false;            

        this._clearReduntantDataFromCtx(selection);
        
        this._drawTreeMapDataLabels(selection);       
    };

    TreeMapPlot.prototype._drawTreeMapDataLabels = function(selection){
        var selectionNode = selection.node();                    
        var parent = d3.select(selectionNode);                
        var dataPointG = parent.select(".v-datapoint-group");
        if(!dataPointG.empty()){
            this._drawDataLabels(parent, dataPointG.node());                    
        }    
    };

   /**
   * To remove ctx, children and val, etc. all of these properties is useless after renndering.
   */
    TreeMapPlot.prototype._clearReduntantDataFromCtx = function(selection){
        var dataPointGroup = selection.select(".v-datapoint-group");
        if(dataPointGroup.empty()){
            return;
        }              
        var dataPoints = dataPointGroup.node().querySelectorAll("g");
        for(var i=0, len=dataPoints.length; i<len; i++){            
            var item = d3.select(dataPoints[i]).datum();            
            if(item!==undefined){
                delete item["children"];
                delete item["val"];
                delete item["ctx"];
                delete item["rawdata"];
                delete item["height"];
                delete item["width"];
                delete item["left"];
                delete item["top"];
                delete item["labelHeight"];
                delete item["labelWidth"];
                delete item["showLabel"];
                delete item["needMoreHeightToShowLabel"];
                delete item["color"];
                delete item["colorValue"];
                delete item["label"];  
                delete item["stroke"];
                delete item["strokeWidth"];
                delete item["labelYPos"];
                delete item["fontSize"];
            }
        }
    };

    function setupItems(gItems, plot, option){
        gItems.each(function(d) {
            var dpConfig = plot._buildWrapperConfig(d.rawdata, {width:d.width, height:d.height}, d.ctx, option);
            var dpData = plot._buildData(dpConfig);
            d.color = dpData.color;
            DataGraphics.setData(this, dpData);
            DataPointUtils.setDataPointId(this, d.rawdata.dp.id);
        }); 
    }
    
    TreeMapPlot.prototype._drawTreeMapItems = function(treeLevelRoot, rectObjs, redrawAll, iLevel,
        padding, effectManager, randomSuffix, props) {
        if (rectObjs.length <= 0) {
            return;
        }
        
        var textAnchor = null;
        var envManager = this.runtime().envManager();
        if (envManager) {
            textAnchor = envManager.textAnchor();
        }

        var ellipsisOptions = {};
        ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());
        ellipsisOptions.needRealLength = true;
        //rectObjs.length > 0
        var isLeafItem = (rectObjs[0].children.length === 0);

        //draw this level
        if (redrawAll) {
            treeLevelRoot = treeLevelRoot.append("g").attr("class", m_className + "level" + rectObjs[0].level);
        } else {
            treeLevelRoot = treeLevelRoot.select("." + m_className + "level" + rectObjs[0].level);
        }
        

        var rectObjArrayToDraw = [];
        for (var i = 0; i < rectObjs.length; i++) {
            if (rectObjs[i].level === iLevel) {
                var context = rectObjs[i].ctx;
                ObjectUtils.extend(true, rectObjs[i], context);
                if(isLeafItem && rectObjs[i].val[0]===0){
                    continue; //Don't draw the rectangle which weight is zero.
                }
                rectObjArrayToDraw.push(rectObjs[i]);
            }
        }

        var rootClassName = treeLevelRoot.attr("class");
        var items = treeLevelRoot.selectAll("." + rootClassName + " > ." + m_classNameItem);
        items = items.data(rectObjArrayToDraw);
        var toDrawItems = items.enter();

        var gItems;
        //items of this level

        //help functions
        var drawLabelArea = function(labelArea) {
            var rectRes = labelArea.attr("x", function(d) {
                return (d.left + padding);
            }).attr("class", "v-labelarea v-mbc-axis-item v-axis-item").attr("y", function(d) {
                return (d.top + padding);
            }).attr("width", function(d) {
                return d.width - 2 * padding > 0 ? d.width - 2 * padding : 0;
            }).attr("height", function(d) {
                return d.showLabel ? d.labelHeight : 0;
            }).attr("opacity", 0).attr("shape-rendering", "crispEdges").attr('fill-opacity', 1);

            rectRes.each(function(d) {
                this.labelContexts = d.ctx;
            });
            return rectRes;
        };
        var drawRect = function(rect) {
            var rectRes = rect.attr("x", function(d) {
                return (isLeafItem) ? (0) : (d.left + padding);
            }).attr("class", function(d) {
                return (isLeafItem) ? ("v-item") : ("v-item");
            }).attr("y", function(d) {
                return (isLeafItem) ? (0) : (d.top + padding);
            }).attr("width", function(d) {
                return d.width - 2 * padding > 0 ? d.width - 2 * padding : 0;
            }).attr("height", function(d) {
                return d.height - 2 * padding > 0 ? d.height - 2 * padding : 0;
            }).attr("fill", function(d) {
                var parameter = {
                    drawingEffect: 'normal',
                    fillColor: NameColorUtils.convertColor(d.color)
                };
                return effectManager.register(parameter);
            }).attr("shape-rendering", "crispEdges")
            .attr('stroke', function(d) {
                return isLeafItem ? d.stroke : undefined;
            })
            .attr('stroke-width', function(d) {
                return isLeafItem ? d.strokeWidth : undefined;
            });
            if (!isLeafItem) {
                rectRes.attr("fill-opacity", 1);
            }

            return rectRes;
        };
        var _self = this;
        
        var drawLabels = function(gItems, flag) {
            var dimensionLabelProp = _self._dimensionLabels;
            if (flag) {
                var dimensionLabelRenderer = (dimensionLabelProp && dimensionLabelProp.renderer) ||
                    TreeMapDimensionLabelRenderer;
                var i;
                for (i = 0; i < gItems[0].length; i++) {
                    var ctx = DataGraphics.getContext(gItems[0][i]);
                    var fontSize = LABEL_STYLE["fontSize"];
                    var fontWeight = LABEL_STYLE["fontWeight"];
                    var fontFamily =  LABEL_STYLE["fontFamily"];
                    var fontStyle = LABEL_STYLE["fontStyle"];
                    var fontColor = LABEL_STYLE["color"];
                    var styles = {
                        fontSize : fontSize,
                        fontWeight : fontWeight,
                        fontFamily : fontFamily,
                        fontStyle : fontStyle,
                        color: fontColor
                    };
                    var context = {
                        ctx: ctx.ctx,
                        data: ctx,
                        styles: styles,
                        props: props,
                        ellipsisOptions: ellipsisOptions,
                        isLeafItem: isLeafItem,
                        textAnchor: textAnchor,
                        borderWidth: _self._borderWidth,
                        padding: padding
                    };
                    var label = dimensionLabelRenderer(context, TreeMapDimensionLabelRenderer.expose);
                    if(label) {
                        DataGraphics.setContext(label, ctx.ctx);
                        gItems[0][i].appendChild(label);
                    }
                }
            }
        };
        var labelArea, labels, rects;
        var option = {
            disableSemantic : false
        };  

        // add data context
        if (redrawAll) {
            var className = m_classNameItem;
            if (isLeafItem) {
                className += ' v-datashape v-datapoint v-morphable-datapoint';
            }
            gItems = toDrawItems.append("g").attr('class', className);
            if (isLeafItem) {
                gItems.attr('transform', function(d) {
                    return 'translate(' + (d.left + padding) + ',' + (d.top + padding) + ')';
                });
                setupItems(gItems, this, option);
            }
            
            rects = gItems.append("rect");
            drawRect(rects);

            if (isLeafItem) {
                rects.attr('id', function(d, i) {
                    return ("HM" + d.index + randomSuffix);
                });
            } else {
                labelArea = gItems.append("rect");
                drawLabelArea(labelArea);
            }
            //add labels
            drawLabels(gItems, this._labelVisibility);
        }
   
        //draw children recursively
        var eachSubFun = function(thisObj, d, i) {
            var thisItem = d3.select(thisObj);            
            this._drawTreeMapItems(thisItem, thisItem.datum().children, redrawAll, iLevel + 1,
                padding, effectManager, randomSuffix, props);
        }.bind(this);

        if(!isLeafItem){
            setupItems(gItems, this, option);
        }

        gItems.each(function(d, i) {
            eachSubFun(this, d, i,  option);
        });

        return gItems;
    };
    TreeMapPlot.prototype._getDataLabels = function(name, runtime) {
        var labelPosition = this._properties.get('labelPosition');
        var borderWidth = this._properties.get("border.visible") ? 1 : 0;
        return new TreeMapDataLabels(runtime, {
            name: name,
            labelPosition: labelPosition,
            borderWidth: borderWidth
        });
    };
    TreeMapPlot.prototype.render = function(selection) {
        var width = this._size.width,
            height = this._size.height;
        this._size.width = width < 0 ? 0 : width;
        this._size.height = height < 0 ? 0 : height;
        TreeMapPlot.superclass.render.apply(this, arguments);
    };
    
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR, ChartConstants.TREEMAP, DataPointNavigator);
    return TreeMapPlot;
});

define('sap/viz/chart/components/accessibility/MBCLegendNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/accessibility/ColorLegendNavigator"
], function(oo, ColorLegendNavigator) {

    function MBCLegendNavigator(options) {
        MBCLegendNavigator.superclass.constructor.apply(this, arguments);
    }

    oo.extend(MBCLegendNavigator, ColorLegendNavigator);

    return MBCLegendNavigator;
});

define('sap/viz/chart/scales/QuantizeScaleUtil',['sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/common/util/ColorUtils'],
    function Setup(NumberUtils, NameColorUtils, TypeUtils, ArrayUtils, ColorUtils) {
        // For big number values
        function getStep(value) {
            var step = 1;
            while (value + step === value) {
                step *= 10;
            }
            return step;
        }
        var MeasureBasedColoring = {
            getColorScale: function(minVal, maxVal, hasNoValue, props, values) {
                var fontColorScale;
                var quantizeScaleConfig = {};
                var startColor = ColorUtils.fromCSSColor(
                    NameColorUtils.convertColor(props.startColor)).toString();
                var endColor = ColorUtils.fromCSSColor(
                    NameColorUtils.convertColor(props.endColor)).toString();
                var nullColor = NameColorUtils.convertColor(props.nullColor);
                var oldMinVal = minVal;
                var oldMaxVal = maxVal;
                if(!hasNoValue){
                    if (props.palette && props.palette.length) {
                        quantizeScaleConfig.range = props.palette;
                    } else if(endColor) {
                        quantizeScaleConfig.range = [endColor];
                    }
                }
                if ((minVal === undefined && maxVal === undefined) ||
                    (minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE)) {
                    if (hasNoValue) {
                        fontColorScale = d3.scale.ordinal().domain([
                            []
                        ]).range([props.nullColor]);
                        fontColorScale.domainInfo = [{}];
                        quantizeScaleConfig.nullColor = nullColor;
                    }
                } else {
                    var colorScale = null;
                    var tickNum = props.numOfSegments;
                    var range;
                    var tempDomain;
                    if (props.palette && props.palette.length >= tickNum) {
                        range = props.palette.slice(0, tickNum);
                        if (tickNum === 1) {
                            range.push(props.palette[0]);
                        }
                        colorScale = d3.scale.quantize().domain([minVal, maxVal]).range(range);
                        tempDomain = d3.scale.linear().domain([minVal, maxVal]).range(range).nice().domain();
                        colorScale.domain(tempDomain);
                    } else {
                        // bug fix for BITSDC2-5826
                        // when only one dataset and with color palette
                        if (props.palette.length > 0 && minVal === maxVal){
                            range = props.palette.slice(0, props.palette.length);
                            colorScale = d3.scale.quantize().domain([minVal, maxVal]).range(range);
                            tempDomain = d3.scale.linear().domain([minVal, maxVal]).range(range).nice().domain();
                            colorScale.domain(tempDomain);
                        } else {
                            colorScale = d3.scale.linear().domain([minVal, maxVal])
                                .range([startColor, endColor]).nice();
                        }
                    }

                    var ticks = [], i, len;
                    if (isLegendValuesValid(props.legendValues, tickNum)) {
                        ticks = props.legendValues.slice(0, tickNum + 1);
                    } else {
                        if(props.type === 'quantile') {
                            var k = 0, sorted = [];
                            for(i = 0, len = values.length; i < len; i++) {
                                if(TypeUtils.isArray(values[i])) {
                                    sorted = sorted.concat(values[i]);
                                }else {
                                    sorted.push(values[i]);
                                }
                            }
                            sorted = sorted.sort(function(a, b){return a - b;}).filter(
                                function(n){return n !== null;});
                            while (++k < tickNum) {
                                ticks[k - 1] = quantile(sorted, k / tickNum);
                            }
                            ticks = ArrayUtils.unique([Math.floor(sorted[0])].concat(ticks)).concat(
                                    [Math.ceil(sorted[sorted.length -1])]);
                        } else {
                            var colorScaleNice = colorScale.domain();
                            var t1 = getAccFormat(colorScaleNice[0]),
                                t2 = getAccFormat(colorScaleNice[1]);
                            var totalPrecision = t1 > t2 ? t1 : t2;
                            totalPrecision++;
                            var niceDomain = colorScale.domain();
                            niceDomain = formatRange(niceDomain, totalPrecision);

                            minVal = niceDomain[0];
                            maxVal = niceDomain[1];

                            if (minVal === maxVal) {
                                // only one value in range.
                                tickNum = 1;
                            }
                            var span = maxVal - minVal,
                                step, precision = 0,
                                start;
                            if (span / tickNum > 1) {
                                if (span % tickNum === 0) {
                                    // divied properly
                                    step = format(span / tickNum, totalPrecision + 1);
                                    precision = getAccFormat(step);

                                    for (i = 0; i < tickNum + 1; i++) {
                                        ticks.push(minVal + format(i * step, precision));
                                    }
                                } else {
                                    step = Math.ceil(span / tickNum);
                                    precision = getAccFormat(step);
                                    start = Math.floor(minVal / step) * step;
                                    if (start === 0 || (start + step * tickNum < maxVal)) {
                                        start = minVal;
                                    }

                                    for (i = 0; i < tickNum + 1; i++) {
                                        ticks.push(start + format(i * step, precision));
                                    }
                                }
                            } else {
                                // Can't be divided with integrate.
                                start = minVal;
                                step = format(span / tickNum, totalPrecision + 1);
                                precision = getAccFormat(step);

                                for (i = 0; i < tickNum; i++) {
                                    ticks.push(start + format(i * step, precision));
                                }
                                ticks.push(format(maxVal, precision));
                            }

                            // format all values
                            for (i = 0, len = ticks.length; i < len; i++) {
                                ticks[i] = format(ticks[i], precision);
                            }
                            step = getStep(ticks[0]);
                            while (minVal < ticks[0]) {
                                ticks[0] -= step;
                            }
                            step = getStep(ticks[ticks.length -1]);
                            while (maxVal > ticks[ticks.length - 1]) {
                                ticks[ticks.length - 1] += step;
                            }
                        }
                    }

                    // reset color scale
                    if (!(props.palette && props.palette.length)) {
                        tickNum = ticks.length - 1;
                    }
                    colorScale.domain([0, tickNum === 1 ? 1 : tickNum - 1]);


                    var domainRg = [],
                        rangeRg = [],
                        domainInfo = [];
                    for (i = 0, len = ticks.length - 1; i < len; i++) {
                        domainRg.push([ticks[i], ticks[i + 1]]);
                        rangeRg.push(colorScale(i));
                        domainInfo.push({
                            isLeftOpen: false,
                            isRightOpen: true,
                            isAscending: true
                        });
                    }
                    domainInfo[len - 1].isRightOpen = false;

                    var deleteMin = false;
                    var deleteMax = false;
                    if (props.legendValues &&
                        props.legendValues.length > 0) {
                        var last = props.legendValues.length - 1;
                        if (props.numOfSegments && props.numOfSegments < props.legendValues.length) {
                            last = props.numOfSegments - 1;
                        }
                        deleteMin = (oldMinVal < props.legendValues[0]);
                        deleteMax = (oldMaxVal > props.legendValues[last]);
                    }
                    var color, otherMinColor, otherMaxColor;
                    if (minVal < domainRg[0][0]) {
                        if (deleteMin) {
                            domainRg.splice(0, 1);
                        }
                        domainRg.unshift([-Number.MAX_VALUE, domainRg[0][0]]);
                        if (deleteMin) {
                            domainInfo.splice(0, 1);
                        }
                        domainInfo.unshift({
                            isLeftOpen: false,
                            isRightOpen: true,
                            isAscending: true
                        });
                    }
                    if (maxVal > domainRg[domainRg.length - 1][1]) {
                        if (deleteMax) {
                            domainRg.pop();
                        }
                        domainRg.push([domainRg[domainRg.length - 1][1], Number.MAX_VALUE]);
                        if (deleteMax) {
                            domainInfo.pop();
                        }
                        domainInfo.push({
                            isLeftOpen: true,
                            isRightOpen: true,
                            isAscending: true
                        });
                    }
                    quantizeScaleConfig.domain = domainRg;
                    quantizeScaleConfig.range = rangeRg;
                    quantizeScaleConfig.domainInfo = domainInfo;
                    quantizeScaleConfig.legendValues = domainRg;

                    if (hasNoValue) {
                        quantizeScaleConfig.nullColor = props.nullColor;
                    }
                }

                return quantizeScaleConfig;

            },
            getScale: function(minVal, maxVal, ticksCount, startColor, endColor) {
                return MeasureBasedColoring.getColorScale(minVal, maxVal, false, {
                    numOfSegments: ticksCount,
                    startColor: startColor,
                    endColor: endColor
                });
            }
        };


        /**
         * 20131128_JohnWen: attach contexts of datapoints to corresponding color
         * so that interaction can select these points directly instead of
         * asking plot module to get points when clicking on legend
         * @param {type} fontColorScale the scale generated by getColorScale method
         * @param {type} objArray all data objects used to draw data point
         * @param {type} getValCB a callback which can get value from item in objArray. if undefined,
           then get .val of data object
         * @param {type} getPathCB a callback which can get path from item in objArray. if undefined, 
           then get .ctx.path of data object
         * @returns
         */
        MeasureBasedColoring.fillContexts2DomainInfo4MBC = function(fontColorScale, objArray, getValCB, getPathCB) {
            if (fontColorScale) {
                var domains = fontColorScale.domain,
                    domain;
                var domainInfos = fontColorScale.domainInfo,
                    domainInfo;
                var hitted, left, leftOpen, right, rightOpen, val;
                var path;
                for (var i = -1; ++i < objArray.length;) {
                    val = getValCB ? getValCB(objArray[i]) : objArray[i].val;
                    for (var j = -1; ++j < domains.length;) {
                        //if performace is not good, optimize this loop
                        domain = domains[j];
                        domainInfo = domainInfos[j];
                        if (NumberUtils.isNoValue(val)) {
                            hitted = domain.length === 0; //if domain is an empty array, then it's for "no value" points
                        } else if (domain.length > 0) {
                            left = domain[0];
                            leftOpen = domainInfo.isLeftOpen;
                            right = domain[1];
                            rightOpen = domainInfo.isRightOpen;
                            hitted = (
                                (val < left || (!leftOpen && val === left)) && (val > right || (!rightOpen && val ===
                                    right))
                            ) || (
                                (val > left || (!leftOpen && val === left)) && (val < right || (!rightOpen && val ===
                                    right))
                            );
                        }
                        if (hitted) {
                            domainInfo.dpPaths = domainInfo.dpPaths || [];
                            path = getPathCB ? getPathCB(objArray[i]) : objArray[i].ctx.path;
                            domainInfo.dpPaths.push(path);
                            break;
                        }
                    }
                }
            }
        };

        var isLegendValuesValid = function(legendValues, numOfSegments) {
            var i;
            if (!legendValues || !numOfSegments) {
                return false;
            }
            if (legendValues.length < numOfSegments + 1) {
                return false;
            }
            for (i = 0; i < numOfSegments + 1; i++) {
                if (isNaN(legendValues[i])) {
                    return false;
                }
            }
            for (i = 0; i < numOfSegments + 1; i++) {
                if (legendValues[i] >= legendValues[i + 1]) {
                    return false;
                }
            }
            return true;
        };

        var formatRange = function(range, precision) {
            for (var i = 0, len = range.length; i < len; i++) {
                range[i] = format(range[i], precision);
            }
            return range;
        };

        var getAccFormat = function(value) {
            var t = value.toString().split(".");
            return t.length > 1 ? t[1].length : 0;
        };

        var format = function(value, precision) {
            return Math.round(Math.pow(10, precision) * value) / Math.pow(10, precision);
        };
        
        var quantile = function(values, q) {
            var I = (values.length - 1) * q + 1, i = Math.floor(I), v = +values[i - 1], e = I - i;
            return (e ? v + e * (values[i] - v) : v);
        };
        
        MeasureBasedColoring.isLegendValuesValid = isLegendValuesValid;

        return MeasureBasedColoring;
    });
define(
    'sap/viz/chart/components/legend/MBCLegend',['sap/viz/framework/common/util/oo',
     'sap/viz/chart/components/legend/BaseLegend',
     'sap/viz/chart/components/legend/ColorLegend',
     'sap/viz/chart/components/util/TextUtils',
     'sap/viz/framework/common/lang/LangManager',
     'sap/viz/framework/common/util/TypeUtils',
     'sap/viz/framework/common/format/UnitFormat',
     'sap/viz/framework/common/util/UADetector',
     'sap/viz/framework/common/util/ObjectUtils',
     "sap/viz/framework/common/util/Constants",
     'sap/viz/framework/common/util/NameColorUtils',
     "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
     "sap/viz/chart/components/accessibility/MBCLegendNavigator",
     "sap/viz/chart/components/util/ChartConstants",
     'sap/viz/chart/scales/QuantizeScaleUtil',
    ],
    function Setup(oo,
            BaseLegend,
            ColorLegend,
            TextRuler,
            langManager,
            TypeUtils,
            UnitFormat,
            UADetector,
            ObjectUtils,
            Constants,
            NameColorUtils,
            ChartNavigator,
            ItemNavigator,
            ChartConstants,
            QuantizeScaleUtil) {
        var V_MARKERSIZE = {
            width: 14,
            maxHeight: 34,
            minHeight: 12,
        };
        var H_MARKERSIZE = {
            height: 14,
            defaultWidth: 36,
            maxWidth: 36,
            minWidth: 14
        };
        var POSINFO = {
            noValuePadding: 18,
            valuePadding: 8,
            markerPaddingRight: 0.5,
            maxValueSpace: 1.6,
            minValueSpace: 0.5
        };
        // default value of ticker stroke-width is 1px
        var TICKER_WIDTH = 1,
        TICKER_LENGTH = 5;
        var MBCLegend = function (runtime, options) {
            MBCLegend.superclass.constructor.apply(this, arguments);

            var props = this._properties.get();

            this._mbcLA_width = 400;
            this._mbcLA_height = 200;
            this._mbcLA_valueLabelFont = props.label.style;
            this._mbcLA_wrap = undefined;
            this._mbcLA_chartData = undefined;
            this._mbcLA_colors = [];
            this._mbcLA_markerSize = {
                width: 12,
                height: 12
            };
            this._mbcLA_paddingBottom = 1;
            this._mbcLA_selectedItem = [];

            this._mbcLA_textInfos = null;
            this._mbcLA_perferredSize = null;
            this._mbcLA_nullLabelIndex = -1;
            this._mbcLA_textHeight = 20;
            this._mbcLA_minimized = false;

            this._mbcLA_effectManager = this.runtime().effectManager();
            this._mbcLA_styleManager = props;

            this._mbcLA_style = {};
            this._mbcLA_style.clickedshadow = props.mouseDownShadow.color;

            this._need_calTextSize = false;
            this._cells = [];
            this._type = "MBCLegend";
        };

        oo.extend(MBCLegend, ColorLegend);

        MBCLegend.prototype._addDefaultProperties = function() {

            MBCLegend.superclass._addDefaultProperties.call(this);
            this._properties.add({
                'formatString': null,
                'unitFormatType' : null,
                'drawingEffect': 'normal',
                'hovershadow': {
                    'color':'#cccccc'
                },
                'mouseDownShadow': {
                    'color':'#808080'
                },
                'onlyShowStartEndLabel': false
            });
        };
        MBCLegend.prototype.syncProperties = function () {
            // enable style (such as font color) change
            this._mbcLA_valueLabelFont = this._properties.get('label.style');
            this._mbcLA_styleManager = this._properties.get();
            this._formatString = this._mbcLA_styleManager.formatString;
            this._onlyShowStartEndLabel = this._properties.get('onlyShowStartEndLabel');
        };

        MBCLegend.prototype.setData = function (info) {
            if (!info) {
                return;
            }

            this.syncProperties();
            H_MARKERSIZE.maxWidth = H_MARKERSIZE.defaultWidth;
            // Jquery extend will ignore null/undefined
            //this._mbcLA_colors = ObjectUtils.extend(true, [], info.color.scale._range);

            if (info.color) {
                this._bindingFields = info.color.metaData;
            }

            this._mbcLA_colors = [];
            if (info.color && info.color.scale && info.color.scale._range) {
                var j;
                for (j = 0; j < info.color.scale._range.length; j++) {
                    this._mbcLA_colors.push(info.color.scale._range[j]);
                }
            }
            var _range = info.color.range,
                isAsending, i, len, _metaData = info.color.metaData,
                _legendValues = ObjectUtils.extend(true, [],info.color.scale._legendValues);
            this._mbcLA_chartData = [];
            if (!_metaData || !_metaData.length || !_range.length || !_range[0] || !_range[0].length) {
                return;
            }
            // cal label text without legendValues
            var _start = _range[0][0],
                _end = _range[0][1],
                _measureName = _metaData[0].id;
            this._measureName = _metaData[0].name;
            isAsending = _start <= _end ? true : false;
            // var _delta = Math.round((_end -
            // _start)/this._mbcLA_colors.length);
            if (_legendValues && _legendValues.length) {
                if (isAsending) {
                    _legendValues = _legendValues.reverse();
                }
                for (i = 0, len = _legendValues.length; i < len; i++) {
                    var ctx = {
                        measureName: _measureName
                    };
                    // set a half-open range for measure
                    ctx[_measureName] = {
                        min: _legendValues[i][0],
                        openmax: _legendValues[i][1]
                    };

                    if (i === 0) {
                        ctx[_measureName].max = _legendValues[i][1];
                    }

                    this._mbcLA_chartData.push({
                        ctx: ctx,
                        val: _legendValues[i][0]
                    });
                    if (i === 0) {
                        this._mbcLA_chartData[0].val1 = _legendValues[i][1];
                        // > max
                        if (Math.abs(_legendValues[i][1]) === Number.MAX_VALUE) {
                            this._mbcLA_chartData[i].val1 = undefined;
                        }
                    }
                    // < min
                    if (i === len - 1 && Math.abs(_legendValues[i][0]) === Number.MAX_VALUE) {
                        if (len > 1) {
                            this._mbcLA_chartData[i].val = undefined;
                        }
                    }
                }
            }
            // find no value
            var isNoValue = function(data){
                var i, j;
                for (i = 0; i < data.length; i++) {
                    if(TypeUtils.isArray(data[i])){
                        if(data[i].length !== data[0].length){
                            return true;
                        }
                        for(j = 0; j < data[i].length; j++){
                            if(data[i][j] === null || isNaN(data[i][j])){
                                return true;
                            }
                        }
                    }else{
                        if (data[i] === null|| isNaN(data[i])) {
                            return true;
                        }
                    }
                }
                return false;
            };

            var _values = info.color.values;
            var _isNaNFlag = isNoValue(_values);

            if (_isNaNFlag) {
                // set no value
                this._mbcLA_chartData.push({
                    ctx: {
                        measureName: _measureName,
                        'and': function(context){
                            return context[_measureName] === null || isNaN(context[_measureName]);
                        }
                    },
                    val: 'N/A'
                });
                this._mbcLA_colors.push(info.color.scale.scale(null));
            }
            this._need_calTextSize = true;
        };

        MBCLegend.prototype.isInSemanticMode = function(){
            var semanticMgr = this.runtime().semanticManager();
            return semanticMgr.hasDataPointColorStyle() &&  semanticMgr.isOverrideMode();
        };

        MBCLegend.prototype.render = function (selection, needRender) {
            if(this.isInSemanticMode()){
                selection.selectAll('g.v-mbc-content').remove();
                ColorLegend.prototype.render.apply(this, arguments);
                selection.selectAll('g.v-content').classed("v-color-content", true);
                return;
            }

            selection.selectAll('g.v-color-content').remove();
            BaseLegend.prototype.render.apply(this, arguments);

            if (!this.isVisible()) {
                selection.selectAll('g.v-content').remove();
                return this;
            }
            this._cells = [];
            var that = this;
            this.syncProperties();

            var parent = this._parent = selection;
            // append container
            var legendContent = parent.selectAll('g.v-content').data(['content']);
            legendContent.enter().append('g').classed('v-content v-mbc-content', true);
            legendContent.exit().remove();
            legendContent.attr('transform', 'translate(0, ' + this._pos.y + ')');

            // append content groups
            var groups = legendContent.selectAll('g.v-groups').data(['groups']);

            groups.enter().append('g').classed('v-groups', true).classed('v-label', true).classed(
                'viz-legend-valueLabel', true);

            // for acc doc requirements
            groups.attr('role','listbox');
            groups.exit().remove();

            this._tempGroups = groups;

            var calMarkerAndTextInfo = function (labelsData) {
                var info = {
                        marker: [],
                        label: [],
                        ticker: []
                    },
                    xPos = 0,
                    yPos = 0,
                    colors = that._mbcLA_colors.map(NameColorUtils.convertColor),
                    eachMarkerCellSize, i, len, val, tVal;
                var valuePaddingLeft = POSINFO.markerPaddingRight * that._mbcLA_textHeight;
                var textInfos = that._mbcLAfn_calTextSize();
                var valueSizes = textInfos.textSize;
                var tValueWidth = textInfos.tValueWidth;

                colors = colors.reverse();
                if (that._mbcLA_nullLabelIndex !== -1) {
                    var firstColor = colors.shift();
                    colors.push(firstColor);
                }

                len = labelsData.length;
                var hasNoValue = len > 0 && labelsData[len - 1].val === 'N/A';
                if (that._orientation === 'top' || that._orientation === 'bottom') {
                    // Horizontial layout

                    valuePaddingLeft = valuePaddingLeft + that._getValuePaddingDelta(valuePaddingLeft);
                    var onlyShowStartEndLabel = that._properties._props["legend.onlyShowStartEndLabel"];
                    if (onlyShowStartEndLabel && onlyShowStartEndLabel.value === undefined) {
                        // if user has defined legendValues correctly, all the labels should be show
                        var colorProp = that._runtime._scaleMgr.get('color');
                        if (colorProp && colorProp.legendValues) {
                            if (!QuantizeScaleUtil.isLegendValuesValid(colorProp.legendValues,
                                colorProp.numOfSegments)) {
                                that._onlyShowStartEndLabel = true;
                            }
                        }
                    }
                    if (tValueWidth && valueSizes[0].visibility_tVal !== 'hidden') {
                        xPos = tValueWidth / 2 - TICKER_WIDTH / 2;
                    }
                    eachMarkerCellSize = that._mbcLA_markerSize.width + that._mbcLA_paddingBottom;
                    var textYPos = that._mbcLA_markerSize.height + valuePaddingLeft - that._mbcLA_textY;
                    var tickerYPos = that._mbcLA_markerSize.height + (valuePaddingLeft - TICKER_LENGTH) / 2;

                    for (i = 0; i < len; i++) {
                        val = labelsData[i].val;
                        tVal = labelsData[i].val1;
                        // Marker
                        if (val === 'N/A' && len > 1) {
                            var noValuePadding = POSINFO.valuePadding;
                            if (valueSizes[i - 1].visibility !== 'hidden') {
                                noValuePadding += valueSizes[i - 1].width / 2;
                            }
                            // if the last num exist, we need to consider the ticker width
                            if (valueSizes[i - 1].width !== 0) {
                                noValuePadding -= TICKER_WIDTH / 2;
                            }
                            xPos = xPos - that._mbcLA_paddingBottom + noValuePadding;
                        }
                        info.marker.push({
                            x: xPos,
                            y: yPos,
                            color: colors[i],
                            val: labelsData[i].val,
                            ctx: labelsData[i].ctx
                        });

                        // TextL
                        if (tVal !== undefined) {
                            info.label.push({
                                val: tVal,
                                x: 0,
                                y: textYPos,
                                visibility: valueSizes[i].visibility_tVal
                            });
                            info.ticker.push({
                                val: tVal,
                                x1: xPos + TICKER_WIDTH / 2,
                                x2: xPos + TICKER_WIDTH / 2,
                                y1: tickerYPos,
                                y2: tickerYPos + TICKER_LENGTH,
                                visibility: valueSizes[i].visibility_tVal
                            });
                        }
                        if(!(that._onlyShowStartEndLabel && i < len - (hasNoValue ? 2 : 1))) {
                            if (val !== undefined) {
                                if (val === 'N/A') {
                                    info.label.push({
                                        val: langManager.get('IDS_ISNOVALUE'),
                                        x: xPos,
                                        y: textYPos,
                                        visibility: valueSizes[i].visibility
                                    });
                                } else {

                                    var tickerXPos = xPos + eachMarkerCellSize -
                                        ((i === len - (hasNoValue ? 2 : 1)) ?
                                        that._mbcLA_paddingBottom + TICKER_WIDTH / 2 : TICKER_WIDTH / 2);

                                    info.label.push({
                                        val: val,
                                        x: tickerXPos - valueSizes[i].width/2,
                                        y: textYPos,
                                        visibility: valueSizes[i].visibility
                                    });
                                    info.ticker.push({
                                        val: val,
                                        x1: tickerXPos,
                                        x2: tickerXPos,
                                        y1: tickerYPos,
                                        y2: tickerYPos + TICKER_LENGTH,
                                        visibility: valueSizes[i].visibility
                                    });
                                }
                            }
                        }

                        xPos = xPos + eachMarkerCellSize;
                    }

                    // Handler only one value label. Put it again.
                    // now we set tVal for labelData[0] in
                    // legend/common.js/_legendfn_parseMeasureBasedColoringLegend(),
                    // so do not need these codes
                    // if(len === 1 && labelsData[0].val !== 'N/A'){
                    // info.label.push({val:
                    // labelsData[0].ctx.ranges.endValue, x: xPos -
                    // eachMarkerCellSize, y: textYPos});
                    // }
                } else {
                    // Vertical layout
                    eachMarkerCellSize = that._mbcLA_markerSize.height + that._mbcLA_paddingBottom;
                    var textXPos = that._mbcLA_markerSize.width + valuePaddingLeft;
                    for (i = 0; i < len; i++) {
                        val = labelsData[i].val;
                        tVal = labelsData[i].val1;
                        // Marker
                        if (val === 'N/A' && len > 1) {
                            yPos = yPos + POSINFO.noValuePadding;
                        }
                        var yMarker = yPos;
                        if(val !== 'N/A'){
                            yMarker = yPos + that._mbcLA_textHeight / 2;
                        }
                        info.marker.push({
                            x: xPos,
                            y: yMarker,
                            color: colors[i],
                            val: val,
                            ctx: labelsData[i].ctx
                        });
                        // Text
                        if (tVal !== undefined) {
                            info.label.push({
                                val: tVal,
                                x: textXPos,
                                y: -that._mbcLA_textY,
                                visibility: valueSizes[i].visibility_tVal
                            });
                        }
                        if (val !== undefined) {
                            if(!(that._onlyShowStartEndLabel && i < len - (hasNoValue ? 2 : 1))) {
                                // For quantile MBC legend, only the start and end label will be shown
                                if (val === 'N/A') {
                                    info.label.push({
                                        val: langManager.get('IDS_ISNOVALUE'),
                                        x: textXPos,
                                        y: yPos - that._mbcLA_textY / 2 -
                                           that._mbcLA_paddingBottom + eachMarkerCellSize / 2,
                                        visibility: valueSizes[i].visibility
                                    });
                                } else {
                                    info.label.push({
                                        val: val,
                                        x: textXPos,
                                        y: yPos + eachMarkerCellSize - that._mbcLA_textY - that._mbcLA_paddingBottom,
                                        visibility: valueSizes[i].visibility
                                    });
                                }
                            }
                        }

                        yPos = yPos + eachMarkerCellSize;
                    }

                    // Handler only one value label. Put it again.
                    // now we set tVal for labelData[0] in
                    // legend/common.js/_legendfn_parseMeasureBasedColoringLegend(),
                    // so do not need these codes
                    // if(len === 1 && labelsData[0].val !== 'N/A'){
                    // info.label.push({val:
                    // labelsData[0].ctx.ranges.endValue, x: textXPos, y:
                    // yPos - eachMarkerCellSize + that._mbcLA_textHeight -
                    // that._mbcLA_paddingBottom});
                    // }
                }

                return info;
            };
            selection.each(function () {
                that._mbcLAfn_setupThemeStyleDef();

                // Calculate marker size.
                that._mbcLAfn_calMarkerSize({
                    width: that._mbcLA_width,
                    height: that._mbcLA_height - that._pos.y
                });

                var labelsData = that._mbcLA_chartData,
                    textElements, y = 0,
                    j, jlen, valuePaddingLeft = POSINFO.markerPaddingRight * that._mbcLA_textHeight;
                // var wrap = d3.select(this);
                var wrap = that._tempGroups;
                that._mbcLA_wrap = wrap;

                var indicatedRectElement = wrap.selectAll('rect.v-indicatedRect');
                if (indicatedRectElement.empty()) {
                    indicatedRectElement = wrap.append('rect').attr('class', 'v-indicatedRect v-hovershadow');
                }
                indicatedRectElement.attr('visibility', 'hidden');
                if (that._orientation === 'top' || that._orientation === 'bottom') {
                    indicatedRectElement.attr('width', that._mbcLA_markerSize.width + 2).attr('height',
                        that._mbcLA_markerSize.height + 4);
                } else {
                    indicatedRectElement.attr('width', that._mbcLA_markerSize.width + 4).attr('height',
                        that._mbcLA_markerSize.height + 2);
                }

                var infos = calMarkerAndTextInfo(labelsData);
                var makerWrapper = wrap.selectAll('rect.v-marker').data(infos.marker);
                makerWrapper.exit().remove();
                makerWrapper.enter().append('rect');
                makerWrapper.attr('class', function (d, i) {
                    return 'v-marker v-mbc-legend-item ID_' + i;
                });
                makerWrapper.attr("legendlabel-id", function (d, i) {
                    that._cells.push([{id: i}]);
                    return i;
                });

                if(that.isSelectable()){
                    // for acc doc requirements
                    makerWrapper.attr('aria-posinset', function(d, i) {
                        return i + 1;
                    }).attr('aria-setsize', infos.marker.length)
                      .attr('role', 'option');
                }

                makerWrapper.attr('width', that._mbcLA_markerSize.width).attr('height',
                    that._mbcLA_markerSize.height).attr('x', function (d) {
                    return d.x;
                }).attr('y', function (d) {
                    return d.y;
                }).attr('fill', function (d) {
                    var parameter = {
                        drawingEffect: 'normal',
                        fillColor: d.color
                    };
                    var fillID = that._mbcLA_effectManager.register(parameter);
                    return fillID;
                });

                var labelmaxLen = (that._mbcLA_nullLabelIndex === -1) ? infos.label.length : (infos.label.length -
                    1);
                var textWrapper = wrap.selectAll('text').data(infos.label);
                textWrapper.exit().remove();
                textWrapper.enter().append('text');
                textWrapper.text(function (d) {
                    return that._getLabelValue(d.val);
                });
                textWrapper.attr('x', function (d) {
                    return d.x;
                }).attr('y', function (d) {
                    return d.y;
                }).attr('visibility', function (d) {
                    return d.visibility;
                });

                var textAnchor = null;
                var envManager = that.runtime() && that.runtime().envManager();
                if (envManager) {
                    textAnchor = envManager.textAnchor();
                }
                textWrapper.attr("text-anchor", textAnchor);

                var defaultValueLabelStyle = that._mbcLA_styleManager.label.style;
                wrap.attr('font-family', defaultValueLabelStyle['fontFamily']).attr('font-size',
                    defaultValueLabelStyle['fontSize']).attr('font-weight',
                    defaultValueLabelStyle['fontWeight']).attr('fill', defaultValueLabelStyle.color).attr(
                    'font-style', defaultValueLabelStyle['fontStyle']);

                // tickers should be removed when the legend is change from horizontal to vertical
                var tickerWrapper = wrap.selectAll('line').data(infos.ticker);
                tickerWrapper.exit().remove();

                if (that._orientation === 'top' || that._orientation === 'bottom') {
                    tickerWrapper.enter().append('line');
                    tickerWrapper.attr('x1', function (d) {
                        return d.x1;
                    }).attr('x2', function (d) {
                        return d.x2;
                    }).attr('y1', function (d) {
                        return d.y1;
                    }).attr('y2', function (d) {
                        return d.y2;
                    }).attr('visibility', function (d) {
                        return d.visibility;
                    }).attr('stroke-width', TICKER_WIDTH)
                    .attr('stroke', defaultValueLabelStyle.color);
                }
            });
        };

        MBCLegend.prototype._getValuePaddingDelta = function(valuePadding) {
            var minValuePadding = 9;
            return valuePadding < minValuePadding ? minValuePadding - valuePadding : 0;
        };

        MBCLegend.prototype._updateHeight = function (svg) {
            var groups = this._tempGroups;
            var hidden = true;
            groups.selectAll('text').each(function(t) {
                hidden = hidden && t.visibility === 'hidden';
            });
            if (hidden && this._mbcLA_perferredSize.height > this._mbcLA_perferredSize.minHeight) {
                var h = svg.getAttribute("height");
                svg.setAttribute("height", h - (POSINFO.markerPaddingRight *
                    this._mbcLA_textHeight + this._mbcLA_textHeight));
            }
        };

        MBCLegend.prototype.highlight = function (target) {
            if (target.__data__) {
                var indicatedItem = this._mbcLA_wrap.selectAll('.v-indicatedRect');
                var indicatedItemPos = target.__data__;
                if (indicatedItemPos.x !== undefined && indicatedItemPos.y !== undefined) {
                    indicatedItem.attr('class', 'v-indicatedRect v-mbc-legend-item v-hovershadow').attr('visibility',
                        'visible').attr('fill', this._mbcLA_style.hovershadow.fill);
                    if (this._orientation === 'top' || this._orientation === 'bottom') {
                        indicatedItem.attr('x', indicatedItemPos.x - 1).attr('y', indicatedItemPos.y - 2);
                    } else {
                        indicatedItem.attr('x', indicatedItemPos.x - 2).attr('y', indicatedItemPos.y - 1);
                    }
                }
            }
        };

        MBCLegend.prototype._shouldInitColorShapeScale = function(){
            return !this._colorShapeScale || !this._colorScale;
        };

        MBCLegend.prototype.hasData = function () {
            if(this.isInSemanticMode()){
                this._initColorShapeScale();
                return this._colorShapeScale && this._colorShapeScale.getLength() > 0;
            }
            return !!(this._mbcLA_chartData && this._mbcLA_chartData.length);
        };

        MBCLegend.prototype.unhighlight = function (target) {
            if (this._mbcLA_wrap) {
                this._mbcLA_wrap.selectAll('.v-indicatedRect').attr('visibility', 'hidden');
            }
        };

        MBCLegend.prototype.selected = function (target) {
            if (target.__data__) {
                var indicatedItem = this._mbcLA_wrap.selectAll('.v-indicatedRect');
                var indicatedItemPos = target.__data__;
                if (indicatedItemPos.x !== undefined && indicatedItemPos.y !== undefined) {
                    indicatedItem.attr('class', 'v-indicatedRect v-mbc-legend-item v-hovershadow-mousedown').attr(
                        'visibility', 'visible').attr('fill', this._mbcLA_style.clickedshadow);
                    if (this._orientation === 'top' || this._orientation === 'bottom') {
                        indicatedItem.attr('x', indicatedItemPos.x - 1).attr('y', indicatedItemPos.y - 2);
                    } else {
                        indicatedItem.attr('x', indicatedItemPos.x - 2).attr('y', indicatedItemPos.y - 1);
                    }
                }
            }
        };

        MBCLegend.prototype.setSize = function (size) {
            MBCLegend.superclass.setSize.apply(this , arguments);
            this.width(size.width);
            this.height(size.height);
        };

        MBCLegend.prototype.width = function (width) {
            MBCLegend.superclass.width.apply(this , arguments);
            var args = [].slice.call(arguments);
            if (args.length < 1 || args[0] === undefined) {
                this._properties.set('width', this._mbcLA_width);
                return this._mbcLA_width;
            }
            this._mbcLA_width = width;
            this._properties.set('width', this._mbcLA_width);
            return this;
        };

        MBCLegend.prototype.height = function (height) {
            MBCLegend.superclass.height.apply(this , arguments);
            var args = [].slice.call(arguments);
            if (args.length < 1 || args[0] === undefined) {
                this._properties.set('height', this._mbcLA_height);
                return this._mbcLA_height;
            }
            this._mbcLA_height = height;
            this._properties.set('height', this._mbcLA_height);
            return this;
        };

        MBCLegend.prototype.setOrientation = function (orientation) {
            if (!arguments.length) {
                return this._orientation;
            }
            // TODO use extends...
            if (orientation && orientation !== this._orientation) {
                // reset default marker size
                this._mbcLA_markerSize = {
                    width: 12,
                    height: 12
                };
            }
            this._orientation = orientation;
            this._need_calTextSize = true;
            return this;
        };

        MBCLegend.prototype.getPreferredSize = function (bound, wrap) {
            this.syncProperties();
            return MBCLegend.superclass.getPreferredSize.apply(this, arguments);
        };

        MBCLegend.prototype._getBodyPreferredSize = function (bound) {
            if(this.isInSemanticMode()){
                return ColorLegend.prototype._getBodyPreferredSize.apply(this, arguments);
            }
            var maxWidth = 0,
                maxHeight = 0,
                minHeight = 0,
                minWidth = 0;
            if (this._mbcLA_chartData && this._mbcLA_chartData.length && this._need_calTextSize) {
                this._mbcLAfn_setupThemeStyleDef();
                var sampleTextSize = TextRuler.fastMeasure("M",
                    this._mbcLA_valueLabelFont.fontsize, this._mbcLA_valueLabelFont.fontweight,
                    this._mbcLA_valueLabelFont.fontfamily);
                this._mbcLA_textHeight = sampleTextSize.height;
                this._mbcLA_textY = sampleTextSize.y;
                var textInfos = this._mbcLAfn_calTextSize();
                var maxValueWidth = textInfos.maxValueWidth;
                var valueSizes = textInfos.textSize;
                var len = this._mbcLA_chartData.length;
                if (textInfos.maxNumValueWidth > H_MARKERSIZE.maxWidth) {
                    H_MARKERSIZE.maxWidth = textInfos.maxNumValueWidth + POSINFO.valuePadding;
                }


                if (this._orientation === 'top' || this._orientation === 'bottom') {
                    var temp = this._mbcLAfn_calLegendWidthFromMarkerWidth(H_MARKERSIZE.maxWidth);
                    maxHeight = temp.height;
                    maxWidth = temp.width;
                    temp = this._mbcLAfn_calLegendWidthFromMarkerWidth(H_MARKERSIZE.minWidth);
                    minHeight = temp.height;
                    minWidth = temp.width;

                } else {

                    maxWidth = this._mbcLA_markerSize.width + POSINFO.markerPaddingRight *
                        this._mbcLA_textHeight + maxValueWidth;
                    minWidth = this._mbcLA_markerSize.width + POSINFO.markerPaddingRight *
                        this._mbcLA_textHeight + (valueSizes[0].width > valueSizes[len - 1].width ?
                            valueSizes[0].width : valueSizes[len - 1].width);
                    if (this._mbcLA_nullLabelIndex !== -1) {
                        maxHeight = (V_MARKERSIZE.maxHeight + this._mbcLA_paddingBottom) * len +
                            POSINFO.noValuePadding - this._mbcLA_paddingBottom;
                        minHeight = (V_MARKERSIZE.minHeight + this._mbcLA_paddingBottom) * len +
                            POSINFO.noValuePadding - this._mbcLA_paddingBottom;
                    } else {
                        maxHeight = (V_MARKERSIZE.maxHeight + this._mbcLA_paddingBottom) * len +
                            this._mbcLA_textHeight - this._mbcLA_paddingBottom;
                        minHeight = (V_MARKERSIZE.minHeight + this._mbcLA_paddingBottom) * len +
                            this._mbcLA_textHeight - this._mbcLA_paddingBottom;
                    }
                }

                this._mbcLA_perferredSize = {
                    minHeight: minHeight,
                    minWidth: minWidth,
                    width: maxWidth,
                    height: maxHeight,
                    maxWidth: maxWidth,
                    maxHeight: maxHeight
                };
            } else {
                this._mbcLA_perferredSize = {
                    minHeight: 0,
                    minWidth: 0,
                    width: 0,
                    height: 0,
                    maxWidth: 0,
                    maxHeight: 0
                };
            }
            return this._mbcLA_perferredSize;
        };

        MBCLegend.prototype._mbcLAfn_calTextSize = function () {
            var maxValueWidth = -1,
                maxNumValueWidth = -1,
                valueSizes = [],
                tValueWidth = 0,
                data = this._mbcLA_chartData, value, tValue, i, temp;
            var len = data.length;
            var lenNoNovalue = len;

            if (this._need_calTextSize) {
                this._mbcLA_nullLabelIndex = -1;
                if (len > 0 && data[len - 1].val === 'N/A') {
                    lenNoNovalue = len - 1;
                }

                for (i = 0; i < len; i++) {
                    if (data[i].val === 'N/A') {
                        valueSizes[i] = TextRuler.fastMeasure(langManager.get('IDS_ISNOVALUE'),
                            this._mbcLA_valueLabelFont.fontsize, this._mbcLA_valueLabelFont.fontweight,
                            this._mbcLA_valueLabelFont.fontfamily);
                        this._mbcLA_nullLabelIndex = i;
                    } else {
                        value = data[i].val;
                        if (value !== undefined) {
                            value = this._getLabelValue(data[i].val);
                            valueSizes[i] = TextRuler.fastMeasure(value, this._mbcLA_valueLabelFont.fontsize,
                                this._mbcLA_valueLabelFont.fontweight, this._mbcLA_valueLabelFont.fontfamily);
                        } else {
                            valueSizes[i] = {
                                width: 0,
                                height: 0
                            };
                        }

                        tValue = data[i].val1;
                        if (tValue !== undefined) {
                            tValue = this._getLabelValue(tValue);
                            temp = TextRuler.fastMeasure(tValue, this._mbcLA_valueLabelFont.fontsize,
                                this._mbcLA_valueLabelFont.fontweight, this._mbcLA_valueLabelFont.fontfamily);
                            if (this._orientation === 'top' || this._orientation === 'bottom') {
                                tValueWidth = temp.width;
                                if (tValueWidth > maxNumValueWidth) {
                                    maxNumValueWidth = tValueWidth;
                                }
                            } else {
                                if (temp.width > valueSizes[i].width) {
                                    valueSizes[i] = temp;
                                }
                            }
                        }

                        if (valueSizes[i].width > maxNumValueWidth) {
                            maxNumValueWidth = valueSizes[i].width;
                        }
                    }
                    if (valueSizes[i].width > maxValueWidth) {
                        maxValueWidth = valueSizes[i].width;
                    }
                }

                if (this._onlyShowStartEndLabel) {
                    var lastNumWidth = valueSizes[lenNoNovalue - 1].width;
                    maxNumValueWidth = tValueWidth >  lastNumWidth ? tValueWidth :  lastNumWidth;
                }

                this._mbcLA_textInfos = {
                    maxValueWidth: maxValueWidth,
                    maxNumValueWidth: maxNumValueWidth,
                    textSize: valueSizes,
                    tValueWidth: tValueWidth
                };
                this._need_calTextSize = false;
            }
            return this._mbcLA_textInfos;
        };

        MBCLegend.prototype._mbcLAfn_calMarkerSize = function (size) {
            if (!this.hasData()) {
                return false;
            }
            var len = this._mbcLA_chartData.length,
                h = 0,
                areaSize, value, tValue, i;
            this._mbcLA_minimized = false;
            var maxValueSpace = POSINFO.maxValueSpace * this._mbcLA_textHeight;
            var minValueSpace = POSINFO.minValueSpace * this._mbcLA_textHeight;
            var valueSizes = this._mbcLAfn_calTextSize().textSize;

            if (this._orientation === 'top' || this._orientation === 'bottom') {
                areaSize = size.width;

                var r = H_MARKERSIZE.maxWidth;
                var l = H_MARKERSIZE.minWidth;
                var m = -1;
                var temp = this._mbcLAfn_calLegendWidthFromMarkerWidth(r);
                if (temp.width <= areaSize) {
                    h = r;
                } else {
                    temp = this._mbcLAfn_calLegendWidthFromMarkerWidth(l);
                    if (temp.width >= areaSize) {
                        h = l;
                    } else {
                        while (r - l > 1) {
                            m = l + (r - l) / 2;
                            temp = this._mbcLAfn_calLegendWidthFromMarkerWidth(m);
                            if (Math.abs(temp.width - areaSize) < 1) {
                                l = m;
                                break;
                            } else if (temp.width > areaSize) {
                                r = m;
                            } else {
                                l = m;
                            }
                        } // while
                        h = l;
                        temp = this._mbcLAfn_calLegendWidthFromMarkerWidth(h);
                        if (temp.isAllHidden && h > H_MARKERSIZE.defaultWidth) {
                            h = H_MARKERSIZE.defaultWidth;
                        }
                    }
                }
            } else {
                areaSize = size.height;

                var isFontOverflow = false;
                var lenNoNovalue;
                if (this._mbcLA_textHeight > V_MARKERSIZE.maxHeight) {
                    isFontOverflow = true;
                }
                // Calculate marker size
                if (this._mbcLA_nullLabelIndex !== -1) {
                    // No value
                    h = (areaSize - this._mbcLA_paddingBottom * (len - 1) - POSINFO.noValuePadding - (
                        isFontOverflow ? (this._mbcLA_textHeight - V_MARKERSIZE.maxHeight) : 0)) / (len);
                } else {
                    h = (areaSize - this._mbcLA_paddingBottom * (len - 1) - this._mbcLA_textHeight) / len;
                }
                // Check marker size
                if (h > V_MARKERSIZE.maxHeight) {
                    h = V_MARKERSIZE.maxHeight;
                }
                if (h < this._mbcLA_textHeight) {
                    isFontOverflow = true;
                }
                if (isFontOverflow) {
                    this._mbcLA_minimized = true;
                }
                for (i = 0; i < valueSizes.length; i++) {
                    if (this._mbcLA_minimized) {
                        valueSizes[i].visibility = 'hidden';
                    } else {
                        valueSizes[i].visibility = 'visible';
                    }
                }
                valueSizes[0].visibility_tVal = 'visible';
                if (this._mbcLA_nullLabelIndex !== -1) {
                    valueSizes[this._mbcLA_nullLabelIndex].visibility = 'visible';
                    lenNoNovalue = valueSizes.length - 1;
                } else {
                    lenNoNovalue = valueSizes.length;
                }
                if (lenNoNovalue > 0) {
                    if (valueSizes[lenNoNovalue - 1].height === 0) {
                        valueSizes[lenNoNovalue - 2].visibility = 'visible';
                    } else {
                        valueSizes[lenNoNovalue - 1].visibility = 'visible';
                    }
                }
            }

            if (this._orientation === 'top' || this._orientation === 'bottom') {
                this._mbcLA_markerSize.width = h;
                this._mbcLA_markerSize.height = H_MARKERSIZE.height;
            } else {
                this._mbcLA_markerSize.width = V_MARKERSIZE.width;
                this._mbcLA_markerSize.height = h;
            }
        };

        MBCLegend.prototype._mbcLAfn_setupThemeStyleDef = function () {
            var valueLabelStyle = this._mbcLA_styleManager.label.style;
            var fontChangedFlag = false;
            if (valueLabelStyle) {
                if (valueLabelStyle['fill'] && valueLabelStyle['fill'] !== this._mbcLA_valueLabelFont.color) {
                    this._mbcLA_valueLabelFont.color = valueLabelStyle['fill'];
                }
                if (valueLabelStyle['fontFamily'] && valueLabelStyle['fontFamily'] !==
                        this._mbcLA_valueLabelFont.fontfamily) {
                    this._mbcLA_valueLabelFont.fontfamily = valueLabelStyle['fontFamily'];
                    fontChangedFlag = true;
                }
                if (valueLabelStyle['fontSize'] && valueLabelStyle['fontSize'] !==
                        this._mbcLA_valueLabelFont.fontsize) {
                    this._mbcLA_valueLabelFont.fontsize = valueLabelStyle['fontSize'];
                    fontChangedFlag = true;
                }
                if (valueLabelStyle['fontWeight'] && valueLabelStyle['fontWeight'] !==
                        this._mbcLA_valueLabelFont.fontweight) {
                    this._mbcLA_valueLabelFont.fontweight = valueLabelStyle['fontWeight'];
                    fontChangedFlag = true;
                }
                if (fontChangedFlag) {
                    this._need_calTextSize = true;
                }
            }
        };

        MBCLegend.prototype.getActiveLevels = function() {
            return this._cells;
        };

        MBCLegend.prototype.destroy = function () {
            MBCLegend.superclass.destroy.apply(this, arguments);
            // remove listener
            if (this._mbcLA_wrap) {
                this._mbcLA_wrap.remove();
                this._mbcLA_wrap = null;
            }
            this._need_calTextSize = null;
            this._mbcLA_perferredSize = null;
            this._mbcLA_styleManager = null;
            this._mbcLA_effectManager = null;
            this._mbcLA_selectedItem = null;
            this._mbcLA_chartData = null;
            this._mbcLA_nullLabelIndex = null;

            this._mbcLA_width = null;
            this._mbcLA_height = null;
            this._mbcLA_valueLabelFont = null;

            this._mbcLA_colors = null;
            this._mbcLA_markerSize = null;
            this._mbcLA_paddingBottom = null;
            this._mbcLA_textInfos = null;
            this._mbcLA_textHeight = 20;
            this._mbcLA_minimized = false;
            this._mbcLA_style = null;
            this._cells = null;
        };

        MBCLegend.prototype._mbcLAfn_calLegendWidthFromMarkerWidth = function (width) {
            var noValueWidth = 0, resultHeight = 0, resultWidth = 0, MINVALUEPADDING = 2;
            var leftIndex, rightIndex, minValueSpace, tempValueSpace;
            var textInfos = this._mbcLAfn_calTextSize();
            var valueSizes = textInfos.textSize;
            var tValueWidth = textInfos.tValueWidth;
            var len = this._mbcLA_chartData.length,
                lenNoNovalue = len;
            var isAllHidden = false;
            if (this._mbcLA_nullLabelIndex !== -1) {
                noValueWidth = valueSizes[this._mbcLA_nullLabelIndex].width;
                lenNoNovalue = len - 1;
            }

            if (this._onlyShowStartEndLabel) {

                resultWidth = (width + this._mbcLA_paddingBottom) * lenNoNovalue - this._mbcLA_paddingBottom;

                if (lenNoNovalue * width - (tValueWidth + valueSizes[lenNoNovalue - 1].width) / 2 <
                MINVALUEPADDING) {
                    valueSizes[0].visibility_tVal = 'hidden';
                    valueSizes[lenNoNovalue - 1].visibility = 'hidden';
                } else {
                    resultWidth += tValueWidth / 2 + valueSizes[lenNoNovalue - 1].width / 2;
                }
            } else {
                for (var i = 0; i !== lenNoNovalue; i++) {
                    if (i === 0) {
                        minValueSpace = width - (tValueWidth + valueSizes[i].width) / 2;
                    } else {
                        tempValueSpace = width - (valueSizes[i].width + valueSizes[i - 1].width) / 2;
                        if (minValueSpace > tempValueSpace) {
                            minValueSpace = tempValueSpace;
                        }
                    }
                }

                for (i = 0; i !== lenNoNovalue; i++) {
                    if (minValueSpace < MINVALUEPADDING) {
                        valueSizes[i].visibility = 'hidden';
                    } else {
                        valueSizes[i].visibility = 'visible';
                    }
                }

                if (this._mbcLA_nullLabelIndex !== -1) {
                    valueSizes[this._mbcLA_nullLabelIndex].visibility = 'visible';
                }

                if (lenNoNovalue > 0) {
                    resultWidth = (width + this._mbcLA_paddingBottom) * lenNoNovalue - this._mbcLA_paddingBottom;

                    if (tValueWidth !== 0) {
                        resultWidth -= TICKER_WIDTH / 2;
                        valueSizes[0].visibility_tVal = 'visible';
                        leftIndex = -1;
                    } else {
                        valueSizes[0].visibility = 'visible';
                        leftIndex = 0;
                    }

                    if (valueSizes[lenNoNovalue - 1].width !== 0) {
                        resultWidth -= TICKER_WIDTH / 2;
                        rightIndex = lenNoNovalue - 1;
                    } else {
                        rightIndex = lenNoNovalue - 2;
                    }
                    valueSizes[rightIndex].visibility = 'visible';

                    var dis = width * (rightIndex - leftIndex);
                    var leftValueWidth = tValueWidth !== 0 ? tValueWidth : valueSizes[0].width;
                    var rightValueWidth = valueSizes[rightIndex].width;
                    if (leftIndex === rightIndex) {
                        // when there is only one value displayed in the middle
                        if (valueSizes[leftIndex].width + 2 * MINVALUEPADDING > lenNoNovalue * width) {
                            valueSizes[leftIndex].visibility = 'hidden';
                        }
                    }
                    else if (dis - (leftValueWidth + rightValueWidth) / 2 < MINVALUEPADDING) {
                        valueSizes[rightIndex].visibility = 'hidden';
                        isAllHidden = true;
                        if (tValueWidth !== 0) {
                            valueSizes[0].visibility_tVal = 'hidden';
                        } else {
                            valueSizes[0].visibility = 'hidden';
                        }
                    } else {
                        resultWidth += tValueWidth / 2 + valueSizes[lenNoNovalue - 1].width / 2;
                    }
                }
            }

            if (this._mbcLA_nullLabelIndex !== -1) {
                resultWidth += POSINFO.valuePadding + ((noValueWidth > width) ? noValueWidth : width);
            }

            var valuePadding = POSINFO.markerPaddingRight * this._mbcLA_textHeight;
            resultHeight = H_MARKERSIZE.height + valuePadding + this._mbcLA_textHeight;
            resultHeight = resultHeight + this._getValuePaddingDelta(valuePadding);

            return {
                width: resultWidth,
                height: resultHeight,
                isAllHidden: isAllHidden
            };
        };
        // Utility method.
        MBCLegend.prototype._getLabelValue = function (value) {
            value = (value === null) ? langManager.get('IDS_ISNOVALUE') : value;
            var props = this._properties.get();
            var metaDataFormatString = null;
            if (this._bindingFields && this._bindingFields.length) {
                metaDataFormatString = this._bindingFields[0].formatString;
                if (TypeUtils.isArray(metaDataFormatString)) {
                    metaDataFormatString = metaDataFormatString[0];
                }
            }

            var unitFormatType = props.unitFormatType;
            var options = {
                decimalFormatString:
                UnitFormat.getDecimalFormatString(UnitFormat.SUPPORT_CUSTOM_COMPONENTS.MBCLegend)
            };
            value = UnitFormat.format(value, this._formatString || metaDataFormatString, unitFormatType, options);
            return value;
        };

        MBCLegend.prototype._getTitleText = function() {
            var text = "";
            var userInputTitle = this._properties.get("title.text");

            if (TypeUtils.isString(userInputTitle)) {
                text = userInputTitle;
            } else {
                text = this._measureName;
            }
            return text;
        };
        ChartNavigator.register(ChartConstants.MBCLEGEND_NAVIGATOR, null, ItemNavigator);
        return MBCLegend;
    });

define('sap/viz/chart/scales/QuantizeScale',['sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/BaseScale',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/Constants'
], function (oo, 
    BaseScale,
    NumberUtils,
    Constants) {

    /*
     * Used for quantize scale
     */
    var QuantizeScale = function (config) {
        this.__className = "sap.viz.scale.QuantizeScale";
        this._name = null;
        this._type = "quantize";
        this._domain = config.domain;
        this._range = config.range;
        this._nullColor = config.nullColor;
        this._legendValues = config.legendValues;
        this._domainInfo = config.domainInfo;
        this._defaultColors = Constants.COLOR.SAPColorSingleAxis;
        this._initScale();
    };

    oo.extend(QuantizeScale, BaseScale);



    QuantizeScale.prototype._initScale = function () {
        if (this._scale === undefined) {
            this._scale = d3.scale.ordinal();
            if (this._domain) {
                this._scale.domain(this._domain);
            }
            if (this._range) {
                this._scale.range(this._range);
            } else {
                this._scale.range(this._defaultColors);
            }
        }
    };

    QuantizeScale.prototype.scale = function (value) {
        if (NumberUtils.isNoValue(value)) {
            if (this._nullColor) {
                return this._nullColor;
            }
        }
        var domainValue, j, tdv, info, flag;
        if (this._domain) {
            for (j = 0; j < this._domain.length; j++) {
                tdv = this._domain[j];
                info = this._domainInfo[j];
                flag = false;
                if ((j === this._domain.length - 1) || (this._domain[j + 1].length === 0)) {
                    domainValue = tdv;
                    break;
                }
                if ((value > tdv[0]) && (value < tdv[1])) {
                    flag = true;
                } else if (!info.isLeftOpen && (value === tdv[0])) {
                    flag = true;
                } else if (!info.isRightOpen && (value === tdv[1])) {
                    flag = true;
                }
                if (flag) {
                    domainValue = tdv;
                    break;
                }
                if ((value >= tdv[0]) && (value < tdv[1])) {
                    domainValue = tdv;
                    break;
                }
            }
            return this._scale(domainValue);
        } else {
            return this._scale.range()[0];
        }       
    };
    
    QuantizeScale.prototype.getLegendValues = function(){
        return this._legendValues;
    };

    QuantizeScale.prototype.destroy = function() {
        // release all properties which hold dom instances
        QuantizeScale.superclass.destroy.call(this);
        
        this._nullColor = null;
        this._legendValues = null;
        this._domainInfo = null;
        this._defaultColors = null;
    }; 
    return QuantizeScale;
});
define('sap/viz/chart/scales/QuantizeScaleProcessor',[
    'sap/viz/framework/scale/ScaleRepository',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/scales/QuantizeScaleUtil',
    'sap/viz/chart/scales/QuantizeScale',
    'sap/viz/framework/common/util/ObjectUtils'
],function(
ScaleRepository,
ArrayUtils,
TypeUtils,
Constants,
QuantizeScaleUtil,
QuantizeScale,
ObjectUtils)
{  
    ScaleRepository.quantizeScale = function(data, name, scaleMgr, propMgr, option) {
        option = option || {};
        var seriesType = option.seriesType, role = option.role;
        var _valArr = ObjectUtils.clone(data.values || [], true),
            _realArr = [],
            isNoValue = false;

        var _checkNoValue = function(valArr) {
            for (var i = 0; i < valArr.length; i++) {
                if (TypeUtils.isArray(valArr[i])) {
                    if(valArr[i].length !== valArr[0].length)
                    {
                        isNoValue = true;
                    }
                    _checkNoValue(valArr[i]);
                } else {
                    if (valArr[i] === null || isNaN(valArr[i])) {
                        isNoValue = true;
                    } else if (_realArr.indexOf(+valArr[i]) < 0) {
                        _realArr.push(+valArr[i]);
                    }
                }
            }
        }; 
        
        _checkNoValue(_valArr);
        
        var min, max;
        if (_realArr.length === 1) {
            min = _realArr[0];
            max = _realArr[0];
        } else if (_realArr.length === 0) {
            min = undefined;
            max = undefined;
        } else {
            min = ArrayUtils.min(_realArr);
            max = ArrayUtils.max(_realArr);
        }

        var props = scaleMgr.get(name);
        var colorPalette = (props && props.palette) ? props.palette : Constants.TREE_MAP.PALETTE;
        var startColor = (props && props.startColor) ? props.startColor : Constants.TREE_MAP.START_COLOR;
        var endColor = (props && props.endColor) ? props.endColor : Constants.TREE_MAP.END_COLOR;
        var legendValues = (props && props.legendValues) ? props.legendValues : Constants.TREE_MAP.LEGEND_VALUES;
        var maxNumOfSegments = (props && props.maxNumOfSegments) || 9;

        var defaultScale = scaleMgr.getDefault(name);
        var defaultValue = {
            "feed": name,
            "type": "quantize",
            "palette": Constants.TREE_MAP.PALETTE,
            "startColor": Constants.TREE_MAP.START_COLOR,
            "endColor": Constants.TREE_MAP.END_COLOR,
            "nullColor": Constants.TREE_MAP.NULL_COLOR,
            "numOfSegments": Constants.TREE_MAP.DEFAULT_TICKS,
            "legendValues": Constants.TREE_MAP.LEGEND_VALUES
        };

        if (!TypeUtils.isExist(defaultScale)) {
            scaleMgr.add(name, {
                serializable: true,
                defaultValue: defaultValue
            });
        }
        else {
            //There will be color palette in tempate, then we need to merge the template value with defaul value;
            scaleMgr.set(name, ObjectUtils.extend({}, defaultValue, defaultScale), 1, 'templateValue');
        }

        propMgr.origin.add('plotArea.colorPalette', {
            defaultValue: Constants.TREE_MAP.PALETTE,
            serializable: false,
            get: function() {
                return colorPalette;
            }
        });
        propMgr.origin.add('plotArea.startColor', {
            defaultValue: Constants.TREE_MAP.START_COLOR,
            serializable: false,
            get: function() {
                return startColor;
            }
        });
        propMgr.origin.add('plotArea.endColor', {
            defaultValue: Constants.TREE_MAP.END_COLOR,
            serializable: false,
            get: function() {
                return endColor;
            }
        });
        propMgr.origin.add('plotArea.legendValues', {
            defaultValue: Constants.TREE_MAP.LEGEND_VALUES,
            serializable: false,
            get: function() {
                return legendValues;
            }
        });

        var scaleOption = ObjectUtils.extend({}, scaleMgr.get(name));
        var scaleDefaultOption = scaleMgr.getDefault(name);
        // assign default value for config
        if (!scaleOption) {
            scaleOption = scaleDefaultOption;
        } else {
            scaleOption.numOfSegments = scaleOption.numOfSegments;
            scaleOption.legendValues = scaleOption.legendValues || scaleDefaultOption.legendValues;
            scaleOption.nullColor = scaleOption.nullColor || scaleDefaultOption.nullColor;
            scaleOption.startColor = scaleOption.startColor || scaleDefaultOption.startColor;
            scaleOption.endColor = scaleOption.endColor || scaleDefaultOption.endColor;
            scaleOption.palette = scaleOption.palette || scaleDefaultOption.palette;
            // add limit of 1 to 9 as required in BITSDC2-2290
            if (!TypeUtils.isNumber(scaleOption.numOfSegments)) {
                scaleOption.numOfSegments = scaleDefaultOption.numOfSegments;
            } else if (scaleOption.numOfSegments > maxNumOfSegments) {
                scaleOption.numOfSegments = maxNumOfSegments;
            } else if (scaleOption.numOfSegments < 2) {
                scaleOption.numOfSegments = 2;
            }
        }

        var quantizeScaleConfig = QuantizeScaleUtil.getColorScale(min, max, isNoValue, scaleOption, data.values);

        //Save current legend values to properties
        var configValues = quantizeScaleConfig.legendValues;
        if (configValues && configValues.length > 0) {
            var values = [];
            for(var i = 0; i < configValues.length; i++){
                values.push(configValues[i][0]);
                if (i === configValues.length - 1){
                    values.push(configValues[i][1]);
                }
            }
            propMgr.setDefault('plotArea.autoLegendValues', values);
        }

        if (quantizeScaleConfig.domain !== null) {
            return new QuantizeScale(quantizeScaleConfig);
        }
    };
});
define('sap/viz/chart/chains/TreeChains',[
    'sap/viz/framework/common/util/TypeUtils', 
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/binding/BindingManager'
], function Setup(
    TypeUtils, 
    BaseChains, 
    DataUtils,
    BindingManager
) {
    var treeChains = {};
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetMeasuresFromFlattable',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];
    treeChains = BaseChains.extend('treemap', defaultChains);

    var buildTree = function (bindingResults) {
        var titles = bindingResults.title.rowArray;
        var length = titles.length;
        var trees = {};
        var weight = bindingResults.weight? bindingResults.weight.values : [];
        var color = bindingResults.color ? bindingResults.color.values : [];
        var context = bindingResults.context ? bindingResults.context.values : [];
        for (var i = 0; i < length; i++) {
            var tmpTree, hierarchyLength = titles[i].length,
                item = titles[i], title;
            
            hierarchyLength = item.length;
            tmpTree = trees;

            for (var j = 0; j < hierarchyLength; j++) {
                title = DataUtils.getDimensionValue(item[j]);
                if (!tmpTree[title]) {
                    tmpTree[title] = {title:item[j]};
                }
                tmpTree = tmpTree[title];

                if (j !== hierarchyLength - 1) {
                    tmpTree.weight = tmpTree.weight || 0;
                    tmpTree.weight += +weight[i] > 0 ? +weight[i] : 0;
                    if (!tmpTree.children) {
                        tmpTree.children = {};    
                    }
                    tmpTree = tmpTree.children;
                } 
                else {
                    tmpTree.weight = weight[i];
                    tmpTree.color = color[i];
                    tmpTree.context = [];
                    if(TypeUtils.isArray(tmpTree.weight)){
                        tmpTree.weight = tmpTree.weight[0];
                    }
                    if(TypeUtils.isArray(tmpTree.color)){
                        tmpTree.color = tmpTree.color[0];
                    }
                    for(var t = 0; t < context.length; ++t){
                        tmpTree.context.push(context[t][i]);
                    }
                }
            }
        }
        return trees;
    };

    var buildTreeMetadata = function(bindingResults) {
        var metaData = {};
        metaData.hierarchy = bindingResults.title ? bindingResults.title.metaData : [];
        metaData.color = bindingResults.color ? bindingResults.color.metaData : [];
        metaData.weight = bindingResults.weight ? bindingResults.weight.metaData : [];
        return metaData;
    };

    treeChains.treemapGetBindingSeries = function (rawData, dimensions, measures, bindingResults, 
            bindings, bindingDefinition) {
        var data = buildTree(bindingResults);
        bindingResults.series = data;
        var metaData = buildTreeMetadata(bindingResults);
        return {
            data: data,
            metaData: metaData
        };
    };
    Object.keys(treeChains).forEach(function(key) {
        BindingManager.registerChain(key, treeChains[key]);
    });
    return treeChains;
});

define('sap/viz/chart/behavior/config/AxisBehaviorConfigForTreeMap',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/interaction/Constants',
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/framework/interaction/BehaviorManager"
], function (Constants,
        SDKConstants,
        UADetector,
        ObjectUtils,
        DataPointUtils,
        SelectionUtil,
        BehaviorManager) {
    var BehaviorConstants = SDKConstants.BEHAVIOR,
        axisItemPattern = "v-axis-item",
        nonLeafDimensionLabel = "v-nonLeafDimensionLabel",
        CSS_CLASS = Constants.CSS.CLASS,
        treeType = "info/treemap",

        HOVER_SHADOW_COLOR = "#cccccc",
        HOVER_SHADOW_MOUSE_DOWN_COLOR = "#808080";

    function isTriggerable(service) {
        var selectability = service.getProperties().get("interaction.selectability");
        if (!selectability) {
            return false;
        }
        var selectionMode = selectability.mode.toUpperCase();
        var axisNode = service.getNodes(service.NodeType.TREE_MAP_ITEM);
        if (!selectability.axisLabelSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE ||
            selectionMode === SDKConstants.SELECTION_MODE.SINGLE || !axisNode.node()) {
            return false;
        } else {
            return true;
        }
    }

    var getTargets = function (event, service) {
        var ctx1 = DataPointUtils.getContext(event.data.currentTarget);
        // level is required for design-time behavior, however it will block selection
        ctx1 = ObjectUtils.extend({}, ctx1);
        delete ctx1.level;
        delete ctx1.levelNum;
        delete ctx1.realLabelWidth;

        return SelectionUtil.getDataPointIds(ctx1, service);
    };

    var treeAxis = [{
        "id": "hover_on_axis_label_treemap",
        "triggerEvent": {
            "name": "hover",
            "targets": axisItemPattern,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            service.fireEvent("processUnhighlight");
            d3.select(event.data.currentTarget).attr("fill", HOVER_SHADOW_COLOR)
                .attr("opacity", event.data.byKeyboard ? 0 :1)
                .classed(CSS_CLASS.HOVER_SHADOW, true);
            //get targets
            var highlighted = getTargets(event, service);
            service.fireEvent("processHighlight", {
                targets: highlighted
            });
        }
    }, {
        "id": "hover_on_non_axis_label_treemap",
        "triggerEvent": {
            "name": "hover",
            //legend items should be excluded.
            "excludeTargets": [axisItemPattern, Constants.CSS.CLASS.MBCLEGENDITEM,
                               Constants.CSS.CLASS.LEGENDITEM],
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            service.fireEvent("processUnhighlight");
        }
    }, {
        "id": "hover_on_non_leaf_dimension_label_treemap",
        "triggerEvent": {
            "name": "hover",
            "targets": nonLeafDimensionLabel,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            service.fireEvent("processUnhighlight");
            d3.select(event.data.currentTarget.previousElementSibling)
                .attr("fill", HOVER_SHADOW_COLOR).attr("opacity", 1)
                .classed(CSS_CLASS.HOVER_SHADOW, true);

            //get targets
            var highlighted = getTargets(event, service);
            service.fireEvent("processHighlight", {
                targets: highlighted,
            });
        }
    },{
        "id": "click_on_non_leaf_dimension_label_treemap",
        "triggerEvent": {
            "name": "click",
            "targets": nonLeafDimensionLabel,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            var ctx1 = DataPointUtils.getContext(event.data.currentTarget.previousElementSibling);
            // level is required for design-time behavior, however it will block selection
            ctx1 = ObjectUtils.extend({}, ctx1);
            delete ctx1.level;
            delete ctx1.levelNum;
            delete ctx1.realLabelWidth;

            var targets = SelectionUtil.getDataPointIds(ctx1, service);
            service.fireEvent("processSelection", {
                targets: targets,
                deselectable: true,
                ctrlKeyPressed: event.data.ctrlKey
            });
            service.fireEvent("processMultipleSelectionTooltip", {
                targets: targets,
                point: event.data.point
            });
        }
    },{
        "id": "cleanAxisHoverEffect_treemap",
        "triggerEvent": {
            "name": "cleanAxisHoverEffect",
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            service.getNodes(service.NodeType.AXIS_ITEM)
                .attr("opacity", "0")
                .classed(CSS_CLASS.HOVER_SHADOW, false)
                .classed(CSS_CLASS.FOCUS_SHADOW, false);
        }
    }, {
        "id": "click_on_axis_label_treemap",
        "triggerEvent": {
            "name": "click",
            "targets": axisItemPattern,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }

            var targets = getTargets(event, service);
            service.fireEvent("processSelection", {
                targets: targets,
                deselectable: true,
                ctrlKeyPressed: event.data.ctrlKey
            });
            service.fireEvent("processMultipleSelectionTooltip", {
                targets: targets,
                point: event.data.point
            });
        }
    }, {
        "id": "down_on_axis_label_treemap",
        "triggerEvent": {
            "name": "down",
            "targets": axisItemPattern,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }

            d3.select(event.data.currentTarget).attr("fill", HOVER_SHADOW_MOUSE_DOWN_COLOR)
                .attr("opacity", 1)
                .classed(CSS_CLASS.FOCUS_SHADOW, true).classed(CSS_CLASS.HOVER_SHADOW, false);
        }
    }, {
        "id": "down_on_non_leaf_dimension_label_treemap",
        "triggerEvent": {
            "name": "down",
            "targets": nonLeafDimensionLabel,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }

            d3.select(event.data.currentTarget.previousElementSibling).attr("fill", HOVER_SHADOW_MOUSE_DOWN_COLOR)
                .attr("opacity", 1)
                .classed(CSS_CLASS.FOCUS_SHADOW, true).classed(CSS_CLASS.HOVER_SHADOW, false);
        }
    }, {
        "id": "up_on_axis_label_treemap",
        "triggerEvent": {
            "name": "up",
            "targets": axisItemPattern,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            if(UADetector.isMobile()){
                d3.select(event.data.currentTarget).attr("fill", HOVER_SHADOW_COLOR)
                    .attr("opacity", 0)
                    .classed(CSS_CLASS.HOVER_SHADOW, true).classed(CSS_CLASS.FOCUS_SHADOW, false);
            }else{
                d3.select(event.data.currentTarget).attr("fill", HOVER_SHADOW_COLOR)
                    .attr("opacity", 1)
                    .classed(CSS_CLASS.HOVER_SHADOW, true).classed(CSS_CLASS.FOCUS_SHADOW, false);
            }

        }
    }, {
        "id": "up_on_non_leaf_dimension_label_treemap",
        "triggerEvent": {
            "name": "up",
            "targets": nonLeafDimensionLabel,
            "supportedChartTypes": treeType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            if(UADetector.isMobile()){
                d3.select(event.data.currentTarget.previousElementSibling).attr("fill", HOVER_SHADOW_COLOR)
                    .attr("opacity", 0)
                    .classed(CSS_CLASS.HOVER_SHADOW, true).classed(CSS_CLASS.FOCUS_SHADOW, false);
            }else{
                d3.select(event.data.currentTarget.previousElementSibling).attr("fill", HOVER_SHADOW_COLOR)
                .attr("opacity", 1)
                .classed(CSS_CLASS.HOVER_SHADOW, true).classed(CSS_CLASS.FOCUS_SHADOW, false);
            }
        }
    }];
    BehaviorManager.registerAll(treeAxis);
    return treeAxis;

});

define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForTreeMap',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/components/util/ChartTypeUtils",
    "sap/viz/framework/interaction/InteractionUtils",
    "sap/viz/framework/interaction/BehaviorManager"
], function(Constants,
    TypeUtils,
    HighlightHelper,
    ChartTypeUtils,
    InteractionUtils,
    BehaviorManager) {
    var treeType = [
        "info/treemap"
    ];
    treeType = ChartTypeUtils.addTrellisType(treeType);
    var CSS_CLASS = Constants.CSS.CLASS;

    var treeHandlers = [{
        "id": "selectDataPoint_tree",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": treeType
        },
        "handler": function(event, service) {
            if(event.data.targets[0] && event.data.targets[0].parentNode){
                service.fireEvent(event, true);
                var elements = HighlightHelper.turnToArray(event.data.targets);
                var prop = service.getProperties().get('interaction.selected');
                elements.forEach(function(e) {
                    HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 1);
                    HighlightHelper.drawFill(service, e, 'rect', prop,
                            TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
                });
            }
        }
    }, {
        "id": "deselectDataPoint_tree",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": treeType
        },
        "handler": function(event, service) {
            if(event.data.targets[0] && event.data.targets[0].parentNode){
                service.fireEvent(event, true);
                var elements = HighlightHelper.turnToArray(event.data.targets);
                var prop;
                elements.forEach(function(e) {
                    if(event.data.isAnyOtherSelected) {
                        prop = service.getProperties().get('interaction.deselected');
                    }else{
                        prop = service.getProperties().get('plotArea.dataPoint');
                    }
                    HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 1);
                    HighlightHelper.drawFill(service, e, 'rect', prop,
                            TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
                });
            }
        }
    }, {
        "id": "hoverOnDataPoint_tree",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": treeType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop = service.getProperties().get('interaction.hover');
            elements.forEach(function(e) {
                if (!event.data.byKeyboard) {
                    HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 2);
                }
                HighlightHelper.drawFill(service, e, 'rect', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });
        }
    }, {
        "id": "unhoverOnDataPoint_tree",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": treeType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            elements.forEach(function(e) {
                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    prop = service.getProperties().get('interaction.selected');
                } else {
                    var selectedDataPoints = service.getStatus("selectedDataPoints");
                    if(selectedDataPoints.length) {
                        prop = service.getProperties().get('interaction.deselected');
                    } else {
                        prop = service.getProperties().get('plotArea.dataPoint');
                    }
                }
                HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'rect', prop,
                        TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });
        }
    }, {
        "id": "clearPlot_tree",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": treeType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if(!mainNode || !mainNode.length){
                return;
            }
            var gray = event.data.isGray;
            var prop;
            mainNode.forEach(function(e) {
                if(gray){
                    prop = service.getProperties().get('interaction.deselected');
                }else{
                    prop = service.getProperties().get('plotArea.dataPoint');
                }
                HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'rect', prop,
                        TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')));
            });
        }
    },
    InteractionUtils.getDeselectEvent("click_on_non_selection_tree", treeType,
        HighlightHelper.getDeselAllExTargets())];
    BehaviorManager.registerAll(treeHandlers);
});
define('sap/viz/chart/behavior/config/handler/MBCLegendBehaviorHandler',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/interaction/Constants',
    "sap/viz/framework/common/util/UADetector",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/DOM",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/chart/behavior/config/AlignToUtil"
], function(Constants, SDKConstants, UADetector, ObjectUtils, DOM, DataPointUtils,
        SelectionUtil, AlignToUtil) {

    var BehaviorConstants = SDKConstants.BEHAVIOR,
        CSS_CLASS = Constants.CSS.CLASS;

    var MBCLegendBehaviorHandler = function() {};

    MBCLegendBehaviorHandler.prototype = {
        standAloneInitialized: function(event, service) {
            service.getProperties().origin.add({
                legend: {
                    mouseDownShadow: {
                        color: "#808080"
                    },
                    hoverShadow: {
                        color: "#cccccc"
                    }
                },
                interaction : {
                    selectability : {
                        legendSelection : true
                    }
                }
            });
        },
        hover: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.MBC_LEGEND_ITEM)) {
                return;
            }
            //unhighlight data point items
            service.fireEvent("processUnhighlight");

            if (event.data.byKeyboard) {
                var highlightProps = service.getProperties().get("interaction.keyboard");
                highlightProps.color = service.getEffectManager().register({
                    fillColor: highlightProps.color
                });
                d3.select(event.data.currentTarget).attr("stroke", highlightProps.color)
                    .attr("stroke-width", highlightProps.width)
                    .attr("stroke-dasharray", "1, 1")
                    .attr("shape-rendering", "crispEdges");
            } else {
                d3.select(event.data.currentTarget).attr("stroke",
                    SelectionUtil.getColorProperty(service, "legend.hoverShadow",
                        Constants.MBCLEGEND.HOVER_SHADOW_COLOR))
                    .attr("stroke-width", Constants.MBCLEGEND.VISIBLE_STROKE_WIDTH)
                    .attr("stroke-dasharray", undefined)
                    .attr("shape-rendering", undefined)
                    .classed(CSS_CLASS.HOVER_SHADOW, true);
            }

            if (!event.data.byKeyboard) {
                SelectionUtil.resetMBCLegendSelectionEffect(service);
            }

            //add data point hightlight effects.
            var context = ObjectUtils.extend({}, DataPointUtils.getContext(event.data.currentTarget).ctx);
            delete context.measureName;
            var highlighted = this._getTargets(context, event, service);
            service.fireEvent("processHighlight", {
                targets: highlighted,
            });
        },
        syncSelectedMBCLegendItems: function (event, service) {
            SelectionUtil.updateCorrespondingSelectedLegendItems(service, true);
        },
        nonHover: function (event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.MBC_LEGEND_ITEM) ||
                !SelectionUtil.isLegendTriggerable(service, service.NodeType.LEGEND_ITEM)) {
                return;
            }
            //unhighlight data point items
            service.fireEvent("processUnhighlight");
        },
        cleanMBCHoverEffect: function(event, service) {
            service.getNodes(service.NodeType.MBC_LEGEND_ITEM)
            .classed(CSS_CLASS.HOVER_SHADOW, false)
            .classed(CSS_CLASS.FOCUS_SHADOW, false)
            .attr("stroke-width", 0)
            .attr("stroke-dasharray", undefined)
            .attr("shape-rendering", undefined);

            SelectionUtil.resetMBCLegendSelectionEffect(service);
        },
        click: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.MBC_LEGEND_ITEM)) {
                return;
            }
            var context = ObjectUtils.extend({}, DataPointUtils.getContext(event.data.currentTarget).ctx);
            delete context.measureName;

            var targets = this._getTargets(context, event, service);
            service.fireEvent("processSelection", {
                targets: targets,
                deselectable: true,
                ctrlKeyPressed: event.data.ctrlKey
            });
            var legendGroupDOM = DOM.parent(event.data.target, ".v-groups");
            var alignTarget = AlignToUtil.getMBCTooltipData(event, service, targets, event.data.target, legendGroupDOM);
            service.fireEvent("processMultipleSelectionTooltip", alignTarget);
        },
        _getTargets: function (ctx, event, service) {
            return SelectionUtil.getDataPointIds(ctx, service);
        },
        mouseDown: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.MBC_LEGEND_ITEM)) {
                return;
            }
            var shadowColor = SelectionUtil.getColorProperty(service, "legend.mouseDownShadow",
                Constants.MBCLEGEND.HOVER_SHADOW_MOUSE_DOWN_COLOR);

            SelectionUtil.resetMBCLegendSelectionEffect(service);

            d3.select(event.data.currentTarget).attr("stroke", shadowColor)
                .attr("stroke-width", Constants.MBCLEGEND.VISIBLE_STROKE_WIDTH)
                .classed(CSS_CLASS.FOCUS_SHADOW, true);
        },
        mouseUp: function(event, service) {
            if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.MBC_LEGEND_ITEM)) {
                return;
            }
            var shadowColor = SelectionUtil.getColorProperty(service, "legend.hoverShadow",
                Constants.MBCLEGEND.HOVER_SHADOW_COLOR);
            if (UADetector.isMobile()) {
                d3.select(event.data.currentTarget).attr("stroke", null).attr("stroke-width", null)
                    .classed(CSS_CLASS.FOCUS_SHADOW, false);
            } else {
                d3.select(event.data.currentTarget).attr("stroke", shadowColor)
                    .attr("stroke-width", Constants.MBCLEGEND.VISIBLE_STROKE_WIDTH)
                    .classed(CSS_CLASS.FOCUS_SHADOW, false);
            }
            SelectionUtil.resetMBCLegendSelectionEffect(service);
        }
    };

    return MBCLegendBehaviorHandler;

});

define('sap/viz/chart/behavior/config/MBCLegendBehaviorConfig',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/chart/behavior/config/handler/MBCLegendBehaviorHandler",
    "sap/viz/framework/interaction/BehaviorManager",
    "sap/viz/chart/behavior/config/SelectionTreeUtil",
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/ObjectUtils"
], function(Constants,
         MBCLegendBehaviorHandler,
         BehaviorManager,
         SelectionTreeUtil,
         oo,
         ObjectUtils) {
    var mbcItemPattern = "v-mbc-legend-item";

    var mbc = [{
        "id": "mbcLegendBehaviorDefinition",
        "handler": MBCLegendBehaviorHandler,
        "handlerType": "class",
        "supportedChartTypes": ["info/treemap", "info/heatmap", "info/tagcloud"],
        "triggerEvent": [{
            "name": "standAloneInitialized",
            "method": "standAloneInitialized"
        }, {
            "name": "hover",
            "targets": mbcItemPattern,
            "method": "hover"
        }, {
            "name": "hover",
            "excludeTargets": [mbcItemPattern, Constants.CSS.CLASS.AXIS.LABEL_SELECTION,
                Constants.TREE_MAP.NON_LEAF_DIMENSION_LABEL],
            "method": "nonHover"
        }, {
            "name": "cleanMBCHoverEffect",
            "excludeTargets": mbcItemPattern,
            "method": "cleanMBCHoverEffect"
        }, {
            "name": "click",
            "targets": mbcItemPattern,
            "method": "click"
        }, {
            "name": "syncSelectedMBCLegendItems",
            "excludeTargets": mbcItemPattern,
            "method": "syncSelectedMBCLegendItems"
        }, {
            "name": "down",
            "targets": mbcItemPattern,
            "method": "mouseDown"
        }, {
            "name": "up",
            "targets": mbcItemPattern,
            "method": "mouseUp"
        }]
    }];
    
    var SFinMBCLegendBehaviorHandler = function() {};
    oo.extend(SFinMBCLegendBehaviorHandler, MBCLegendBehaviorHandler);

    SFinMBCLegendBehaviorHandler.prototype.click = function(event, service) {
        if(SelectionTreeUtil.isSelectable(service, "MBC")){
            SFinMBCLegendBehaviorHandler.superclass.click.apply(this, arguments);
        }
    };
    var sFinMbc = ObjectUtils.clone(mbc, true);
    sFinMbc[0].handler = SFinMBCLegendBehaviorHandler;
    BehaviorManager.registerAll(mbc, sFinMbc);
    return mbc;
});

define('sap/viz/chart/views/TreeChartView',['sap/viz/framework/common/util/oo',
        'sap/viz/chart/views/ChartView',
        'sap/viz/chart/components/plots/treemap/TreeMapPlot',
        'sap/viz/chart/components/legend/MBCLegend',
        "sap/viz/chart/scales/QuantizeScaleProcessor",
        "sap/viz/chart/chains/TreeChains",
        "sap/viz/chart/behavior/config/AxisBehaviorConfigForTreeMap",
        "sap/viz/chart/behavior/config/DataPointBehaviorConfigForTreeMap",
        "sap/viz/chart/behavior/config/MBCLegendBehaviorConfig"
    ],
    function Setup(oo, 
            ChartView,
            TreeMapPlot,
            MBCLegend) {

        var TreeChartView = function(runtime, options) {
            TreeChartView.superclass.constructor.apply(this, arguments);
        };

        oo.extend(TreeChartView, ChartView);

        TreeChartView.prototype._getDataItems = function() {
            return ["title", "weight", "color", "series"];
        };

        TreeChartView.prototype._createPlotContainer = function() {
            this._plotArea = new TreeMapPlot(this.runtime(), {
                name: "plotArea"
            });
            this.setChild("plot", this._plotArea, {
                priority: 3
            });
        };

        TreeChartView.prototype._getLegendDefinition = function() {
            return [ MBCLegend ];
        };

        return TreeChartView;
    });
define( 'sap/viz/chart/metadata/bindings/TreeBindings',[], 
        function Setup()  {
    var feeds = [ {
        "id" : "title",
        "name" : "IDS_TITLE",
        "type" : "Dimension",
        "min" : 1,
        "max" : Number.POSITIVE_INFINITY,
        "role" : "layout.tree",
        "acceptMND" : false
    }, {
        "id" : "color",
        "name" : "IDS_COLOR",
        "type" : "Measure",
        "min" : 0,
        "max" : 1,
        "role" : "mark.quantizeColor"
    }, {
        "id" : "weight",
        "name" : "IDS_WEIGHT",
        "type" : "Measure",
        "min" : 1,
        "max" : 1,
        "role" : "layout.value"
    } ];

    return feeds;
});

define('sap/viz/chart/components/axis/ReversedCategoryAxis',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/scales/CategoryScale",
    "sap/viz/chart/components/axis/CategoryAxis",
    "sap/viz/framework/common/util/ObjectUtils",
    'sap/viz/framework/common/util/DataGraphics'
], function(oo, CategoryScale, CategoryAxis, ObjectUtils, DataGraphics) {
   
    var ReversedCategoryAxis = function(runtime, options) {

        ReversedCategoryAxis.superclass.constructor.apply(this, arguments);
    };

    oo.extend(ReversedCategoryAxis, CategoryAxis);
    
    ReversedCategoryAxis.prototype.setData = function(data, hasNegativeValue) {
        ReversedCategoryAxis.superclass.setData.apply(this, arguments);
        if (data.scale) {
            var cloneDomian = ObjectUtils.clone(data.scale.getDomain());
            this._scale = new CategoryScale(cloneDomian.reverse(), [0, 1]);
        }
    };

    ReversedCategoryAxis.prototype.render = function(rootElement){
        ReversedCategoryAxis.superclass.render.apply(this, arguments);
        if(this.getParent() && this.getParent().node()){
            var axisNode = this.getParent().node();
            DataGraphics.setContext(axisNode, {
                name: this.getName()
            });
        }
    };
    
    ReversedCategoryAxis.prototype.destroy = function() {
        ReversedCategoryAxis.superclass.destroy.call(this);
        this._scale = null;
    };
    
    return ReversedCategoryAxis;

});

define('sap/viz/chart/components/datalabels/HeatMapDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/common/util/GeometryUtils",
    "sap/viz/framework/common/util/TypeUtils"
], function Setup(oo, DataLabels, DataPointUtils, GeometryUtils, TypeUtils) {

    /**
     * To initialize HeatMapDataLabels object.
     *
     * @name HeatMapDataLabels
     * @constructor
     */
    var HeatMapDataLabels = function(runtime, options) {
        HeatMapDataLabels.superclass.constructor.apply(this, arguments);
        this._ignoreEmptyDataLabel = true;
    };

    oo.extend(HeatMapDataLabels, DataLabels);

    HeatMapDataLabels.prototype._getDataLabelInfo = function(node) {
        var ctx = DataPointUtils.getContext(node);
        var key = this._data.color.metaData[0].id;
        return {
            key: key,
            value: TypeUtils.isExist(ctx[key]) ? ctx[key] : null
        };
    };

    HeatMapDataLabels.prototype._computeDataLabelTranslate = function(node, ctm, labelPosition, labelBBox, config) {
        var hasDimensionLabel = false;
        if(node.childNodes[1] && node.childNodes[1].textContent){
            hasDimensionLabel = true;
            ctm.f += GeometryUtils.getBBox(node.childNodes[1]).height / 2;
        }
        return this._computeDataLabelPosition(ctm, this._fixBBoxWhenInvisible(node), labelPosition, labelBBox,
            config, hasDimensionLabel);
    };


    HeatMapDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox, 
        config, hasDimensionLabel) {

        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;

        x = (nodeX + shapeBBox.width/2) - (labelBBox.x + labelBBox.width/2);
        if(hasDimensionLabel){
            y = (nodeY + shapeBBox.height/2) - labelBBox.y;
        }else{
            y = nodeY + shapeBBox.height/2 - labelBBox.y / 2;
        }

        return [x, y];
    };

    HeatMapDataLabels.prototype.hideConditional = function(dataLabelInfos) {
        var i;
        for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
            var dataPointNode = dataLabelInfos[i].dataPoint;
            var dataLabelNode = dataLabelInfos[i].node;

            var dataLabelBBox = dataLabelNode.getBoundingClientRect();
            var dataPointBBox = dataPointNode.getBoundingClientRect();

            if (((dataLabelBBox.width) > dataPointBBox.width) || ((dataLabelBBox.bottom) > dataPointBBox.bottom)) {
                if (dataLabelNode && dataLabelNode.parentNode) {
                    dataLabelNode.parentNode.removeChild(dataLabelNode);
                }
                dataLabelInfos.splice(i, 1);
            }

        }
        return HeatMapDataLabels.superclass.hideConditional.apply(this, arguments);
    };


    return HeatMapDataLabels;
});

define('sap/viz/chart/components/plots/HeatMapPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/renderers/BarRenderer',
    'sap/viz/chart/components/datalabels/HeatMapDataLabels',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/PropertyZoneUtil',
    'sap/viz/framework/common/util/FeedingZoneUtil',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/util/TextUtils',
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/framework/common/util/UADetector",
    'sap/viz/framework/common/util/DataUtils',
    "sap/viz/chart/components/util/ColorUtil",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/HeatMapDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
    "sap/viz/chart/behavior/config/DataPointBehaviorConfigForBar"
], function Setup(oo,
        BasePlot,
        ItemScaleHandler,
        ScaleHandler,
        BarRenderer,
        HeatMapDataLabels,
        Constants, 
        PropertyZoneUtil,
        FeedingZoneUtil,
        SVG,
        DataPointUtils,
        DataGraphics, 
        TextUtils,
        NameColorUtils,
        UADetector,
        DataUtils,
        ColorUtil,
        ChartNavigator,
        DataPointNavigator,
        ChartConstants) {


    var LABEL_STYLE = {
        fontSize : "12px",
        fontWeight : "normal",
        fontFamily : "'Open Sans', Arial, Helvetica, sans-serif",
        fontStyle : "normal"
    };

    /**
     * To initialize HeatMapPlot object.
     *
     * @name HeatMapPlot
     * @constructor
     */
    var HeatMapPlot = function(runtime, options) {
        HeatMapPlot.superclass.constructor.apply(this, arguments);

        runtime.zoneManager().add(PropertyZoneUtil.plot(this));
        runtime.zoneManager().add(FeedingZoneUtil.plot(this));
        this._ellipsisText = [];
    };

    oo.extend(HeatMapPlot, BasePlot);

    HeatMapPlot.prototype._getXHandlers = function() {
        return [ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: true,
            itemScaleHandler: ItemScaleHandler.get(true, {
                forBar: false
            })
        })];
    };

    HeatMapPlot.prototype._getYHandlers = function() {
        return [ScaleHandler.getCategoryScaleHandler("categoryAxis2", {
            isHorizontal: false,
            itemScaleHandler: ItemScaleHandler.get(true, {
                forBar: false
            })
        })];
    };

    HeatMapPlot.prototype.setData = function(data){
        this._isOnlyOneCategory = false;
        if (!data.categoryAxis2 || !data.categoryAxis2.metaData) {
            this._isOnlyOneCategory = true;
        }
        data._isOnlyOneCategory = this._isOnlyOneCategory;
        HeatMapPlot.superclass.setData.apply(this, arguments);
    };

    HeatMapPlot.prototype._applyChanges = function() {
        HeatMapPlot.superclass._applyChanges.apply(this, arguments);
        this._borderWidth = this._properties.get("border.visible") ? 1 : 0;
        var label = this._properties.get("dimensionLabel");
        if (label && label.style) {
            LABEL_STYLE = label.style;
            this._dimensionLabelVisible = label.visible;
            var semanticMgr = this._semanticMgr;
            this._dimensionLabelSemantic = semanticMgr.hasRuleForProp("dimensionLabel") || 
                semanticMgr.othersStyleHas("dimensionLabel");
        }
        if (label && label.renderer) {
            this._dimensionLabels = label;
        }
    };

    HeatMapPlot.prototype._calculatePreferredLayout = function(){
        var size = this._size;
        var m_height = size.height;
        var m_width = size.width;
        var m_heatObjArray = this._getSeries()[0];

        //build the rect size. The rule is making the rect width and height have similar values
        var score = -Number.MAX_VALUE;//the bigger the better

        var rHeight;
        var rWidth;

        var iRow;
        var iCol;

        var emptyCellNum;

        var scoreArray = [];
        var varianceRec;
        var offset = this._borderWidth;

        if(this._isOnlyOneCategory){

            if(m_heatObjArray.length == 1){
                rHeight = m_height;
                rWidth = m_width;
                iCol = 1;
                iRow = 1;
            }else{

                for(iRow = 1; iRow <= m_heatObjArray.length; iRow++){
                    //count the height
                    rHeight = m_height/iRow;

                    //count the num of one row.
                    iCol = Math.ceil(m_heatObjArray.length / iRow);

                    //count the width
                    rWidth = m_width/iCol;

                    emptyCellNum = (iCol * iRow) - m_heatObjArray.length;
                    varianceRec = (rHeight - rWidth)*(rHeight - rWidth);

                    if(varianceRec < 1){
                        varianceRec = 1; //to avoid 1/varianceRec huge number
                    }

                    if(emptyCellNum === 0 && varianceRec === 0){
                        score = 1 + 1;
                    }else if(emptyCellNum === 0 && varianceRec !== 0){
                        score = 1 + 1/varianceRec;
                    }else if(emptyCellNum !== 0 && varianceRec === 0){
                        score = 1 + 1;
                    }
                    else{
                        score = 1 + 1/varianceRec;
                    }



                    scoreArray.push(
                    {
                        "iRow":iRow,
                        "iCol":iCol,
                        "rHeight":rHeight,
                        "rWidth":rWidth,
                        "varianceRec":varianceRec,
                        "emptyCellNum":emptyCellNum,
                        "score":score
                    });
                }

                //select the best score
                var maxS = 0;
                var iChoose = -1;
                for(var i = 0; i < scoreArray.length; i++){
                    if(scoreArray[i].score > maxS){
                        maxS = scoreArray[i].score;
                        iChoose = i;
                    }
                }

                rHeight = scoreArray[iChoose].rHeight;
                rWidth = scoreArray[iChoose].rWidth;
                iCol = scoreArray[iChoose].iCol;
                iRow = scoreArray[iChoose].iRow;

            }
            //build the rect height, width and left, right
            for(var j = 0; j < m_heatObjArray.length; j++){
                m_heatObjArray[j].width = rWidth - 2 * offset;
                m_heatObjArray[j].height = rHeight - 2 * offset;
                m_heatObjArray[j].x = rWidth * (j % iCol) + offset;
                m_heatObjArray[j].y = rHeight * (Math.floor(j/iCol)) + offset;
            }
        }else{
            iCol = this._data.categoryAxis.rowArray.length;
            iRow = this._data.categoryAxis2.rowArray.length;
            rHeight = m_height / iRow;
            rWidth = m_width / iCol;

            //build the rect height, width and left, right
            for(var k = 0; k < m_heatObjArray.length; k++){
                m_heatObjArray[k].width = rWidth - offset;
                m_heatObjArray[k].height = rHeight - offset;
                m_heatObjArray[k].x = rWidth * (Math.floor(k/iRow)) + offset / 2;
                m_heatObjArray[k].y = rHeight * (k % iRow) + offset / 2;
            }
        }

        return m_heatObjArray;
    };

    HeatMapPlot.prototype._buildWrapperConfig = function(dpConfig){
        var color = this._getColor(dpConfig);
        var config = {
            graphic: {
                width : dpConfig.width,
                height : dpConfig.height,
                fill: color,
                opacity: 1
            },
            ctx: dpConfig.dp.context(),
            effectManager: this._effectManager,
            categoryAxis : dpConfig.categoryAxis
        };
        if(this._strokeProp && this._strokeProp.visible && config.graphic) {
            config.graphic.stroke = this._strokeProp.color;
            config.graphic.strokeWidth = '1px';
        }
        config = this._getFillColorConfig(config, config.ctx, dpConfig.options, dpConfig);
        if(config.graphic.fill) {
            config.graphic.fill = NameColorUtils.convertColor(config.graphic.fill);
        }
        if( config.graphic.color) {
            config.graphic.color = NameColorUtils.convertColor(config.graphic.color);
        }
        return config;
    };

    HeatMapPlot.prototype._drawDimensionLabel = function(config){
        var i;
        var labelText = "";
        var dpContext = config.categoryAxis;
        var textNode;

        for(i = 0; i < dpContext.length; i++){
            if(dpContext[i]){
                labelText += DataUtils.getLabelText(dpContext[i]) + " / ";
            }else{
                labelText += "null /";
            }
        }
        labelText = labelText.slice(0, labelText.length - 2);

        var ellipsisOptions = {};
        var envManager = this.runtime().envManager();
        ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

        var fontSize = LABEL_STYLE["fontSize"];
        var fontWeight = LABEL_STYLE["fontWeight"];
        var fontFamily =  LABEL_STYLE["fontFamily"];
        var fontStyle = LABEL_STYLE["fontStyle"];
        var fontColor = LABEL_STYLE["color"];
        var styles = {
            fontSize : fontSize,
            fontWeight : fontWeight,
            fontFamily : fontFamily,
            fontStyle : fontStyle,
            color: fontColor
        };
        var context = {
            ctx : config.ctx,
            text : labelText,
            styles : styles,
            defaultColor : "#ffffff",
            dpSize : {
                width : config.graphic.width,
                height : config.graphic.height
            },
            isMeasureText : true,
            background: config.graphic.fill,
            dataLabelColor: this._properties.get("dataLabel.style.color"),
            ellipsisText: this._ellipsisText,
            ellipsisOptions: ellipsisOptions,
            colorRange : this._properties.get("dataLabel.style.colorRange")
        };


        if(this._dimensionLabels && this._dimensionLabels.renderer) {
            textNode = this._dimensionLabels.renderer(context, defaultDimensionLabelRenderer.expose);
        }
        if(!textNode && this._showDimensionLabelFor(context.ctx)){
            var semanticMgr = this._semanticMgr;
            var style;
            if (semanticMgr.hasRuleForProp("dataLabel")) {
                style = semanticMgr.analyzeDataPointForProperty(context.ctx, "dataLabel", false, {});
            }
            if(style){
                context.dataLabelVisible = style.dataLabel;
            }else{
                context.dataLabelVisible = this._properties.get("dataLabel.visible");
            }
            textNode = defaultDimensionLabelRenderer(context);
        }

        if(textNode){
            DataGraphics.setContext(textNode, context.ctx);
            var textBBox = TextUtils.getTextBBox(textNode);
            var allNodes = d3.select(textNode).attr("class", "v-dimensionlabel v-heatmapdimensionlabel")
                .attr("fill-opacity", "1")
                .attr("x", context.dpSize.width / 2 - textBBox.width / 2)
                .attr("y", context.dpSize.height / 2 - (textBBox.height / 2 + textBBox.y));

            var textAnchor = null;
            if (envManager) {
                textAnchor = envManager.textAnchor();
            }
            allNodes.attr("text-anchor", textAnchor);
        }
        return textNode;
    };

    HeatMapPlot.prototype._showDimensionLabelFor = function(ctx) {
        if (this._dimensionLabelSemantic) {
            var semanticMgr = this._semanticMgr;
            var style =  semanticMgr.analyzeDataPointForProperty(ctx, "dimensionLabel");
            if(style){
                return style.dimensionLabel;
            }
        }
        return this._dimensionLabelVisible;
    };

    function defaultDimensionLabelRenderer(context) {
        var textNode;
        var fontSize = context.styles["fontSize"];
        var fontWeight = context.styles["fontWeight"];
        var fontFamily =  context.styles["fontFamily"];
        var fontStyle = context.styles["fontStyle"];
        var fontColor = context.styles["color"];

        if (!fontColor && context.dataLabelVisible) {
            if(context.colorRange === 'outside'){
                fontColor = ColorUtil.getDataLabelColor(context.background);
            }else{
                fontColor = context.dataLabelColor;
            }
        }
        if (!fontColor) {
            fontColor = ColorUtil.getDataLabelColor(context.background);
        }
        
        fontSize = TextUtils.validateFontStyle(fontSize);
        fontWeight = TextUtils.validateFontStyle(fontWeight);
        
        var textLength = 0;
        var textSize = TextUtils.superFastMeasure(context.text, fontSize, fontWeight, fontFamily);
        if (textSize.height > context.dpSize.height) {
            textLength = -1;
        }else{
            textNode = SVG.create("text");
            textLength = context.dpSize.width;
            var styleStr = "font-size:" + fontSize + ";";
            styleStr += "font-weight:" + fontWeight + ";";
            styleStr += "font-family:" + fontFamily + ";";
            styleStr += "font-style:" + fontStyle + ";";
            styleStr += "fill:" + fontColor + ";";

            //set dimension label text in ellipsis mode if it is too long
            var textContent = null;
            for(var i = 0; i < context.ellipsisText.length; i++) {
                var ellipsisText = context.ellipsisText[i];
                if(context.text.indexOf(ellipsisText) === 0) {
                    textContent = context.text.length > ellipsisText.length ? 
                            ellipsisText + '...' : ellipsisText;
                    break;
                }
            }
            if(textContent) {
                textNode.textContent = textContent;
                if(textContent !== context.text) {
                    textNode.appendChild(document.createElementNS(textNode.namespaceURI, "title"))
                    .textContent = context.text;
                }                
                context.text = textContent;
            }
            else {
                context.text = TextUtils.ellipsis(context.text, textNode, textLength, styleStr,
                    context.ellipsisOptions);
                if (context.text.length > 0) {
                    var index = context.text.indexOf('...');
                    var DOT_LENGTH = 3;
                    if (context.ellipsisOptions.reverseDots) {
                        context.ellipsisText.push(index < 0 ? context.text : context.text.substring(DOT_LENGTH));
                    }
                    else {
                        context.ellipsisText.push(index < 0 ? context.text : context.text.substring(0, index));
                    }
                }
            }


            d3.select(textNode)
                .attr("font-size", fontSize)
                .attr("font-weight", fontWeight)
                .attr("font-family", fontFamily)
                .attr("font-style", fontStyle)
                .attr("fill", fontColor);
        }
        return textNode;
    }

    defaultDimensionLabelRenderer.expose = {
        renderer: defaultDimensionLabelRenderer
    };

    HeatMapPlot.prototype._drawDatapoint = function(config){
        var dpNode = SVG.create("g");
        var node = BarRenderer(config);
        dpNode.appendChild(node);
        return dpNode;
    };

    HeatMapPlot.prototype._drawOneCategoryDataPoint = function(config){
        var dpNode = SVG.create("g");
        var node = BarRenderer(config);
        var textNode = this._drawDimensionLabel(config);
        dpNode.appendChild(node);
        if(textNode){
            dpNode.appendChild(textNode);
        }
        return dpNode;
    };

    HeatMapPlot.prototype._filterHidden = function(dpCfgArray) {
        var hiddenIdx = this._data.categoryAxis.metaData.map(function(meta) {
            return meta.hidden;
        });
        if (hiddenIdx.length > 0) {
            dpCfgArray.forEach(function(cfg) {
                cfg.categoryAxis = hiddenIdx.reduce(function(list, hidden, idx) {
                    return hidden ? list : list.concat(cfg.categoryAxis[idx]);
                }, []);
            });
        }
        return dpCfgArray;
    };

    HeatMapPlot.prototype._drawDatapoints = function(selection) {
        var dpConfigArray = this._filterHidden(this._calculatePreferredLayout());
        var dp, drawDatapoints;
        this._dataPointRenderer = this._isOnlyOneCategory ? this._drawOneCategoryDataPoint : this._drawDatapoint;
        var dpTranslateNode, dpNum, textNode, dpConfig, config;
        var dataPointG = SVG.create("g");
        dataPointG.setAttribute("class", Constants.CSS.CLASS.DATAPOINT_GROUP);
        this._ellipsisText = [];
        var options = {
            disableSemantic: false
        };
        for(dpNum = 0; dpNum < dpConfigArray.length; dpNum++){
            dpConfig = dpConfigArray[dpNum];
            dpConfig.options = options;
            config = this._buildWrapperConfig(dpConfig);
            config.twoDirection = true;
            dpTranslateNode = this._dataPointRenderer(config);
            DataPointUtils.setDataId(dpTranslateNode, dpNum);
            DataPointUtils.setDataPointId(dpTranslateNode, dpConfig.dp.id);
            DataGraphics.setContext(dpTranslateNode, config.ctx);
            DataGraphics.setData(dpTranslateNode, {color: config.graphic.fill, 
                strokeWidth: dpTranslateNode.querySelector("rect").getAttribute("stroke-width")});
            dpTranslateNode.setAttribute("class", Constants.CSS.CLASS.DATAPOINT + ' ' +
            Constants.CSS.CLASS.MORPHABLEDATAPOINT + ' ' + Constants.CSS.CLASS.DATAPOINTDEFAULT);
            dpTranslateNode.setAttribute("transform", 'translate(' + dpConfig.x + "," + dpConfig.y + ')');
            dataPointG.appendChild(dpTranslateNode);
        }
        selection.node().appendChild(dataPointG);
        this._drawHeatMapDataLabels(selection);
    };


    HeatMapPlot.prototype.destroy = function() {
        HeatMapPlot.superclass.destroy.call(this);
        this._dataPointRenderer = null;
        this._borderWidth = null;
        this._properties = null;
        this._isOnlyOneCategory = null;
        if(this._dimensionLabels && this._dimensionLabels.destroy){
            this._dimensionLabels.destroy();
        }
        this._dimensionLabels = null;
        this._ellipsisText = null;
    };

    HeatMapPlot.prototype._drawHeatMapDataLabels = function(selection) {
        var dataPointG = selection.select(".v-datapoint-group");
        if(!dataPointG.empty()){
            this._drawDataLabels(selection, dataPointG.node());
        }
    };

    HeatMapPlot.prototype._getDataLabels = function(name, runtime) {
        return new HeatMapDataLabels(runtime, {
            name: name
        });
    };
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.HEATMAP, DataPointNavigator);
    return HeatMapPlot;
});

define('sap/viz/chart/components/plotareas/XXPlotArea',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/container/XYContainer',
    'sap/viz/chart/components/axis/CategoryAxis',
    'sap/viz/chart/components/axis/ReversedCategoryAxis',
    'sap/viz/chart/components/plots/HeatMapPlot'
], function Setup(oo, XYContainer, CategoryAxis, ReversedCategoryAxis, HeatMapPlot) {
    var XXPlotArea = function(runtime, options) {
        XXPlotArea.superclass.constructor.apply(this, arguments);
        this._init();
    };

    oo.extend(XXPlotArea, XYContainer);

    XXPlotArea.prototype._init = function() {
        this._plot = new HeatMapPlot(this.runtime(), {
            name: "plotArea"
        });
        this._categoryAxis = new CategoryAxis(this.runtime(), {
            name: "categoryAxis"
        });
        this._categoryAxis2 = new ReversedCategoryAxis(this.runtime(), {
            name: "categoryAxis2"
        });

        this.setLayoutSequence(['left', 'right', 'bottom', 'top']);
        this.setChild("categoryAxis", this._categoryAxis, {
            position: "bottom"
        });
        this.setChild("categoryAxis2", this._categoryAxis2, {
            position: "left"
        });

        this.setChild("plot", this._plot, {
            position: "center"
        });
    };

    XXPlotArea.prototype.setData = function(data) {
        XXPlotArea.superclass.setData.apply(this, arguments);
        var isOneCategory = false;
        if (!data.categoryAxis2 || !data.categoryAxis2.scale) {
            this._categoryAxis2 = null;
            //add flag to inform categoryAxis of no need to render categoryAxis body
            //when only one categoryAxis exists
            isOneCategory = true;
        } else {
            this._categoryAxis2.setData(data.categoryAxis2);
        }
        this._categoryAxis.setData(data.categoryAxis);
        this._categoryAxis.isAxisBodyOptional(isOneCategory);
        this._plot.setData(data);
    };

    XXPlotArea.prototype.destroy = function() {
        XXPlotArea.superclass.destroy.call(this);
        this._plot = null;
        this._categoryAxis = null;
        this._categoryAxis2 = null;
    };

    return XXPlotArea;
});
define('sap/viz/chart/chains/XXChains',[
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/framework/binding/BindingManager'
], function Setup(
    BaseChains,
    BindingManager
) {
    var xxChains = {};
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetMeasuresFromFlattable',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];
    xxChains = BaseChains.extend('xx', defaultChains);
    //TODO: we may not just support feeding key as categoryAxis and categoryAxis2.
    xxChains.xxGetBindingSeries = function(rawData, dimensions, measures, bindingResults,
            bindings, bindingDefinition) {

        var series = [];
        var result = series[0] = [];
        var i, j, ca1Length, ca2Length, ctx;

        var _context = bindingResults.context,
            _ctxMeta = (_context && _context.metaData) ? _context.metaData[0] : undefined,
            _ctxVals = (_context && _context.values && _context.values.length > 0) ? _context.values : undefined,
            hasContext = _context && _ctxMeta && _ctxVals;
        
        if (!bindingResults.categoryAxis2 || !bindingResults.categoryAxis2.values) {
            ca1Length = bindingResults.categoryAxis.rowArray.length;
            for (i = 0; i < ca1Length; i++) {
                ctx = {
                    categoryAxis: bindingResults.categoryAxis.rowArray[i],
                    color: bindingResults.color.values[i]
                };
                if (hasContext) {
                    ctx.context = [_ctxVals[0][i]];
                }
                result.push(ctx);
            }
        } else {
            ca1Length = bindingResults.categoryAxis.rowArray.length;
            ca2Length = bindingResults.categoryAxis2.rowArray.length;
            for (i = 0; i < ca1Length; i++) {
                for (j = ca2Length -1; j > -1; j--) {
                    ctx = {
                        categoryAxis: bindingResults.categoryAxis.rowArray[i],
                        categoryAxis2: bindingResults.categoryAxis2.rowArray[j],
                        color: bindingResults.color.values[i][j]
                    };
                    if (hasContext) {
                        ctx.context = [];
                        for(var t = 0; t < _ctxVals.length; ++t){
                            ctx.context.push(_ctxVals[t][i][j]);
                        }
                    }
                    result.push(ctx);
                }
            }
        }
        bindingResults.series = series;
    };
    Object.keys(xxChains).forEach(function(key) {
        BindingManager.registerChain(key, xxChains[key]);
    });
    return xxChains;
});

define('sap/viz/chart/views/XXChartView',['sap/viz/framework/common/util/oo',
        'sap/viz/chart/views/ChartView',
        'sap/viz/chart/components/plotareas/XXPlotArea',
        'sap/viz/chart/components/legend/MBCLegend',
        "sap/viz/chart/scales/QuantizeScaleProcessor",
        'sap/viz/chart/chains/XXChains',
        "sap/viz/chart/behavior/config/MBCLegendBehaviorConfig"
    ],
    function Setup(oo, ChartView, PlotArea, MBCLegend) {

        var XXChartView = function(runtime, option) {
            XXChartView.superclass.constructor.apply(this, arguments);
        };

        oo.extend(XXChartView, ChartView);

        XXChartView.prototype._getLegendDefinition = function() {
            return [MBCLegend];
        };

        XXChartView.prototype._getDataItems = function() {
            return ["categoryAxis", "categoryAxis2", "series", "color"];
        };

        XXChartView.prototype._createPlotContainer = function() {
            this._plotArea = new PlotArea(this.runtime());
            this._plotArea.setRoughSize(this._size);
            this.setChild("main", this._plotArea, {
                priority: 3
            });
        };

        return XXChartView;
    });

define('sap/viz/chart/metadata/bindings/XXBindings',[], 
        function Setup()  {
    var feeds = [{
        "id": "categoryAxis",
        "name": "IDS_CATEGORY_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "layout.category"
    }, {
        "id": "categoryAxis2",
        "name": "IDS_CATEGORY_AXIS2",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "layout.secondCategory"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Measure",
        "min": 1,
        "max": 1,
        "role": "mark.quantizeColor"
    }];

    return feeds;
});

define('sap/viz/chart/components/datalabels/StackedCombinationDataLabels',[
    'sap/viz/framework/common/util/oo',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/datalabels/StackedDataLabels',
    'sap/viz/chart/components/util/CombinationDataLabelUtil',
    'sap/viz/chart/components/datalabels/LineDataLabels',
    'sap/viz/chart/components/datalabels/CombinationDataLabels'
], function(
    oo,
    DOM,
    DataGraphics,
    StackedDataLabels,
    CombinationDataLabelUtil,
    LineDataLabels,
    CombinationDataLabels
    ) {
    var StackedVertical = function(ctx, options) {
        StackedVertical.superclass.constructor.apply(this, arguments);
        this.isHorizontal = options.isHorizontal;
        this._labelPosition = "outside";
        this._stackedLabelPosition = "inside";
        this._lineLabelPosition = "outside";
    };
    oo.extend(StackedVertical, StackedDataLabels);
    
    StackedVertical.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition,
            labelBBox, config, node) {
        if (DataGraphics.getData(node).type !== "line") {
            return StackedDataLabels.prototype._computeDataLabelPosition.apply(this, arguments);
        } else {
            return LineDataLabels.prototype._computeDataLabelPosition.apply(this, arguments);
        }
        
    };

    StackedVertical.prototype._computeDataLabelTranslate = function(node) {
        if (DataGraphics.getData(node).type !== "line") {
            return StackedDataLabels.prototype._computeDataLabelTranslate.apply(this, arguments);
        } else {
            return LineDataLabels.prototype._computeDataLabelTranslate.apply(this, arguments);
        }
    };

    StackedVertical.prototype.hideConditional = function(dataLabelInfos, allDataPoints) {
        //hide datalabels which overlap with other datapoints
        var i;
        var isCheck;
        var dataPointBoxes = new Array(allDataPoints.length);
        for (i = 0; i < allDataPoints.length; i++) {
            dataPointBoxes[i] = allDataPoints[i].getBoundingClientRect();
        }

        for (i = (dataLabelInfos.length - 1); i >= 0; i--) {
            var dataLabelinfo = dataLabelInfos[i];

            var dataLabelNode = dataLabelinfo.node;
            var dataLabelBBox = dataLabelNode.getBoundingClientRect();

            var currectDataPoint = dataLabelinfo.dataPoint;
            var iIndex = this.indexOfDataLabelIntersectDataPoints(dataLabelBBox, dataPointBoxes,
                allDataPoints, currectDataPoint);

            if (iIndex !== -1) {
                DOM.remove(dataLabelNode);
                dataLabelInfos.splice(i, 1);
            }
        }

        return StackedVertical.superclass.hideConditional.apply(this, arguments);
    };

    StackedVertical.prototype.allowIntersectionCheck = function(datapoint) {
        var dataType = DataGraphics.getData(datapoint).type;
        var isCheck = false;
        if (dataType == "line") {
            isCheck = true;
        }
        return isCheck;
    };

    StackedVertical.prototype.getDataLabelDefaultPosition = function(dataPoint) {
        if (DataGraphics.getData(dataPoint).type == "line") {
            this._labelPosition = this._lineLabelPosition;
        } else {
            this._labelPosition = this._stackedLabelPosition;
        }
    };

    StackedVertical.prototype.drawZero = function(dataPoint) {
        if (DataGraphics.getData(dataPoint).type == "line") {
            return true;
        } else {
            return false;
        }
    };

    StackedVertical.prototype.intersectResult = function(dataLabelBBox,dataPointBoxes,allDataPoints,currectDataPoint)
    {
        return CombinationDataLabelUtil.isIntersectedHelper.
               call(this, dataLabelBBox, dataPointBoxes, allDataPoints, currectDataPoint);
    };

    StackedVertical.prototype.isDataLabelOutOfDataPoint =  CombinationDataLabels.prototype.isDataLabelOutOfDataPoint;
    return StackedVertical;
});
define('sap/viz/chart/components/accessibility/StackedCombinationDataPointNavigator',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/util/SeriesUtil",
    "sap/viz/chart/components/accessibility/BaseDataPointNavigator",
    "sap/viz/chart/components/accessibility/StackedColumnDataPointNavigator",
    "sap/viz/chart/components/accessibility/LineDataPointNavigator"
], function(oo, SeriesUtil, BaseDataPointNavigator, StackedColumnDataPointNavigator,
    LineDataPointNavigator) {

    function StackedCombinationDataPointNavigator(options) {
        StackedCombinationDataPointNavigator.superclass.constructor.apply(this, arguments);
        this._dataShapes = null;
        this._seriesTypeLookup = [];
        this._stackedColumnNavigator = null;
        this._lineNavigator = null;
        this._lineSortedDPInCategory = [];
        this._barDPInCategory = [];
        this._stackedSeries = [];
        this._lineSeries = [];
        this._initSubComponent(options);
    }

    oo.extend(StackedCombinationDataPointNavigator, BaseDataPointNavigator);

    var prot = StackedCombinationDataPointNavigator.prototype;

    prot._initSubComponent= function(options) {
        if (this._series) {
            this._setupSeriesTypeTable();
            for (var k = 0; k < this._seriesTypeLookup.length; k++) {
                if (this._seriesTypeLookup[k] === this._constants.BAR) {
                    this._stackedSeries.push(this._series[k]);
                    this._lineSeries.push(undefined);
                } else {
                    this._stackedSeries.push(undefined);
                    this._lineSeries.push(this._series[k]);
                }
            }
            var stackedColumnOptions = {
                isVerticalRender : options.isVerticalRender,
                dataModel : options.dataModel,
                series: this._stackedSeries,
                isCombination : true
            };
            this._stackedColumnNavigator = new StackedColumnDataPointNavigator(stackedColumnOptions);
            var lineOptions = {
                isDual :options.isDual,
                isVerticalRender : options.isVerticalRender,
                dataModel : options.dataModel,
                series : this._lineSeries,
                propertyManager: options.propertyManager
            };
            this._lineNavigator = new LineDataPointNavigator(lineOptions);
        }
    };

    prot.destroy = function() {
        StackedCombinationDataPointNavigator.superclass.destroy.apply(this, arguments);
        if (this._stackedColumnNavigator) {
            this._stackedColumnNavigator.destroy();
        }
        if (this._lineNavigator) {
            this._lineNavigator.destroy();
        }
        this._stackedColumnNavigator = null;
        this._lineNavigator = null;
        this._stackedSeries = null;
        this._lineSeries = null;
        this._lineSortedDPInCategory = null;
        this._barDPInCategory = null;
    };

    prot.left = function(id) {
        return this._DPRouter(id, this._constants.LEFT);
    };

    prot.right = function(id) {
        return this._DPRouter(id, this._constants.RIGHT);
    };

    prot.up = function(id) {
        return this._DPRouter(id, this._constants.UP); 
    };

    prot.down = function(id) {
        return this._DPRouter(id, this._constants.DOWN);  
    };

    function isMeaningful(dp){
        return dp && !dp.ignore;
    }

    prot._DPRouter = function (id, direction) {
        var dp = this.getDataPoint(id);
        var nextDp = null;
        if (dp) {
            var address = this.getDataPoint(id).address();
            updateDPTableByType.call(this, address[0]);
            var seriesType = this._getSeriesType(dp);
            if (seriesType === this._constants.BAR) {
                switch (direction) {
                    case this._constants.UP:
                        nextDp = this._stackedColumnNavigator.up(id);
                        if (this._isVerticalRender && !isMeaningful(nextDp)) {
                            nextDp = this._getFirstDPByTypeInCategory(this._constants.LINE, address[0]);
                        }
                        break;
                    case this._constants.DOWN:
                        nextDp = this._stackedColumnNavigator.down(id);
                        break;
                    case this._constants.LEFT:
                        nextDp = this._stackedColumnNavigator.left(id);                      
                        break;
                    case this._constants.RIGHT:
                        nextDp = this._stackedColumnNavigator.right(id);
                        if (!this._isVerticalRender && !isMeaningful(nextDp)) {
                            nextDp = this._getFirstDPByTypeInCategory(this._constants.LINE, address[0]);
                        }
                        break;
                }
            } else if (seriesType === this._constants.LINE) {
                switch (direction) {
                    case this._constants.UP:
                        nextDp = this._lineNavigator.up(id);
                        break;
                    case this._constants.DOWN:
                        nextDp = this._lineNavigator.down(id);
                        if (this._isVerticalRender && !isMeaningful(nextDp)) {
                            nextDp = this._getFirstDPByTypeInCategory(this._constants.BAR, address[0]);
                        }                        
                        break;
                    case this._constants.LEFT:
                        nextDp = this._lineNavigator.left(id);
                        if (!this._isVerticalRender && !isMeaningful(nextDp)) {
                            nextDp = this._getFirstDPByTypeInCategory(this._constants.BAR, address[0]);
                        }
                        break;
                    case this._constants.RIGHT:
                        nextDp = this._lineNavigator.right(id);
                        break;
                }
            }
        }
        return nextDp;
    };

    prot._getFirstDPByTypeInCategory = function(dpType, categoryIndex) {
        var targets = dpType === this._constants.BAR? this._barDPInCategory[categoryIndex] : 
                                                      this._lineSortedDPInCategory[categoryIndex];
        for(var ii = 0; ii < targets.length; ii++){
            if(isMeaningful(targets[ii])){
                return targets[ii];
            }
        }
        return null;
    };

    prot._getLastDPByTypeInCategory = function(dpType, categoryIndex) {
        var targets = dpType === this._constants.BAR? this._barDPInCategory[categoryIndex] : 
                                                      this._lineSortedDPInCategory[categoryIndex];
        for(var ii = targets.length-1; ii > -1; ii--){
            if(isMeaningful(targets[ii])){
                return targets[ii];
            }
        }
        return null;
    };


    function updateDPTableByType(columnIdx) {
        if (!this._sortedDataPointsByDirection[columnIdx]) {
            this.dataPointValueSortInCategory(columnIdx);
        }

        if (!this._lineSortedDPInCategory[columnIdx]) {
            this._lineSortedDPInCategory[columnIdx] = [];
            for (var i = 0; i < this._sortedDataPointsByDirection[columnIdx].length; i++) {
                var dp = this._sortedDataPointsByDirection[columnIdx][i];
                if (this._seriesTypeLookup[dp.address()[1]] === this._constants.LINE) {
                    this._lineSortedDPInCategory[columnIdx].push(dp);
                }
            }
        }

        if (!this._barDPInCategory[columnIdx]) {
            this._barDPInCategory[columnIdx] = [];
            var dps = this.getColumn(columnIdx);
            for (var j = 0; j < dps.length; j++) {
                if (this._seriesTypeLookup[dps[j].address()[1]] === this._constants.BAR) {
                    this._barDPInCategory[columnIdx].push(dps[j]);
                }
            }
        }
    }

    prot._getLineShortestDPInCategory = function(id, direction) {
        var currentDp = this.getDataPoint(id);
        var shortestDp = null;
        var shortestDpIdx = -1;
        var address = currentDp.address();
        var columnIdx = address[0];

        var curtDpIndex = this._lineSortedDPInCategory[columnIdx].indexOf(currentDp);
        if (curtDpIndex === -1) {
            return this._lineSortedDPInCategory[columnIdx][0];
        } else {
            if (direction === this._constants.UP || direction === this._constants.RIGHT) {
                shortestDpIdx = curtDpIndex + 1;
            } else if (direction === this._constants.DOWN || direction === this._constants.LEFT) {
                shortestDpIdx = curtDpIndex - 1;
            }           
        }

        if (shortestDpIdx > -1 && 
            shortestDpIdx < this._lineSortedDPInCategory[columnIdx].length) {
            shortestDp = this._lineSortedDPInCategory[columnIdx][shortestDpIdx];
        } else {

        }
        return shortestDp;
    };

    return StackedCombinationDataPointNavigator;
});

define('sap/viz/chart/components/plots/StackedCombinationPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/plots/StackedColumnPlot',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/plots/BasePlot',
    'sap/viz/chart/components/plots/BaseLinePlot',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    'sap/viz/chart/components/renderers/StackedBarRenderer',
    'sap/viz/chart/components/renderers/LineRenderer',
    'sap/viz/chart/components/renderers/SmoothLineRenderer',
    'sap/viz/chart/components/util/DrawUtil',
    "sap/viz/chart/components/util/DataPointUtils",
    'sap/viz/chart/components/util/LineRendererUtil',
    'sap/viz/chart/components/datalabels/StackedCombinationDataLabels',
    "sap/viz/chart/components/plots/XYPlotFactory",
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/StackedCombinationDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants"
], function Setup(
    oo,
    SVG,
    ObjectUtils,
    DataGraphics,
    Constants,
    DOM,
    ContextBuilder,
    StackedColumnPlot,
    ScaleHandler,
    DataHandler,
    ItemScaleHandler,
    BasePlot,
    BaseLinePlot,
    SeriesRenderer,
    PathRenderer,
    StackedBarRenderer,
    LineRenderer,
    SmoothLineRenderer,
    DrawUtil,
    DataPointUtils,
    LineRendererUtil,
    StackedCombinationDataLabels,
    XYPlotFactory,
    ChartNavigator,
    DataPointNavigator,
    ChartConstants
) {

    var LINE = "line";
    var BAR = "bar";
    var StackedCombinationPlot = function(runtime, options) {
        StackedCombinationPlot.superclass.constructor.apply(this, arguments);

        //categoryScaleHandler for stacked datapoint
        this._barCategoryAxis = ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: false,
            itemScaleHandler: this._getItemScaleHandler()
        });

        this._categoryScaleHandler = this._barCategoryAxis;

        this._lineDataHandler = DataHandler.getHandler();
        this._stackDataHandler = this._getDataHandler();

        this._drawZeroLineBeforeDatapoints = true;

        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.setUseSemanticPattern(true);
        semanticMgr.setUseSemanticDPLineStyle(true);

        this._attachMarkManager();
        this._markerPropName = "line.marker";

        this.dataShapePrimaryAxisPW = this._properties.watch("dataShape.primaryAxis",
            this._onDataShapeChange.bind(this));

        this._options.isCombination = true;
        var isDualValueAxis = options && options.isDualValueAxis;
        if(isDualValueAxis){
            this.dataShapeSecondaryAxisPW = this._properties.watch("dataShape.secondaryAxis",
                this._onDataShapeChange.bind(this));
        }

        this.lineMarkerShapePW = this._properties.watch("line.marker.shape", this._onDataShapeChange.bind(this));
        this._lineRenderer = null;
        this._defaultLineRenderer = LineRendererUtil.getDefaultRenderer(this._properties.get("line.isSmoothed"));
    };

    oo.extend(StackedCombinationPlot, StackedColumnPlot);

    StackedCombinationPlot.prototype._isSupportBarPathGenerator = function () {
        return true;
    };

    StackedCombinationPlot.prototype.destroy = function() {

        this.dataShapePrimaryAxisPW.remove();
        this.dataShapePrimaryAxisPW = null;

        if(this.dataShapeSecondaryAxisPW) {
            this.dataShapeSecondaryAxisPW.remove();
            this.dataShapeSecondaryAxisPW = null;
        }
        this.lineMarkerShapePW.remove();
        this.lineMarkerShapePW = null;

        StackedCombinationPlot.superclass.destroy.call(this);

        this._barCategoryAxis = null;
        this._categoryScaleHandler = null;
        this._realSize = null;
        this._markerD = null;

        this._lineDataHandler = null;
        this._stackDataHandler = null;
        this._reversedSeries = null;
        this._lineRenderer = null;
        this._dpPlotNode = null;
        this._dpParentNode = null;
        this._extendSize = null;
    };

    StackedCombinationPlot.prototype._createMainNode = BaseLinePlot.prototype._createMainNode;

    StackedCombinationPlot.prototype._getClipPathAttribute = BaseLinePlot.prototype._getClipPathAttribute;

    StackedCombinationPlot.prototype.zoom = BaseLinePlot.prototype.zoom;

    StackedCombinationPlot.prototype.scroll = BaseLinePlot.prototype.scroll;

    StackedCombinationPlot.prototype._isNeedSimplifyLine = function(){
        return false;
    };

    StackedCombinationPlot.prototype._getItemScaleHandler = function() {
        var result;
        var options = this._getBarProperties();
        if (this._options.isDualValueAxis) {
            var isPrimaryhasBar = this._properties.get("dataShape.primaryAxis").indexOf('bar') > -1;
            var isSecondaryhasBar = this._properties.get("dataShape.secondaryAxis").indexOf('bar') > -1;
            if (isPrimaryhasBar && isSecondaryhasBar) {
                options.valueAxis = ["valueAxis", "valueAxis2"];
                result = ItemScaleHandler.get(false, options);
                delete options.valueAxis;
            } else {
                result = ItemScaleHandler.get(false, options);
            }
        } else {
            result = ItemScaleHandler.get(false, options);
        }
        this._itemScaleHandler = result;
        return result;
    };

    StackedCombinationPlot.prototype._attachMarkManager = function() {
        var markerMgr = this.runtime().markManager();
        var primaryAxis = this._properties.get("dataShape.primaryAxis");
        var lineMarker = this._getMarkerShape();
        var propRoot = this._properties.parentLevel;

        var shapes = [];
        markerMgr.lock();
        markerMgr.setMode("combination");

        var seriesShape = [];
        seriesShape.push(primaryAxis);
        shapes.push(processMark.call(this, primaryAxis, lineMarker, propRoot));
        if(this._options && this._options.isDualValueAxis){
            var secondaryAxis = this._properties.get("dataShape.secondaryAxis");
            shapes.push(processMark.call(this, secondaryAxis, lineMarker, propRoot));
            seriesShape.push(secondaryAxis);
        }
        markerMgr.setShape(shapes, lineMarker);
        markerMgr.setSeriesShape(seriesShape);
    };

    function processMark(arr, lineMark, propRoot) {
        var result = [];
        if(!arr || !arr.length){
            return result;
        }
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === LINE) {
                result.push(lineMark);
            } else {
                //we should use default shape
                var defaultMarkerShape = this._getLegendMarkerShape();
                result.push(defaultMarkerShape);
            }
        }
        return result;
    }

    StackedCombinationPlot.prototype._onDataShapeChange = function() {
        this._attachMarkManager();
    };

    //categoryScaleHandler for line datapoint
    StackedCombinationPlot.prototype._getCategoryScaleHandlers = function(isHorizontal) {
        return [ScaleHandler.getCategoryScaleHandler("categoryAxis", {
            isHorizontal: isHorizontal,
            itemScaleHandler: ItemScaleHandler.get(false),
            alignment: "center"
        })];
    };

    StackedCombinationPlot.prototype._getSeriesRenderer = function() {
        return new SeriesRenderer(this._drawLine.bind(this), this._updateLine.bind(this));
    };

    StackedCombinationPlot.prototype._applyChanges = function() {
        StackedCombinationPlot.superclass._applyChanges.apply(this, arguments);
        var scale = this._data["categoryAxis"].scale;
        var range = this.isHorizontal() ? this._realSize.height : this._realSize.width;
        this._barCategoryAxis.init(scale, this._data.series.length, range);
    };

    StackedCombinationPlot.prototype._preRender = function() {
        StackedCombinationPlot.superclass._preRender.apply(this, arguments);
        this._generateMarkerPath();
        this._lineRenderer = null;

    };

    StackedCombinationPlot.prototype._getDataShape = function(seriesIndex) {
        this._reversedSeries = this._reversedSeries || this._getSeries();
        var items = this._reversedSeries[seriesIndex];
        var item = null;
        for (var i = 0; i < items.length; i++) {
            item = items[i];
            if (item) {
                break;
            }
        }
        if (item) {
            var propKey = "dataShape.primaryAxis";
            if (!item.hasOwnProperty("valueAxis")) {
                propKey = "dataShape.secondaryAxis";
            }
            var dataShapes = this._properties.get(propKey);
            // for bug BITSDC1-6233 check the datashapes.
            if (!( dataShapes instanceof Array)) {
                dataShapes = this._properties.get(propKey, 'defaultValue');
            }

            var index;
            if (item.color){
                index = item.color.mndIndex;
            } else if (item.color2){
                index = item.color2.mndIndex;
            } else {
                index = -1;
            }

            // for bug BITSDC1-6233 check the datashapes.
            if (dataShapes[index] !== LINE && dataShapes[index] !== BAR) {
                dataShapes[index] = LINE;
            }

            return dataShapes[index];

        }
        return LINE;
    };

    StackedCombinationPlot.prototype._getXPosition = function(seriesIndex, itemIndex, data) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
        if (this.isHorizontal()) {
            //value
            if (isLine) {
                this._dataHandler = {"valueAxis": this._lineDataHandler};
            } else {
                this._dataHandler = this._stackDataHandler;
            }
            var result = StackedCombinationPlot.superclass._getXPosition.apply(this, arguments);
            if (isLine) {
                return [result[0] + result[1], result[1]];
            } else {
                return result;
            }
        } else {
            //category
            if (isLine) {
                return StackedCombinationPlot.superclass._getXPosition.apply(this, arguments);
            } else {
                return this._getAxisPosition([this._barCategoryAxis], seriesIndex, itemIndex, data);
            }
        }
    };

    StackedCombinationPlot.prototype._adjustPosition = function(position, seriesIndex) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
        if (!isLine) {
            StackedCombinationPlot.superclass._adjustPosition.apply(this, arguments);
        }
    };

    StackedCombinationPlot.prototype._getYPosition = function(seriesIndex, itemIndex, data) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
        if (!this.isHorizontal()) {
            //value
            if (isLine) {
                this._dataHandler = {"valueAxis": this._lineDataHandler};
            } else {
                this._dataHandler = this._stackDataHandler;
            }
            var result = StackedCombinationPlot.superclass._getYPosition.apply(this, arguments);
            return result;
        } else {
            //category
            if (isLine) {
                return StackedCombinationPlot.superclass._getYPosition.apply(this, arguments);
            } else {
                return this._getAxisPosition([this._barCategoryAxis], seriesIndex, itemIndex, data);
            }
        }
    };

    StackedCombinationPlot.prototype.getLineRenderer = function(){
        if (!this._lineRenderer){
            var props = this._properties;
            this._lineRenderer = LineRendererUtil.getRenderer(
                props.get('line.lineRenderer'),
                props.get("line.isSmoothed")
            );
        }
        return this._lineRenderer;
    };

    StackedCombinationPlot.prototype._isLineVisible = function (){
        return this._properties.get('line.visible');
    };


    StackedCombinationPlot.prototype._drawLine = function(seriesG, data, seriesIndex, isUpdate) {
        if (this._getDataShape(seriesIndex) !== LINE) {
            return 0;
        }
        var index = this._data.series.length - 1 - seriesIndex;
        BaseLinePlot.prototype._drawLine.apply(this, [seriesG, data, index, isUpdate]);
        return 1;
    };

    StackedCombinationPlot.prototype._updateLine = function(seriesG, data, seriesIndex){
        this._drawLine(seriesG, data, seriesIndex, true);
    };

    StackedCombinationPlot.prototype._updateDatapoint = function(dataPointG, dpRenderer, dpConfig,
        position) {
        StackedCombinationPlot.superclass._updateDatapoint.apply(this, arguments);
        if (position.hasOwnProperty("x") && position.hasOwnProperty("y")) {
            var translate = DataGraphics.getData(dataPointG).translate;
            if (translate) {
                translate[0] = position.x;
                translate[1] = position.y;
            }
        }
    };

    StackedCombinationPlot.prototype._buildConfig = function(data, position, context) {
        var config = StackedCombinationPlot.superclass._buildConfig.apply(this, arguments);
        config.graphic.d = this._markerD;

        if (!this._properties.get("line.marker.visible")) {
            config.graphic.opacity = 0;
        }
        return config;
    };

    StackedCombinationPlot.prototype._getDataPointRenderer = function(seriesIndex) {
        if (seriesIndex == null || this._getDataShape(seriesIndex) !== LINE){
            this._isLineMarker = false;
            return StackedCombinationPlot.superclass._getDataPointRenderer.apply(this, arguments);
        } else {
            this._isLineMarker = true;
            return this._customMarkerRenderer || PathRenderer;
        }
    };


    StackedCombinationPlot.prototype._getDataLabels = function(name, runtime) {
        var options = ObjectUtils.extend({}, this._options);
        options.name = name;
        return new StackedCombinationDataLabels(runtime, options);
    };

    StackedCombinationPlot.prototype._getPatternConfig = BaseLinePlot.prototype._getPatternConfig;

    StackedCombinationPlot.prototype._updateDatapoints = function(parent) {
        var series = this._reversedSeries = this._getSeries();

        var seriesLength = series.length;
        var dataPointG;
        dataPointG = parent.select("." + Constants.CSS.CLASS.DATAPOINT_GROUP).node();

        var dpRenderer;

        for (var dhID in this._stackDataHandler) {
            if (this._stackDataHandler[dhID].reset) {
                this._stackDataHandler[dhID].reset();
            }
        }

        this._lineDataHandler.reset();
        if (this._seriesRenderer) {
            this._seriesRenderer.resetDataPoints();
        }

        var currentId;
        var countId = 0;
        var categories = [], category;

        for (var seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {
            var seriesItem = series[seriesIndex];
            if (!seriesItem) {
                continue;
            }
            dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }

            var isLine = this._getDataShape(seriesIndex) === LINE;
            var seriesStyle = this.getSeriesDPStyle(this._reversedSeries ? seriesLength - seriesIndex - 1: seriesIndex,
                    null, isLine);

            for (var itemIndex = 0; itemIndex < seriesItem.length; itemIndex++) {
                var data = seriesItem[itemIndex];
                if (!data) {
                    continue;
                }
                var position = this._getPosition(seriesIndex, itemIndex, data);
                if (!position) {
                    continue;
                }

                currentId = countId++;
                var options = this._getDPOptions(seriesStyle, isLine, data);
                var dpConfig = this._buildWrapperConfig(data, position, data.dp.context(), options);
                dpConfig.seqId = currentId;
                var dpData = this._buildData(dpConfig);

                if (isLine) {
                    dpConfig.isLineMarker = true;
                    //draw line series
                    var dpModel = this._createDataPoint(seriesIndex, itemIndex, dpConfig, dpData, position, currentId,
                            data);
                    var dp;
                    if(!this._isBigData){
                        dp =  this._drawDataPoint(dpRenderer, dpModel, true);
                        var _data = DataGraphics.getData(dp);
                        if(!_data){
                            _data = {};
                        }
                        _data.seriesIndex = data.dp._addr[1];
                        _data.itemIndex = data.dp._addr[0];
                        DataGraphics.setData(dp, _data);
                    }

                    var currentDp = DataPointUtils.find(dataPointG, currentId);
                    if(currentDp){
                        this._updateDatapoint(currentDp, dpRenderer, dpConfig, position);
                        dpModel.setNode(currentDp);
                    }else if(dp){
                        dataPointG.appendChild(dp);
                        dpModel.setNode(dp);
                    }

                    if (this._seriesRenderer) {
                        this._seriesRenderer.updateDataPoint(seriesIndex, itemIndex, dpConfig, position, dp);
                    }
                } else {
                    dpConfig.isLineMarker = false;
                    //draw stacked category
                    category = categories[itemIndex] = categories[itemIndex] || {
                        configs: [],
                        positions: [],
                        currentIds: [],
                        dataPoints: [],
                        addrs: [],
                    };
                    if (!category.node) {
                        var dpNode = DataPointUtils.find(dataPointG, currentId);
                        var categoryNode = dpNode;
                        while ((categoryNode = categoryNode.parentNode) &&
                            !DOM.hasClass(categoryNode, Constants.CSS.CLASS.STACK)) {}
                        category.node = categoryNode;
                    }
                    category.configs.push(dpConfig);
                    category.dataPoints.push(data.dp);
                    category.addrs.push([seriesIndex, itemIndex]);
                    category.positions.push(position);
                    category.currentIds.push(currentId);
                }

                this._pushDataPointContext(dpConfig);
            }
        }

        //render stacked
        this._dataPointRenderer = StackedBarRenderer;
        dpRenderer = this._getDataPointRenderer();
        for (var i = 0; i < categories.length; i++) {
            if (categories[i]){
                category = categories[i];
                var cp = this._drawCategory(category, dpRenderer, []);
            }
        }

        this._dataPointRenderer = PathRenderer;
        //render line
        if (this._seriesRenderer) {
            this._seriesRenderer.update(dataPointG);
        }

        var dataPoints = parent.selectAll('.' + Constants.CSS.CLASS.DATAPOINT)[0];
        this._dataLabels.updatePosition(parent, dataPoints);
    };

    StackedCombinationPlot.prototype._drawDataPoint = function(dpRenderer, dataPoint, isLineDataPoint) {
        if(isLineDataPoint) {
            //the root cause of the bug is because of changelist 6893534 in P4. Line datapoint
            //should not have the (0,1) offset.
            var dp = BasePlot.prototype._drawDataPoint.apply(this, arguments);
            var dpData = dataPoint.getData();
            dpData.shape = this._getMarkerShape();
            DataGraphics.setData(dp, dpData);
            // add this attribute to combination marker
            dp.setAttribute("combination-marker","true");
            return dp;
        }
        else {
            return StackedCombinationPlot.superclass._drawDataPoint.apply(this, arguments);
        }
    };

    StackedCombinationPlot.prototype._getDPOptions = function(seriesStyle, isLine, data){
        return  { seriesStyle:seriesStyle,
                  seriesType: (isLine?"line":"bar") };
    };

    StackedCombinationPlot.prototype._drawDatapoints = function(parent) {
        //reverse series because of stack
        var series = this._reversedSeries = this._getSeries();

        var seriesLength = series.length;
        var dataPointG = parent.node().querySelector("."+Constants.CSS.CLASS.DATAPOINT_GROUP);
        if (!dataPointG){
            dataPointG = SVG.create("g");
            dataPointG.setAttribute("class", Constants.CSS.CLASS.DATAPOINT_GROUP);
            parent.node().appendChild(dataPointG);
        } 
        var dpRenderer;

        if (this._seriesRenderer) {
            this._seriesRenderer.init(seriesLength);
        }

        for (var dhID in this._stackDataHandler) {
            if (this._stackDataHandler[dhID].reset) {
                this._stackDataHandler[dhID].reset();
            }
        }

        this._lineDataHandler.reset();

        var currentId;
        var countId = 0;
        var categories = [], category;

        for (var seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {
            var seriesItem = series[seriesIndex];
            if (!seriesItem) {
                continue;
            }
            var isLine = this._getDataShape(seriesIndex) === LINE;
            var seriesStyle = this.getSeriesDPStyle(this._reversedSeries ? seriesLength - seriesIndex - 1: seriesIndex,
                    null,isLine);
            dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }

            for (var itemIndex = 0; itemIndex < seriesItem.length; itemIndex++) {
                var data = seriesItem[itemIndex];
                if (!data) {
                    continue;
                }
                var position = this._getPosition(seriesIndex, itemIndex, data);
                if (!position) {
                    continue;
                }

                currentId = countId++;
                var options = this._getDPOptions(seriesStyle, isLine, data);
                var dpConfig = this._buildWrapperConfig(data, position, data.dp.context(), options);
                dpConfig.seqId = currentId;

                var dpData = this._buildData(dpConfig);
                if (isLine) {
                    dpConfig.isLineMarker = true;

                    if(this.allowBreakLine(dpConfig.rawData.dp)){
                        position = null;
                        continue;
                    }

                    //draw line series
                    var dpModel = this._createDataPoint(seriesIndex, itemIndex, dpConfig, dpData, position, currentId,
                            data);
                    // make sure the line use lineRender in case customer line is not rendered.
                    this._dataPointRenderer = PathRenderer;
                    var dp;

                    if(!this._isBigData){
                        dp = this._drawDataPoint(dpRenderer, dpModel, true);
                        var _extraData = DataGraphics.getData(dp);
                        _extraData = _extraData || {};
                        _extraData.seriesIndex = data.dp._addr[1];
                        _extraData.itemIndex = data.dp._addr[0];
                        DataGraphics.setData(dp, _extraData);
                        dpModel.setNode(dp);
                    }

                    if (dp || this._isBigData) {
                        if (this._seriesRenderer) {
                            this._seriesRenderer.addDataPoint(seriesIndex, itemIndex, dpConfig,
                                position, dp);
                        } else if(dp){
                            dataPointG.appendChild(dp);
                        }
                    }
                } else {
                    //draw stacked category
                    category = categories[itemIndex] = categories[itemIndex] || {
                        configs: [],
                        positions: [],
                        currentIds: [],
                        dataPoints: [],
                        addrs : [],

                    };
                    category.data = category.data || [];
                    category.data.push(dpData);
                    // add these attributes to config
                    dpConfig.isLineMarker = false;
                    dpConfig.isStacked = true;
                    category.configs.push(dpConfig);
                    category.dataPoints.push(data.dp);
                    category.addrs.push([seriesIndex, itemIndex]);
                    category.positions.push(position);
                    category.currentIds.push(currentId);
                }

                this._pushDataPointContext(dpConfig);
            }
        }

        // make sure the stacked  use stacked renderer in case customer stacked is not rendered.
        // StackedCombinationPlot.superclass._dataPointRenderer may be unefined.
        // so use StackedBarRenderer instead.
        this._dataPointRenderer = StackedBarRenderer;
        //render stacked
        dpRenderer = this._getDataPointRenderer();

        for (var i = 0; i < categories.length; i++) {
            category = categories[i];
            if (!category){
                continue;
            }
            var cp = this._drawCategory(category, dpRenderer, []);
            // add the attribute to combination-column
            if (cp.children) {
                for (var j = 0; j < cp.children.length; j++) {
                    cp.children[j].setAttribute("combination-column", "true");
                }
            }

            if (cp) {
                dataPointG.appendChild(cp);
            }
        }

        // make sure the line use lineRender in case customer line is not rendered.
        this._dataPointRenderer = PathRenderer;

        //render line
        if (this._seriesRenderer) {
            this._seriesRenderer.render(dataPointG);
        }

        this._postRender(dataPointG);
        this._dataLabels._gridlineScale = this._gridlineScale;
        this._drawDataLabels(parent, dataPointG);
    };

    StackedCombinationPlot.prototype._renderNode =  BaseLinePlot.prototype._renderNode;

    StackedCombinationPlot.prototype._buildWrapperConfig = function(data, position, context, options) {
        var config = StackedCombinationPlot.superclass._buildWrapperConfig.apply(this, arguments);
        config.graphic.shape = this._getMarkerShape();
        return config;
    };

    StackedCombinationPlot.prototype.update = function() {
        StackedCombinationPlot.superclass.update.apply(this, arguments);
        BaseLinePlot.prototype._updateLightLine.apply(this, arguments);
    };

    StackedCombinationPlot.prototype.getSeriesStyle = function() {
        var seriesStyle = BaseLinePlot.prototype.getSeriesStyle.apply(this, arguments);
        seriesStyle.isCombination = true;
        return seriesStyle;
    };

    StackedCombinationPlot.prototype._buildSeriesContext = function(seriesIndex){
        return  ContextBuilder.buildSeriesContext(this._data, seriesIndex,
                ["color", "color2", "trellisColumn", "trellisRow"]);
    };

    StackedCombinationPlot.prototype._pushDataPointContext = function(){
        //do nothing
        //its child will overwrite this
    };

    StackedCombinationPlot.prototype.allowBreakLine = function(dp){
        return false;
    };

    XYPlotFactory.registerClazz("stacked_combination", StackedCombinationPlot);
    XYPlotFactory.registerClazz("horizontal_stacked_combination", StackedCombinationPlot);
    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,
        ChartConstants.STACKED_COMBINATION, DataPointNavigator);

    return StackedCombinationPlot;
});

define('sap/viz/chart/metadata/bindings/XYYCombinationBindings',[], function Setup() {

    var feeds = [{
        "id": "dataFrame",
        "name": "IDS_DATA_FRAME",
        "type": "Dimension",
        "min": 0,
        "max": 1,
        "acceptMND": false,
        "role": "frame.data"
    }, {
        "id": "trellisColumn",
        "name": "IDS_TRELLIS_COLUMN",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.columnCategory"
    }, {
        "id": "trellisRow",
        "name": "IDS_TRELLIS_ROW",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "trellis.rowCategory"
    }, {
        "id": "categoryAxis",
        "name": "IDS_CATEGORY_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "layout.category"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }, {
        "id": "valueAxis2",
        "name": "IDS_VALUE_AXIS2",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.secondValue"
    }];

    return feeds;
});
define('sap/viz/chart/components/trendline/mixin/timeLinePlot',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/trendline/mixin/scatterPlot',
    "sap/viz/chart/components/trendline/Trendline"
], function(Constants, oo, ScatterTrendLine, Trendline) {
    function TimeLinePlotTrendLine(){
    }
    oo.extend(TimeLinePlotTrendLine, ScatterTrendLine);
    TimeLinePlotTrendLine.prototype._getTrendLineContainer = function(trendlineG, container){
        var dataPointLayer = container.querySelector("."+Constants.CSS.CLASS.DATAPOINT_GROUP);
        if(dataPointLayer){
            container.insertBefore(trendlineG, dataPointLayer);
        }else{
            container.appendChild(trendlineG);
        }
    };
    return TimeLinePlotTrendLine;
});
define('sap/viz/chart/components/plots/TimePlotHelper',[
        'sap/viz/framework/common/util/TypeUtils',
        'sap/viz/framework/common/util/TimeUtil',
    ],
    function(
    TypeUtils,
    TimeUtil) {
        var helper = {};
        helper.getVisibleRange = function(instance){
            var result;
            if(instance._needLazyRender()){
                var scale = instance.getData().timeAxis.scale;
                var domain = scale.getDomain();
                var start = (-instance._offset.x) / instance._realSize.width * (domain[1] - domain[0])  + domain[0];
                var end = domain[0] + instance._visibleBound.x / 
                    instance._realSize.width * (domain[1] - domain[0]);
                result = {
                    min: start,
                    max: end
                };
            }
            return result;
        }; 
        helper.getDataPointRange = function(dataPoints, range){
            var low = 0, high = dataPoints.length -1;
            var ret = {
                min: low,
                max: high
            };
          
            if(range){
                var vIndexes = [];
                var count = 0;
                // In some case, some dataPoints doesn't exist in array, we have to filter these.
                for(var i = low; i <= high; ++i){
                    if(dataPoints[i]){
                        vIndexes[count++] = i; 
                    }
                }
                high = count - 1;
                var mid, rawData;
                var rValue = low;
                while (low < high) {
                    mid = Math.floor((low + high) / 2); 
                    rawData = dataPoints[vIndexes[mid]].getRawData();
                    if (rawData.timeAxis[0].parsedValue < range.min) {
                        low = mid + 1;
                        rValue = mid;
                    } else {
                        high = mid  - 1;
                    }
                }
                ret.min = low = vIndexes[rValue];
                
                rValue = high = count -1;
                while (low < high) {
                    mid = Math.floor((low + high) / 2); 
                    rawData = dataPoints[vIndexes[mid]].getRawData();
                    if (rawData.timeAxis[0].parsedValue > range.max) {
                        high = mid - 1;
                        rValue = mid;
                    } else {
                        low = mid + 1;
                    }
                }
                
                ret.max = vIndexes[rValue];
                
            }
            return ret;
        };
        return helper;
    }
);
define('sap/viz/chart/components/plots/TimeLinePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/chart/components/plots/LinePlot',
    'sap/viz/chart/components/plots/model/DataPointInfo',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/util/SeriesUtil',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/renderers/TimeReferenceLineRenderer',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/decorator/HitTestDecorator',
    'sap/viz/chart/components/trendline/mixin/timeLinePlot',
    'sap/viz/chart/components/plots/TimePlotHelper'
], function(
    oo,
    SVG,
    DOM,
    LinePlot,
    DataPointInfo,
    Series,
    ContextBuilder,
    ScaleHandler,
    SeriesUtil,
    Constants,
    ObjectUtils,
    TimeReferenceLineRenderer,
    NameColorUtils,
    DataUtils,
    HitTestDecorator,
    TrendLine,
    TimePlotHelper
) {

    var TimeLinePlot = function(runtime, options) {
        TimeLinePlot.superclass.constructor.apply(this, arguments);
        this._dataPointContext = [];
        this._calloutInfo = [];
    };

    oo.extend(TimeLinePlot, LinePlot);

    TimeLinePlot.prototype._buildData = function(dpConfig) {
        var ret = TimeLinePlot.superclass._buildData.apply(this, arguments);
        ret.timeField = this._data.timeAxis.metaData.map(function(e) {
            return e.id;
        });
        dpConfig.timeField = ret.timeField;
        return ret;
    };

    TimeLinePlot.prototype.getReferenceLineRenderer = function () {
        return TimeReferenceLineRenderer;
    };

    TimeLinePlot.prototype._getCategoryScaleHandlers = function() {
        return [ScaleHandler.getTimeScaleHandler("timeAxis", {
            isHorizontal: true
        })];
    };

    TimeLinePlot.prototype._getCategoryCount = function() {
        var cateAxis = this._data.timeAxis;
        return (cateAxis && cateAxis.rowArray) ? cateAxis.rowArray.length : 1;
    };
    
   

    TimeLinePlot.prototype._buildWrapperConfig = function(data, position, context, options) {
        options = options ? options : {};
        var config;
        var size = options.markerSize || this._properties.get("marker.size") || 
                                         this._properties.get("line.marker.size");
        var shape = options.markerShape || this._properties.get("marker.shape") || 
                                          this._properties.get("line.marker.shape");
        var ctx;
        if (this._isBigData) {
            var transparent = data.transparent || 0;
            var w = position.width;
            var h = position.height;
            var c = NameColorUtils.convertColor(options.color);
            config = {
                graphic: {
                    width: w,
                    height: h,
                    drawingEffect: this._drawingEffect || options.drawingEffect ||
                        this._properties.get('drawingEffect'),
                    fill: (options && options.seriesStyle && options.seriesStyle.color) ? 
                        NameColorUtils.convertColor(options.seriesStyle.color) : c,
                    opacity: 1 - transparent,
                    shape: shape,
                    size: size
                },
                data: {
                    color: c,
                    width: w,
                    height: h,
                    translate: [position.x, position.y]
                },
                effectManager: this._effectManager,
                rawData: data,
                horizontal : this.isHorizontal(),
                dataId: data.dp.id
            };
            //generare context is expensive, and is only used by combination chart
            if(this._isCombination){
                ctx = data.dp && data.dp.context() ? data.dp.context() : Constants.NULL_VALUE;
                config.ctx = ctx;
            }
            
            if(this._calloutInfo && this._calloutInfo.length) {
                //if the chart has _calloutInfo, we may need to draw some data points for callouts
                config.graphic.d = this._markerD;
            }
        } else {
            ctx = data.dp && data.dp.context() ? data.dp.context() : Constants.NULL_VALUE;
            // Not using arguments (which might change its length in this case) to enable v8 optimization.
            // Otherwise it will cause "not optimized: optimized too many times" issue in v8.
            config = TimeLinePlot.superclass._buildWrapperConfig.call(this,
                data, position, ctx, options);
            config.graphic.size = size;
        }
        return config;
    };

    TimeLinePlot.prototype._preRender = function() {
        var preSeries = this._series;
        TimeLinePlot.superclass._preRender.apply(this, arguments);
        this._series = preSeries || this._series || [];
        this._resetDataPoints();
    };

    TimeLinePlot.prototype._postRender = function(){
        TimeLinePlot.superclass._postRender.apply(this, arguments);
        // There might be zoom on time axis, so need to reposition referenceline here
        this._repositionReferenceLine();
    };
    
    TimeLinePlot.prototype.setCalloutInfo = function(_calloutInfo) {
        this._calloutInfo = _calloutInfo;
    };
  
    TimeLinePlot.prototype._getVisibleRange = function(){
        return TimePlotHelper.getVisibleRange(this);  
    };
   

    TimeLinePlot.prototype._hideDataPoints = function(dataPoints, range){
        if (!this._isBigData){
            return TimeLinePlot.superclass._hideDataPoints.apply(this, arguments);
        } else {
            dataPoints.forEach(function(dp){
                if (dp){
                    var node = dp.getNode();
                    DOM.remove(node);
                    dp.setNode(null);
                }
            });
        }
    };
    
    TimeLinePlot.prototype.isDrawDataPointForCallout = function(dataPointID) {
        var drawCurrentDataPoint = false;
        var i;
        for(i = 0; i < this._calloutInfo.length; i++) {
            if(this._calloutInfo[i].dpId === dataPointID) {
                drawCurrentDataPoint = true;
                break;
            }
        }
        return drawCurrentDataPoint;
    };

    TimeLinePlot.prototype._getDataPointRange = function(dataPoints, range){
        return TimePlotHelper.getDataPointRange(dataPoints, range);
    };

    TimeLinePlot.prototype._showDataPoints = function() {
        this._preShowDataPoints();
        var newDataPoints = [];
        var timeField = this._data.timeAxis.metaData.map(function(e) {
            return e.id;
        });
        this._dataPointContext = [];
        this._seriesRenderer.resetDataPoints();
        var shape = this._getMarkerShape();
        var options = {
            color: null,
            markerShape: shape,
            markerSize: this._properties.get('marker.size'),
            drawingEffect: this._properties.get('drawingEffect')
        };
        var range = this._getVisibleRange();
        // The default invalidity value is 'break'
        var allowBreakLine = Constants.DATAPOINT_INVALIDITY_SUPPORTED.indexOf(
                this._properties.get('dataPoint.invalidity')) <= 0;
        for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
            var seriesStyle = this.getSeriesDPStyle(seriesIndex, null, true);
            var seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }

            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
            var color = null;
            var dataPoints = seriesModel.getDataPoints();
            var curRange = this._getDataPointRange(dataPoints, range);
            this._hideDataPoints(dataPoints, curRange);
            curRange = curRange || {min: 0, max: dataPoints.length - 1};
            for (var itemIndex = curRange.min; itemIndex <= curRange.max; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }
                var position = this._getDataPointPosition(dataPointModel);
                if (!position || isNaN(position.x)) {
                    continue;
                }
                var currentId = dataPointModel.getId();
                var dpNode = null;
                var dpConfig = dataPointModel.getConfig();
                var data = dataPointModel.getRawData();
                if (!color) {
                    color = this._getColor(data);
                }

                if(allowBreakLine && data.dp.ignore){
                    // Insert a null position for series renderer to break the line
                    position = null;
                    //Even data point is ignored, still need carry on its color to series util for line renderer
                    if (!dpConfig) {
                        dpConfig = {
                            graphic: {
                                fill: color,
                            }
                        };
                    }
                }else{
                    if(!dpConfig){
                        options.color = color;

                        // don't bind context into dom in time-line chart
                        options.seriesStyle = seriesStyle;
                        dpConfig = this._buildWrapperConfig(data, position, null, options);
                        dpConfig.timeField = timeField;
                        dpConfig.seriesIndex = seriesIndex;
                        dpConfig.itemIndex = itemIndex;
                        dpConfig.seqId = currentId;
                    }
                    this._dataPointContext[data.dp.id] = dpConfig;
                    
                    if (!this._isBigData || this.isDrawDataPointForCallout(data.dp.id)) {
                        var dpData = dataPointModel.getData();
                        if(!dpData){
                            dpData = this._buildData(dpConfig);
                            dataPointModel.init(dpConfig, currentId, dpData, data.dp.id);
                        }

                        dpNode = dataPointModel.getNode();
                        if(dpNode){
                            this._updateDatapoint(dpNode, dpRenderer, dpConfig, position);
                        } else {
                            dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                            dataPointModel.setNode(dpNode);
                        }
                        if (dpNode) {
                            newDataPoints.push(dpNode);
                        }
                    }
                }
                this._seriesRenderer.addDataPoint(seriesIndex, itemIndex, dpConfig, position, dpNode);
            }
        }

        return newDataPoints;
    };

  

    TimeLinePlot.prototype.destroy = function() {
        TimeLinePlot.superclass.destroy.call(this);
        this._dataPointContext = null;
        this._calloutInfo = null;
    };

    TimeLinePlot.prototype._getDefaultZeroLineColor = function() {
        return this._properties.origin.get("timeAxis.color");
    };

    TimeLinePlot.prototype._calMarkProps = function() {
        var series = this._getSeries();
        var seriesMaxLength = SeriesUtil.getMaxSeriesLength(series);
        var isBigDataTmp = SeriesUtil.isBigDensityMode(this._realSize.width, seriesMaxLength);
        this._isBigData = isBigDataTmp;
        var _hoverOnlyMode = this._properties.get('marker.hoverOnlyMode');
        this._isMarkerVisible = this._properties.get('marker.visible');
        if (!_hoverOnlyMode) {
            this._isBigData = false;
            if (isBigDataTmp) {
                this._isMarkerVisible = false;
            }
        }
    };

    TimeLinePlot.prototype.isBigDataMode = function() {
        this._calMarkProps();
        return this._isBigData;
    };

    TimeLinePlot.prototype.getDataPointGraphicFromLineRenderer = function (context) {
        if (this._lineRenderer.getGraphic) {
            var rendererGraphic = this._lineRenderer.getGraphic(context);
            return rendererGraphic;
        }
    };

    TimeLinePlot.prototype.getDataPointsRenderInfo = function () {
        var lineRenderer = this._lineRenderer;
        var getRendererDataWithGraphicColor = this._lineRenderer.getGraphic ? function (dpInfo) {
            var context = dpInfo.rawData.dp.context();
            var data = dpInfo.data;
            var rendererGraphic = lineRenderer.getGraphic(context);
            if (rendererGraphic && rendererGraphic.color) {
                data = ObjectUtils.extend({}, data, {color: rendererGraphic.color});
            }
            return data;
        } : function (dpInfo) {
            return dpInfo.data;
        };
        return this._dataPointContext && this._dataPointContext
            .filter(function (e) { return !!e; })
            .map(function (dpInfo) {
                var data = getRendererDataWithGraphicColor(dpInfo);
                return {
                    dataId: dpInfo.dataId,
                    seriesIndex: dpInfo.seriesIndex,
                    itemIndex: dpInfo.itemIndex,
                    graphic: dpInfo.graphic,
                    data: data,
                    context: dpInfo.rawData.dp.context(),
                    width: dpInfo.graphic.size,
                    height: dpInfo.graphic.size
                };
            });
    };

    TimeLinePlot.prototype._shiftOffsetForIncompleteRange = function(){
        //do nothing
    };

    TimeLinePlot.prototype.mappingDataPointInfo = function(id) {
        var dpInfo = this._dataPointContext[id];

        if (dpInfo == null) {
            return null;
        }

        return dpInfo;
    };

    (new HitTestDecorator()).decorate(TimeLinePlot);
    (new TrendLine()).inject(TimeLinePlot.prototype);
    return TimeLinePlot;
});

define('sap/viz/chart/components/trendline/mixin/timeColumnPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/trendline/mixin/scatterPlot',
    "sap/viz/chart/components/trendline/Trendline"
], function(oo, ScatterTrendLine, Trendline) {
    function TimeColumnPlotTrendLine(){
    }
    oo.extend(TimeColumnPlotTrendLine, ScatterTrendLine);
    return TimeColumnPlotTrendLine;
});
define('sap/viz/chart/components/plots/TimeColumnPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/chart/components/plots/ColumnPlot',
    'sap/viz/chart/components/plots/model/DataPointInfo',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/util/SeriesUtil',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/renderers/TimeReferenceLineRenderer',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/chart/components/plots/BarWidthUtils',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/components/trendline/mixin/timeColumnPlot',
    'sap/viz/chart/components/plots/TimePlotHelper'
], function(
    oo,
    SVG,
    DOM,
    ColumnPlot,
    DataPointInfo,
    Series,
    ContextBuilder,
    ScaleHandler,
    SeriesUtil,
    Constants,
    ObjectUtils,
    TimeReferenceLineRenderer,
    NameColorUtils,
    DataUtils,
    TimeUtil,
    BarWidthUtils,
    TypeUtils,
    TimeColumnPlotTrendLine,
    TimePlotHelper
) {

    var TimeColumnPlot = function(runtime, options) {
        TimeColumnPlot.superclass.constructor.apply(this, arguments);
        this._dataPointContext = [];
    };

    oo.extend(TimeColumnPlot, ColumnPlot);

    TimeColumnPlot.prototype._buildData = function(dpConfig) {
        var ret = TimeColumnPlot.superclass._buildData.apply(this, arguments);
        ret.timeField = this._data.timeAxis.metaData.map(function(e) {
            return e.id;
        });
        dpConfig.timeField = ret.timeField;
        return ret;
    };

    // As required by PO, Time column would use column's count to decide whether to use saving mode or not.
    // Comment out following paragraph to enable column's mechanism.

    // TimeColumnPlot.prototype._getDpCount = function(){
    //     var domain = this._data.timeAxis.scale.getDomain();
    //     var utc = this._properties.origin.get("general.showAsUTC");
    //     var minLevel = this.runtime().statusManager().get("timeLevels")[0];
    //     var dpCount = TimeUtil.getTickNumberByLevel(...
    //     return dpCount;
    // };

    TimeColumnPlot.prototype.getReferenceLineRenderer = function () {
        return TimeReferenceLineRenderer;
    };

    TimeColumnPlot.prototype._getBarProperties = function(){
        if(!this._barInfoProperties){
            var options = this._barInfoProperties = BarWidthUtils.getBarProperties(this._properties.origin);
            var props = this._properties.origin;
            var timeLevels = this.runtime().statusManager().get('timeLevels');
            options.isHorizontal = true;
            options.minTimeLevel = timeLevels.length? timeLevels[0]:["day"];
            options.showAsUTC = props.get('general.showAsUTC');
        }
        return this._barInfoProperties;
    };

    TimeColumnPlot.prototype._getCategoryScaleHandlers = function() {
        var barProperties = this._getBarProperties();
        this._categoryScaleHandler = ScaleHandler.getTimeScaleHandler("timeAxis", barProperties);
        return [this._categoryScaleHandler];
    };

    TimeColumnPlot.prototype._getCategoryCount = function() {
        return this._calcCount ? (this._calcCount - 1):1;
    };

    TimeColumnPlot.prototype._preRender = function() {
        var preSeries = this._series;
        TimeColumnPlot.superclass._preRender.apply(this, arguments);
        this._series = preSeries || this._series || [];
        this._resetDataPoints();
    };

    TimeColumnPlot.prototype._postRender = function(){
        TimeColumnPlot.superclass._postRender.apply(this, arguments);
        // There might be zoom on time axis, so need to reposition referenceline here
        this._repositionReferenceLine();
    };


    TimeColumnPlot.prototype.destroy = function() {
        TimeColumnPlot.superclass.destroy.call(this);
        this._dataPointContext = null;
    };

    TimeColumnPlot.prototype._getDefaultZeroLineColor = function() {
        return this._properties.origin.get("timeAxis.color");
    };

    TimeColumnPlot.prototype.getRealSizeByFixedDPSize = function(ColumnWidth) {
        var plotWidth =
            TimeColumnPlot.superclass.getRealSizeByFixedDPSize.call(this,
            ColumnWidth, this._getColumnCount(), this._getCategoryCount());
        return plotWidth;
    };



    TimeColumnPlot.prototype._getRangeTick = function() {
        var scale = this.getData().timeAxis.scale;
        var domain = scale.getDomain();
        //This assertion is to judge full no value data set.
        if (domain[0] === Infinity && domain[1] === -Infinity){
            return 0;
        }
        var options = this._getBarProperties();
        var minLevel = options.minTimeLevel;
        minLevel = TypeUtils.isArray(minLevel)? minLevel[0]: minLevel;
        var utc = options.showAsUTC;
        var start = TimeUtil.truncate(domain[0], minLevel, utc, this._properties.origin);
        var end = TimeUtil.truncate(domain[1], minLevel, utc, this._properties.origin);
        if (start === end){
            end = TimeUtil.nextDateByLevel(end, minLevel, utc, this._properties.origin);
        }
        this._calcCount = TimeUtil.getTickNumberByLevel(minLevel, start, end, utc, this._properties.origin);
    };

    TimeColumnPlot.prototype._getVisibleRange = function(){
        return TimePlotHelper.getVisibleRange(this);
    };
    // For time
    TimeColumnPlot.prototype._getDataPointRange = function(dataPoints, range){
        return TimePlotHelper.getDataPointRange(dataPoints, range);
    };

    TimeColumnPlot.prototype._getColumnWidthRatio = function(){
        this._getRangeTick();
        //Let barWidth=x, then (count-1)*x +(count-1)*spacing*x=wholeWidth
        var barWidth =
            BarWidthUtils.getBarInfo(this._getColumnCount(), this._getBarProperties()).barWidth/(this._calcCount - 1);

        return barWidth;
    };

    TimeColumnPlot.prototype._getColumnWidth = function() {
        return this._getColumnWidthRatio() * this._size.width;
    };

    TimeColumnPlot.prototype.getPreferredSize = function(){
        var barWidth = this._getColumnWidthRatio();
        this._categoryScaleHandler.updateBarWidth(this._getColumnWidthRatio(),
            this._getBarProperties().innerGroupSpacing * barWidth,
            this._getColumnCount());
        return  TimeColumnPlot.superclass.getPreferredSize.call(this);
    };

    TimeColumnPlot.prototype._updateBarWidth = function(maxWidth) {
        var barWidth = maxWidth / this._size.width;
        this._categoryScaleHandler.updateBarWidth(barWidth,
            this._getBarProperties().innerGroupSpacing * barWidth,
            this._getColumnCount());
    };

    TimeColumnPlot.prototype._shiftOffsetForIncompleteRange = function(){
        //do nothing
    };

    //this maybe able to be moved to columnPlot, but afraid of regression issue
    TimeColumnPlot.prototype._adjustPosition = function(position, seriesIndex){
        TimeColumnPlot.superclass._adjustPosition.apply(this,arguments);
        var max = this._properties.get("dataPointSize.max");
        if(TypeUtils.isNumber(max) && position.width > max){
            position.x = position.x + position.width/2 - max/2;
            position.width = max;
        }
    };
    (new TimeColumnPlotTrendLine()).inject(TimeColumnPlot.prototype);
    return TimeColumnPlot;
});

define('sap/viz/chart/components/decorator/HitTestCombDecorator',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/ArrayUtils',
    "sap/viz/chart/components/util/BoundingBoxUtils",
    'sap/viz/chart/components/decorator/BaseHitTestDecorator',
    'sap/viz/chart/components/util/HitTestUtils'
], function(
    oo,
    ArrayUtils,
    BoundingBoxUtils,
    BaseHitTestDecorator,
    HitTestUtils
) {
    var isInCircle = HitTestUtils.isInCircle;
    var isInRect =  HitTestUtils.isInRect;
    var isInRectWithRatio = HitTestUtils.isInRectWithRatio;

    //hit test decorator for combination chart
    var HitTestCombDecorator = function() {
        HitTestCombDecorator.superclass.constructor.apply(this, arguments);
        this._decos.hitTest = function(coord, sortByShape) {
            var datas = this._dataPointContext,
                x = coord.left,
                y = coord.top;
            var result;
            var that = this;
            //Calculate a ratio in case user set a css transform especially scale on root chart div
            var plotBound = this._selection.select(".v-plot-bound").node();
            var ratio = plotBound.getBoundingClientRect().width / plotBound.getBBox().width;

            if (coord.hasOwnProperty("width") && coord.hasOwnProperty("height")) {
                var width = coord.width;
                var height = coord.height;
                var size = this.getSize();
                var offset = this._offset;
                var startXRange = -offset.x;
                var startYRange = -offset.y;
                coord.left = coord.left + startXRange;
                coord.top = coord.top + startYRange;
                var plotWidth = size.width;
                var plotHeight = size.height;
                if (ratio != 1){
                    plotWidth *= ratio;
                    plotHeight *= ratio;
                }
                var plotRect = {
                    left: startXRange,
                    top: startYRange,
                    width:plotWidth,
                    height:plotHeight
                };

                if(!BoundingBoxUtils.intersects(plotRect, coord)){
                    //if the selection happen outside the plotarea, do nothing
                    return [];
                }

                //the lassor range only work inside plotarea
                coord = BoundingBoxUtils.intersection(plotRect, coord);

                result = datas.filter(function(e) {
                    var seriesIndex = e.seriesIndex;
                    var shape = that.getDataPointShape(seriesIndex);
                    //decide according to it shape
                    if(shape === "bar"){
                        var position = e.position;
                        var p = {
                            left: position.x,
                            top: position.y,
                            width: position.width,
                            height: position.height
                        };

                        if (ratio != 1){
                            p.left *= ratio;
                            p.top *= ratio;
                            p.width *= ratio;
                            p.height *= ratio;
                        }

                        return BoundingBoxUtils.intersects(p, plotRect) &&
                        BoundingBoxUtils.intersects(p, coord);
                    }else{
                        var translate = e.data.translate.slice();
                        if (ratio != 1){
                            translate[0] *= ratio;
                            translate[1] *= ratio;
                        }
                        return translate[0] >= startXRange && translate[0] <= plotWidth + startXRange &&
                            isInRect(translate, [x + startXRange, y + startYRange], width, height);
                    }
                });
            } else {
                //decide according to it shape
                result = datas.filter(function(e) {
                    var seriesIndex = e.seriesIndex;
                    var shape = that.getDataPointShape(seriesIndex);
                    if(shape === "bar"){
                        return isInRectWithRatio(coord, e.position, ratio);
                    }else{
                        return isInCircle(e.data.translate, [x, y], 4);
                    }
                });
            }

            if(sortByShape){
               //sort the result such that line is ahead bar
                ArrayUtils.stableSort(result, function(a, b){
                    var value1 = that.getDataPointShape(a.seriesIndex) === "bar"? 1 : 0;
                    var value2 = that.getDataPointShape(b.seriesIndex) === "bar"? 1 : 0;
                    return value1 - value2;
                });
            }
            return result;
        };
    };

    oo.extend(HitTestCombDecorator, BaseHitTestDecorator);

    return HitTestCombDecorator;
});
define('sap/viz/chart/components/plots/TimeStackedColumnPlot',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/plots/ColumnPlot",
    "sap/viz/chart/components/plots/TimeColumnPlot",
    "sap/viz/chart/components/plots/StackedColumnPlot",
    "sap/viz/chart/components/plots/ScaleHandler",
    'sap/viz/chart/components/plots/StackedPlotHelper'
], function(
    oo,
    ColumnPlot,
    TimeColumnPlot,
    StackedColumnPlot,
    ScaleHandler,
    StackedPlotHelper
) {

    var TimeStackedColumnPlot = function(runtime, options) {
        TimeStackedColumnPlot.superclass.constructor.apply(this, arguments);
    };

    oo.extend(TimeStackedColumnPlot, TimeColumnPlot);

    TimeStackedColumnPlot.prototype._getColor = ColumnPlot.prototype._getColor;

    TimeStackedColumnPlot.prototype._adjustPosition = StackedColumnPlot.prototype._adjustPosition;

    TimeStackedColumnPlot.prototype._drawDatapoints = StackedColumnPlot.prototype._drawDatapoints;

    TimeStackedColumnPlot.prototype._updateDatapoints = StackedColumnPlot.prototype._updateDatapoints;

    TimeStackedColumnPlot.prototype._needValidEmptyAxisData = StackedColumnPlot.prototype._needValidEmptyAxisData;

    TimeStackedColumnPlot.prototype._showDataPoints = StackedColumnPlot.prototype._showDataPoints;

    TimeStackedColumnPlot.prototype._drawCategory = StackedColumnPlot.prototype._drawCategory;

    TimeStackedColumnPlot.prototype._getDataHandler = StackedColumnPlot.prototype._getDataHandler;

    TimeStackedColumnPlot.prototype._getSeries = StackedColumnPlot.prototype._getSeries;

    TimeStackedColumnPlot.prototype._generatePath = StackedColumnPlot.prototype._generatePath;

    TimeStackedColumnPlot.prototype._getDataLabels = StackedColumnPlot.prototype._getDataLabels;

    TimeStackedColumnPlot.prototype._removeEmptyStacks = StackedColumnPlot.prototype._removeEmptyStacks;

    TimeStackedColumnPlot.prototype._getVisibleRange = function(){
        return StackedPlotHelper.getVisibleRange(this, TimeColumnPlot);
    };

    TimeStackedColumnPlot.prototype._pushDataPointContext = function(dpConfig) {
        if (dpConfig) {
            this._dataPointContext[dpConfig.dataId] = dpConfig;
        }
    };

    TimeStackedColumnPlot.prototype._getCategoryScaleHandlers = function() {
        var barProperties = this._getBarProperties();
        barProperties.forSingleBar = true;
        this._categoryScaleHandler = ScaleHandler.getTimeScaleHandler("timeAxis", barProperties);
        return [this._categoryScaleHandler];
    };

    TimeStackedColumnPlot.prototype._getColumnWidthRatio = function() {
        var options = this._getBarProperties();
        var barSpacing = options.barSpacing;
        this._getRangeTick();
        var barWidth =  1 / (this._calcCount - 1) / (1 + barSpacing);
        return barWidth;
    };

    TimeStackedColumnPlot.prototype._getColumnCount = function() {
        return 1;
    };

    return TimeStackedColumnPlot;
});

define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForComb',[
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/components/util/ChartTypeUtils",
    'sap/viz/chart/components/util/DataPointUtils',
    "sap/viz/chart/behavior/config/SelectionUtil",
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/framework/common/util/ObjectUtils',
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/interaction/BehaviorManager",
    'sap/viz/chart/behavior/config/handler/DataPointBehaviorHandler'
], function(
    HighlightHelper,
    ChartTypeUtils,
    DataPointUtils,
    SelectionUtil,
    TypeUtils,
    ObjectUtils,
    DataGraphics,
    BehaviorManager,
    DPBhvrHdlr
) {
    var timeCombTypes = ["info/timeseries_combination","info/dual_timeseries_combination"];
    var timeStackType = ["info/timeseries_stacked_combination"];
    var allTypes = timeStackType.concat(timeCombTypes);
    var setMakerOpacity = DPBhvrHdlr.setMakerOpacity;

    function seperateBarLine(idArray, service){
        var dataModel = service.getDataModel();
        var plotModule = service.getModule("main.plot");
        var barInfos = [], lineInfos = [];

        for (var i = 0; i < idArray.length; i++) {
            var id = idArray[i];
            var dataPoint = dataModel.getDataPoint(id);
            if (dataPoint) {
                var shape = plotModule.getDataPointShape(dataPoint);
                if(shape === "line"){
                    lineInfos.push(id);
                }else if(shape === "bar"){
                    barInfos.push(id);
                }
            }
        }  

        return {
            bar: barInfos,
            line: lineInfos
        };
    }

    function seperateBarLineDom(targets, service){
        var plot = service.getModule("main.plot");
        var dataModel = service.getDataModel();
        
        var elements = HighlightHelper.turnToArray(targets);
        var barInfos = [], lineInfos = [];

        elements.forEach(function(e){
            var dataId = DataPointUtils.getDataPointId(e);
            var dataPoint = dataModel.getDataPoint(dataId);
            var shape = plot.getDataPointShape(dataPoint);
            if(shape === "line"){
                lineInfos.push(e);
            }else {
                barInfos.push(e);
            }
        });

        return {
            bar: barInfos,
            line: lineInfos
        };
    }

    function selectOnCombOnNormalMode(event, service){
        var original = event.data.targets;
        var shapes = seperateBarLineDom(event.data.targets, service);

        event.data.targets = shapes.bar;
        DPBhvrHdlr.selectOnBarOnNormalMode(event, service);

        event.data.targets = shapes.line;
        DPBhvrHdlr.selectOnLineOnNormalMode(event, service);

        event.data.targets = original;
    }

    var comb = [{
        "id": "selectDataPoint_comb",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": timeCombTypes
        }, 
        "handler": function(event, service) {
            if (service.isBigDataMode()) {
                DPBhvrHdlr.selectOnCombinationDuringBigData(event, service);
            } else {
                selectOnCombOnNormalMode(event, service);
            }
        }
    }, {
        "id": "selectDataPoint_stacked_comb",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": timeStackType
        }, 
        "handler": function(event, service) {
            if (service.isBigDataMode()) {
                var original = event.data.targets;

                var shapes = seperateBarLine(event.data.targets, service);
                //bar in normal mode
                event.data.targets = DataPointUtils.getNodeDom(shapes.bar, service);
                DPBhvrHdlr.selectOnBarOnNormalMode(event, service);
                //line as big data
                event.data.targets = shapes.line;
                DPBhvrHdlr.selectOnLineDuringBigData(event, service);

                event.data.targets = original;
            } else {
                selectOnCombOnNormalMode(event, service);
            }
        }
    }, {
        "id": "hoverOnDataPoint_comb",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": timeCombTypes
        },
        "handler": function(event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                DPBhvrHdlr.highlightOnCombDuringBigData(event, service);
            } else {
                DPBhvrHdlr.hoverEffectDuringNormalMode(event, service);
            }
        }
    }, {
        "id": "hoverOnDataPoint_stack_comb",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": timeStackType
        },
        "handler": function(event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                var original = event.data.targets;
                var selectedDataPoints = service.getStatus('selectedDataPoints');
                var allItems = selectedDataPoints.concat(event.data.targets);

                //bar in normal mode
                //so it only needs to hover new targer
                var shapes = seperateBarLine(event.data.targets, service);
                event.data.targets = DataPointUtils.getNodeDom(shapes.bar, service);
                DPBhvrHdlr.hoverEffectDuringNormalMode(event, service);

                //line as big data
                //so it need to hover both old and new
                shapes = seperateBarLine(allItems, service);
                event.data.targets = shapes.line;
                DPBhvrHdlr.selectOnLineDuringBigData(event, service);

                event.data.targets = original;
            } else {
                DPBhvrHdlr.hoverEffectDuringNormalMode(event, service);
            }
        }
    }, {
        "id": "unhoverOnDataPoint_comb_big_data",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": timeCombTypes
        },
        "handler": function (event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                DPBhvrHdlr.unhighlightOnCombDuringBigData(event, service);
            }else{
                DPBhvrHdlr.unhoverEffectDuringNormalMode(event, service);
            }
        }
    }, {
        "id": "unhoverOnDataPoint_stk_comb_big_data",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": timeStackType
        },
        "handler": function (event, service) {
            if (service.isBigDataMode() && !service.isTrellis()) {
                var original = event.data.targets;

                //unhover the bar 
                var shapes = seperateBarLine(event.data.targets, service);
                event.data.targets = DataPointUtils.getNodeDom(shapes.bar, service);
                DPBhvrHdlr.unhoverEffectDuringNormalMode(event, service);

                //hightlight previous line again
                var selectedDataPoints = service.getStatus('selectedDataPoints');
                var prev = seperateBarLine(selectedDataPoints, service);
                event.data.targets = prev.line;
                DPBhvrHdlr.selectOnLineDuringBigData(event, service);

                event.data.targets = original;
            }else{
                DPBhvrHdlr.unhoverEffectDuringNormalMode(event, service);
            }
        }
    }, {
        "id": "deselectDataPoint_comb",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": allTypes
        },
        "handler": function(event, service) {
            if (service.isBigDataMode()) {
                return;
            }
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            var properties = service.getProperties();
            var lineRenderer;
            var isMarkerRendererExist = TypeUtils.isExist(properties.get('plotArea.markerRenderer'));
            var plot = service.getModule("main.plot");
            var dataModel = service.getDataModel();

            elements.forEach(function(e) {
                var dataId = DataPointUtils.getDataPointId(e);
                var dataPoint = dataModel.getDataPoint(dataId);
                var shape = plot.getDataPointShape(dataPoint);
                var width = 1;
                if (event.data.isAnyOtherSelected) {
                    prop = properties.get('interaction.deselected');
                } else {
                    prop = properties.get('plotArea.dataPoint');
                    var extraData = DataGraphics.getData(e);
                    if (extraData) {
                        width = extraData.strokeWidth;
                    }
                }

                if(shape === "line"){
                    DataPointUtils.unhighlight(e);
                    lineRenderer = DPBhvrHdlr.getLineRenderer(service, e);
                    DPBhvrHdlr.renderLightLine(service, e, false, lineRenderer);
                    
                    HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, width);
                    HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRendererExist, true);
                    setMakerOpacity(service, e);
                }else{
                    HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, width);
                    HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
                }
            });
        }
    },{
        "id": "clearPlot_comb",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": allTypes
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            service._getDecorationLayer().clear();

            var gray = event.data.isGray;
            var rangeSelection = event.data.rangeSelection;
            var bUseRange = rangeSelection && rangeSelection !== "clear";
            var props = service.getProperties();
            var prop = props.get('interaction.deselected');

            DPBhvrHdlr.cleanLine(event, service);

            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if (!mainNode || !mainNode.length) {
                DPBhvrHdlr.cleanBar(event, service);
                return;
            }

            var plot = service.getModule("main.plot");
            var dataModel = service.getDataModel();

            var isMarkerRendererExist = TypeUtils.isExist(props.get('plotArea.markerRenderer'));
            mainNode.forEach(function(e) {
                var width = 1;
                if (gray || bUseRange) {
                    if (bUseRange) {
                        prop = ObjectUtils.extend(true, {}, prop);
                        prop.opacity = 1;
                    }
                } else {
                    prop = props.get('plotArea.dataPoint');
                    var extraData = DataGraphics.getData(e);
                    if (extraData) {
                        width = extraData.strokeWidth;
                        width = TypeUtils.isExist(width) ? width : 1;
                    }
                }

                var dataId = DataPointUtils.getDataPointId(e);
                var dataPoint = dataModel.getDataPoint(dataId);
                var shape = plot.getDataPointShape(dataPoint);
                if(shape === "line"){
                    HighlightHelper.drawStroke(service, e, 'path, rect', prop.stroke, width);
                    HighlightHelper.drawFill(service, e, 'path, rect', prop, isMarkerRendererExist, true);
                    setMakerOpacity(service, e);
                }else{
                    HighlightHelper.drawStroke(service, e, 'rect', prop.stroke, width);
                    HighlightHelper.drawFill(service, e, 'rect, path', prop, isMarkerRendererExist);
                }
            });
        }
    }];
    BehaviorManager.registerAll(comb);
    return comb;
    
});

define('sap/viz/chart/components/plots/TimeCombinationPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/chart/components/plots/TimeColumnPlot',
    'sap/viz/chart/components/plots/TimeLinePlot',
    'sap/viz/chart/components/plots/CombinationPlot',
    'sap/viz/chart/components/plots/BaseLinePlot',
    'sap/viz/chart/components/plots/LinePlot',
    'sap/viz/chart/components/plots/model/Series',
    'sap/viz/chart/components/util/BarSeriesUtil',
    "sap/viz/framework/common/util/TypeUtils",
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/decorator/HitTestCombDecorator',
    'sap/viz/framework/common/util/DataGraphics',
    "sap/viz/framework/common/util/Constants",
    'sap/viz/chart/components/util/LineRendererUtil',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/chart/components/plots/TimeStackedColumnPlot',
    'sap/viz/chart/behavior/config/DataPointBehaviorConfigForComb'
], function(
    oo,
    SVG,
    DOM,
    TimeColumnPlot,
    TimeLinePlot,
    CombinationPlot,
    BaseLinePlot,
    LinePlot,
    Series,
    SeriesUtil,
    TypeUtils,
    SeriesRenderer,
    HitTestDecorator,
    DataGraphics,
    Constants,
    LineRendererUtil,
    DrawUtil,
    TimeStackedColumnPlot
) {

    var LINE = "line";
    var BAR = "bar";
    var TimeCombinationPlot = function(runtime, options) {
        TimeCombinationPlot.superclass.constructor.apply(this, arguments);
        this._isCombination = true;
        this._isBigData = false;
        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.setUseSemanticPattern(true);
        semanticMgr.setUseSemanticDPLineStyle(true);
        this._attachMarkManager();
        this.lineMarkerShapePW = this._properties.watch("line.marker.shape", this._onDataShapeChange.bind(this));
        this._isInTrellis = false;
        this._markerPropName = "line.marker";
        this._defaultLineRenderer = LineRendererUtil.getDefaultRenderer(this._properties.get("line.isSmoothed"));
        this._isFlexibleStack = false;
    };
    oo.extend(TimeCombinationPlot, TimeColumnPlot);

    TimeCombinationPlot.prototype._isSupportBarPathGenerator = function () {
        return true;
    };

    TimeCombinationPlot.prototype._applyScroll = function(){
        return TimeLinePlot.prototype._applyScroll.apply(this, arguments);
    };
    TimeCombinationPlot.prototype._getPatternConfig = BaseLinePlot.prototype._getPatternConfig;
    TimeCombinationPlot.prototype._isLineVisible = function (){
        return this._properties.get('line.visible');
    };

    TimeCombinationPlot.prototype.getLineRenderer = function(){
        if (!this._lineRenderer){
            var props = this._properties;
            this._lineRenderer = LineRendererUtil.getRenderer(
                props.get('line.lineRenderer'),
                props.get("line.isSmoothed")
            );
        }
        return this._lineRenderer;
    };

    TimeCombinationPlot.prototype._renderNode = TimeLinePlot.prototype._renderNode;
    TimeCombinationPlot.prototype._preShowDataPoints = function() {
        var offset = this._offset;
        var offsetX = offset.hasOwnProperty("x") ? offset.x : 0;
        var offsetY = offset.hasOwnProperty("y") ? offset.y : 0;
        if (this._positionInWindow) {
            offsetX += this._positionInWindow.hasOwnProperty("x") ? this._positionInWindow.x : 0;
            offsetY += this._positionInWindow.hasOwnProperty("y") ? this._positionInWindow.y : 0;
        }
        var maxSize = this._getMaxVisibleSize();
        this._visibleBound = {
            x : maxSize.width - offsetX,
            y : maxSize.height - offsetY
        };

        var prevMode = this._isBigData;
        TimeColumnPlot.prototype._preShowDataPoints.apply(this, arguments);

        //change from normal mode to big data mode or vice versa
        if(prevMode !== this._isBigData){
            //hide all bars
            for (var seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
                var shape = this._getDataShape(seriesIndex);
                if(shape === BAR){
                    var seriesModel = this._series[seriesIndex];
                    var dataPoints = seriesModel.getDataPoints();
                    for(var i=0; i<dataPoints.length; i++){
                        this._hideNode(dataPoints, i);
                    }
                }
            }
        }

        this._isMarkerVisible = this._isBigData? false: this._properties.get('line.marker.visible');
    };

    TimeCombinationPlot.prototype._preRender = function(){
        LinePlot.prototype._preRender.apply(this,arguments);

        return TimeColumnPlot.prototype._preRender.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._buildData = function(dpConfig){
        var shape = this._getDataShape(dpConfig.seriesIndex);
        var result;

        if(shape === BAR){
            result = TimeColumnPlot.prototype._buildData.apply(this, arguments);
            result.type = BAR;
        }else{
            result = TimeLinePlot.prototype._buildData.apply(this, arguments);
            result.type = LINE;
        }

        return result;
    };

    TimeCombinationPlot.prototype._buildConfig = function(data, position, context) {
        var shape = this.getDataPointShape(data.dp);
        if(shape === BAR){
            return TimeColumnPlot.prototype._buildConfig.apply(this, arguments);
        }else{
            return TimeLinePlot.prototype._buildConfig.apply(this, arguments);
        }
    };

    //an important method that will construct the config of datapoint
    //used to decide the datapoint rendering and etc
    TimeCombinationPlot.prototype._buildWrapperConfig = function(data, position, context, option){
        var seriesIndex = this.getSeriesIndex(data.dp);
        var shape = this._getDataShape(seriesIndex);
        var config;
        if(shape === BAR){
            option.seriesType = "bar";
            config = TimeColumnPlot.prototype._buildWrapperConfig.apply(this, arguments);
            config["isLineMarker"] = false;
        }else if(shape === LINE){
            if(!data.hasOwnProperty('transparent')){
                data.transparent =  this._isMarkerVisible? 0:1;
            }
            option.seriesType = "line";
            config = TimeLinePlot.prototype._buildWrapperConfig.apply(this, arguments);
            config.graphic.opacity = this._properties.get("line.marker.visible")? 1:0;
            config.graphic.d = config.graphic.d || this._markerD;
            config["isLineMarker"] = true;
            config.data.width = 0;
        }
        var ctx = data.dp && data.dp.context() ? data.dp.context() : Constants.NULL_VALUE;
        config.ctx = ctx;
        return config;
    };

    TimeCombinationPlot.prototype.getDataPointShape = function(dataPoint){
        if(TypeUtils.isNumber(arguments[0])){
            return this._getDataShape(arguments[0]);
        }else{
            return this._getDataShape(dataPoint._addr[1]);
        }
    };

    TimeCombinationPlot.prototype._createMainNode = BaseLinePlot.prototype._createMainNode;

    TimeCombinationPlot.prototype._getClipPathAttribute = BaseLinePlot.prototype._getClipPathAttribute;

    TimeCombinationPlot.prototype.zoom = BaseLinePlot.prototype.zoom;

    TimeCombinationPlot.prototype.scroll = BaseLinePlot.prototype.scroll;

    TimeCombinationPlot.prototype._isNeedSimplifyLine = function(){
        return false;
    };

    //decide the shape of a series. line or bar
    TimeCombinationPlot.prototype._getDataShape = function(seriesIndex){
        //!!! ugly hard code
        return (this._data.series[seriesIndex].rIndex || seriesIndex) === 0 ? BAR : LINE;
    };

    TimeCombinationPlot.prototype.getSeriesStyle = function(){
        return TimeLinePlot.prototype.getSeriesStyle.apply(this, arguments);
    };

    //decide the color of columns and lines
    TimeCombinationPlot.prototype._getColor = function(data) {
        return CombinationPlot.prototype._getColor.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._attachMarkManager = function(){
        var markerMgr = this.runtime().markManager();
        var primaryAxis =  ["bar", "line", "line"];  //!!hard code
        var lineMarker = this._getMarkerShape();
        var propRoot = this._properties.parentLevel;

        var shapes = [];
        markerMgr.lock();
        markerMgr.setMode("combination");
        var seriesShape = [];
        seriesShape.push(primaryAxis);

        shapes.push(CombinationPlot.processMark.call(this, primaryAxis, lineMarker, propRoot));

        if(this._options && this._options.isDualValueAxis){
            var secondaryAxis =  ["line", "line", "line"];  //!!hard code
            shapes.push(CombinationPlot.processMark.call(this, secondaryAxis, lineMarker, propRoot));
            seriesShape.push(secondaryAxis);
        }

        markerMgr.setShape(shapes, lineMarker);
        markerMgr.setSeriesShape(seriesShape);
    };

    TimeCombinationPlot.prototype._onDataShapeChange = function() {
        this._attachMarkManager();
    };

    //the small wrapper for below two methods
    TimeCombinationPlot.prototype._getSeriesRenderer = function(){
        return new SeriesRenderer(this._drawLine.bind(this), this._updateLine.bind(this));
    };

    //adjust dataPoint position on the plot
    //the naming is not good
    //there is anohter method "_getPosition". it return dataPoint Position
    TimeCombinationPlot.prototype._adjustPosition = function(position, seriesIndex){
        var shape = this._getDataShape(seriesIndex);
        if (shape === BAR) {
            TimeColumnPlot.prototype._adjustPosition.apply(this,arguments);
        }else{
            //do nothing for line
        }
    };

    TimeCombinationPlot.prototype._getXPosition = function(seriesIndex, itemIndex, data) {
        var isLine = this._getDataShape(seriesIndex) === LINE;
          //category
        if (isLine) {
            return TimeLinePlot.superclass._getXPosition.apply(this, arguments);
        } else {
            return TimeColumnPlot.prototype._getXPosition.apply(this, arguments);
        }
    };

    TimeCombinationPlot.prototype._getYPosition = function(seriesIndex, itemIndex, data) {
        return CombinationPlot.prototype._getYPosition.apply(this, arguments);
    };



    TimeCombinationPlot.prototype._drawLine = function(seriesG, data, seriesIndex, isUpdate) {
        if (this._getDataShape(seriesIndex) !== LINE) {
            SeriesUtil.drawBarSeries(seriesG, data, this._semanticMgr,
                this._effectManager, this.isHorizontal(), !this._isBigData);
            return 0;
        }
        BaseLinePlot.prototype._drawLine.apply(this, [seriesG, data, seriesIndex, isUpdate]);
        return 1;
    };

    //update the line or the columns' path
    TimeCombinationPlot.prototype._updateLine = function(seriesG, data, seriesIndex){
        var shape = this._getDataShape(seriesIndex);
        if (shape === BAR) {
            SeriesUtil.updateBarSeries(seriesG, data, this._semanticMgr,
                this._effectManager, this.isHorizontal(), !this._isBigData);
        } else {
            this._drawLine(seriesG, data, seriesIndex, true);
        }
    };

    TimeCombinationPlot.prototype._buildSeriesContext = function(seriesIndex){
        return  BaseLinePlot.prototype._buildSeriesContext.apply(this, arguments);
    };

    //tell if display marker
    TimeCombinationPlot.prototype.isMarkerVisible = function(){
        return this._isMarkerVisible;
    };

    TimeCombinationPlot.prototype._getDataLabels = function(){
        return CombinationPlot.prototype._getDataLabels.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._drawDataPoint = function(dpRenderer, dataPoint){
        var seriesIndex = dataPoint._seriesIndex;
        var shape = this._getDataShape(seriesIndex);

        if (shape === BAR) {
            return TimeColumnPlot.prototype._drawDataPoint.apply(this, arguments);
        }else{
            return TimeLinePlot.prototype._drawDataPoint.apply(this, arguments);
        }
    };


    TimeCombinationPlot.prototype._hideDataPoints = function(dataPoints, visibleRange){
        var i;
        if(!visibleRange){
            visibleRange =  TimeLinePlot.prototype._getVisibleRange.call(this, dataPoints);
            visibleRange =  TimeLinePlot.prototype._getDataPointRange.call(this, dataPoints, visibleRange);
        }
        if (dataPoints[0] && this._getDataShape(dataPoints[0].getSeriesIndex()) === LINE) {
            //hide all lines
            for (i = 0; i < dataPoints.length; i++){
                this._hideNode(dataPoints, i);
            }
            this._lightLineOutOfRange(dataPoints, visibleRange);
        } else {
            this._columnOutOfRange(dataPoints, visibleRange);
        }
    };

    TimeCombinationPlot.prototype.update = function(){
        TimeCombinationPlot.superclass.update.apply(this, arguments);
        this._updateLightLine();
    };

    TimeCombinationPlot.prototype._updateLightLine = function(){
        BaseLinePlot.prototype._updateLightLine.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._lightLineOutOfRange = function(dataPoints, visibleRange){
        CombinationPlot.prototype._lightLineOutOfRange.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._updateDatapoints = function(){
        return  CombinationPlot.prototype._updateDatapoints.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._updateDatapoint = function(dataPointG, dpRenderer, dpConfig, position){
        var seriesIndex = dpConfig.seriesIndex;
        var shape = this._getDataShape(seriesIndex);
        if (shape === BAR) {
            return TimeColumnPlot.prototype._updateDatapoint.apply(this, arguments);
        }else{
            return TimeLinePlot.prototype._updateDatapoint.apply(this, arguments);
        }
    };

    TimeCombinationPlot.prototype._getDataPointRenderer = function(seriesIndex){
        return CombinationPlot.prototype._getDataPointRenderer.apply(this,arguments);
    };

    TimeCombinationPlot.prototype.destroy = function(){
        TimeColumnPlot.prototype.destroy.apply(this,arguments);
        CombinationPlot.prototype.destroy.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._getAxisPosition = function(handlers, seriesIndex, itemIndex, data) {
        return TimeColumnPlot.prototype._getAxisPosition.call(this, handlers, seriesIndex, itemIndex, data,
                this._getDataShape(seriesIndex));
    };

    TimeCombinationPlot.prototype._getFillColorConfig = function(){
        return CombinationPlot.prototype._getFillColorConfig.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._useSemanticPattern = function(){
        return CombinationPlot.prototype._useSemanticPattern.apply(this, arguments);
    };

    TimeCombinationPlot.prototype._getColumnWidthRatio =
        TimeStackedColumnPlot.prototype._getColumnWidthRatio;

    TimeCombinationPlot.prototype._getCategoryScaleHandlers =
        TimeStackedColumnPlot.prototype._getCategoryScaleHandlers;

    TimeCombinationPlot.prototype._getColumnCount = function() {
        return 1;
    };


    (new HitTestDecorator()).decorate(TimeCombinationPlot);
    return TimeCombinationPlot;
});

define('sap/viz/chart/components/decorator/HitTestBulletDecorator',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/decorator/BaseHitTestDecorator',
    'sap/viz/chart/components/util/HitTestUtils'
], function(
    oo,
    BaseHitTestDecorator,
    HitTestUtils
) {

    var inRange = HitTestUtils.inRange;

    
    var HitTestBulletDecorator = function() {
        HitTestBulletDecorator.superclass.constructor.apply(this, arguments);
        this._decos.hitTestForRangeSelection = function(cord){
            if(!cord.hasOwnProperty("start") && !cord.hasOwnProperty("end")){
                return null;
            }
            
            //in range selection, we treat each dp as a point, no matter its size
            var result = [];
            var bound = this._data.actualValues.scale._domain;

            this._data.series.forEach(function(datas){
                var hitForSeries = datas.filter(function(e) {
                        var timeValue =  e.timeAxis[0].parsedValue || e.timeAxis[0].value;
                        return inRange(timeValue, cord["start"], cord["end"]) && 
                                    inRange(e.actualValues, bound[0], bound[1]);
                    });
                result = result.concat(hitForSeries);
            });
            

            return result.map(function(e){return e.dp.id;});
        };
    };

    oo.extend(HitTestBulletDecorator, BaseHitTestDecorator);

    return HitTestBulletDecorator;
});
define('sap/viz/chart/components/plots/TimeBulletPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/BulletPlot',
    'sap/viz/chart/components/plots/TimeColumnPlot',
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/decorator/HitTestBulletDecorator'
], function(
    oo,
    BulletPlot,
    TimeColumnPlot,
    TimeUtil,
    ObjectUtils,
    HitTestDecorator
) {
    function TimeBulletPlot() {
        TimeBulletPlot.superclass.constructor.apply(this, arguments);
    }

    oo.extend(TimeBulletPlot, BulletPlot);

    TimeBulletPlot.prototype.update = function(scale) {
        if(!this._selection){
            return;
        }
        TimeBulletPlot.superclass.update.apply(this, arguments);
    };

    TimeBulletPlot.prototype.setData = function() {
        TimeBulletPlot.superclass.setData.apply(this, arguments);
        this._data.categoryAxis = this._data.timeAxis;
    };

    TimeBulletPlot.prototype._getCategoryWidth = function() {
        return this._getColumnWidthRatio() * this.getRealSize().width;
    };

    TimeBulletPlot.prototype._getCategoryCount = function() {
        var scale = this.getData().timeAxis.scale,
            domain = scale.getDomain();
        if (domain[0] === Infinity && domain[1] === -Infinity) {
            return null;
        }
        var barProps = this._getBarProperties();
        var start = TimeUtil.truncate(domain[0], barProps.minTimeLevel, barProps.utc, this._properties.origin),
            end = TimeUtil.truncate(domain[1], barProps.minTimeLevel, barProps.utc, this._properties.origin);
        if (start === end) {
            end = TimeUtil.nextDateByLevel(end, barProps.minTimeLevel, barProps.utc, this._properties.origin);
        }
        return {
            range: scale.scale(end) - scale.scale(start),
            count: TimeUtil.getTickNumberByLevel(barProps.minTimeLevel, start, end, barProps.utc,
                this._properties.origin) - 1
        };
    };

    TimeBulletPlot.prototype._getColumnWidthRatio = function() {
        var category = this._getCategoryCount();
        return category ? category.range / category.count : 0;
    };

    TimeBulletPlot.prototype._getExtraData = function() {
        var result = TimeBulletPlot.superclass._getExtraData();
        result.timeField = [this._data.timeAxis.metaData[0].id];
        return result;
    };

    TimeBulletPlot.prototype._categoryPosFn = function() {
        var series = this._data.series,
            scale = this._data.timeAxis.scale,
            size = this.isHorizontal() ? this._realSize.height : this._realSize.width,
            offset = this.__barSize() / 2;
        return function(seriesIdx, categoryIdx) {
            var item = series[seriesIdx][categoryIdx];
            if (item) {
                //TODO enhance in later patch
                if (series.length > 1){
                    //seriesIdx start from 0, 1, 2 ...
                    // x increases as the time value increases
                    return size * scale.scale(item.timeAxis) + 2* offset * (seriesIdx - series.length/2);
                }else{
                    return size * scale.scale(item.timeAxis) - offset;
                }
            } else {
                return null;
            }
        };
    };

    TimeBulletPlot.prototype.sizeByFixedDPSize = function(barSize) {
        var category = this._getCategoryCount();
        var plotWidth = TimeBulletPlot.superclass.sizeByFixedDPSize.apply(this, arguments);
        return plotWidth / category.range;
    };

    TimeBulletPlot.prototype._categoryCount = function() {
        var categoryCount = this._getCategoryCount();
        return categoryCount? categoryCount.count : 0;
    };

    TimeBulletPlot.prototype._getBarProperties = function() {
        return {
            minTimeLevel: (this.runtime().statusManager().get("timeLevels") || [])[0] || ["day"],
            utc: this._properties.origin.get("general.showAsUTC")
        };
    };

    TimeBulletPlot.prototype.scroll = function(offset) {
        TimeBulletPlot.superclass.scroll.apply(this, arguments);
        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };

    TimeBulletPlot.prototype._getCategoryRange = function(){
        return null;
    };

    TimeBulletPlot.prototype._shiftOffsetForIncompleteRange = function(){
        return null;
    };

    TimeBulletPlot.prototype._getDefaultZeroLineColor = function() {
        return this._properties.origin.get("timeAxis.color");
    };

    (new HitTestDecorator()).decorate(TimeBulletPlot);

    return TimeBulletPlot;
});

define('sap/viz/chart/components/plots/TimeStackedPercentagePlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/TimeStackedColumnPlot',
    'sap/viz/chart/components/plots/PercentagePlot'
], function Setup(oo, TimeStackedColumnPlot, PercentagePlot) {

    /**
     * To initialize PercentagePlot object.
     *
     * @name PercentagePlot
     * @constructor
     */
    var TimeStackedPercentagePlot = function(runtime, options) {
        TimeStackedPercentagePlot.superclass.constructor.apply(this, arguments);
        this._isPercent = true;
    };

    oo.extend(TimeStackedPercentagePlot, TimeStackedColumnPlot);

    TimeStackedPercentagePlot.prototype._getDataHandler = PercentagePlot.prototype._getDataHandler;

    TimeStackedPercentagePlot.prototype._total = PercentagePlot.prototype._total;

    TimeStackedPercentagePlot.prototype._getPosition = function(seriesIndex, itemIndex, data) {
        var ret = this._total(itemIndex, data);
        if (!ret) {
            return null;
        }
        return TimeStackedPercentagePlot.superclass._getPosition.apply(this, arguments);
    };

    TimeStackedPercentagePlot.prototype._buildWrapperContext = PercentagePlot.prototype._buildWrapperContext;

    TimeStackedPercentagePlot.prototype._buildWrapperConfig = function(data, position, context, option){
        context = this._buildWrapperContext(data, context);
        return TimeStackedPercentagePlot.superclass._buildWrapperConfig.apply(this, [data, position, context, option]);
    };

    TimeStackedPercentagePlot.prototype._buildData = function(dpConfig) {
        var ret = TimeStackedPercentagePlot.superclass._buildData.apply(this, arguments);
        ret.percentageValue = dpConfig.ctx.percentage;
        return ret;
    };

    TimeStackedPercentagePlot.prototype._drawGridlines = PercentagePlot.prototype._drawGridlines;
    
    TimeStackedPercentagePlot.prototype._getDataLabels = PercentagePlot.prototype._getDataLabels;

    return TimeStackedPercentagePlot;
});

define('sap/viz/chart/components/datalabels/WaterfallDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/DOM',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/framework/common/util/GeometryUtils'
], function(
    oo,
    Constants,
    DOM,
    DataGraphics,
    DataPointUtils,
    DataLabels,
    SVG,
    GeometryUtils
    ) {
    var DATA_LABEL_CLASS = Constants.CSS.CLASS.DATALABEL + " " + Constants.CSS.CLASS.MORPHABLELABEL,
        DATA_LABELS_GROUP_CLASS = Constants.CSS.CLASS.DATALABEL_GROUP_RECAP,
        DATA_LABELS_GROUP_TAG = "g";
    var PADDING = 8;
    var HORIZONTAL_OFFSET = 2;
    var DATA_ATTR_DATAID = "data-id";

    var waterfallTypeScaleArray = [0, 2, 1]; //[null, subtotal, total]

    var WaterfallDataLabels = function(ctx, options) {
        WaterfallDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = "waterfall";
        this._recapLabelsGroupNode = null;
    };

    oo.extend(WaterfallDataLabels, DataLabels);
    WaterfallDataLabels.prototype.verticalLabelOffset = Constants.DATALABEL.VERTICAL_LABEL_OFFSET;
    WaterfallDataLabels.prototype.horizontalLabelOffset = Constants.DATALABEL.HORIZONTAL_LABEL_OFFSET;

    WaterfallDataLabels.prototype._getStyle = function(dp) {
        var props = this._properties;
        var style = WaterfallDataLabels.superclass._getStyle.apply(this, arguments);
        if(dp) {
            var ctx = DataPointUtils.getContext(dp);
            if (ctx && ctx.isCumulative) {
                style["font-weight"] = "bold";
                style["cssString"] = "fill:" + style.fill +
                    ";font-family:" + props.get('style.fontFamily') +
                    ";font-size:" + props.get('style.fontSize') +
                    ";font-weight:" + "bold" +
                    ";font-style:" + props.get('style.fontStyle') + ";";
            }
        }

        return style;
    };

    WaterfallDataLabels.prototype.hideConditional = function(dataLabelInfos, allDataPoints) {
        var i, dataPointBoxes = new Array(allDataPoints.length);
        for (i = 0; i < allDataPoints.length; i++) {
            dataPointBoxes[i] = allDataPoints[i].getBoundingClientRect();
        }

        var recapLabelInfos;
        if(this._recapLabelsGroupNode) {
            recapLabelInfos = [];
            var dataShapesGroupNode = this._dataShapesGroupNode;
            var dataLabelsNode = this._recapLabelsGroupNode.querySelectorAll('.' + Constants.CSS.CLASS.DATALABEL);
            var len = dataLabelsNode.length;
            for (i = 0; i < len; i++) {
                var dataLabelGroup = dataLabelsNode[i];
                var dataLabelId = DataGraphics.getData(dataLabelGroup).id;
                var dp = DataPointUtils.find(dataShapesGroupNode, dataLabelId);
                if(dp) {
                    var recapInfo = DataGraphics.getData(dp).recap;
                    if(recapInfo) {
                        var dataLabelValue = DataGraphics.getContext(dataLabelGroup).val;
                        var translate = /translate\((.*)\)/g.exec(dataLabelGroup.getAttribute("transform"))[1]
                            .replace(/\s+/g,',').split(',');
                        translate[0] = parseFloat(translate[0]);
                        translate[1] = parseFloat(translate[1]);
                        var labelBBox = GeometryUtils.getBBox(dataLabelGroup);
                        recapLabelInfos.push({
                            info:{value: dataLabelValue},
                            node: dataLabelGroup,
                            dataPoint: dp,
                            left: translate[0] + labelBBox.x,
                            right: translate[0] + labelBBox.x + labelBBox.width,
                            top: translate[1] + labelBBox.y,
                            bottom: translate[1] + labelBBox.y + labelBBox.height,
                            x:recapInfo.x,
                            y:recapInfo.y
                        });
                    }
                }
            }
            recapLabelInfos.sort(function(a, b) {
                return a.x - b.x;
            });
        }


        var allLabelInfos = recapLabelInfos ? dataLabelInfos.concat(recapLabelInfos) : dataLabelInfos;
        for (i = (allLabelInfos.length - 1); i >= 0; i--) {
            var dataLabelinfo = allLabelInfos[i];

            var dataLabelNode = dataLabelinfo.node;
            var dataLabelBBox = dataLabelNode.getBoundingClientRect();

            var currectDataPoint = dataLabelinfo.dataPoint;
            var iIndex = this.indexOfDataLabelIntersectDataPoints(dataLabelBBox, dataPointBoxes,
                    allDataPoints, currectDataPoint, dataLabelinfo.info.value);

            if (iIndex !== -1) {
                DOM.remove(dataLabelNode);
                allLabelInfos.splice(i, 1);
            }
        }
        return WaterfallDataLabels.superclass.hideConditional.call(this, allLabelInfos);
    };

    WaterfallDataLabels.prototype.sortDataLabelInfos = function(dataLabelInfos) {
        var aNodeCtx, bNodeCtx, aNodeTypeScale, bNodeTypeScale;
        var _this = this;
        //Since time waterfall does not have waterfallTypeScale. Not need to sort.
        if (this._data.waterfallTypeScale) {
            dataLabelInfos.sort(function(a, b) {
                aNodeCtx = DataPointUtils.getContext(a.node);
                aNodeTypeScale = _this._data.waterfallTypeScale.scale(aNodeCtx ? aNodeCtx.Type : null);
                bNodeCtx = DataPointUtils.getContext(b.node);
                bNodeTypeScale = _this._data.waterfallTypeScale.scale(bNodeCtx ? bNodeCtx.Type : null);
                return waterfallTypeScaleArray.indexOf(aNodeTypeScale) -
                    waterfallTypeScaleArray.indexOf(bNodeTypeScale);
            });
        }
    };

    WaterfallDataLabels.prototype._computeDataLabelTranslate = function(node, ctm,
        labelPosition, labelBBox, config) {
        var locationArray = WaterfallDataLabels.superclass._computeDataLabelTranslate.apply(this, arguments);
        // For horizontal_waterfall chart, datalabel of negative value can flip
        // from left of the bar to right when the left space is not enough for datalabel,
        // and right space is enough.
        if (this._horizontal) {
            var shapeBBox = this._fixBBoxWhenInvisible(node, config && config.dpBBox);
            var nodeX = shapeBBox.x + ctm.e;
            var bound = this.getBound();
            var BOUND_OFFSET = Constants.DATALABEL.BOUND_OFFSET;
            var minWidth = labelBBox.width + BOUND_OFFSET;
            if (config.val < 0 &&
                nodeX - labelBBox.x - bound.left < minWidth &&
                bound.width + bound.left - (nodeX + shapeBBox.width) >= minWidth
                ) {
                // Put the datalabel at the right of the bar
                locationArray[0] = nodeX + shapeBBox.width + this.horizontalLabelOffset;
                // If datalabel is out of the plot bound,
                // force the datalabel display in the plot
                if ((locationArray[0] + labelBBox.x + labelBBox.width) >
                    (bound.width + bound.left)) {
                    locationArray[0] = (bound.width + bound.left) -
                        BOUND_OFFSET - labelBBox.width - labelBBox.x;
                }
            }
        }

        return locationArray;

    };

    var VERTICAL_ADJUST_THERSHOLD = 100;
    WaterfallDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox,
                                                                config, node) {
        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;
        var labelOffset;

        if (this._horizontal) {
            labelOffset = this.horizontalLabelOffset;
        }else{
            if(this._size.height < VERTICAL_ADJUST_THERSHOLD){
                labelOffset = this.verticalLabelOffset * 0.2;
            }else{
                labelOffset = this.verticalLabelOffset;
            }
        }

        if (this._horizontal) {
            y = (nodeY + shapeBBox.height / 2) -
                (labelBBox.y + labelBBox.height / 2);
            if (config.val >= 0) {
                x = nodeX + shapeBBox.width + labelOffset;
            }
            else {
                x = nodeX - (labelBBox.x + labelBBox.width) - labelOffset;
            }
        } else {
            x = (nodeX + shapeBBox.width / 2) -
                (labelBBox.x + labelBBox.width / 2);
            if (config.val >= 0) {
                y = nodeY - (labelBBox.y + labelBBox.height);
                if(y + labelBBox.y < 0) {
                    y = -labelBBox.y - labelOffset;
                }else{
                    y = y + labelOffset;
                }
            }
            else {
                y = nodeY + shapeBBox.height - labelBBox.y;
                if(y + labelBBox.height + labelBBox.y > config.plotSize.height) {
                    y = config.plotSize.height - (labelBBox.y + labelBBox.height) + labelOffset;
                }
                else {
                    y = y - labelOffset;
                }
            }
        }

        return [x, y];
    };

    WaterfallDataLabels.prototype.indexOfDataLabelIntersectDataPoints = function(dataLabelBBox,
        dataPointBoxes, allDataPoints, currectDataPoint, value) {
        var intersectIndex = -1;
        var i;

        for (i = 0; i < dataPointBoxes.length; i++) {
            var dataPointBox = dataPointBoxes[i];
            if (!(dataLabelBBox.left > dataPointBox.right ||
                dataLabelBBox.right < dataPointBox.left ||
                dataLabelBBox.top > dataPointBox.bottom ||
                dataLabelBBox.bottom < dataPointBox.top)) {
                intersectIndex = i;
                break;
            }
        }
        return intersectIndex;
    };

    WaterfallDataLabels.prototype.render = function(selection, dataPoints) {
        dataPoints = dataPoints || DataPointUtils.findAll(this._dataShapesGroupNode) || [];
        this._plotSelection = selection;
        var filteredDataPoints = this._beforeRender(dataPoints);
        this._render(selection, filteredDataPoints);
        var allPoints = DataPointUtils.findAll(selection.node());
        this._renderRecapLabels(selection, allPoints);
        this._afterRender(selection);
    };


    WaterfallDataLabels.prototype._renderRecapLabels = function(selection, dataPoints) {
        var props = this._properties;
        if(!props.origin.get('plotArea.dataLabel.showRecap')) {
            return;
        }

        this._recapLabels = [];
        var parentNodeDOM = selection.node();
        var dataLabelsGroup = parentNodeDOM.querySelector("." + DATA_LABELS_GROUP_CLASS);
        if(!dataLabelsGroup){
            dataLabelsGroup = SVG.create(DATA_LABELS_GROUP_TAG, parentNodeDOM);
            dataLabelsGroup.setAttribute("class", DATA_LABELS_GROUP_CLASS);
            this._recapLabelsGroupNode = dataLabelsGroup;
        }
        var existDataLabelNodes = dataLabelsGroup.querySelectorAll('.' + Constants.CSS.CLASS.DATALABEL);
        var textAnchor = null;
        var envManager = this.runtime().envManager();
        if (envManager) {
            textAnchor = envManager.textAnchor();
        }
        dataLabelsGroup.setAttribute("text-anchor", textAnchor);

        var labelRenderer = props.get('renderer') || defaultRenderer;
        var dataLabelStyle = this._getStyle();
        for (var j in dataLabelStyle) {
            if (dataLabelStyle.hasOwnProperty(j)) {
                dataLabelsGroup.setAttribute(j, dataLabelStyle[j]);
            }
        }

        var formatPatterns = props.get('formatString');
        var measureName, metaDataFormat;
        if (this._data && this._data.valueAxis && this._data.valueAxis.metaData) {
            measureName = this._data.valueAxis.metaData[0].id;
            metaDataFormat = this._data.valueAxis.metaData[0].formatString;
        }
        var formatPattern = formatPatterns ? formatPatterns : metaDataFormat;
        var dynamicScale = this._runtime.statusManager().get("dynamicScale");

        for (var i = 0, len = dataPoints.length; i < len; i++) {
            var dp = dataPoints[i];
            var datapointId = DataPointUtils.getDataPointId(dp);
            var dataLabelGroup = DataPointUtils.findByDataRecapIds(existDataLabelNodes, datapointId);
            if(dataLabelGroup.length) {
                continue;
            }
            var dataId = DataPointUtils.getDataId(dp);
            var recapInfo = DataGraphics.getData(dp).recap;
            if(!recapInfo) {
                continue;
            }
            var dataLabelInfo = {
                key : measureName,
                value : recapInfo.value,
                dynamicScale: dynamicScale
            };

            var dataLabelText = this._buildDataLabelText(formatPattern, dataLabelInfo, null,
                false, dp);

            dataLabelGroup = SVG.create("g", dataLabelsGroup);
            DataPointUtils.setDataRecapId(dataLabelGroup, datapointId);
            dataLabelGroup.setAttribute("class", DATA_LABEL_CLASS);
            DataGraphics.setData(dataLabelGroup, {
                "id": dataId
            });

            var config = {
                val: dataLabelInfo.value,
                text: dataLabelText,
                info: dataLabelInfo,
                styles: dataLabelStyle,
                horizontal: this._horizontal
            };
            var labelContentNode = labelRenderer(config);
            if (labelContentNode) {
                dataLabelGroup.appendChild(labelContentNode);
            }

            DataGraphics.setContext(dataLabelGroup, {val: dataLabelInfo.value});
        }
    };

    WaterfallDataLabels.prototype.updatePosition = function(selection, dataPoints) {
        var parentNode = selection, parentNodeDOM = selection.node();
        var dataLabelsGroup = parentNode.select("." + DATA_LABELS_GROUP_CLASS);
        if (dataLabelsGroup.node()) {
            var dataShapesGroupNode = this._dataShapesGroupNode;
            var updatedDpIds = [];
            var dataLabelsNode = dataLabelsGroup.node().querySelectorAll('.' + Constants.CSS.CLASS.DATALABEL);
            for (var i = 0, len = dataLabelsNode.length; i < len; i++) {
                var dataLabelGroup = dataLabelsNode[i];
                var dataLabelId = DataGraphics.getData(dataLabelGroup).id;
                var dp = DataPointUtils.find(dataShapesGroupNode, dataLabelId);
                if (!dp){
                    DOM.remove(dataLabelGroup);
                    continue;
                }
                var recapInfo = DataGraphics.getData(dp).recap;
                if(!recapInfo) {
                    DOM.remove(dataLabelGroup);
                    continue;
                }
                updatedDpIds.push(dataLabelId);
                var translate = getTranslate(dataLabelGroup, recapInfo);
                dataLabelGroup.setAttribute("transform", "translate(" + translate[0] + "," + translate[1] + ")");
            }

            if (dataPoints) {
                var newDatapoints = dataPoints.filter(function(dp) {
                    return updatedDpIds.indexOf(DataPointUtils.getDataId(dp)) === -1;
                });
                if (newDatapoints.length) {
                    this._renderRecapLabels(selection,
                        DataPointUtils.findAll(dataShapesGroupNode));
                }
            }
        }

        WaterfallDataLabels.superclass.updatePosition.apply(this, arguments);
    };

    WaterfallDataLabels.prototype._afterRender = function(selection, dpMaps, lableGroupMaps) {
        if(this._recapLabelsGroupNode) {
            var dataShapesGroupNode = this._dataShapesGroupNode;
            var dataLabelsNode = this._recapLabelsGroupNode.querySelectorAll('.' + Constants.CSS.CLASS.DATALABEL);
            var setRecapTranslate = function (dataShapesGroupNode, dataLabelGroup, recapInfo, labelBox, translate){
                var dataPoint, dataPointBox, offset;
                if (recapInfo.basePos === 'end' || recapInfo.basePos === 'start') {
                    dataPoint = DataPointUtils.find(dataShapesGroupNode, recapInfo.basePosId);
                } else if (recapInfo.nearBasePos) {
                    dataPoint = DataPointUtils.find(dataShapesGroupNode, recapInfo.nearBasePosId);
                } else {
                    return ;
                }
                if(!dataPoint) {
                    DOM.remove(dataLabelGroup);
                    return;
                }
                dataPointBox = dataPoint.getBoundingClientRect();
                if ((recapInfo.basePos === "end" ||  recapInfo.nearBasePos === "right") &&
                    labelBox.right >= dataPointBox.left) {
                    translate[0] -= labelBox.right - dataPointBox.left + HORIZONTAL_OFFSET;
                } else if((recapInfo.basePos === "start" ||  recapInfo.nearBasePos === "left") &&
                    labelBox.left <= dataPointBox.right){
                    translate[0] += dataPointBox.right - labelBox.left + HORIZONTAL_OFFSET;
                }
                dataLabelGroup.setAttribute(
                    "transform", "translate(" + translate[0] + "," + translate[1] + ")");
            };
            for(var i = 0, len = dataLabelsNode.length; i < len; i++) {
                var dataLabelGroup = dataLabelsNode[i];
                var dataLabelId = DataGraphics.getData(dataLabelGroup).id;
                var dp = DataPointUtils.find(dataShapesGroupNode, dataLabelId);
                if (!dp){
                    DOM.remove(dataLabelGroup);
                    continue;
                }
                var recapInfo = DataGraphics.getData(dp).recap;
                if(!recapInfo) {
                    DOM.remove(dataLabelGroup);
                    continue;
                }
                var translate = getTranslate(dataLabelGroup, recapInfo);
                dataLabelGroup.setAttribute(
                    "transform", "translate(" + translate[0] + "," + translate[1] + ")");
                var labelBox = dataLabelGroup.getBoundingClientRect();
                if (recapInfo.basePos) {
                    setRecapTranslate(dataShapesGroupNode, dataLabelGroup, recapInfo, labelBox, translate);
                } else {
                    // It is the last recap point
                    translate[0] -= labelBox.width / 2 + HORIZONTAL_OFFSET;
                    dataLabelGroup.setAttribute(
                        "transform", "translate(" + translate[0] + "," + translate[1] + ")");
                }
            }
        }
        WaterfallDataLabels.superclass._afterRender.apply(this, arguments);
    };

    function getTranslate(dataLabelGroup, recapInfo) {
        var labelBBox = GeometryUtils.getBBox(dataLabelGroup);
        var x = recapInfo.x - 0.5 * labelBBox.width, y;
        if(recapInfo.position === 'up') {
            y = recapInfo.y - PADDING;
        }else {
            y = recapInfo.y - labelBBox.y + PADDING;
        }
        return[x, y];
    }

    function defaultRenderer(config) {
        var text = SVG.create("text");
        text.textContent = config.text;
        return text;
    }

    return WaterfallDataLabels;
});

define('sap/viz/chart/util/WaterfallUtils',["sap/viz/framework/common/util/TypeUtils",
        'sap/viz/framework/common/util/SVG',
        'sap/viz/framework/common/util/CSSUtils',
        'sap/viz/framework/common/util/Constants'],
        function(TypeUtils,
                SVG,
                CSSUtils,
                Constants) {
    var WaterfallUtils = {};

    WaterfallUtils.WATERFALLTYPE = "waterfallType";
    var linklineCSS = Constants.CSS.CLASS.WATERFALL_LINKLINE;
    var recapCSS = Constants.CSS.CLASS.WATERFALL_RECAP;
    var recapWidth = Constants.RECAP.WIDTH;
    var recapPadding = Constants.RECAP.PADDING;
    
    WaterfallUtils.Key2Type = [{
        key : 'subtotal',
        type : 2
    }, {
        key : 'total',
        type : 1
    }, {
        key : '',
        type : 0
    }];
    
    WaterfallUtils.scale = function(key, key2Type) {
        if (TypeUtils.isString(key)) {
            key = key.trim().split(':')[0].toLowerCase().trim();
        }
        for (var i in key2Type) {
            if (key2Type[i].key === key) {
                return key2Type[i].type;
            }
        }
        return 0;
    };
    
    WaterfallUtils.joinLines = function(lines, isHorizontal) {
        var i, prev;
        if (isHorizontal) { //horizontal
            lines.sort(function(a, b) {
                return a.x1 !== b.x1 ? a.x1 - b.x1 : a.y1 - b.y1;
            });
            
            for (i = 0; i < lines.length; i++) {
                if (!prev) {
                    prev = lines[i];
                } else {
                    if (prev.x1 === lines[i].x1) {
                        if (prev.y2 < lines[i].y1) {
                            prev = lines[i];
                        } else {
                            if (prev.y2 < lines[i].y2) {
                                prev.y2 = lines[i].y2;    
                            }
                            lines[i].skip = true;
                        }
                    } else {
                        prev = lines[i];
                    }
                }
            }
        } else { //vertical
            lines.sort(function(a, b) {
                return a.y1 !== b.y1 ? a.y1 - b.y1 : a.x1 - b.x1;
            });
            
            for (i = 0; i < lines.length; i++) {
                if (!prev) {
                    prev = lines[i];
                } else {
                    if (prev.y1 === lines[i].y1) {
                        if (prev.x2 < lines[i].x1) {
                            prev = lines[i];
                        } else {
                            if (prev.x2 < lines[i].x2) {
                                prev.x2 = lines[i].x2;    
                            }
                            lines[i].skip = true;
                        }
                    } else {
                        prev = lines[i];
                    }
                }
            }
        }
    };
    
    WaterfallUtils.drawLines = function(lines, properties, isHorizontal, lineG, needJoin, periodsWidth){
        if (lines.length === 0) {
            return;
        }
        if (needJoin) {
            WaterfallUtils.joinLines(lines, isHorizontal);
        }
        
        var opacity = 1;
        var lineColor = properties.get("linkline.color");
        var lineWidth = properties.get("linkline.size");
        var recapColor = lineColor;
        var lineType = properties.get("linkline.type");
        var style = (lineType == Constants.LINE_TYPE.DASHED || lineType === Constants.LINE_TYPE.DOTTED) ? 
            "stroke-dasharray:6" : "";
            
        for (var i = 0; i < lines.length; i++) {
            if (lines[i]) {
                if(!lines[i].skip) {
                    var line = SVG.create("line");
                    line.setAttribute("class", linklineCSS);
                    line.setAttribute("stroke", lineColor);
                    line.setAttribute("stroke-opacity", opacity);
                    line.setAttribute("stroke-width", lineWidth);
                    //CSP Fixing. line.setAttribute("style") is bad. 
                    //The only way to allow style attributes is to use unsafe-inline.
                    //(we cannot do this).
                    CSSUtils.setDOMStyle(line, style);

                    line.setAttribute("pointer-events", "none");
                        
                    line.setAttribute("x1", lines[i].x1);
                    line.setAttribute("y1", lines[i].y1);
                    line.setAttribute("x2", lines[i].x2);
                    line.setAttribute("y2", lines[i].y2);
                    lineG.appendChild(line);
                }                
                if(lines[i].recap && (periodsWidth >= recapPadding*2 + recapWidth)) {
                    var point = SVG.createSVGNode("circle");
                    point.setAttribute("class", recapCSS);
                    point.setAttribute("fill-opacity", opacity);
                    point.setAttribute("fill", recapColor);
                    point.setAttribute("r", recapWidth / 2);
                    point.setAttribute("cx", lines[i].recap.x);
                    point.setAttribute("cy", lines[i].recap.y);
                    lineG.appendChild(point);
                }
            }
        }
    };
    
    return WaterfallUtils;
});

define('sap/viz/chart/components/plots/WaterFallPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/plots/BaseColumnPlot',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/SeriesUtil',
    'sap/viz/chart/components/datalabels/WaterfallDataLabels',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/chart/util/WaterfallUtils',
    'sap/viz/framework/common/util/NameColorUtils',
    "sap/viz/chart/behavior/config/DataPointBehaviorConfigForBar"
], function Setup(oo, DrawUtil, SVG, BaseColumnPlot, ContextBuilder, ScaleHandler, DataHandler, ItemScaleHandler,
    SeriesRenderer, PathRenderer, DataGraphics, ObjectUtils, SeriesUtil, WaterfallDataLabels,
    UADetector, DataPointUtils, Constants, WaterfallUtils, NameColorUtils) {


    var WaterFallPlot = function(runtime, options) {
        WaterFallPlot.superclass.constructor.apply(this, arguments);
        this._dpGap = 0;
        //todo
    };

    oo.extend(WaterFallPlot, BaseColumnPlot);
    WaterFallPlot.prototype._isSupportNoFill = function (){
        return false;
    };
    
    var NEGATIVE_OFFSET = 0.5;
    var linklineCSS = Constants.CSS.CLASS.WATERFALL_LINKLINE;
    var lineLineGroup = "v-wtf-linklinegroup";
    
    WaterFallPlot.prototype.setData = function(data) {
        if (data && data.waterfallType && data.waterfallType.scale) {
            data.waterfallTypeScale = data.waterfallType.scale;
        }
        WaterFallPlot.superclass.setData.apply(this, arguments);
        return this;
    };
    
    WaterFallPlot.prototype.render = function(selection) {
        var width = this._size.width, height = this._size.height;
        this._size.width = width < 0 ? 0 : width;
        this._size.height = height < 0 ? 0 : height;
        WaterFallPlot.superclass.render.apply(this, arguments);
    };
    
    WaterFallPlot.prototype._getDataHandler = function() {
        return {
            "valueAxis": DataHandler.getWTFHandler()
        };
    };

    WaterFallPlot.prototype._getXYPosition = function(seriesIndex, itemIndex, data, handler, dataHandler) {
        return handler.scale({
            value:data.valueAxis,
            total:data.total,
            base:data.base
        }, {
            index: itemIndex,
            seriesIndex: seriesIndex,
            dataHandler:dataHandler
        });
    };
    
    WaterFallPlot.prototype._getXPosition = function(seriesIndex, itemIndex, data) {
        var handler = this._xHandlers[0];
        return this._getXYPosition(seriesIndex, itemIndex, data, handler);
    };
    
    WaterFallPlot.prototype._getYPosition = function(seriesIndex, itemIndex, data) {
        var handler = this._yHandlers[0];
        return this._getXYPosition(seriesIndex, itemIndex, data, handler);
    };
    
    WaterFallPlot.prototype._getValueScaleHandlers = function(isHorizontal) {
        return [ScaleHandler.getWTFScaleHandler("valueAxis", {
            isHorizontal: this.isHorizontal()
        })];
    };

    WaterFallPlot.prototype._showDataPoints = function(dataPointG) {
        this._preShowDataPoints();
        var newDataPoints = [];
        this._dataPointContext = [];
        if(this._seriesRenderer){
            this._seriesRenderer.resetDataPoints();
        }

        this._selection.selectAll("." + lineLineGroup).remove();
        
        var lineG = SVG.create("g");
        lineG.setAttribute("class", lineLineGroup);
        var range = this._getVisibleRange();
        var seriesIndex, seriesModel, dataPoints;

        for (seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
            seriesModel = this._series[seriesIndex];
            if (!seriesModel) {
                continue;
            }
            var dpRenderer = this._getDataPointRenderer(seriesIndex);
            if (!dpRenderer) {
                continue;
            }
           
            dataPoints = seriesModel.getDataPoints();
            var curRange = this._getDataPointRange(dataPoints, range);
            this._hideDataPoints(dataPoints, curRange);
             
            for (var itemIndex = curRange.min; itemIndex <= curRange.max; itemIndex++) {
                var dataPointModel = dataPoints[itemIndex];
                if (!dataPointModel) {
                    continue;
                }
                var data = dataPointModel.getRawData();

                var position = this._getDataPointPosition(dataPointModel);
                if (!position) {
                    continue;
                }
                var itemChanged = false;
                var dpConfig = dataPointModel.getConfig();
                if(!dpConfig){
                    itemChanged = true;
                    var ctx = data.dp && data.dp.context() ? data.dp.context() : Constants.NULL_VALUE;
                    var timeValue = data.timeAxis && data.timeAxis[0] && data.timeAxis[0].parsedValue;
                    dpConfig = this._buildWrapperConfig(data, position, ctx, {timeValue: timeValue});
                }
                this._dataPointContext.push(dpConfig);
                var dpData = dataPointModel.getData();
                if(!dpData){
                    itemChanged = true;
                    var currentId = dataPointModel.getId();
                    dpData = this._buildData(dpConfig);
                    dataPointModel.init(dpConfig, currentId, dpData,
                        data.dp && data.dp.id ? data.dp.id : Constants.NULL_VALUE);
                }

                var dpNode = dataPointModel.getNode();
                if(dpNode){
                    if(itemChanged){
                        this._updateDatapoint(dpNode, dpRenderer, dpConfig, position);
                        newDataPoints.push(dpNode);
                    }
                } else {
                    dpNode = this._drawDataPoint(dpRenderer, dataPointModel);
                    dataPointModel.setNode(dpNode);
                    if (dpNode) {
                        newDataPoints.push(dpNode);
                    }
                }
                if(this._seriesRenderer){
                    this._seriesRenderer.addDataPoint(seriesIndex, itemIndex, dpConfig, position, dpNode);
                } else if(!dpNode.parentNode){
                    dataPointG.appendChild(dpNode);
                }
            }
        
        }
        
        
        if (!this._seriesRenderer) {
            this._drawLine(lineG,  this._series, range);
        }
        dataPointG.appendChild(lineG);
        return newDataPoints;
    };

    WaterFallPlot.prototype._getSeriesDataPoint = function(seriesIndex, itemIndex) {
        return {
                valueAxis : 0,
                total : 0,
                base : 0
            };
    };
    
    WaterFallPlot.prototype._getGap = function(seriesIndex, itemIndex) {
        var pFunc;
        var handler;
        var realSize = this.getRealSize();
        var gap;
        if (this.isHorizontal()) {
            handler = this._yHandlers[0];
            pFunc = this._getYPosition.bind(this);
            gap = realSize.height;
           
        } else {
            handler = this._xHandlers[0];
            pFunc = this._getXPosition.bind(this);
            gap = realSize.width;
        }
        if(handler._scale.getDomain().length > 1){
            var value1 = this._getSeriesDataPoint(seriesIndex, itemIndex);
            var value2 = this._getSeriesDataPoint(seriesIndex, itemIndex + 1);
            if (!value2) {
                return undefined;
            }
            var p1 =  pFunc(0,0, value1);
            var p2 =  pFunc(0,1, value2);
            gap = p2[0] - p1[0];
        }
        return gap;
        
    };

    WaterFallPlot.prototype._getHorizontalLine = 
    function(position, negative, wtfType, childNum) {
        var lLine, rLine, subLine;
        var x; 
        var offset = NEGATIVE_OFFSET;
        var gap = this._dpGap;
        var barSpacing = gap - position.height;
        lLine = {
            'y1' : Math.round(position.y - barSpacing / 2),
            'y2' : Math.round(position.y + position.height)
        };
        rLine = {
            'y1' : Math.round(position.y),
            'y2' : Math.round(position.y + position.height + barSpacing / 2)
        };
        
        if (1 === wtfType) {
            x = !negative ? Math.round(position.x + position.width) : Math.round(position.x + offset);
            lLine.x1 = lLine.x2 = rLine.x1 = rLine.x2 = x;
        } else if (2 === wtfType) {
            subLine = {
                'y1' : Math.round(position.y - gap * childNum),
                'y2' : Math.round(position.y + position.height)
            };
            x = !negative ? Math.round(position.x + position.width) : Math.round(position.x + offset);
            lLine.x1 = lLine.x2 = rLine.x1 = rLine.x2 = x;
            x = !negative ? Math.round(position.x) : Math.round(position.x + position.width + offset);
            subLine.x1 = subLine.x2 = x;
        } else {
            x= !negative ? Math.round(position.x) : Math.round(position.x + position.width + offset);
            lLine.x1 = lLine.x2 = x;
            x= !negative ? Math.round(position.x + position.width) : Math.round(position.x + offset);
            rLine.x1 = rLine.x2 = x;
        }
        
        return {
            'lLine' : lLine, 
            'rLine' : rLine,
            'subLine' : subLine
        };
    };

    WaterFallPlot.prototype._getVerticalLine = 
    function(position, negative, wtfType, childNum) {
        var lLine, rLine, subLine;
        var y;
        var offset = NEGATIVE_OFFSET;
        var gap = this._dpGap;
        var barSpacing = gap - position.width;
        lLine = {
            'x1' : Math.round(position.x - barSpacing / 2),
            'x2' : Math.round(position.x + position.width)
        };
        rLine = {
            'x1' : Math.round(position.x),
            'x2' : Math.round(position.x + position.width + barSpacing / 2)
        };
        
        if (1 === wtfType) {
            y = !negative ? Math.round(position.y) : Math.round(position.y + position.height + offset);
            lLine.y1 = lLine.y2 = rLine.y1 = rLine.y2 = y;
        } else if (2 === wtfType) {
            subLine = {
                'x1' : Math.round(position.x - gap * childNum),
                'x2' : Math.round(position.x + position.width)
            };
            y = !negative ? Math.round(position.y) : Math.round(position.y + position.height + offset);
            lLine.y1 = lLine.y2 = rLine.y1 = rLine.y2 = y;
            y = !negative ? Math.round(position.y + position.height) : Math.round(position.y + offset);
            subLine.y1 = subLine.y2 = y;
        } else {
            y = !negative ? Math.round(position.y + position.height) : Math.round(position.y + offset);
            lLine.y1 = lLine.y2 = y;
            y = !negative ? Math.round(position.y) : Math.round(position.y + position.height + offset);
            rLine.y1 = rLine.y2 = y; 
        }
        
        return {
            'lLine' : lLine, 
            'rLine' : rLine,
            'subLine' : subLine
        };    
    };

    WaterFallPlot.prototype._getWaterFallTypeScale = function(waterfallType) {
        return this._data.waterfallType.scale.scale(waterfallType);
    };

    WaterFallPlot.prototype._getChildNumScale = function(waterfallType) {
        return this._data.waterfallType.scale.childrenNum(waterfallType);
    };

    WaterFallPlot.prototype._drawLine = function(lineG, dataPoints, range) {
        dataPoints = dataPoints[0].getDataPoints();
        var visible = this._properties.get("linkline.visible");
        if(!visible){
            return;
        }
        this._dpGap = this._getGap(0, 0);
        var lines = [];
        var retLine;
        
        for (var itemIndex = range.min; itemIndex <= range.max; itemIndex++) {
            var dataPoint = dataPoints[itemIndex];
            if (!dataPoint || dataPoint.getRawData().valueAxis === null) {
                continue;
            }
            
            var dpConfig = dataPoint.getConfig();
            var position = dataPoint.getPosition();
            //fix the offset when negative datapoint is flipped.
            
            var negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
            var waterfallType = dataPoint.getRawData().waterfallType;
            var wtfType = this._getWaterFallTypeScale(waterfallType);
            var childNum = this._getChildNumScale(waterfallType);

            if (this.isHorizontal()) {
                retLine = this._getHorizontalLine(position, negative, wtfType, childNum);
            } else {
                retLine = this._getVerticalLine(position, negative, wtfType, childNum);
            }

            if (!retLine) {
                continue;
            }

            if (dataPoint.getItemIndex() !== 0) {
                lines.push(retLine.lLine);
            }
            if (dataPoint.getItemIndex() !== this._data.series[0].length - 1) {
                lines.push(retLine.rLine);
            }
            if (2 === wtfType) {
                lines.push(retLine.subLine);
            }
        }
        
        WaterfallUtils.drawLines(lines, this._properties, this.isHorizontal(), lineG, true);
    };
    
    WaterFallPlot.prototype._buildWrapperConfig = function(data, position, context) {
        var config = WaterFallPlot.superclass._buildWrapperConfig.apply(this, arguments);
        if (this._semanticMgr.hasDataPointColorStyle()) {
            if (this._semanticMgr.isOverrideMode()) {
                return config;
            } else if (config.hasOwnProperty('isOthers') && config.graphic.fill) {
                return config;
            }
        }
        var isSemanticColoring = this._properties.get("dataPoint.color.isSemanticColoring");
        var positiveColor,negativeColor,totalColor;
        if (isSemanticColoring === false) {
            var colorPalette = this._properties.get("colorPalette");
            positiveColor = negativeColor = config.data.color || colorPalette[0];
        } else {
            positiveColor = this._properties.get("dataPoint.color.positive");
            negativeColor = this._properties.get("dataPoint.color.negative");
        }

        positiveColor = NameColorUtils.convertColor(positiveColor);
        negativeColor = NameColorUtils.convertColor(negativeColor);

        totalColor = this._properties.get("dataPoint.color.total");
        totalColor = NameColorUtils.convertColor(totalColor);

        var wtfType = this._getWaterFallTypeScale(data.waterfallType);
        config.graphic.fill = (1===wtfType) ? totalColor :
            (data.valueAxis >= 0 ? positiveColor : negativeColor);

        return config;
    };
    
    WaterFallPlot.prototype._getDataLabels = function(name, runtime) {
        this._datalabels = new WaterfallDataLabels(runtime, {
            name: name,
            horizontal: this.isHorizontal()
        });
        return this._datalabels;
    };
    
    /*
     * To fix bug BITSDC1-7944, PO changes the behavior for column chart.
     * Waterfall chart overwrites this function to keep the old behavior and move up/left the negative columns/bars
     * 0.5px from the zero line.
     */
    WaterFallPlot.prototype._adjustPosition = function(position, seriesIndex) {
        var horizontal = this.isHorizontal();
        if(horizontal && position.width < 0) {
            position.width = position.width > -1 ? 1 : Math.abs(position.width);
            position.x -= position.width + 0.5;
        }
        if (!horizontal && position.height < 0) {
            position.height = position.height > -1 ? 1 : Math.abs(position.height);
            position.y -= position.height + 0.5;
        }
    };

    WaterFallPlot.prototype.destroy = function() {
        WaterFallPlot.superclass.destroy.call(this);
        this._dpGap = null;
    };
    
    return WaterFallPlot;
});

define('sap/viz/chart/components/plots/TimeWaterFallPlot',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/plots/TimeColumnPlot",
    "sap/viz/chart/components/plots/WaterFallPlot",
    "sap/viz/chart/util/WaterfallUtils",
    "sap/viz/framework/common/util/TimeUtil",
    'sap/viz/framework/common/util/FiscalUtil',
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/chart/components/plots/TimeStackedColumnPlot",
    'sap/viz/chart/components/renderers/TimeReferenceLineRenderer',
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/util/ArrayUtils"
], function Setup(oo, TimeColumnPlot, WaterFallPlot, WaterfallUtils, TimeUtil,
    FiscalUtil,
    DataGraphics, TimeStackedColumnPlot,
    TimeReferenceLineRenderer,
    Constants, NumberUtils,
    LangManager,
    TypeUtils,
    ArrayUtils) {

    var TimeWaterFallPlot = function(runtime, options) {
        TimeWaterFallPlot.superclass.constructor.apply(this, arguments);
        this._isSyncValueAxis =
            this.runtime().propertyManager().get("interaction.syncValueAxis") || false;
        this._visibleRange = null;
    };

    oo.extend(TimeWaterFallPlot, WaterFallPlot);

    TimeWaterFallPlot.prototype._getXPosition = TimeColumnPlot.prototype._getXPosition;

    TimeWaterFallPlot.prototype._getBarProperties = TimeColumnPlot.prototype._getBarProperties;

    TimeWaterFallPlot.prototype._getColumnWidth = TimeColumnPlot.prototype._getColumnWidth;
    
    TimeWaterFallPlot.prototype._getVisibleRange = TimeColumnPlot.prototype._getVisibleRange;
    
    TimeWaterFallPlot.prototype._getDataPointRange = TimeColumnPlot.prototype._getDataPointRange;

    TimeWaterFallPlot.prototype.getPreferredSize = TimeColumnPlot.prototype.getPreferredSize;

    TimeWaterFallPlot.prototype._updateBarWidth = TimeColumnPlot.prototype._updateBarWidth;
    
    TimeWaterFallPlot.prototype._getStartEnd = TimeColumnPlot.prototype._getStartEnd;

    TimeWaterFallPlot.prototype._getWaterFallTypeScale = function(dataPoint) {
        return 0;
    };

    TimeWaterFallPlot.prototype._getChildNumScale = function(dataPoint) {
        return 0;
    };

    TimeWaterFallPlot.prototype.getReferenceLineRenderer = function () {
        return TimeReferenceLineRenderer;
    };

    TimeWaterFallPlot.prototype._buildData = TimeColumnPlot.prototype._buildData;

    TimeWaterFallPlot.prototype.getRealSizeByFixedDPSize = TimeColumnPlot.prototype.getRealSizeByFixedDPSize; 

    TimeWaterFallPlot.prototype._getSeriesDataPoint = function(seriesIndex, itemIndex) {
        return this._data.series[seriesIndex][itemIndex];
    };
    
    TimeWaterFallPlot.prototype._getConnectionLine = function(position, negative, dpAddress, endPosition) {
        var connectionLine = {};
        if (!endPosition) {
            return undefined;
        }
        connectionLine.skip = false;
        connectionLine.x1 = position.x;
        connectionLine.x2 = endPosition.x + endPosition.width;
        if (negative) {
            connectionLine.y1 = position.y + position.height;
            connectionLine.y2 = position.y + position.height;
        } else {
            connectionLine.y1 = position.y;
            connectionLine.y2 = position.y;
        }
        return connectionLine;
    };

    TimeWaterFallPlot.prototype._getRecapDate = function (dataPoint, level, showAsUTC, originProp) {
        var isFiscal = false;
        if (this._data.rawData && this._data.rawData.dataModel &&
            this._data.rawData.dataModel._rawData) {
            isFiscal = FiscalUtil.isFiscal(this._data.rawData.dataModel._rawData);
        }
        var reDate;
        var timeValue = dataPoint.getRawData().timeAxis[0].parsedValue;
        var ceiledValue;
        if (isFiscal) {
            ceiledValue = TimeUtil.nextDateByLevel(timeValue, level, showAsUTC, originProp);
            reDate = 0.5 * (timeValue + ceiledValue);
        }
        else {
            ceiledValue = TimeUtil.ceil(timeValue, level, showAsUTC, originProp);
            reDate = Math.ceil(0.5 * (timeValue + ceiledValue));
        }
        return reDate;
    };

    TimeWaterFallPlot.prototype._drawLine = function(lineG, series, range) {
        var lineVisible = this._properties.get("linkline.visible");
        var recapVisible = this._properties.origin.get("plotArea.dataLabel.showRecap");
        if(!lineVisible && !recapVisible){
            return;
        }

        var values = this.getData().valueAxis.values;
        var timeValues = this.getData().timeAxis._sortedTimeStampSet;

        var lines = [];
        var connectionLine, periodsWidth, seriesDataPoints, seriesDataPoint;
        var startIndex = 0;
        var seriesLen = series.length;
        var endIndex = seriesLen - 1;
        var width = this.getRealSize().width;
        var scale = this.getData().timeAxis.scale;
        var date, dataPoints, firstDataPoint = null, lastDataPoint = null, itemIndex, idx;
        var dpConfig, position, negative, exData, recapX, recapY;
        var barProperties = this._getBarProperties();
        var level = barProperties.minTimeLevel;
        var showAsUTC = this._properties.origin.get('general.showAsUTC');       
        var originProp = this._properties.origin;

        var findDataPoint = function(seriesData, index, nearSeriesData) {
            var dataPoints = seriesData.getDataPoints();
            var nearDataPoints;
            if (nearSeriesData) {
                nearDataPoints = nearSeriesData.getDataPoints();
            }
            var getDataPointByTimeValues = function(dataPoints, timeValue) {
                var i = ArrayUtils.bisearch(dataPoints, timeValue, function(item) {
                    return item ? item.getRawData().timeAxis[0].parsedValue : 0;
                });
                return (dataPoints[i] && dataPoints[i].getRawData().timeAxis[0].parsedValue === timeValue) ?
                    dataPoints[i] : null;
            };
            return {
                dataPoint: getDataPointByTimeValues(dataPoints, timeValues[index]),
                nearDataPoint: nearDataPoints ? getDataPointByTimeValues(nearDataPoints, timeValues[index]) : null
            };
        };

        if(recapVisible) {
            //Here we get the width of any exist datapoint as the single column width.
            for (var i = 0; i < seriesLen; i++) {
                if (series[i]) {
                    seriesDataPoints = series[i].getDataPoints();
                    for (var j = 0; j < seriesDataPoints.length; j++) {
                        seriesDataPoint = seriesDataPoints[j];
                        if (seriesDataPoint) {
                            position = this._getDataPointPosition(seriesDataPoint);
                            periodsWidth = (seriesLen === 1) ? 
                            position.width * barProperties.barSpacing : 
                            position.width * barProperties.groupSpacing;
                            break;
                        }
                    }
                }
            }
            // First half line
            for (itemIndex = 0; itemIndex <= timeValues.length && !firstDataPoint; itemIndex++) {
                for(idx = startIndex; idx <= endIndex && !firstDataPoint; idx++) {
                    if(series[idx]) {
                        firstDataPoint = findDataPoint(series[idx], itemIndex).dataPoint;
                    }
                }
            }
            if(firstDataPoint) {
                dpConfig = firstDataPoint.getConfig();
                if(dpConfig) {
                    position = firstDataPoint.getPosition();            
                    negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
                    var firstLine = {};
                    firstLine.skip = false;
                    firstLine.x1 = 0;
                    firstLine.x2 = position.x + position.width;
                    if (negative) {
                        firstLine.y1 = position.y;
                        firstLine.y2 = position.y;
                    } else {
                        firstLine.y1 = position.y + position.height;
                        firstLine.y2 = position.y + position.height;
                    }
                    lines.push(firstLine);
                }
            }
        }

        for (itemIndex = 0; itemIndex < timeValues.length - 1; itemIndex++) {
            var startDataPoint = null, itemIdx, result, nearStartDataPoint = null;
            for(idx = endIndex; idx >= startIndex && !startDataPoint; idx--) {
                if(series[idx]) {
                    result = findDataPoint(series[idx], itemIndex, series[idx - 1]);
                    startDataPoint = result.dataPoint;
                    nearStartDataPoint = result.nearDataPoint;
                }
            }

            if(!startDataPoint || !startDataPoint.getNode()) {
                continue;
            }

            dpConfig = startDataPoint.getConfig();
            if(!dpConfig) {
                continue;
            }
            position = startDataPoint.getPosition();
            negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
            var addr = {seriesIndex: idx, itemIndex: itemIndex};

            var endDataPoint = null, nearEndDataPoint = null;
            for (var index = itemIndex + 1; index < timeValues.length && !endDataPoint; index++) {
                for(idx = startIndex; idx <= endIndex && !endDataPoint; idx++) {
                    if(series[idx]) {
                        result = findDataPoint(series[idx], index, series[idx + 1]);
                        endDataPoint = result.dataPoint;
                        nearEndDataPoint = result.nearDataPoint;
                    }
                }
            }
            
            date = this._getRecapDate(startDataPoint, level, showAsUTC, originProp);
            var endPosition = endDataPoint ? endDataPoint.getPosition() : undefined;
            exData = DataGraphics.getData(startDataPoint.getNode());
            if(endPosition) {
                connectionLine = this._getConnectionLine(position, negative, addr, endPosition);
                if(!lineVisible) {
                    connectionLine.skip = true;
                }
                lines.push(connectionLine);
            }else {
                connectionLine = {
                    skip: true
                };
            }
            if(recapVisible) {  
                recapX = scale.scale(date) * width;
                recapY = negative ? position.y + position.height : position.y;            
                connectionLine.recap = {
                    x : recapX,
                    y : recapY
                };
                var startDataPointVaule = startDataPoint.getRawData().valueAxis, 
                endDataPointVaule = endDataPoint ? endDataPoint.getRawData().valueAxis : null;
                exData.recap = {
                    x : recapX,
                    y : recapY,
                    value : NumberUtils.preciseSimple(startDataPoint.getRawData().total),
                    position : startDataPointVaule >= 0 && endDataPointVaule < 0 ? 'up' : 'down'
                };
                if (startDataPointVaule < 0 && endDataPointVaule < 0) {
                    // If the recap label overlap with the end datapoint, then move towards left
                    exData.recap.basePos = "end";
                    exData.recap.basePosId = endDataPoint.getId();
                } else if (startDataPointVaule >= 0 && endDataPointVaule >= 0) {
                    // If the recap label overlap with the start datapoint, then move towards right
                    exData.recap.basePos = "start";
                    exData.recap.basePosId = startDataPoint.getId();
                } else {
                    exData.recap.basePos = "middle";
                    //When the basePos of recap label is middle,
                    //consider the dataPoints that close to the startDataPoint and endDataPoint 
                    //to determine whether the recap label needs to move towards right or left.

                    //When the dataPoint is null, we can assume its value is 0.
                    var nearStartDataPointValue = nearStartDataPoint ? nearStartDataPoint.getRawData().valueAxis : 0;
                    var nearEndDataPointValue = nearEndDataPoint ? nearEndDataPoint.getRawData().valueAxis : 0;
                    var setNearBasePose = function (exData, nearBasePos, dataPoint) {
                        exData.recap.nearBasePos = nearBasePos;
                        exData.recap.nearBasePosId = dataPoint.getId();
                    };
                    if (startDataPointVaule >= 0 && endDataPointVaule < 0) {
                        if (((nearStartDataPointValue < 0 && 
                            Math.abs(nearStartDataPointValue) <= startDataPointVaule) || 
                            nearStartDataPointValue >= 0) &&
                            nearEndDataPointValue > Math.abs(endDataPointVaule)) {
                            setNearBasePose(exData, "right",nearEndDataPoint);
                        } else if (nearStartDataPointValue < 0 && 
                            Math.abs(nearStartDataPointValue) > startDataPointVaule && 
                            nearEndDataPointValue <= Math.abs(endDataPointVaule)
                            ) {
                            setNearBasePose(exData, "left", nearStartDataPoint);
                        }
                    } else {
                        if ((nearStartDataPointValue <= 0 ||
                            (nearStartDataPointValue > 0 && 
                            nearStartDataPointValue <= Math.abs(startDataPointVaule))) &&
                            nearEndDataPointValue < 0 &&
                            Math.abs(nearEndDataPointValue) > endDataPointVaule) {
                            setNearBasePose(exData, "right", nearEndDataPoint);
                        } else if ((nearEndDataPointValue >= 0 || 
                            (nearEndDataPointValue < 0 && 
                            Math.abs(nearEndDataPointValue) <= endDataPointVaule)) &&
                            nearStartDataPointValue > Math.abs(startDataPointVaule)) {
                            setNearBasePose(exData, "left", nearStartDataPoint);
                        }
                    }
                }
                DataGraphics.setData(startDataPoint.getNode(), exData);
            }
        }
        if(recapVisible) {
            // Last half line
            for (itemIndex = timeValues.length - 1; itemIndex >= 0; itemIndex--) {
                for(idx = endIndex; idx >= startIndex; idx--) {
                    if(series[idx]) {
                        lastDataPoint = findDataPoint(series[idx], itemIndex).dataPoint;
                    }
                    if(lastDataPoint) {
                        break;
                    }
                }
                if(lastDataPoint) {
                    break;
                }
            }
            if(lastDataPoint && lastDataPoint.getNode()) {
                dpConfig = lastDataPoint.getConfig();
                if(dpConfig) {
                    position = lastDataPoint.getPosition();            
                    negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
                    date = this._getRecapDate(lastDataPoint, level, showAsUTC, originProp);
                    var lastLine = {};
                    lastLine.skip = false;
                    lastLine.x1 = position.x;
                    lastLine.x2 = width;
                    if (negative) {
                        lastLine.y1 = position.y + position.height;
                        lastLine.y2 = position.y + position.height;
                    } else {
                        lastLine.y1 = position.y;
                        lastLine.y2 = position.y;
                    }
                    lines.push(lastLine);
                    recapX = lastLine.x2 - Constants.RECAP.WIDTH / 2;
                    recapY = lastLine.y1;
                    lastLine.recap = {
                        x : recapX,
                        y : recapY
                    };
                    exData = DataGraphics.getData(lastDataPoint.getNode());
                    exData.recap = {
                        x : recapX,
                        y : recapY,
                        value : NumberUtils.preciseSimple(lastDataPoint.getRawData().total),
                        position : negative ? 'down' : 'up',
                        startId : lastDataPoint.getId(),
                        endId : null
                    };
                    DataGraphics.setData(lastDataPoint.getNode(), exData);
                }
            }
        }
        
        WaterfallUtils.drawLines(lines, this._properties, this.isHorizontal(), lineG, false, periodsWidth);
    };

    TimeWaterFallPlot.prototype._shiftOffsetForIncompleteRange =
        TimeColumnPlot.prototype._shiftOffsetForIncompleteRange;

    TimeWaterFallPlot.prototype._getDefaultZeroLineColor = function() {
        return this._properties.origin.get("timeAxis.color");
    };

    TimeWaterFallPlot.prototype._drawDatapoints = function (parent, addtionalInfo) {
        TimeWaterFallPlot.superclass._drawDatapoints.apply(this, arguments);
        //to draw ValueBasedColor use this._dataPointContext and addtionalInfo.timeAxis
        this._addtionalInfo = addtionalInfo;
        this.renderAddition();
    };

    TimeWaterFallPlot.prototype._updateDatapoints = function (parent) {
        TimeWaterFallPlot.superclass._updateDatapoints.apply(this, arguments);
        this.renderAddition();
    };

    TimeWaterFallPlot.prototype.scroll = function (parent) {
        TimeWaterFallPlot.superclass.scroll.apply(this, arguments);
        this.renderAddition();
    };

    TimeWaterFallPlot.prototype.renderAddition = function () {
        return this._addtionalInfo && this._addtionalInfo.timeAxis &&
            this._addtionalInfo.timeAxis.renderAddition &&
            this._addtionalInfo.timeAxis.renderAddition(this._dataPointContext);
    };

    TimeWaterFallPlot.prototype._preShowDataPoints = function (dataPointG) {
        TimeWaterFallPlot.superclass._preShowDataPoints.apply(this, arguments);
        //build _endOfPeriodArray
        this._endOfPeriodArray = [];
        var seriesIndex;
        for (seriesIndex = 0; seriesIndex < this._series.length; seriesIndex++) {
            var seriesModel = this._series[seriesIndex];
            if (seriesModel) { // The whole series value may be null
                var dataPoints = seriesModel.getDataPoints();
                //we should count all (include invisible)
                for (var itemIndex = 0; itemIndex < dataPoints.length; itemIndex++) {
                    var dataPointModel = dataPoints[itemIndex];
                    if (!dataPointModel) {
                        continue;
                    }
                    var data = dataPointModel.getRawData();
                    var timeValue = data.timeAxis[0].parsedValue;
                    //the last one is the total.
                    this._endOfPeriodArray[timeValue] = data.total;
                }
            }
        }
    };

    TimeWaterFallPlot.prototype._buildWrapperConfig = function (data, position, context, option) {
        var statusMgr = this.runtime().statusManager();
        var recapName = statusMgr.get(Constants.RECAP.RECAP_KEY);
        if (TypeUtils.isExist(recapName)) {
            //to avoid multiple recap names
            delete context[recapName];
        }
        else {
            statusMgr.add(Constants.RECAP.RECAP_KEY, recapName);
        }

        if (this._properties.origin.get('plotArea.dataLabel.showRecap')) {
            //as the requirment of out PO, the ctx porperty name should follow user setting.
            recapName = this._properties.origin.get("plotArea.dataLabel.recapTitle") ||
                LangManager.get("IDS_END_OF_PERIOD", "en");
            if (this._endOfPeriodArray && option &&
                this._endOfPeriodArray[option.timeValue]) {
                context[recapName] = this._endOfPeriodArray[option.timeValue];
            }
            else {
                context[recapName] = data.total;
            }
            statusMgr.set(Constants.RECAP.RECAP_KEY, recapName);
        }

        var config = TimeWaterFallPlot.superclass._buildWrapperConfig.apply(this, arguments);

        //to add value based color context
        var additionCtx = (data && !data.isNullValue) ? data.dp.additionCtx() : {};
        config.vbcContext = {};
        config.vbcContext.color = this._semanticMgr.analyzeValueBasedColor(context, additionCtx);
        return config;
    };

    TimeWaterFallPlot.prototype.destroy = function() {
        TimeWaterFallPlot.superclass.destroy.call(this);
        this._isSyncValueAxis = null;
        this._visibleRange = null;
    };

    TimeWaterFallPlot.prototype._getRangeTick =
        TimeColumnPlot.prototype._getRangeTick;

    TimeWaterFallPlot.prototype._getColumnWidthRatio = 
        TimeColumnPlot.prototype._getColumnWidthRatio;

    TimeWaterFallPlot.prototype._getCategoryScaleHandlers =
        TimeColumnPlot.prototype._getCategoryScaleHandlers;

    TimeWaterFallPlot.prototype._getCategoryCount =
        TimeColumnPlot.prototype._getCategoryCount;

    return TimeWaterFallPlot;
});

define('sap/viz/chart/components/plots/TimeStackedCombinationPlot',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/plots/TimeCombinationPlot",
    "sap/viz/chart/components/plots/TimeStackedColumnPlot",
    "sap/viz/chart/components/plots/StackedCombinationPlot",
    "sap/viz/chart/components/plots/ScaleHandler",
    'sap/viz/chart/components/plots/StackedPlotHelper',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils"
], function(
    oo,
    TimeCombinationPlot,
    TimeStackedColumnPlot,
    stkCombPlot,
    ScaleHandler,
    StackedPlotHelper,
    DataHandler,
    Constants,
    TypeUtils
) {

    var LINE = "line";
    var BAR = "bar";

    var TimeStackedCombinationPlot = function(runtime, options) {
        TimeStackedCombinationPlot.superclass.constructor.apply(this, arguments);

        this._lineDataHandler = DataHandler.getHandler();
        this._stackDataHandler = this._getDataHandler();

        this._drawZeroLineBeforeDatapoints = true;

        this._attachMarkManager();
        this._markerPropName = "line.marker";

        this.dataShapePrimaryAxisPW = this._properties.watch("dataShape.primaryAxis",
            this._onDataShapeChange.bind(this));

        this._options.isCombination = true;

        this._lineRenderer = null;
        this._isDrawDp = true;
    };

    oo.extend(TimeStackedCombinationPlot, TimeCombinationPlot);

    var prop = TimeStackedCombinationPlot.prototype;

    var stackCombinationPlotInheritList = [
        "_adjustPosition",
        "_attachMarkManager",
        "_buildConfig",
        "_getColor",
        "_getDataHandler",
        "_getDataPointRenderer",

        "_drawCategory",
        "_drawDataPoint",
        "_drawLine",
        "_updateLine",
        "_updateDatapoint",

        "_getSeries",
        "getSeriesStyle",

        "_getDataHandler",
        "_generatePath",
        "_getDataLabels",
        "_getDataShape",
        "_getYPosition",

        "isMarkerVisible",
        "_needValidEmptyAxisData",
        "_removeEmptyStacks"
    ];

    stackCombinationPlotInheritList.forEach(function(e){
        prop[e] = stkCombPlot.prototype[e];
    });

    prop._pushDataPointContext = TimeStackedColumnPlot.prototype._pushDataPointContext;
    prop._getCategoryScaleHandlers = TimeStackedColumnPlot.prototype._getCategoryScaleHandlers;
    prop._getColumnWidthRatio = TimeStackedColumnPlot.prototype._getColumnWidthRatio;
    prop._getColumnCount = TimeStackedColumnPlot.prototype._getColumnCount;


    prop._showDataPoints = function(){
        //do nothing
        //_drawDataPoints is the one used
    };

    prop._updateDatapoints = function(){
        this._preShowDataPoints();
        stkCombPlot.prototype._updateDatapoints.apply(this, arguments);
    };

    prop._preShowDataPoints = function() {
        this._dataPointContext = [];
        TimeStackedCombinationPlot.superclass._preShowDataPoints.apply(this, arguments);
    };

    prop._drawDatapoints = function(parent){
        this._initSeries();
        this._preShowDataPoints();
        stkCombPlot.prototype._drawDatapoints.apply(this, arguments);
    };

    prop._buildData =  function(dpConfig){
        var ret = stkCombPlot.prototype._buildData.apply(this, arguments);
        ret.timeField = this._data.timeAxis.metaData.map(function(e) {
            return e.id;
        });
        dpConfig.timeField = ret.timeField;
        return ret;
    };

    prop._buildWrapperConfig = function(data, position, context, option){
        var config = TimeStackedCombinationPlot.superclass._buildWrapperConfig.apply(this, arguments);
        config.graphic.shape = this._getMarkerShape();
        config.position = position;

        if(!TypeUtils.isExist(config.graphic.fill)){
            config.graphic.fill =  this._getColor(data);
        }

        config.seriesIndex = this.getSeriesIndex(data.dp);
        return config;
    };

    prop._getVisibleRange = function(){
        return StackedPlotHelper.getVisibleRange(this, TimeCombinationPlot);
    };

    prop.allowBreakLine = function(dp){
        return Constants.DATAPOINT_INVALIDITY_SUPPORTED.indexOf(
                this._properties.get('dataPoint.invalidity')) <= 0 && dp.ignore;
    };

    prop._createDataPoint = function(seriesIndex, itemIndex, dpConfig, dpData, position, currentId,
                            data){
        
        var dpModel;
        var seriesModel = this._series[seriesIndex];
        var dataPoints = seriesModel.getDataPoints();
        if (dataPoints) {
            dpModel = dataPoints[itemIndex];
            dpModel.init(dpConfig, currentId, dpData,
                                    data.dp && data.dp.id ? data.dp.id : Constants.NULL_VALUE);
            dpModel.setPosition(position);
            dpModel.setRawData(data);
        } else {
            dpModel = stkCombPlot.prototype._createDataPoint.apply(this, arguments);
        }
        return dpModel;
    };

    prop.getSeriesIndex = function(dp){
        return this._series.length -  dp._addr[1] - 1;
    };

    prop.getDataPointShape = function(dataPoint){
        var seriesIndex;
        if(TypeUtils.isNumber(dataPoint)){
            seriesIndex = dataPoint;
        }else{
            //reversed
            seriesIndex = this._series.length - dataPoint._addr[1] - 1;
        }
        return this._getDataShape(seriesIndex);
    };

    prop.getSeriesStyle = function(seriesIndex, context, isNormalIndex){
        // stacked chart's series is reversed.
        // getSeriesStyle() need normal index.
        // During chart creating, normal index is passed.
        // During legend hovering, reveresed index is passed.
        // During tooltip, normal index is passed

        //reversed index and nornaml index are used all around
        //!!TODO: use one single index
        seriesIndex = (context || isNormalIndex)? seriesIndex: this._series.length -  seriesIndex - 1;
        return TimeStackedCombinationPlot.superclass.getSeriesStyle.call(this, seriesIndex, context);
    };

    prop._getDPOptions = function(seriesStyle, isLine, data){
        var ret = stkCombPlot.prototype._getDPOptions.apply(this, arguments);
        ret.color = this._getColor(data);  //color is needed for big data line
        return ret; 
    };

    return TimeStackedCombinationPlot;
});

define('sap/viz/chart/components/plots/TYPlotFactory',[
    'jquery',
    'sap/viz/chart/components/plots/TimeLinePlot',
    'sap/viz/chart/components/plots/TimeColumnPlot',
    'sap/viz/chart/components/plots/TimeCombinationPlot',
    'sap/viz/chart/components/plots/TimeBulletPlot',
    "sap/viz/chart/components/plots/TimeStackedColumnPlot",
    "sap/viz/chart/components/plots/TimeStackedPercentagePlot",
    "sap/viz/chart/components/plots/TimeWaterFallPlot",
    'sap/viz/chart/components/plots/TimeStackedCombinationPlot',
], function($,
    TimeLinePlot,
    TimeColumnPlot, 
    TimeCombinationPlot,
    TimeBulletPlot,
    TimeStackedColumnPlot,
    TimeStackedPercentagePlot,
    TimeWaterFallPlot,
    TimeStackedCombinationPlot
) {

    var plotMapping = {
        'timeseries_line' : {
            plotClazz : TimeLinePlot
        },
        'timeseries_column' : {
            plotClazz : TimeColumnPlot
        },
        "timeseries_stacked_column" : {
            plotClazz : TimeStackedColumnPlot
        },
        "timeseries_100_stacked_column" : {
            plotClazz : TimeStackedPercentagePlot
        },
        'timeseries_combination' : {
            plotClazz : TimeCombinationPlot
        },
        'dual_timeseries_combination' : {
            plotClazz : TimeCombinationPlot
        },
        'timeseries_bullet' : {
            plotClazz : TimeBulletPlot
        },
        'timeseries_waterfall' : {
            plotClazz : TimeWaterFallPlot
        },
        'timeseries_stacked_combination' : {
            plotClazz : TimeStackedCombinationPlot
        },
    };

    return {
        getPlotClazz: function(renderType) {
            var config = plotMapping[renderType];
            return config && config.plotClazz;
        }
    };

});

define('sap/viz/chart/components/plotareas/TimeYPlotArea',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/oo',
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/chart/components/callout/CalloutContainer',
    'sap/viz/chart/components/plotareas/XYPlotArea',
    'sap/viz/chart/components/axis/ValueAxis',
    'sap/viz/chart/components/axis/TimeAxis',
    'sap/viz/chart/components/plots/TYPlotFactory',
    'sap/viz/chart/components/plots/PlotHelper',
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/chart/components/util/ZoomUtil',
    'sap/viz/chart/components/scrollbar/Scrollbar',
    "sap/viz/framework/common/util/ArrayUtils",
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/TimeUtil',
    'sap/viz/framework/common/util/FiscalUtil',
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/chart/scales/TimeScale',
    'sap/viz/chart/components/zoom/TimeYZoomer',
    "sap/viz/chart/components/plots/TimeWaterFallPlot",
    "sap/viz/chart/components/zoom/ZoomLimit",
    "sap/viz/chart/components/util/SeriesUtil",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/trendline/Trendline'
], function(
    Constants,
    oo,
    ValueScale,
    ValueScaleUtil,
    CalloutContainer,
    XYPlotArea,
    ValueAxis,
    TimeAxis,
    PlotFactory,
    PlotHelper,
    ValueAxisUtils,
    ZoomUtil,
    Scrollbar,
    ArrayUtils,
    DataUtils,
    UADetector,
    TypeUtils,
    TimeUtil,
    FiscalUtil,
    NumberUtils,
    TimeScale,
    TimeYZoomer,
    TimeWaterFallPlot,
    ZoomLimit,
    SeriesUtil,
    ObjectUtils,
    TrendLine
) {

    var TimeYPlotArea = function(runtime, options) {
        this._rawData = (options && options.rawData && options.rawData.dataModel &&
            options.rawData.dataModel._rawData);
        this._isTruncatedWindowInput = false;
        TimeYPlotArea.superclass.constructor.apply(this, arguments);
    };

    var precise = NumberUtils.preciseSimple;
    var isNum = TypeUtils.isNumber;

    oo.extend(TimeYPlotArea, XYPlotArea);

    TimeYPlotArea.prototype._getValueAxis = function(data){
        return data.valueAxis;
    };

    TimeYPlotArea.prototype.destroy = function() {
        TimeYPlotArea.superclass.destroy.apply(this, arguments);
    };

    TimeYPlotArea.prototype._init = function(config, options) {
        this._plot = PlotHelper.create(this._renderType, PlotFactory.getPlotClazz(this._renderType),
                                       this.runtime(), this._getPlotOptions());
        this.setChild("plot", this._plot, {
            position: "center"
        });
        this._plot.getDispatch().on("reRenderComplete.plotarea", this._reRenderComplete.bind(this));

        var hasScrollbar = !this._properties.get("interaction.noninteractiveMode") ||
                        !this.isColumnLike() && !!this._properties.get('timeAxis.interval.unit');
        this.setLayoutSequence(['left', 'right', 'bottom', 'top']);

        var dataModel = (options && options.rawData && options.rawData.dataModel);
        this._categoryAxis = new TimeAxis(this.runtime(), {
            name: "timeAxis",
            hasScrollbar: hasScrollbar,
            isColumnLike: this.isColumnLike(),
            isMultiplySeriesColumn: this.isMultiplySeriesColumn(dataModel),
            isKeepMinimalLevelContinuousTicks: this.isKeepMinimalLevelContinuousTicks(dataModel),
            isLineChart: this._isLineChart(),
            rawData: this._rawData
        });
        this.setChild("timeAxis", this._categoryAxis, {
            position: "bottom"
        });
        if (hasScrollbar) {
            this._hScrollbar = this._categoryAxis.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
        }

        this._valueAxis = new ValueAxis(this.runtime(), {
            name: "valueAxis"
        });
        this.setChild("valueAxis", this._valueAxis, {
            position: "left"
        });

        //if charts have callouts
        if(this._properties.get("plotArea.callout.left")) {
            this._leftCallouts = new CalloutContainer(this.runtime(), {
                name: "plotArea.callout",
                position: "left"
            });
            this.setChild("leftCallouts", this._leftCallouts, {
                position: "left",
                priority: 1,
                //unique means there is only one component in the positon.
                //if the "unique" component does not have size, other components can
                //be layouted.
                unique: true
            });
        }

        if(this._properties.get("plotArea.callout.top")) {
            this._topCallouts = new CalloutContainer(this.runtime(), {
                name: "plotArea.callout",
                position: "top"
            });
            this.setChild("topCallouts", this._topCallouts, {
                position: "top"
            });
        }
        if (this._isPercentageChart()) {
            this._valueAxis.setPercentageMode(true);
        }

        this.getZoomer().init({
            main: this,
            plot: this._plot,
            isHorizontal: false
        });
    };

    //for callout in big data model
    TimeYPlotArea.prototype.extractCalloutInfo = function() {
        var calloutInfo = [];
        for(var key in this._children) {
            if(this._children.hasOwnProperty(key)) {
                var module = this._children[key].module;
                if(module._callouts) {
                    calloutInfo = calloutInfo.concat(module._callouts);
                }
            }
        }
        return calloutInfo;
    };

    TimeYPlotArea.prototype._postLayout = function(results) {
        TimeYPlotArea.superclass._postLayout.apply(this, arguments);
        var calloutInfo = this.extractCalloutInfo();
        for(var key in this._children){
            if(this._children.hasOwnProperty(key)){
                var module = this._children[key].module;
                if(module.setCalloutInfo) {
                    module.setCalloutInfo(calloutInfo);
                }
            }
        }
    };

    TimeYPlotArea.prototype.getAddtionalInfo = function (child) {
        var addtionalInfo;
        //TimeWaterFallPlot support VBC callback functions
        if (child instanceof TimeWaterFallPlot) {
            var timeAxisModule;
            var timeAxisChild = this.getChild("timeAxis");
            if (timeAxisChild) {
                timeAxisModule = timeAxisChild.module;
            }
            addtionalInfo = {};
            addtionalInfo.timeAxis = timeAxisModule;
        }

        return addtionalInfo;
    };

    TimeYPlotArea.prototype._hasScrollbar = function(){
        var hasScrollbar = TimeYPlotArea.superclass._hasScrollbar.apply(this, arguments);
        return hasScrollbar || (!this.isColumnLike() && !!this._properties.get('timeAxis.interval.unit'));
    };

    TimeYPlotArea.prototype._preRender = function() {
        var dataScales = this._data.timeAxis.scale;
        var domain = dataScales.getDomain();
        var range = this._getZoomRange(domain);

        //only handle time axis is on bottom or top and only when time axis is visible.
        if (!this._plot.isHorizontal()) {
            if (this.isColumnLike()){
                var refSize = this._plot.getPreferredSize();
                if (this._hasScrollbar()) {
                    // offset = this._plot.getOffset();
                    this._categoryAxis.setRealSize(refSize);
                }
            } else {
                if (this._categoryAxis.isVisible()){
                    var refWidth = this._categoryAxis.getChild("axisBody").module.getRealSize().width;
                    if (refWidth > 0) {
                        this._realSize.width = refWidth;
                        this._plot.setRealSize({
                            "width": refWidth
                        });
                    }
                }
            }
        }
        XYPlotArea.superclass._preRender.apply(this, arguments);
        var globalDomain = this._valueAxis._scale.getDomain();
        this._runtime.statusManager().add('globalDomain', {
            value: [globalDomain[0], globalDomain[1]],
            readonly: true
        });

        this._applyTransform(domain, range);
    };

    TimeYPlotArea.prototype._getZoomRange = function(domain){
        function handlePropInput(dd){
            var result = dd;
            if (TypeUtils.isExist(result)) {
                result = new Date(result).getTime();
                result = parseInt(result);
            }
            return result;
        }

        var props = this._properties;
        var range = ZoomUtil.getZoomRange(props, domain);
        var start = handlePropInput(range[0]);
        var end = handlePropInput(range[1]);

        if (isNum(start) && start < domain[0]) {
            start = domain[0];
        }
        if (isNum(end) && end > domain[1]) {
            end = domain[1];
        }
        return [start, end];
    };


    TimeYPlotArea.prototype._applyTransform = function(domain, range) {
        this._isTruncatedWindowInput = false;
        function checkInputDomain(){
            if ( isNaN(start) || start < domain[0]) {
                start = domain[0];
            }
            if (isNaN(end) || end > domain[1]) {
                end = domain[1];
            }
        }

        var start = range[0];
        var end = range[1];
        var isIncompleteRange = ZoomUtil.isRangeIncomplete(range);
        var isValid = ZoomUtil.isZoomRangeValid(start, end, domain);
        var zoomRatio, delta;

        if(isValid && isIncompleteRange){
            zoomRatio = this.runtime().statusManager().get("plot.transform.scale");
            var minLevel =  this._plot._getBarProperties().minTimeLevel;
            var halfPeriod = TimeUtil.getPeriod(minLevel) / 2;
            var checkInfo = {};
            if(!isNum(start)){
                start = end - Math.abs(domain[0] - domain[1])/zoomRatio.x;
                if(this.isColumnLike()){
                    start += halfPeriod;
                }
                checkInputDomain();
                checkInfo["alignStart"] = domain[0];
                checkInfo["alignEnd"] = end + halfPeriod;
            }else{
                if(this.isColumnLike()){
                    start -= halfPeriod;
                }
                checkInputDomain();
                checkInfo["alignStart"] = start;
                checkInfo["alignEnd"] = domain[1];
            }

            delta = -Math.abs((domain[0] - start) / (domain[0] - domain[1])); //it's a negative value.

            if(this._applyOffserAndZoom(delta, zoomRatio, checkInfo)){
                return;
            }else{
                fillRange(range, domain);
            }
        }

        start = range[0];
        end = range[1];
        isIncompleteRange = ZoomUtil.isRangeIncomplete(range);
        isValid = ZoomUtil.isZoomRangeValid(start, end, domain);

        if (isValid && !isIncompleteRange){
            checkInputDomain();
            if (this.isColumnLike()) {
                this._isTruncatedWindowInput = true;
                var truncatedWindowInput = this._truncateAndExtendWindowInput(start, end);
                start = truncatedWindowInput[0];
                end = truncatedWindowInput[1];
                checkInputDomain();
            }

            if (start >= end) {
                start = domain[0];
                end = domain[1];
            }
            //set zoomLevel and offset
            zoomRatio = Math.abs((domain[0] - domain[1]) / (start - end));

            zoomRatio = {
                x: zoomRatio,
                y: zoomRatio
            };
            delta = -Math.abs((domain[0] - start) / (domain[0] - domain[1])); //it's a negative value.
        } else {
            //if user does not set zoom interval, use original one.
            zoomRatio = this.runtime().statusManager().get("plot.transform.scale");
            delta = 0;
        }

        if(zoomRatio){
            this._applyOffserAndZoom(delta, zoomRatio);
        }

    };

    function fillRange(range, domain){
        if ( !TypeUtils.isExist(range[0])) {
            range[0] = domain[0];
        }
        if (!TypeUtils.isExist(range[1])) {
            range[1] = domain[1];
        }
        return range;
    }

    TimeYPlotArea.prototype._applyOffserAndZoom = function(delta, zoomRatio, checkInfo){
        var scale = {
            x: 1,
            y: 1
        };
        var offset = {
            x: 0,
            y: 0
        };
        var centerModule = this.getChildrenByPosition("center")[0];
        var size = centerModule.getSize();
        var realSize = centerModule.getRealSize();

        var ck = centerModule.isHorizontal()? "y" : "x";
        var sk = centerModule.isHorizontal()? "height" : "width";
        scale[ck] = zoomRatio[ck];
        offset[ck] = precise(delta * size[sk] * zoomRatio[ck]);

        if(checkInfo){
            var endPosition = precise(-offset[ck] + size[sk]);
            var endD = this._convertPositionIntoTimeStemp(endPosition);
            var startD = this._convertPositionIntoTimeStemp(-offset[ck]);

            if(isNum(checkInfo["alignStart"]) && startD  < checkInfo["alignStart"]){
                return false;
            }else if(isNum(checkInfo["alignEnd"]) && endD > checkInfo["alignEnd"] ){
                return false;
            }
        }
        //we can make some cache here in order not to
        //let zoom and scroll logic run every time chart is updated.
        this.zoom(scale);
        // If sync value axis, we should recalculate value axis range
        if(this._properties.get("interaction.syncValueAxis") || offset.x || offset.y){
            this.scroll(offset);
        }
        return true;
    };

    TimeYPlotArea.prototype._convertPositionIntoTimeStemp = function(position){
        var centerModule = this.getChildrenByPosition("center")[0];
        var realSize = centerModule.getRealSize();
        var tempSize = centerModule.isHorizontal()? realSize.height : realSize.width;
        return Math.round(centerModule._data.timeAxis.scale._scale.invert(position/tempSize));
    };

    TimeYPlotArea.prototype._setAxisData = function(data) {
        this._categoryAxis.setData(data.timeAxis, DataUtils.hasNegativeValue(data));
    };

    function getExtendedDomain(s, e, props){
        //This assertion is to judge full no value data set.
        if (s === Infinity && e === -Infinity){
            return [s, e];
        }
        var start = s;
        var end = e;
        var halfPeriod;
        var minLevel = props.minTimeLevel;
        minLevel = TypeUtils.isArray(minLevel)? minLevel[0] : minLevel;
        var utc = props.showAsUTC;
        if (props.labelTruncate) {
            start = TimeUtil.truncate(s, minLevel, utc, props.origin);
            end = TimeUtil.truncate(e, minLevel, utc, props.origin);
        }
        if (props.hasOwnProperty("linePadding")) {
            halfPeriod = props.linePadding;
        } else {
            halfPeriod = TimeUtil.getPeriod(minLevel) / 2;
        }
        start -= halfPeriod;
        end += halfPeriod;
        return [start, end];
    }

    TimeYPlotArea.prototype._updateTrendLineAxis = function(data){
        if(data && data.timeAxis && data.timeAxis.scale){
            var scale = data.timeAxis.scale;
            var oriDomain = scale.getDomain();
            var domain = ObjectUtils.extend(true, [], oriDomain);
            this._plot._expandTrendlineXRange(domain);
            if(domain && domain.length > 1 && domain[1] > oriDomain[1]){
                if (this._isLineChart()) {
                    this._timeOriginalDomain = domain;
                }else if (this.isColumnLike()) {
                    // add half minTimelevel domain
                    var options = this._plot._getBarProperties();
                    domain[1] += TimeUtil.getPeriod(options.minTimeLevel)/2;
                }
                data.timeAxis.scale = new TimeScale(domain, scale.getRange(),
                                            scale.getDomainFixed(), {dataBound:scale.getDataBound()});
            }
        }
    };

    TimeYPlotArea.prototype._updateTimeScale = function(data, axis, props){
        var scale = data.scale;
        var originalDomain = scale.getDomain();
        if (props.recoverDomain) {
            originalDomain = this._timeOriginalDomain;
        }
        props.origin = this._properties.origin;
        var domain = getExtendedDomain(originalDomain[0], originalDomain[1], props);
        data.scale = new TimeScale(domain, scale.getRange(), scale.getDomainFixed(), {dataBound:scale.getDataBound()});
        axis.setData(data);
    };

    TimeYPlotArea.prototype._truncateAndExtendWindowInput = function(start, end) {
        var options = this._plot._getBarProperties();
        options.origin = this._properties.origin;
        return getExtendedDomain(start, end, options);
    };

    TimeYPlotArea.prototype.zoom = function (scale) {
        TimeYPlotArea.superclass.zoom.apply(this, arguments);
        if (this._isLineChart()) {
            var propMgr = this._properties.origin;
            if (!propMgr.get("plotArea.marker.visible")) {
                return;
            }
            var data = this._data;
            var domainFixed = data.timeAxis.scale.getDomainFixed();
            if (domainFixed[0] || domainFixed[1]) {
                return;
            }
            var plotArea = this.getChildrenByPosition("center")[0];
            if (!plotArea) {
                return;
            }
            var options = {};

            if (this._timeSeriesMaxLength !== 0 &&
                SeriesUtil.isBigDensityMode(plotArea.getRealSize().width, this._timeSeriesMaxLength)) {
                options.linePadding = 0;
                options.recoverDomain = true;
                this._updateTimeScale(data.timeAxis, this._categoryAxis, options);
                return;
            }
            var domain = data.timeAxis.scale.getDomain();
            var originalDomain = this._timeOriginalDomain;
            // 2 pixel is compensatory for marker stroke.
            var markerSize = propMgr.get("plotArea.marker.size") + 2;
            options.showAsUTC = propMgr.get('general.showAsUTC');
            if (originalDomain[1] === originalDomain[0]) {
                var timeLevels = this.runtime().statusManager().get('timeLevels');
                var minTimeLevel = timeLevels.length? timeLevels[0]:["day"];
                options.linePadding = TimeUtil.getPeriod(minTimeLevel) / 2;
            } else {
                var onePixelScale = (originalDomain[1] - originalDomain[0]) / plotArea.getRealSize().width;

                var timeAxisBody = this._categoryAxis.getChild("axisBody").module;
                options.linePadding = timeAxisBody.normalizePadding(onePixelScale * markerSize);
            }
            options.recoverDomain = (scale.x !== 1);
            options.labelTruncate = false;
            if (scale.x !== 1 || (domain[0] === originalDomain[0] || domain[1] === originalDomain[1])) {
                this._updateTimeScale(data.timeAxis, this._categoryAxis, options);
            }
        }
    };

    TimeYPlotArea.prototype._adjustTimeDomain = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;

        if (data && width > 0 && height > 0) {
            var options = {};
            if (this.isColumnLike()) {
                options = this._plot._getBarProperties();
                options.labelTruncate = true;
                options.recoverDomain = false;
                this._updateTimeScale(data.timeAxis, this._categoryAxis, options);
            } else if (this._isLineChart()) {
                this._timeOriginalDomain = data.timeAxis.scale.getDomain();
                this._timeSeriesMaxLength = SeriesUtil.getMaxSeriesLength(data.series);
            }
        }
    };

    TimeYPlotArea.prototype.updateValueScale = function() {
        this._adjustTimeDomain();
        return TimeYPlotArea.superclass.updateValueScale.apply(this, arguments);
    };

    TimeYPlotArea.prototype._updateValueScaleDomain = function(domain) {
        this._lastValueDomain = domain;
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        if (!data || width <= 0 || height <= 0) {
            return false;
        }
        var range = [0, 1];
        if (this._plot.isHorizontal()) {
            range[1] = width;
        } else {
            range[1] = height;
        }
        range[1] *= 0.8;
        var scale = this._getValueAxis(this._data).scale;
        var orginDomain = scale.getDomain().slice();

        var valueAxisData;
        var finalDomain;
        // During scroll, do not re-layout axis when the scale is changed.
        // For those charts which support top label display, need to update cloned value scale as well.
        scale.setDomain(domain);
        if (this._isAdjustValueScaleForTopLabel()){
            valueAxisData = this._calcValueScaleWithTopLabel(range);
            finalDomain = valueAxisData.scale.getDomain();
            this._valueAxis.setData(valueAxisData, true);
            this._plot.getData().valueAxis = valueAxisData;
        } else {
            valueAxisData = ValueAxisUtils.calcScale(scale, range, {
                keepAutoScale: true,
                isLineChart: this._isLineChart()
            });
            finalDomain = valueAxisData.scale.getDomain();
            scale.setDomain(finalDomain);
            scale.setRange([0, 1]);

            var tempValueAxis = this._getValueAxis(data);
            tempValueAxis.tickHint = valueAxisData.tickHint;
            this._valueAxis.setData(tempValueAxis, true);
        }
        return (orginDomain[0] !== finalDomain[0] || orginDomain[1] !== finalDomain[1]);
    };



    TimeYPlotArea.prototype._getValueRange = function(series, start, end, options) {
        function getter(item) {
            return item.timeAxis[0].parsedValue;
        }
        var min = Infinity;
        var max = -Infinity;
        var needSearch = 2;
        if (isNum(options.min)) {
            min = options.min;
            needSearch--;
        }
        if (isNum(options.max)) {
            max = options.max;
            needSearch--;
        }
        var isTimeStackedColumn = /timeseries.*stacked_column/.test(this._renderType);
        var isTimeStackedComb = /timeseries.*stacked_combination/.test(this._renderType);
        var isTimeStacked = isTimeStackedColumn || isTimeStackedComb;
        var isTimeWaterFall = /timeseries_waterfall/.test(this._renderType);
        if (needSearch) {
            var hasCandidates = false;
            var indexCache = [];
            var i, j, k, m, len = series.length;
            var seriesItem, startIndex, endIndex, value;
            for (i = 0; i < len; ++i) {
                seriesItem = series[i];
                if (!seriesItem.length){
                    indexCache[i] = null;
                    continue;
                }
                var actualSeriesItem = seriesItem, map = [];
                if (isTimeStacked) {
                    actualSeriesItem = [];
                    for (k = 0, m = 0; k < seriesItem.length; k++) {
                        if (seriesItem[k]) {
                            actualSeriesItem[m] = seriesItem[k];
                            map[m] = k;
                            m++;
                        }
                    }
                }
                startIndex = ArrayUtils.bisearch(actualSeriesItem, start, getter);
                if (isTimeStacked) {
                    startIndex = map[startIndex] || startIndex;
                }
                startIndex = Math.min(startIndex, seriesItem.length - 1);
                endIndex = ArrayUtils.bisearch(actualSeriesItem, end, getter);
                if (isTimeStacked) {
                    endIndex = map[endIndex] || endIndex;
                }
                endIndex = Math.min(endIndex, seriesItem.length - 1);

                // Judge whether items of the two indexes are included in [start, end].
                //
                // Result of ArrayUtils.bisearch would return nearest next index in the array
                // if searching failed. So it's necessary to check whether the indexes are all
                // in the range[start, end].
                if (seriesItem[startIndex] && start > getter(seriesItem[startIndex])){
                    startIndex++;
                }
                if (seriesItem[endIndex] && getter(seriesItem[endIndex]) > end){
                    endIndex--;
                }
                if (startIndex > endIndex){
                    indexCache[i] = null;
                } else {
                    indexCache[i] = [startIndex, endIndex];
                    hasCandidates = true;
                }
            }
            var valueAxis = this.getData().valueAxis;
            var categoryBucket, bucket;
            if (isTimeStackedColumn) {
                categoryBucket = valueAxis && valueAxis.range;
                if (categoryBucket && categoryBucket.length > 0) {
                    for (i = startIndex; i < categoryBucket.length && i <= endIndex; i++) {
                        bucket = categoryBucket[i];
                        min = Math.min(min, bucket[0]);
                        max = Math.max(max, bucket[1]);
                    }
                }
            } else if (isTimeStackedComb && valueAxis) {
                var stackedRange = valueAxis.stackedRange;
                var lineRange =  valueAxis.lineRange;
                var range1 = stackedRange.length >= lineRange.length? stackedRange: lineRange;
                var range2 = stackedRange.length < lineRange.length? stackedRange: lineRange;
                for (i = startIndex; i < range1.length && i <= endIndex; i++) {
                    var rangeMin = range1[i][0];
                    var rangeMax = range1[i][1];
                    if (range2[i]){
                        rangeMin = Math.min(rangeMin, range2[i][0]);
                        rangeMax = Math.max(rangeMax, range2[i][1]);
                    }  

                    min = Math.min(min, rangeMin);
                    max = Math.max(max, rangeMax);
                }
            } else if (isTimeWaterFall) {
                var timeValues = this.getData().timeAxis._sortedTimeStampSet ;
                var plotModule = this.getChild("plot");
                if (plotModule) {
                    plotModule.module._visibleRange = {min: startIndex, max: endIndex};
                }
                if(timeValues) {
                    if(!hasCandidates) {
                        startIndex = 0;
                        endIndex = timeValues.length - 1;
                    }

                    var dataValue = 0, firstData = null;
                    for(i = startIndex; i < timeValues.length && i <= endIndex ; i++) {
                        for (j = 0; j < series.length; j++) {
                            var seriesData = series[j][ArrayUtils.bisearch(series[j], timeValues[i], function(item) {
                                return item ? item.timeAxis[0].parsedValue : 0;
                            })];
                            if(!seriesData || seriesData.timeAxis[0].parsedValue !== timeValues[i]) {
                                continue;
                            }
                            if(!firstData) {
                                firstData = seriesData;
                            }
                            dataValue = seriesData.base + seriesData.valueAxis;
                            min = Math.min(min, dataValue);
                            max = Math.max(max, dataValue);
                        }
                    }
                    min = Math.min(min, firstData.base);
                    max = Math.max(max, firstData.base);
                }
            } else {
                for (i = 0; i < len; ++i) {
                    seriesItem = series[i];
                    if (hasCandidates) {
                        var indexes = indexCache[i];
                        if (!indexes) {
                            continue;
                        }
                        startIndex = indexes[0];
                        endIndex = indexes[1];
                    } else {
                        //if no candidates in range, use whole range to determine value axis's domain
                        startIndex = 0;
                        endIndex = seriesItem.length - 1;
                    }
                    for (j = startIndex; j <= endIndex; ++j) {
                        value =  this._getItemMinMax(seriesItem[j], options.feed);
                        if(!TypeUtils.isNaN(value.min)){
                            min = Math.min(min, value.min);
                        }

                        if(!TypeUtils.isNaN(value.max)){
                            max = Math.max(max, value.max);
                        }
                    }
                }
            }
        }
        if(min === Infinity && max === -Infinity){
            return null;
        }
        if (min === 0 && max === 0) {
            max = 1;
        }
        return [min, max];
    };

    TimeYPlotArea.prototype._getItemMinMax = function(item, feed) {
        return {min:item[feed], max:item[feed]};
    };

    //if change value range to avoid dataLabel exceed the plotarea
    TimeYPlotArea.prototype._isAdjustValueScaleForTopLabel = function () {

        var position = this._properties.get("plotArea.dataLabel.position") ||
            this._properties.getDefault("plotArea.dataLabel.position");

        return position === "outside";
    };

    /**
     * This function return displayed time axis domain which may be different from
     * the whole time axis domain(when scroll).
     */
    TimeYPlotArea.prototype.getDisplayedTimeDomain = function() {
        var centerModule = this.getChildrenByPosition("center")[0];
        var realSize = centerModule.getRealSize();
        var size = centerModule.getSize();
        var isHorizontal = centerModule.isHorizontal();
        var translate = this._plot.getOffset();

        var isFiscal = false;
        if (this._data.rawData && this._data.rawData.dataModel &&
            this._data.rawData.dataModel._rawData) {
            isFiscal = FiscalUtil.isFiscal(this._data.rawData.dataModel._rawData);
        }
        return ValueAxisUtils.getTimeAxisDomain(size, translate, realSize,
                this._data.rawData.scales.timeAxis.getDomain(), isHorizontal, isFiscal);
    };


    TimeYPlotArea.prototype._scroll = function(offset) {
        var centerModule = this.getChildrenByPosition("center")[0];
        //the size of real chart. it can be bigger than the chart when zooming in
        var realSize = centerModule.getRealSize();
        var size = centerModule.getSize();   //the size of the chart rect
        var isHorizontal = centerModule.isHorizontal();
        if (this._properties.get("interaction.syncValueAxis") &&
            ((isHorizontal && realSize.height >= size.height) ||
                (!isHorizontal && realSize.width >= size.width)) ) {
            var data = this._data.rawData;
            var dataModel = data.dataModel;
            var dataScales = data.scales;

            var isFiscal = false;
            if (dataModel && dataModel._rawData) {
                isFiscal = FiscalUtil.isFiscal(dataModel._rawData);
            }
            var timeAxisDomain = ValueAxisUtils.getTimeAxisDomain(size, offset, realSize,
                    this._data.timeAxis.scale.getDomain(), isHorizontal, isFiscal);
            var valueAxisScale = this._getValueAxis(dataScales);

            var valueAxisDomain = this._getValueRange(dataModel.series(),
                timeAxisDomain[0],
                timeAxisDomain[1],
                valueAxisScale.getOption());

            if (valueAxisDomain == null) {
                valueAxisDomain = valueAxisScale.getDomain();
            }
            valueAxisDomain = TrendLine.getValueScaleDomain(this._plot, valueAxisDomain, dataModel,timeAxisDomain);
            var domainChanged = this._updateValueScaleDomain(valueAxisDomain);
            if (domainChanged) {

                var timeAxis = this.getChild("timeAxis").module;
                timeAxis.setHasNegativeValue(DataUtils.domainWithNegativeValue(valueAxisDomain));

                this.getChild("valueAxis").module.update();
            }
        }
        this._plot.update(offset);
        TimeYPlotArea.superclass._scroll.apply(this, arguments);
    };

    TimeYPlotArea.prototype._getZoomer = function() {
        return new TimeYZoomer(this);
    };

    TimeYPlotArea.prototype.isColumnLike = function(){
        return /column|combination|waterfall/.test(this._renderType);
    };

    TimeYPlotArea.prototype.isMultiplySeriesColumn = function (dataModel) {
        var isMultiplySeriesColumn = false;
        if (this.isColumnLike() && dataModel) {
            var isTimeStacked = /timeseries.*stacked_column/.test(this._renderType);
            var isTimeCombination = /combination/.test(this._renderType);
            //for stacked charts, we treat it as single series.
            //for time combination, it is always "bar line line".
            if (!isTimeStacked && !isTimeCombination) {
                var allSeries = (dataModel.series && dataModel.series());
                if (allSeries && allSeries.length > 1) {
                    isMultiplySeriesColumn = true;
                }
            }
        }
        return isMultiplySeriesColumn;
    };

    TimeYPlotArea.prototype.isKeepMinimalLevelContinuousTicks = function (dataModel) {
        var isKeepMinimalLevelContinuousTicks = true;
        if (this.isColumnLike() && dataModel) {
            isKeepMinimalLevelContinuousTicks = false;
            if (/timeseries_waterfall/.test(this._renderType)) {
                var allSeries = (dataModel.series && dataModel.series());
                if (allSeries && allSeries.length === 1) {
                    isKeepMinimalLevelContinuousTicks = true;
                }
            }
        }
        return isKeepMinimalLevelContinuousTicks;
    };

    TimeYPlotArea.prototype._getFormatTime = function( val){
        var display  = this._categoryAxis.getFormatTimeValue(val);
        var strDate = display.day || "";
        if(display.day && display.time){
            strDate += " " + display.time;
        }else if(display.time){
            strDate = display.time;
        }
        return strDate;

    };

    TimeYPlotArea.prototype._getDataRange = function(start, end){
        var result= {start:{}, end:{}, displayValues: {start:start, end:end}};
        var timeAxis = this.getData().timeAxis;
        var scale = timeAxis && timeAxis.scale;
        if(scale){
            var domain = scale.getDomain();
            var tStart = Math.floor(domain[0] + (domain[1] - domain[0]) * start / 100);
            var tEnd =   Math.ceil(domain[0] + (domain[1] - domain[0]) * end / 100);
            var dateId = timeAxis.metaData[0].id;
            result.displayValues.start = this._getFormatTime(tStart);
            result.displayValues.end = this._getFormatTime(tEnd);
            result["start"][dateId] = tStart;
            result["end"][dateId] = tEnd;
        }
        return result;
    };

    return TimeYPlotArea;
});

define('sap/viz/chart/scales/TimeScaleUtil',[
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/common/util/DataUtils'
], function(TypeUtils, ArrayUtils, DataUtils) {

    var scaler = {
        getDomainInfo: function(series, scaleOption) {
            var timestamps = [];
            var getValue = DataUtils.getDimensionParsedValue;
            series.forEach(function(seriesItem) {
                var length = seriesItem.length;
                if (length) {
                    if (!seriesItem._sorted) {
                        for (var i = 0; i < length; ++i) {
                            if (!seriesItem[i]) {
                                continue;
                            }
                            timestamps.push(getValue(seriesItem[i].timeAxis[0]));
                        }
                    } else {
                        var idx = 0;
                        for (idx = 0; idx< seriesItem.length; idx++) {
                            if (seriesItem[idx]) {
                                break;
                            }
                        }
                        timestamps.push(
                            getValue(seriesItem[idx].timeAxis[0]),
                            getValue(seriesItem[length - 1].timeAxis[0])
                        );
                    }
                }
            });
            var timeBound = ArrayUtils.extent(timestamps);
            //to avoid 0 == false judgement
            var startDate = timeBound[0] == null ? Infinity : timeBound[0];
            var endDate = timeBound[1] == null ? -Infinity : timeBound[1];

            var dataBound = [startDate, endDate];
            var startTmp = startDate,
                endTmp = endDate;
            var isStartFixed = false,
                isEndFixed = false;
            var allowEqual = scaleOption && scaleOption.allowEqual;
            if (TypeUtils.isExist(scaleOption)) {
                if (TypeUtils.isExist(scaleOption.start)) {
                    if (TypeUtils.isNumber(scaleOption.start)) {
                        isStartFixed = true;
                        startTmp = Number(scaleOption.start);
                    } else if (TypeUtils.isNumber(new Date(scaleOption.start).getTime())) {
                        isStartFixed = true;
                        startTmp = new Date(scaleOption.start).getTime();
                    }
                }
                if (TypeUtils.isExist(scaleOption.end)) {
                    if (TypeUtils.isNumber(scaleOption.end)) {
                        isEndFixed = true;
                        endTmp = Number(scaleOption.end);
                    } else if (TypeUtils.isNumber(new Date(scaleOption.end).getTime())) {
                        isEndFixed = true;
                        endTmp = new Date(scaleOption.end).getTime();
                    }
                }
                var valid = startTmp < endTmp;
                if (allowEqual){
                    valid = startTmp <= endTmp;
                }
                if (valid) {
                    startDate = startTmp;
                    endDate = endTmp;
                } else {
                    isStartFixed = false;
                    isEndFixed = false;
                }
            }
            return {
                domain: [Number(startDate), Number(endDate)],
                dataBound: dataBound,
                domainFixed: [isStartFixed, isEndFixed]
            };
        }
    };
    return scaler;
});

define('sap/viz/chart/scales/TimeScaleProcessor',[ 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/scale/ScaleRepository',
    'sap/viz/framework/scale/ScaleUtil',
    'sap/viz/chart/scales/TimeScale',
    'sap/viz/chart/scales/TimeScaleUtil',
    'sap/viz/framework/common/util/TimeUtil'
],function(
    TypeUtils,
    ScaleRepository,
    ScaleUtil,
    TimeScale,
    TimeScaleUtil,
    TimeUtils
    )
    {
        var timeScale = function (data, name, scaleMgr, propMgr, option, dataModel, runtime) {
            if (!TypeUtils.isExist(scaleMgr.getDefault(name))) {
                scaleMgr.add(name, {
                    serializable: true,
                    defaultValue: {
                        "feed": name,
                        "start": "auto",
                        "end": "auto"
                    }
                });
            }
            var scaleOption = scaleMgr.get(name);
            if (option && option.allowEqual){
                scaleOption = ScaleUtil.truncateScaleOption(option, scaleOption, propMgr);
            }
            var domainInfo = TimeScaleUtil.getDomainInfo(option.series, scaleOption);
            var timeScale = new TimeScale(domainInfo.domain, [0, 1], domainInfo.domainFixed,
                    {dataBound:domainInfo.dataBound});

            return timeScale;
        };
        ScaleRepository["timeScale"] = timeScale; 
    });
define('sap/viz/chart/chains/SeriesIterator',[],function(){

    function getCommonElements(array1, array2) {
        var base = array1;
        var compare = array2;
        if (array1.length > array2.length){
            base = array2;
            compare = array1;
        }
        var map = {};
        var i, length;
        for (i = 0, length = base.length; i < length; ++i){
            map[base[i]] = true;
        }
        var result = [];
        for (i = 0, length = compare.length; i < length; ++i){
            if (map[compare[i]]){
                result.push(compare[i]);
            }
        }
        return result;
    }

    //SeriesBinds is an array which should always have at least one child element.
    function SeriesIterator(seriesBinds, seriesMeta){
        this._seriesBinds = seriesBinds;
        this._seriesMeta = seriesMeta;
        this._init(seriesBinds);
    }

    var prot = SeriesIterator.prototype;

    prot.hasNext = function(){
        return this._index < this._maxIndex - 1;
    };

    prot.next = function(){
        if (!this.hasNext()){
            return null;
        }
        this._increasePivot();
        var pivots = this._pivots;
        var seriesBinds = this._seriesBinds;
        var seriesMeta = this._seriesMeta;
        var reference = null;
        var seriesData = [];
        var mndIndex;
        for (var i = 0, iLen = this._bindsLength; i < iLen; ++i){
            if(!seriesBinds[i].rowArray){
                continue;
            }
            var item = seriesBinds[i].rowArray[pivots[i]];
            mndIndex = item.mndIndex;
            reference = reference == null ? item.reference : getCommonElements(reference, item.reference);
            seriesData.push({
                key: seriesMeta[i],
                value: item
            });
        }
        var ret = {
            index: this._index,
            reference: reference,
            data: seriesData
        };
        if (mndIndex != null){
            ret.mndIndex = mndIndex;
        }
        return ret;
    };

    prot._init = function(seriesBinds){
        var lengthArr = [];
        var maxIndex = 1;
        for (var i = 0, iLen = seriesBinds.length; i < iLen; i++){
            var temp = seriesBinds[i].rowArray || seriesBinds[i].metaData;
            var length = temp.length;
            lengthArr.push(length);
            maxIndex *= length;
        }
        this._maxIndex = maxIndex;
        this._bindsLength = iLen;
        this._lengthArr = lengthArr;
        this._pivots = lengthArr.map(function(){
            return 0;
        });
        this._pivots[iLen - 1] = -1;
        this._index = -1;
    };

    prot._increasePivot = function(){
        this._index++;
        var pivots = this._pivots;
        var lengthArr = this._lengthArr;
        //increase pivot index from lowest array to topest array.
        for (var i = pivots.length;i--;){
            pivots[i]++;
            if (pivots[i] < lengthArr[i]){
                break;
            } else {
                pivots[i] = 0;
            }
        }
    };

    return SeriesIterator;
});
define('sap/viz/chart/chains/TYChains',[
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/chains/ChainUtils',
    'sap/viz/chart/chains/SeriesIterator',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/framework/common/util/FunctionUtils',
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/framework/common/lang/LangManager',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/framework/binding/BindingManager',
    'sap/viz/chart/chains/SeriesContext'
], function Setup(
    TypeUtils,
    ChainUtils,
    SeriesIterator,
    DataUtils,
    NumberUtils,
    BaseChains,
    FunctionUtils,
    FiscalUtil,
    LangManager,
    ArrayUtils,
    BindingManager,
    SeriesContextFunc
) {
    var tyChains = {};
    var TYPENAME_DIMENSION = "Dimension";
    var defaultChains = [
        'GetDimensionsFromFlattable',
        'OnBindingFinished',
        'getContext'
    ];

    tyChains = BaseChains.extend('ty', defaultChains);

    tyChains.tyOnBindingStart = function() {
        tyChains.parsedData = null;
        tyChains.multiDimensionIndex = null;
    };

    tyChains.tyGetBindingSeries = function(rawData, dimensions, measures,
                                          bindingResults, bindings, bindingDefinition, options) {
        getBindingSeries(rawData, dimensions, measures, bindingResults, bindingDefinition, options);
    };

    function FindMndIndex(mndName, metadata){
        for(var i =0, len = metadata.length;i<len;i++){
            if(metadata[i].id === mndName){
                return i;
            }
        }
        return -1;
    }
    function addContextAndAddition(item, contextValues, additionValues, r, sIdx ){
        var t;
        if (contextValues ){
            item.context = [];
            for(t = 0; t < contextValues.length; ++t){
                item.context.push(contextValues[t][r][sIdx]);
            }
        }
        if (additionValues ){
            item.addition = [];
            for(t = 0; t < additionValues.length; ++t){
                item.addition.push(additionValues[t][r][sIdx]);
            }
        }
    }
    function getBindingSeries(rawData, dimensions, measures, bindingResults, bindingDefinition, options) {
        var series = [];
        var seriesBinds = [];
        var measureBinds = [];
        var categoryBinds;
        var seriesMeta = [];
        var measureMeta = [];
        var categoryMeta;
        var measureValue;
        var currentSeries;
        var returnDimensions = [];
        var returnMeasures = [];
        var bindingResult;
        var item;
        var i, j, iLen, jLen;
        var isTimeBullet = bindingResults.seriesType === "bullet";

        var time, measure, reference;
        var seriesBind, measureBind;

        var needSort = false;
        var sortId = null;
        var errorOnDuplicate = options && options.errorOnDuplicate;
        var isTimeStacked = options && options.isTimeStacked;
        //Only support one sortable binding definition.
        bindingDefinition.some(function(def){
            if (def.sort === true){
                needSort = true;
                sortId = def.id;
                return true;
            }
            return false;
        });

        // get metadata
        for(i = 0; i < dimensions.length; ++i){
            var dimension = dimensions[i];
            bindingResult = bindingResults[dimension];
            if(bindingResult){
                if(dimension === 'timeAxis'){
                    categoryBinds = bindingResult;
                    categoryMeta = dimension;
                }else{
                    seriesBinds.push(bindingResult);
                    seriesMeta.push(dimension);
                }
                returnDimensions.push(dimension);
            }
        }
        var bubbleWidthIndex = -1;
        for(i = 0; i < measures.length; ++i){
            measure = measures[i];
            bindingResult = bindingResults[measure];
            if(bindingResult){
                if(measure === 'bubbleWidth') {
                    bubbleWidthIndex = i;
                }
                measureMeta.push(measure);
                measureBinds.push(bindingResult);
                returnMeasures.push(measure);
            }
        }

        var allowEmptyMeasure = options && options.allowEmptyMeasure;
        var bindsLength = seriesBinds.length;
        var measureExists;
        var allMeasureValues;
        var r, k, t;
        var contextValues = bindingResults.context ? bindingResults.context.values: null;
        var additionValues = bindingResults.additionInfo && bindingResults.additionInfo.values;
        var availableCategories;
        if (isTimeStacked) {
            availableCategories = ChainUtils.getAvailableCategories(measureBinds, seriesBinds);
        }
        //bullet actual values allows more than one bindings
        var valNum = isTimeBullet? bindingResults.actualValues.metaData.length : 1;

        // build series
        if (bindsLength === 0) {
            // # of series binds is zero. Build a series with all measure's value.
            for (var ii = 0; ii < valNum; ii++) {
                currentSeries = [];
                currentSeries._mndIndex = ii;
                if (categoryBinds && categoryBinds.values && categoryBinds.values.length) {
                    var categoryValues = categoryBinds.values[0];

                    if (options && options.isTimeStacked) {
                        categoryValues.sort(function(a, b) {
                            if (a && b) {
                                return a.parsedValue - b.parsedValue;
                            } else if (!a) {
                                return -1;
                            } else if (!b) {
                                return 1;
                            }
                        });
                    }

                    for (var jj = 0; jj < categoryValues.length; jj++) {
                        item = {};
                        var categoryValue = categoryValues[jj];
                        for (k = 0; k < measureMeta.length; ++k) {
                            measureBind = measureBinds[k];
                            if (options && options.isTimeStacked) {
                                measureValue = measureBind.values[jj];
                            } else {
                                measureValue = measureBind.values[jj][ii];
                            }
                            measureExists = bubbleWidthIndex === k ? true : TypeUtils.isExist(measureValue);
                            if (TypeUtils.isExist(categoryValue) &&
                                (measureExists || options.allowEmptyMeasure)) {
                                if (!item[categoryMeta]) {
                                    item[categoryMeta] = [categoryValue];
                                }
                                item[measureMeta[k]] =  measureValue == null? measureValue: +measureValue;
                                if(!measureExists){
                                    if(isTimeBullet){
                                        item.isNullValue = true;
                                    }
                                    if (options.breakOnEmptyMeasure) {
                                        item._break = true;
                                    }
                                }
                                addContextAndAddition(item, contextValues, additionValues, jj, 0);
                            }
                        }
                        if (!TypeUtils.isEmptyObject(item)) {
                            if(isTimeBullet){
                                item._cateIndex = jj;
                            }
                            currentSeries.push(item);
                        }
                    }
                }

                series.push(currentSeries);
            }
        } else {
            time = ChainUtils.parseData(rawData, categoryBinds.metaData[0].id, tyChains.parsedData);
            measure = measureMeta.map(function(meta) {
                return bindingResults[meta].metaData.map(function(metaData){
                    return ChainUtils.parseData(rawData, metaData.id, tyChains.parsedData);
                });
            });
            allMeasureValues = measure.map(function(m){
                return m[0];
            });
            var seriesIter;
            if(isTimeBullet && valNum > 1){
                //bullet actual values allows more than one bindings
                seriesIter = new SeriesIterator(seriesBinds.concat(measureBinds[0]),
                                                    seriesMeta.concat(measureMeta[0]));
            }else{
                seriesIter = new SeriesIterator(seriesBinds, seriesMeta);
            }
            var seriesIndex = 0;
            while (seriesIter.hasNext()){
                var seriesInfo = seriesIter.next();
                currentSeries = series[seriesInfo.index] = [];
                var measureValues = measure;
                var measureMetas = measureMeta;
                if (needSort){
                    currentSeries._mndIndex = 0;
                }

                // If mndIndex exists, find correct measure array.
                if (seriesInfo.hasOwnProperty("mndIndex")){
                    var metadataId = seriesInfo.mndIndex;
                    var mndIndex = FindMndIndex(metadataId, measureBinds[0].metaData);
                    seriesBinds[0].rowArray[seriesIter._index].mndIndex = mndIndex;
                    currentSeries._mndIndex = mndIndex;
                    measureValues = [measure[0][mndIndex]];
                } else { // else use header array in each measure binding.
                    if(!isTimeBullet){
                        measureValues = allMeasureValues;
                    }else{
                        //e.g  act: [profit, cost] color: [china, japan]
                        //     China/Profit, China/cost, Japan/Profit, Japan/cost
                        //     measure value is [Profit, cost]
                        measureValues = measure.map(function(m){return m[seriesIndex%valNum];})
                                              .filter(function(e){return !!e;});
                    }
                }
                reference = seriesInfo.reference;
                if (reference.length > 0 &&  isTimeStacked) {
                    var colorRef = reference.map(function(item) {
                        return {index: item, value: time[item]};
                    });
                    if (colorRef) {
                        ArrayUtils.stableSort(colorRef, function(a, b) {
                            // If we have two null date, should throw exception
                            if(a.value === b.value && errorOnDuplicate){
                                FunctionUtils.error(
                                        LangManager.getLogMessage('IDS_ERROR_DATA_NOT_MATCHING_TIME_LEVEL'));
                            }
                            if (!a.value || !b.value) {
                                return -1;
                            }
                            if (a.value.parsedValue === b.value.parsedValue && errorOnDuplicate) {
                                FunctionUtils.error(
                                    LangManager.getLogMessage('IDS_ERROR_DATA_NOT_MATCHING_TIME_LEVEL'));
                            }
                            return a.value.parsedValue - b.value.parsedValue;
                        });
                        colorRef.map(function(item, idx) {
                            reference[idx] = item.index;
                        });
                    }
                }
                var seriesData = seriesInfo.data;
                for(i = 0, iLen = reference.length; i < iLen; ++i){
                    r = reference[i];
                    measureValue = measureValues.map(function(list) {
                        return list[r];
                    });
                    measureExists = measureValue.every(function(value, i) {
                        if(i === bubbleWidthIndex) {
                            return true;
                        }
                        return TypeUtils.isExist(value);
                    });
                    if (TypeUtils.isExist(time[r]) && (allowEmptyMeasure || measureExists)) {
                        item = {};

                        if(isTimeBullet && !measureExists){
                            var notMeasureExists = measureValue.every(function(value, i) {
                                return !TypeUtils.isExist(value);
                            });
                            //time bullet has actual, additonal, target
                            //if all are null, add a flag
                            //this is flag will be used in ContextBuilder.js function _buildAddr
                            if(notMeasureExists){
                                item.isNullValue = true;
                            }
                        }

                        item[categoryMeta] = [time[r]];
                        measureMetas.forEach(function(meta, i) {
                            item[meta] = measureValue[i];
                        });
                        seriesData.forEach(function(data){
                            item[data.key] = data.value;
                        });
                        if(!measureExists && options.breakOnEmptyMeasure){
                            item._break = true;
                        }
                        if(!isTimeStacked){
                            addContextAndAddition(item, contextValues, additionValues, r, 0);
                            currentSeries.push(item);
                        }else {
                            if(options.dataShapes && options.dataShapes[currentSeries._mndIndex] === "line"){
                                currentSeries.push(item);
                            }else{
                                currentSeries[availableCategories[seriesIndex][i]] = item;
                            }
                            var categoryIdx = availableCategories[seriesIndex][i];
                            addContextAndAddition(item, contextValues, additionValues, categoryIdx, seriesIndex);
                        }
                        if (!TypeUtils.isEmptyObject(item)) {
                            if(isTimeBullet){
                                item._cateIndex = r;
                            }
                        }
                    }
                }
                seriesIndex++;
            }
        }
        // generate final output
        bindingResults.dimensions = returnDimensions;
        bindingResults.measures = returnMeasures;
        bindingResults.series = series;

        bindingResults.seriesContext = SeriesContextFunc(series, seriesMeta, seriesBinds, measureBinds);
        if (!needSort) {
            return;
        }
        // Sort the data according to timestamp, remove duplicated data, and get measure value range
        var valueMinMax = [];
        var getParsedValue = DataUtils.getDimensionParsedValue;
        // Access sortId directly to improve performance
        var compare = function (a, b) {
            return getParsedValue(a[sortId][0]) - getParsedValue(b[sortId][0]);
        };

        for (i = series.length; i--;) {
            currentSeries = series[i];
            if (!isTimeStacked || bindsLength === 0) {
                ArrayUtils.stableSort(currentSeries, compare);
                currentSeries._sorted = true;
            }

            if (!FiscalUtil.isFiscal(rawData)) {
                //sorted flag should be setting correctly for fiscal.
                currentSeries._sorted = true;
            }
            var currentMinMax = valueMinMax[currentSeries._mndIndex] =
                valueMinMax[currentSeries._mndIndex] || [Infinity, -Infinity];

            var prevTime = null;
            // go through in reverse order so we can safely remove items
            for (j = currentSeries.length; j--;) {
                var current = currentSeries[j];
                var prev = currentSeries[j - 1];
                var currentTime = prevTime === null ? getParsedValue(current[categoryMeta][0]) : prevTime;
                prevTime = prev && getParsedValue(prev[categoryMeta][0]);
                if (isTimeStacked && !current) {
                    continue;
                }
                var currentMeasure = current[measureMeta];
                if (currentTime === prevTime) {
                    if (errorOnDuplicate){
                        FunctionUtils.error(LangManager.getLogMessage('IDS_ERROR_DATA_NOT_MATCHING_TIME_LEVEL'));
                    }
                    if (!TypeUtils.isExist(prev[measureMeta])) {
                        prev[measureMeta] = currentMeasure;
                    }
                    currentSeries.splice(j, 1);
                } else {
                    currentMinMax[0] = Math.min(currentMinMax[0], currentMeasure);
                    currentMinMax[1] = Math.max(currentMinMax[1], currentMeasure);
                }
            }
        }
        if(bindingResults.valueAxis2) {
            bindingResults.valueAxis2.range = valueMinMax;
        }
        else if (bindingResults.valueAxis) {
            bindingResults.valueAxis.range = valueMinMax;
        }
    }

    tyChains.tyGetMeasuresFromFlattable = function(rawData, fields, mnd, bindings, duplicated,
            bindingName, parserOption) {
        tyChains.parsedData = ChainUtils.getData(rawData, bindings, tyChains.parsedData, parserOption);
        var rowArray = [], domain = [];
        var ignorePlusMinus = /bubbleWidth/.test(bindingName);
        for (var i = 0; i < fields.length; i++) {
            var row = rowArray[i] = ChainUtils.parseData(rawData, fields[i], tyChains.parsedData);
            if (ignorePlusMinus){
                row = row.slice();
                row.forEach(function(e, i){
                    if (e == null){
                        row[i] = 0;
                    }
                    if (e < 0){
                        row[i] = -e;
                    }
                });
            }
            domain[i] = ArrayUtils.extent(row.filter(function(e){
                return e != null;
            }).map(function(ele){return +ele;}));
        }
        //if mnd is not bind, only display last measure in valueAxis
        if (mnd.length !== rowArray.length && rowArray.length > 1) {
            rowArray = [rowArray[rowArray.length - 1]];
            fields = [fields[fields.length - 1]];
            domain = [domain[domain.length - 1]];
        }
        return {
            values: ArrayUtils.transpose(rowArray),
            metaData: ChainUtils.buildMetaData(rawData, fields),
            range : domain
        };
    };
    Object.keys(tyChains).forEach(function(key) {
        BindingManager.registerChain(key, tyChains[key]);
    });
    return tyChains;
});

define('sap/viz/chart/behavior/config/handler/TimeLassoBehaviorHandler',[
        'sap/viz/framework/common/util/oo',
        "sap/viz/chart/behavior/config/handler/LassoBehaviorHandler",
        "sap/viz/chart/components/util/DataPointUtils",
        "sap/viz/chart/behavior/config/ContextualDataUtil",
        'sap/viz/chart/components/util/ValueAxisUtils',
        'sap/viz/framework/common/util/FiscalUtil',
        "sap/viz/framework/interaction/Constants"
    ],
    function(oo,
            LassoBehaviorHandler,
            DataPointUtils,
            ContextualDataUtil,
            ValueAxisUtils,
            FiscalUtil,
            Constants)
    {
        var tLassoBehaviorHandler = function(){};
        oo.extend(tLassoBehaviorHandler, LassoBehaviorHandler);
        tLassoBehaviorHandler.prototype.processTimeRange  = function(event, service){
            if(service.getStatus("rangeSelection")){
                //from screen point to time domain
                var mainPlot = service.getModule("main.plot");
                var realSize = mainPlot.getRealSize();
                var plotSize = mainPlot.getSize();
                var plotOffset = mainPlot.getOffset();
                var plotBox = service.getBBox(service.BoxType.PLOT_BOUND_NODE);
                var RSBox = service.getBBox(service.BoxType.RANGE_SELECTION);
                var scaleRatio = service.getTransformScaleRatio();
                //because of BoundBox is not exactly the same as internal size, 
                //we have to convert BoundBox to internal size 
                RSBox.width = RSBox.width / plotBox.width * plotSize.width;
                var realOffset = {x: plotOffset.x - (RSBox.left - plotBox.left) / plotBox.width * plotSize.width , y:0};
                var range = service.getExtendTimeRange();
                
                realOffset.x *= scaleRatio.x;
                realOffset.y *= scaleRatio.y;
                realSize.width *= scaleRatio.x;
                realSize.height *= scaleRatio.y;

                var isFiscal = false;
                var dataModel = service.getDataModel();
                if (dataModel && dataModel._rawData) {
                    isFiscal = FiscalUtil.isFiscal(dataModel._rawData);
                }
                var domain = ValueAxisUtils.getTimeAxisDomain(RSBox, realOffset,
                        realSize, range,
                        mainPlot.isHorizontal(), isFiscal);

                if (isFiscal) {
                    domain[0] = parseInt(FiscalUtil.quantityToFiscal(Math.round(domain[0]),
                        service.getProperties()).fiscalString);
                    domain[1] = parseInt(FiscalUtil.quantityToFiscal(Math.round(domain[1]),
                        service.getProperties()).fiscalString);
                    event.data.isConvertedFiscalStamp = true;
                }
                else {
                    domain[0] = Math.round(domain[0]/100) * 100;
                    domain[1] = Math.round(domain[1]/100) * 100;
                }
                service.setStatus("rangeDomain", domain);
                service.fireEvent("showDetail",event.data);
                
            }
        };
        tLassoBehaviorHandler.prototype.refreshTimeRange = function(event, service){
            var tempSelectionMode = service.getProperties().get("interaction.selectability.mode");
            // Not every chart support property interaction.selectability.mode, need verify it first.
            var selectionMode = tempSelectionMode ? tempSelectionMode.toUpperCase(): tempSelectionMode;
            var mode = service.getProperties().get("interaction.selectability.plotLassoMode");
            if (!(mode !== 'range' || !service.getStatusManager().get("interaction.holdSelection") ||
                    selectionMode === Constants.SELECTION_MODE.NONE || 
                    selectionMode === Constants.SELECTION_MODE.SINGLE)){
                this._lassoDecoration.rangeRecover(event);
            }
            service._rootNode.node().style.cursor="default";
            
        };
        
        tLassoBehaviorHandler.prototype.rangeRecover = function(event, service){
            
            this._lassoDecoration.rangeRecover(event);
            
        };
        
        tLassoBehaviorHandler.prototype.changeRangeEffect = function(event, service){
            this._lassoDecoration.changeRangeEffect(event);  
        };
        tLassoBehaviorHandler.prototype._getStartEnd = function(service, ranges){
            var dataModel = service.getDataModel();
            if (dataModel && dataModel._rawData && FiscalUtil.isFiscal(dataModel._rawData)) {
                ranges.start = FiscalUtil.fiscalToQuantity(ranges.start, service.getProperties());
                ranges.end = FiscalUtil.fiscalToQuantity(ranges.end, service.getProperties());
            }
            return ranges;
        };
        
        tLassoBehaviorHandler.prototype._postProcessTargets = function(service, includedTargets){
            includedTargets = tLassoBehaviorHandler.superclass._postProcessTargets.apply(this, arguments);
            var byTimeseriesGroup = service.getProperties().get('interaction.selectByTimeAxisGroup');
            if(byTimeseriesGroup) {
                var groupTargets = [];
                includedTargets.forEach(function(target) {
                    if(groupTargets.indexOf(target) === -1) {
                        var node = service.getNodes(service.NodeType.DATA_POINT_GROUP, false)[0];
                        var dataPoint = DataPointUtils.findByDataPointId(node, target);
                        var dps = ContextualDataUtil.getDataPointsByTimeField(dataPoint, service)
                            .map(function(n){
                                return DataPointUtils.getDataPointId(n);
                            });
                        groupTargets = groupTargets.concat(dps);
                    }
                });
                if(groupTargets.length > 0) {
                    includedTargets = groupTargets;
                }
            }
            return includedTargets;
        };
        

        return tLassoBehaviorHandler;
      
    });

define('sap/viz/chart/behavior/config/TimeLassoBehaviorConfig',[
    "sap/viz/chart/behavior/config/handler/TimeLassoBehaviorHandler",
    "sap/viz/framework/interaction/BehaviorManager"
], function(LassoBehaviorHandler,
        BehaviorManager) {

    var eventLayerPattern = "v-m-root";
    var allTimeCharts = ['info/timeseries_line', 'info/timeseries_column', 'info/timeseries_scatter', 
                        'info/timeseries_bubble', "info/timeseries_combination","info/dual_timeseries_combination",
                        "info/timeseries_stacked_column", "info/timeseries_stacked_combination", 
                        "info/timeseries_100_stacked_column",
                        "info/timeseries_bullet", "info/timeseries_waterfall"];

    var timeHandler =  [{
        "id": "timeLassoBehaviorDefinition",
        "handler": LassoBehaviorHandler,
        "handlerType": "class",
        //"supportedChartTypes": [],
        "triggerEvent": [  {
            "name": "standAloneInitialized",
         //   "supportedChartTypes":allTimeCharts,
            "method": "standAloneInitialized"
        }, {
            "name": "afterBehaviorLoaded",
           // "supportedChartTypes":allTimeCharts,
            "method": "initialized"
        }, {
            "name": "beforeBehaviorUnloaded",
            //"supportedChartTypes":allTimeCharts,
            "method": "unloadClear"
        }, {
            "name": "lassostart",
            "targets": eventLayerPattern,
            "supportedChartTypes":allTimeCharts,
            "excludeTargets": "v-m-scrollbarThumb",
            "method": "lassoStart"
        }, {
            "name": "lassomove",
            "supportedChartTypes":allTimeCharts,
            "targets": eventLayerPattern,
            "method": "lassoMove"
        }, {
            "name": "lassoend",
            "supportedChartTypes":allTimeCharts,
            "targets": eventLayerPattern,
            "method": "lassoEnd"
        },{
            "name" : "afterChartRendered",
            "targets": eventLayerPattern,
            "method" : "refreshTimeRange",
            "supportedChartTypes":allTimeCharts
        }, {
            "name": "rangeRecover",
            "targets": eventLayerPattern,
            "method": "rangeRecover",
            "supportedChartTypes": allTimeCharts
        },{
            "name": "timeRangeChanged",
            "targets": eventLayerPattern,
            "method": "processTimeRange",
            "supportedChartTypes": allTimeCharts
        }, {
            "name": "changeRangeEffect",
            "targets": eventLayerPattern,
            "method": "changeRangeEffect",
            "supportedChartTypes":allTimeCharts
        }]
    }];
    
    BehaviorManager.registerAll(timeHandler);
    return timeHandler;

});

define('sap/viz/chart/views/TimeYChartView',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/views/ChartView',
    'sap/viz/chart/components/plotareas/TimeYPlotArea',
    'sap/viz/chart/components/legend/CombinationLegend',
    'sap/viz/chart/components/legend/LineLegend',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/chart/scales/TimeScaleProcessor",
    "sap/viz/chart/chains/TYChains",
    "sap/viz/chart/dynamicScales/StackedDyScaleProcessor",
    "sap/viz/chart/behavior/config/TimeLassoBehaviorConfig"
], function Setup(oo, ChartView, PlotArea, CombinationLegend, LineLegend, DataUtils, TypeUtils, TextUtils) {

    var TimeYChartView = function(runtime, option) {
        TimeYChartView.superclass.constructor.apply(this, arguments);
        this._supportLazyRender = true;
    };

    oo.extend(TimeYChartView, ChartView);

    TimeYChartView.prototype.setSize = function() {
        if (this._plotArea && this._plotArea.setRoughSize) {
            this._plotArea.setRoughSize.apply(this._plotArea, arguments);
        }
        TimeYChartView.superclass.setSize.apply(this, arguments);
    };

    TimeYChartView.prototype._getDataItems = function() {
        return ["valueAxis", "timeAxis", "color", "series", "seriesContext"];
    };
    TimeYChartView.prototype._getLegendInitOptions = function() {
        return [{noFillSupport:true}];
    };

    TimeYChartView.prototype._createPlotContainer = function() {

        this._plotArea = new PlotArea(this.runtime(), {
            renderType: this._renderType,
            rawData: this._rawData
        });
        this._plotArea.setRoughSize(this._size);

        this.setChild("main", this._plotArea, {
            priority: 3
        });
    };

    TimeYChartView.prototype.isBar = function() {
        return this._renderType.search(/bar|column/) !== -1 &&
            !/timeseries.*column/.test(this._renderType);
    };

    TimeYChartView.prototype.isCombination = function() {
        return this._renderType.search(/combination/) !== -1;
    };

    TimeYChartView.prototype.isLine = function() {
        return this._renderType.indexOf("line") !== -1;
    };

    TimeYChartView.prototype._getLegendDefinition = function() {
        if (this.isCombination()) {
            return [CombinationLegend];
        } else if(this.isLine()){
            return [LineLegend];
        } else {
            return TimeYChartView.superclass._getLegendDefinition.apply(this, arguments);
        }
    };

    TimeYChartView.prototype._getLegendInitOptions = function() {
        if (this.isBar()){
            return [{noFeeding: true, noFillSupport:true}];
        } else {
            return [{noFillSupport:true}];
        }
    };

    TimeYChartView.prototype.calculatePaddingInPX = function(prop){
        var paddings = TimeYChartView.superclass.calculatePaddingInPX.apply(this, arguments);
        if((prop.get("title.visible") === false) && (prop.get("valueAxis.visible") === true)){
            //If padding = 0 and title is invisible, add half value label's height 
            //by default to avoid cut the latest value axis label.   
            this.changePaddingTop(prop, paddings);
        }
        
        return paddings;
    };
    return TimeYChartView;
});

define('sap/viz/chart/metadata/bindings/TimeYBindings',[], function Setup() {

    var feeds = [{
        "id": "timeAxis",
        "name": "IDS_TIME_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "acceptMND": false,
        "continuous": true,
        "sort": true,
        "role": "layout.time"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }];

    return feeds;
});
define('sap/viz/chart/components/plotareas/TimeBulletPlotArea',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/plotareas/TimeYPlotArea",
    "sap/viz/chart/components/plotareas/BulletPlotArea",
    'sap/viz/framework/common/util/TypeUtils'
], function(
    oo,
    TimeYPlotArea,
    BulletPlotArea,
    TypeUtils
) {
    function TimeBulletPlotArea() {
        TimeBulletPlotArea.superclass.constructor.apply(this, arguments);
    }

    oo.extend(TimeBulletPlotArea, TimeYPlotArea);

    TimeBulletPlotArea.prototype.isColumnLike = function() {
        return true;
    };

    TimeBulletPlotArea.prototype._getValueAxis = function(data){
        return data.actualValues;
    };

    TimeBulletPlotArea.prototype._getItemMinMax = function(item) {
        var act = item["actualValues"];
        var add = item["additionalValues"];
        var tar = item["targetValues"];
        //!! in JS, null + null = 0, 0 + undefined = NaN
        var sum = TypeUtils.isNumber(act) && TypeUtils.isNumber(add)? add + act : undefined;
        var candidates = [act, add, sum, tar].filter(TypeUtils.isNumber);

        var min = candidates.length > 0 ? Math.min.apply(null, candidates) : undefined;
        var max = candidates.length > 0 ? Math.max.apply(null, candidates) : undefined;
        return {min: min, max:max};
    };

    TimeBulletPlotArea.prototype.updateValueScale = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;

        if (this.isColumnLike() && data && width > 0 && height > 0) {
            this._updateTimeScale(data.timeAxis, this._categoryAxis, {
                minTimeLevel: (this.runtime().statusManager().get('timeLevels') || [])[0] || ["day"],
                showAsUTC: this.properties("general.showAsUTC")
            });
        }
        return BulletPlotArea.prototype.updateValueScale.apply(this, arguments);
    };

    return TimeBulletPlotArea;
});

define('sap/viz/chart/chains/TBulletChains',[
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/chart/chains/TYChains',
    'sap/viz/chart/chains/BulletChains',
    'sap/viz/framework/common/util/BulletUtils',
    'sap/viz/framework/binding/BindingManager'
], function Setup(
    BaseChains,
    TYChains,
    BulletChains,
    BulletUtils,
    BindingManager
) {
    var tBulletChains = {};

    tBulletChains = BaseChains.extend('tBullet', []);

    Object.keys(TYChains).forEach(function(item) {
        var name = item.replace(/^ty/, "tBullet");
        tBulletChains[name] = TYChains[item];
    });

    tBulletChains.tBulletGetBindingSeries = function(rawData, dimensions, measures,
                                                    bindingResults, bindings, bindingDefinition, options) {
        
        TYChains.tyGetBindingSeries(rawData, dimensions, measures,
            bindingResults, bindings, bindingDefinition, options);
        BulletUtils.bulletSetMinMax(bindingResults);
    };

    tBulletChains.tBulletGetMeasuresFromFlattable = BulletChains.bulletGetMeasuresFromFlattable;
    Object.keys(tBulletChains).forEach(function(key) {
        BindingManager.registerChain(key, tBulletChains[key]);
    });
    
    return tBulletChains;
});

define('sap/viz/chart/views/TimeBulletChartView',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/views/BulletChartView",
    "sap/viz/chart/components/plotareas/TimeBulletPlotArea",
    "sap/viz/chart/scales/BulletColorScale",
    "sap/viz/chart/chains/TBulletChains",
    "sap/viz/chart/scales/TimeScaleProcessor",
    "sap/viz/chart/behavior/config/TimeLassoBehaviorConfig"
], function(
    oo,
    BulletChartView,
    TimeBulletPlotArea,
    BulletColorScale
) {
    var TimeBulletChartView = function() {
        TimeBulletChartView.superclass.constructor.apply(this, arguments);
    };

    oo.extend(TimeBulletChartView, BulletChartView);

    TimeBulletChartView.prototype._getDataItems = function() {
        return ["actualValues", "additionalValues", "color", "series", "timeAxis", "targetValues", "forecastValues"];
    };

    TimeBulletChartView.prototype._createPlotContainer = function() {
        this._plotArea = new TimeBulletPlotArea(this.runtime(), {
            renderType: this._renderType,
            rawData: this._rawData
        });
        this._plotArea.setRoughSize(this._size);

        this.setChild("main", this._plotArea, {
            priority: 3
        });
    };

    TimeBulletChartView.prototype._dataChanged = function() {
        if (this._data && !this._data.color) {
            this._data.color = this._createSeries(this._data);
        }
        TimeBulletChartView.superclass._dataChanged.apply(this, arguments);
    };

    TimeBulletChartView.prototype._createSeries = function(data) {
        var mnd = 'actualValues,additionalValues,forecastValues,targetValues'.split(',').reduce(function(mnds, feed) {
            if (data[feed] && data[feed].metaData) {
                mnds[feed] = data[feed].metaData.map(function(meta) {
                    return meta.name || meta.id;
                });
            }
            return mnds;
        }, {});
        return {
            scale: new BulletColorScale([], this.runtime()._propertyMgr, {mnds: mnd})
        };
    };

    return TimeBulletChartView;
});

define('sap/viz/chart/metadata/bindings/TimeBulletBindings',[], function() {
    return [{
        "id": "timeAxis",
        "name": "IDS_TIME_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "acceptMND": false,
        "continuous": true,
        "sort": true,
        "role": "layout.time"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": false,
        "role": "mark.color"
    }, {
        "id": "actualValues",
        "name": "IDS_PRIMARY_VALE",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }, {
        "id": "additionalValues",
        "name": "IDS_ADDITIONAL_VALE",
        "type": "Measure",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }, {
        "id": "targetValues",
        "name": "IDS_TARGETVALUES",
        "type": "Measure",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "role": "mark.target"
    }];
});

define('sap/viz/chart/metadata/bindings/TimeYCombinationBindings',[], function Setup() {

    var feeds = [{
        "id": "timeAxis",
        "name": "IDS_TIME_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "acceptMND": false,
        "continuous": true,
        "sort": true,
        "configurable": false,
        "role": "layout.time"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "MNDOnly": true,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 2,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }];

    return feeds;
});
define('sap/viz/chart/components/plotareas/TimeYYPlotArea',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/oo',
    "sap/viz/chart/scales/ValueScaleUtil",
    'sap/viz/chart/components/plotareas/TimeYPlotArea',
    'sap/viz/chart/components/plotareas/XYYPlotArea',
    'sap/viz/chart/components/plots/TYPlotFactory',
    'sap/viz/chart/components/plots/PlotHelper',
    'sap/viz/chart/components/axis/ValueAxis',
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/framework/common/format/UnitFormat',
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/framework/common/util/ArrayUtils",
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/datalabels/BarDataLabels',
    'sap/viz/framework/common/util/NumberUtils',
    'sap/viz/framework/common/util/FiscalUtil',
    'sap/viz/chart/components/axis/TimeAxis',
], function(
    Constants,
    oo,
    ValueScaleUtil,
    TimeYPlotArea,
    XYYPlotArea,
    PlotFactory,
    PlotHelper,
    ValueAxis,
    ValueAxisUtils,
    TextUtils,
    UnitFormat,
    TypeUtils,
    ArrayUtils,
    DataUtils,
    BarDataLabels,
    NumberUtils,
    FiscalUtil,
    TimeAxis
) {

    var TimeYYPlotArea = function(runtime, options) {
        TimeYYPlotArea.superclass.constructor.apply(this, arguments);
    };

    oo.extend(TimeYYPlotArea, TimeYPlotArea);

    var prot = TimeYYPlotArea.prototype;
    
    prot._getPlotOptions = function() {
        return {
            isDualValueAxis: true
        };
    };

    prot.setData = function(data) {
        TimeYYPlotArea.superclass.setData.apply(this, arguments);
        this._applyDefaultProperties(data);
    };

    prot._applyDefaultProperties = function(data) {
        XYYPlotArea.prototype._applyDefaultProperties.apply(this, arguments);
    };
    
    prot.allOrNone = function(result, all) {
        XYYPlotArea.prototype.allOrNone.apply(this, arguments);
    };

    prot._init = function() {
        this._plot = PlotHelper.create(this._renderType, PlotFactory.getPlotClazz(this._renderType) , 
                                       this.runtime(), this._getPlotOptions());
        this.setChild("plot", this._plot, {
            position: "center"
        });
        this._plot.getDispatch().on("reRenderComplete.plotarea", this._reRenderComplete.bind(this));
        var isInteractive = !this._properties.get("interaction.noninteractiveMode");

        this.setLayoutSequence(['left', 'right', this.allOrNone.bind(this), 'bottom', 'top']);

        this._categoryAxis = new TimeAxis(this.runtime(), {
            name: "timeAxis",
            hasScrollbar: isInteractive,
            isColumnLike: this.isColumnLike(),
            rawData: this._rawData
        });
        this.setChild("timeAxis", this._categoryAxis, {
            position: "bottom"
        });

        this._valueAxis = new ValueAxis(this.runtime(), {
            name: "valueAxis"
        });
        this.setChild("valueAxis", this._valueAxis, {
            position: "left"
        });
        
        this._valueAxis2 = new ValueAxis(this.runtime(), {
            name: "valueAxis2"
        });
        this.setChild("valueAxis2", this._valueAxis2, {
            position: "right"
        });
        
        if (isInteractive) {
            this._hScrollbar = this._categoryAxis.getChild(Constants.AXIS.SCROLLBAR_NAME).module;
        }
        if (this._isPercentageChart()) {
            this._valueAxis.setPercentageMode(true);
            this._valueAxis2.setPercentageMode(true);
        }

        this.getZoomer().init({
            main: this,
            plot: this._plot,
            isHorizontal: false
        });
    };

    prot._preRender = function() {
        TimeYYPlotArea.superclass._preRender.apply(this, arguments);

        this._runtime.statusManager().add('globalDomain2', {
            value: this._valueAxis2._scale.getDomain(),
            readonly: true
        });
    };

    prot.updateValueScale = function() {
        this._adjustTimeDomain();
        return XYYPlotArea.prototype.updateValueScale.call(this);
    };

    prot._updateValueScaleDomain = function(domain, valueAxisName) {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        if (!data || width <= 0 || height <= 0) {
            return false;
        }
        var range = [0, 1];
        if (this._plot.isHorizontal()) {
            range[1] = width;
        } else {
            range[1] = height;
        }
        range[1] *= 0.8;
        var scale = data[valueAxisName].scale;
        var orginDomain = scale.getDomain().slice();
        scale.setDomain(domain);

        var valueAxisData = ValueAxisUtils.calcScale(scale, range, {
            keepAutoScale: true,
            isLineChart: this._isLineChart()
        });
        domain = valueAxisData.scale.getDomain();
        scale.setDomain(domain);
        data[valueAxisName].tickHint = valueAxisData.tickHint;
        data[valueAxisName].scale.setRange([0, 1]);
        // During scroll, do not re-layout axis when the scale is changed.
        this['_' + valueAxisName].setData(data[valueAxisName], true);
        return (orginDomain[0] !== domain[0] || orginDomain[1] !== domain[1]);
    };

    prot._scroll = function(offset) {
        var centerModule = this.getChildrenByPosition("center")[0];
        var realSize = centerModule.getRealSize();
        var size = centerModule.getSize();
        var isHorizontal = centerModule.isHorizontal();
        if (this._properties.get("interaction.syncValueAxis") &&
            ((isHorizontal && realSize.height > size.height) ||
                (!isHorizontal && realSize.width > size.width))) {

            var data = this._data.rawData;
            var dataModel = data.dataModel;
            var dataScales = data.scales;

            var isFiscal = false;
            if (dataModel && dataModel._rawData) {
                isFiscal = FiscalUtil.isFiscal(dataModel._rawData);
            }
            var timeAxis, timeAxisDomain = ValueAxisUtils.getTimeAxisDomain(size, offset, realSize, 
                    this._data.timeAxis.scale.getDomain(), isHorizontal, isFiscal);

            var valueAxisDomain = this._getValueRange(dataModel.series().filter(function(item) {
                    for(var i = 0; i < item.length; i++) {
                        if(item[i]) {
                            return item[i].hasOwnProperty('valueAxis');
                        }
                    }
                    return false;
                }),
                timeAxisDomain[0],
                timeAxisDomain[1],
                dataScales.valueAxis.getOption());

            if (valueAxisDomain == null) {
                valueAxisDomain = dataScales.valueAxis.getDomain();
            }

            var domainChanged = this._updateValueScaleDomain(valueAxisDomain, 'valueAxis');
            if (domainChanged) {
                timeAxis = this.getChild("timeAxis").module;
                timeAxis.setHasNegativeValue(DataUtils.domainWithNegativeValue(valueAxisDomain));
                this.getChild("valueAxis").module.update();
            }
            
            var valueAxisDomain2 = this._getValueRange(dataModel.series().filter(function(item) {
                    for(var i = 0; i < item.length; i++) {
                        if(item[i]) {
                            return item[i].hasOwnProperty('valueAxis2');
                        }
                    }
                    return false;
                }),
                timeAxisDomain[0],
                timeAxisDomain[1],
                dataScales.valueAxis2.getOption());

            if (valueAxisDomain2 == null) {
                valueAxisDomain2 = dataScales.valueAxis2.getDomain();
            }
            
            var domainChanged2 = this._updateValueScaleDomain(valueAxisDomain2, 'valueAxis2');
            if (domainChanged2) {
                timeAxis = this.getChild("timeAxis").module;
                timeAxis.setHasNegativeValue(DataUtils.domainWithNegativeValue(valueAxisDomain2));
                this.getChild("valueAxis2").module.update();
            }
        }
        this._plot.update(offset);
        TimeYPlotArea.superclass._scroll.apply(this, arguments);
    };

    return TimeYYPlotArea;
});
define('sap/viz/chart/views/TimeYYChartView',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/views/TimeYChartView",
    "sap/viz/chart/components/plotareas/TimeYYPlotArea",
    "sap/viz/chart/scales/FrameScaleProcessor",
    "sap/viz/chart/scales/ShapeScaleProcessor",
    "sap/viz/chart/behavior/config/TimeLassoBehaviorConfig"
], function Setup(oo, TimeYChartView, TimeYYPlotArea) {

    var TimeYYChartView = function(runtime, option) {
        TimeYYChartView.superclass.constructor.apply(this, arguments);
    };

    oo.extend(TimeYYChartView, TimeYChartView);

    TimeYYChartView.prototype._getDataItems = function() {
        return ["valueAxis", "valueAxis2", "timeAxis", "color", "color2", "series"];
    };
    
    TimeYYChartView.prototype._createPlotContainer = function() {

        this._plotArea = new TimeYYPlotArea(this.runtime(), {
            renderType: this._renderType,
            rawData: this._rawData
        });
        this._plotArea.setRoughSize(this._size);

        this.setChild("main", this._plotArea, {
            priority: 3
        });
    };

    return TimeYYChartView;
});

define('sap/viz/chart/metadata/bindings/TimeYYBindings',[], function Setup() {

    var feeds = [{
        "id": "timeAxis",
        "name": "IDS_TIME_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "acceptMND": false,
        "continuous": true,
        "sort": true,
        "configurable": false,
        "role": "layout.time"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "MNDOnly":true,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }, {
        "id": "valueAxis2",
        "name": "IDS_VALUE_AXIS2",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.secondValue"
    }];

    return feeds;
});
define('sap/viz/chart/metadata/bindings/TimeYStackedCombinationBindings',[], function Setup() {

    var feeds = [{
        "id": "timeAxis",
        "name": "IDS_TIME_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "acceptMND": false,
        "continuous": true,
        "sort": true,
        "role": "layout.time"
    }, {
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 2,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    }];

    return feeds;
});
define('sap/viz/chart/metadata/bindings/YYTimeBindings',[], function Setup() {
    var feeds = [
        {
            "id": "color",
            "name": "IDS_COLOR",
            "type": "Dimension",
            "min": 0,
            "max": Number.POSITIVE_INFINITY,
            "acceptMND": false,
            "role": "mark.color"
        }, {
            "id": "shape",
            "name": "IDS_SHAPE",
            "type": "Dimension",
            "min": 0,
            "max": Number.POSITIVE_INFINITY,
            "acceptMND": false,
            "role": "mark.shape"
        }, {
            "id": "valueAxis",
            "name": "IDS_VALUE_AXIS",
            "type": "Measure",
            "min": 1,
            "max": 1,
            "role": "layout.value"
        }, {
            "id": "timeAxis",
            "name": "IDS_TIME_AXIS",
            "type": "Dimension",
            "min": 1,
            "max": 1,
            "acceptMND": false,
            "continuous": true,
            "sort": false,
            "role": "layout.time"
        }, {
            "id": "bubbleWidth",
            "name": "IDS_BUBBLESIZE",
            "type": "Measure",
            "min": 1,
            "max": 1,
            "role": "mark.size"
        }
    ];
    return feeds;
});

define('sap/viz/chart/components/datalabels/StackedWaterfallDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/chart/components/datalabels/DataLabels'
], function(
    oo,
    Constants,
    DOM,
    DataGraphics,
    DataPointUtils,
    DataLabels
    ) {
    var stackedWaterfallTypeScaleArray = [0, 1]; //[null, total]    
        
    var StackedWaterfallDataLabels = function(ctx, options) {
        StackedWaterfallDataLabels.superclass.constructor.apply(this, arguments);
        this._labelPosition = "stackedWaterfall";
    };

    oo.extend(StackedWaterfallDataLabels, DataLabels);
    StackedWaterfallDataLabels.prototype.verticalLabelOffset = -3;
    StackedWaterfallDataLabels.prototype.horizontalLabelOffset = 6;

    StackedWaterfallDataLabels.prototype._getStyle = function(dp) {
        var props = this._properties;
        var style = StackedWaterfallDataLabels.superclass._getStyle.apply(this, arguments);
        var ctx = DataPointUtils.getContext(dp);
        if (ctx && ctx.hasOwnProperty('Type') && this._data.waterfallTypeScale.scale(ctx.Type) !==0) {
            style["font-weight"] = "bold";
            style["cssString"] = "fill:" + style.fill +
                ";font-family:" + props.get('style.fontFamily') +
                ";font-size:" + props.get('style.fontSize') +
                ";font-weight:" + "bold" +
                ";font-style:" + props.get('style.fontStyle') + ";";    
        }
        
        return style;
    };
    
    StackedWaterfallDataLabels.prototype.hideConditional = function(dataLabelInfos) {
        for (var i = dataLabelInfos.length - 1; i >= 0; i--) {
            var dataLabelinfo = dataLabelInfos[i];

            var dataLabelNode = dataLabelinfo.node;
            var dataLabelCtx = DataPointUtils.getContext(dataLabelNode);
            var dataLabelTypeScale = this._data.waterfallTypeScale.scale(dataLabelCtx ? dataLabelCtx.Type : null);

            if (this.isDataLabelOutOfDataPoint(dataLabelNode, dataLabelinfo) && dataLabelTypeScale !== 1) {
                DOM.remove(dataLabelNode);
                dataLabelInfos.splice(i, 1);
            }
        }

        return StackedWaterfallDataLabels.superclass.hideConditional.apply(this, arguments);
    };
    
    StackedWaterfallDataLabels.prototype.sortDataLabelInfos = function(dataLabelInfos) {
        var aNodeCtx, bNodeCtx, aNodeTypeScale, bNodeTypeScale;
        var _this = this;
        dataLabelInfos.sort(function(a, b) {
            aNodeCtx = DataPointUtils.getContext(a.node);
            aNodeTypeScale = _this._data.waterfallTypeScale.scale(aNodeCtx ? aNodeCtx.Type : null);
            bNodeCtx = DataPointUtils.getContext(b.node);
            bNodeTypeScale = _this._data.waterfallTypeScale.scale(bNodeCtx ? bNodeCtx.Type : null);
            return stackedWaterfallTypeScaleArray.indexOf(aNodeTypeScale) - 
                stackedWaterfallTypeScaleArray.indexOf(bNodeTypeScale);
        });
    };
    
    StackedWaterfallDataLabels.prototype._computeDataLabelPosition = function(ctm, shapeBBox, labelPosition, labelBBox, 
                                                                config, node) {
        var x, y;
        var nodeX = shapeBBox.x + ctm.e;
        var nodeY = shapeBBox.y + ctm.f;
        var labelOffset = this._horizontal ? this.horizontalLabelOffset : this.verticalLabelOffset;
        
        if (this._horizontal) {
            y = (nodeY + shapeBBox.height / 2) -
                (labelBBox.y + labelBBox.height / 2);
            if (this._data.waterfallTypeScale.scale(config.ctx.Type) !== 0) {
                x = nodeX + shapeBBox.width + labelOffset;
            } else {
                x = (nodeX + shapeBBox.width / 2) -
                    (labelBBox.x + labelBBox.width / 2);
            }
        } else {
            x = (nodeX + shapeBBox.width / 2) -
                (labelBBox.x + labelBBox.width / 2);
            if (this._data.waterfallTypeScale.scale(config.ctx.Type) !== 0) {
                y = nodeY - (labelBBox.y + labelBBox.height);
                if(y + labelBBox.y < 0) {
                    y = -labelBBox.y - labelOffset;
                }else{
                    y = y + labelOffset;
                }
            }
            else {
                y = (nodeY + shapeBBox.height / 2) -
                    (labelBBox.y + labelBBox.height / 2);
            }
        }

        return [x, y];
    };
    
    StackedWaterfallDataLabels.prototype.drawZero = function(dataPoint) {
        return false;
    };

    return StackedWaterfallDataLabels;
});
define('sap/viz/chart/components/plots/StackedWaterFallPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/plots/StackedColumnPlot',
    'sap/viz/chart/components/plots/WaterFallPlot',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/plots/DataHandler',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    "sap/viz/framework/common/util/DataGraphics",
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/SeriesUtil',
    'sap/viz/chart/components/datalabels/StackedWaterfallDataLabels',
    'sap/viz/framework/common/util/UADetector',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/DOM",
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/util/WaterfallUtils'
], function Setup(
    oo, 
    DrawUtil, 
    SVG, 
    StackedColumnPlot, 
    WaterFallPlot, 
    ContextBuilder, 
    ScaleHandler, 
    DataHandler,
    ItemScaleHandler,
    SeriesRenderer,
    PathRenderer,
    DataGraphics,
    ObjectUtils,
    SeriesUtil,
    StackedWaterfallDataLabels,
    UADetector,
    DataPointUtils,
    Constants,
    DOM,
    TypeUtils,
    WaterfallUtils) {


    var StackedWaterFallPlot = function(runtime, options) {
        StackedWaterFallPlot.superclass.constructor.apply(this, arguments);
    };

    oo.extend(StackedWaterFallPlot, StackedColumnPlot);
    StackedWaterFallPlot.prototype._isSupportNoFill = function (){
        return false;
    };
    
    
    var NEGATIVE_OFFSET = 0.5;
    var linklineCSS = Constants.CSS.CLASS.WATERFALL_LINKLINE;
    
    StackedWaterFallPlot.prototype.setData = function(data) {
        if (data && data.waterfallType && data.waterfallType.scale) {
            data.waterfallTypeScale = data.waterfallType.scale;
        }
        StackedWaterFallPlot.superclass.setData.apply(this, arguments);
        return this;
    };
    
    StackedWaterFallPlot.prototype.render = function(selection) {
        var width = this._size.width, height = this._size.height;
        this._size.width = width < 0 ? 0 : width;
        this._size.height = height < 0 ? 0 : height;
        StackedWaterFallPlot.superclass.render.apply(this, arguments);
    };
    
    StackedWaterFallPlot.prototype._getDataHandler = function() {
        return {
            "valueAxis": DataHandler.getSTKWTFHandler()
        };
    };
    
    StackedWaterFallPlot.prototype._getXPosition = function(seriesIndex, itemIndex, data) {
        var dataHandler = this._dataHandler;
        var handler = this._xHandlers[0];
        return WaterFallPlot.prototype._getXYPosition.call(
            this, seriesIndex, itemIndex, data, handler, dataHandler[handler.id]);
    };
    
    StackedWaterFallPlot.prototype._getYPosition = function(seriesIndex, itemIndex, data) {
        var dataHandler = this._dataHandler;
        var handler = this._yHandlers[0];
        return WaterFallPlot.prototype._getXYPosition.call(
            this, seriesIndex, itemIndex, data, handler, dataHandler[handler.id]);
    };
    
    StackedWaterFallPlot.prototype._getValueScaleHandlers = function(isHorizontal) {
        return [ScaleHandler.getWTFScaleHandler("valueAxis", {
            isHorizontal: this.isHorizontal()
        })];
    };
    

    StackedWaterFallPlot.prototype._drawDatapoints = function(parent) {
        var options = {
            'validAxisData': this._needValidEmptyAxisData()
        };
        drawDataPoints.call(this, parent, options);
    };  
   
    StackedWaterFallPlot.prototype._updateDatapoints = function(parent) {
        var options = {
            'updateOnly': true,
            'validAxisData': this._needValidEmptyAxisData()
        };
        drawDataPoints.call(this, parent, options);
    };
    
    function drawDataPoints(parent, options) {
        var updateOnly =false;
        var inValidEmptyAxisData= false;
        if(options && options.hasOwnProperty('updateOnly')){
            updateOnly = options.updateOnly;
        }

        if(options && options.hasOwnProperty('validAxisData')){
            inValidEmptyAxisData = options.validAxisData;
        }
        var series = this._getSeries();
        var seiresLength = series.length;
        var dpGroupG;
        if (updateOnly) {
            dpGroupG = parent.select("." + Constants.CSS.CLASS.DATAPOINT_GROUP).node();
        } else {
            dpGroupG = SVG.create("g");
            dpGroupG.setAttribute("class", Constants.CSS.CLASS.DATAPOINT_GROUP);
        }
        
        if (!updateOnly && this._seriesRenderer) {
            this._seriesRenderer.init(seiresLength);
        }

        for (var dhID in this._dataHandler) {
            if (this._dataHandler[dhID].reset) {
                this._dataHandler[dhID].reset();
            }
        }
        var currentId;
        var countId = 0;
        var categories = [], category;

        this._selection.selectAll("." + linklineCSS).remove();
        
        var lineG = SVG.create("g");
        
        for (var seriesIndex = 0; seriesIndex < seiresLength; seriesIndex++) {
            var seriesItem = series[seriesIndex];
            if (!seriesItem) {
                continue;
            }
            
            var valAxisName = null;
            
            for (var itemIndex = 0; itemIndex < seriesItem.length; itemIndex++) {
                var data = seriesItem[itemIndex];
                if (!data) {
                    continue;
                }
                if(inValidEmptyAxisData === true){
                    var emptyOfValueAxis = data.valueAxis === undefined || data.valueAxis === null;
                    var emtyOfValueAxis2 = data.valueAxis2 === undefined || data.valueAxis2 === null;
                    if (emptyOfValueAxis && emtyOfValueAxis2) {
                        continue;
                    }
                }

                var position = this._getPosition(seriesIndex, itemIndex, data);
                if (!position) {
                    continue;
                }
                
                currentId = countId++;
                var ctx = data.dp.context();
                if (ctx[ctx.measureNames] === null) {
                    ctx[ctx.measureNames] = data.valueAxis;
                }
                var dpConfig = this._buildWrapperConfig(data, position, ctx);
                
                if (!valAxisName) {
                    valAxisName = "valueAxis";
                }
                categories[itemIndex] = categories[itemIndex] || {};
                category = categories[itemIndex][valAxisName] = categories[itemIndex][valAxisName] || {
                    configs: [],
                    positions: [],
                    currentIds: [],
                    dataPoints: []
                };
                if (updateOnly) {
                    if (!category.node) {
                        var dpNode = DataPointUtils.find(dpGroupG, currentId);
                        var categoryNode = dpNode;
                        while( (categoryNode = categoryNode.parentNode) && 
                            !DOM.hasClass(categoryNode, Constants.CSS.CLASS.STACK) ) {}
                        category.node = categoryNode;
                    }
                } else {
                    var dpData = this._buildData(dpConfig);
                    category.data = category.data || [];
                    category.data.push(dpData);
                }
                category.configs.push(dpConfig);
                category.dataPoints.push(data.dp);
                category.positions.push(position);
                category.currentIds.push(currentId);
            }
        }
        var dpRenderer = this._getDataPointRenderer(seriesIndex);
        for (var i = 0; i < categories.length; i++) {
            var currentCategory = categories[i];
            for (var axis in currentCategory) {
                if (currentCategory.hasOwnProperty(axis)) {
                    category = currentCategory[axis];
                    if (!category) {
                        continue;
                    }
                    var cp = this._drawCategory(category, dpRenderer, []);
                    if (cp) {
                        dpGroupG.appendChild(cp);
                    }
                }
            }
        }
        if (categories.length > 1) {
            this._drawLine(lineG, categories);
        }
        dpGroupG.appendChild(lineG);
        if (!updateOnly) {
            this._postRender(dpGroupG);
            parent.node().appendChild(dpGroupG);
            this._dataLabels._gridlineScale = this._gridlineScale;
            this._drawDataLabels(parent, dpGroupG);
        } else {
            var dataPoints = parent.selectAll('.' + Constants.CSS.CLASS.DATAPOINT)[0];
            this._dataLabels.updatePosition(parent, dataPoints);
        }
    }
    
    StackedWaterFallPlot.prototype._getGap = function() {
        var p1, p2;
        if (this.isHorizontal()) {
            p1 = this._getYPosition(0, 0, {
                valueAxis : 0,
                total : 0,
                base : 0
            });
            p2 = this._getYPosition(0, 1, {
                valueAxis : 0,
                total : 0,
                base : 0
            });
            return p2[0] - p1[0];
        } else {
            p1 = this._getXPosition(0, 0, {
                valueAxis : 0,
                total : 0,
                base : 0
            });
            p2 = this._getXPosition(0, 1, {
                valueAxis : 0,
                total : 0,
                base : 0
            });
            return p2[0] - p1[0];
        }
    };
    
    StackedWaterFallPlot.prototype._getHorizontalLine = 
    function(configs, positions, wtfType, categoryIndex, childNum) {
        var lLine, rLine, subLine;
        var x;
        var offset = NEGATIVE_OFFSET;
        var lastIndex = configs.length - 1;
        var dpConfig = configs[0];
        var position = positions[0];
        var gap = this._getGap();
        var barSpacing = gap - position.height;        
        var negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
        if (1 === wtfType || 2 === wtfType) {
            dpConfig = configs[lastIndex];
            position = positions[lastIndex];
            negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
            x = !negative ? Math.round(position.x + position.width) : Math.round(position.x + offset); 
            if (categoryIndex !== 0) {
                lLine = {
                        'y1' : Math.round(position.y - barSpacing / 2),
                        'y2' : Math.round(position.y + position.height)
                    };
                lLine.x1 = lLine.x2 = x;
            }
            
            if (categoryIndex !== this._data.series[0].length - 1) {
                rLine = {
                    'y1' : Math.round(position.y),
                    'y2' : Math.round(position.y + position.height + barSpacing / 2)
                };
                rLine.x1 = rLine.x2 = x;
            }

            //add subline for subtotal
            if(wtfType === 2){
                dpConfig = configs[0];
                position = positions[0];
                negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
                subLine = {
                    'y1' : Math.round(position.y - gap * childNum),
                    'y2' : Math.round(position.y + position.height)
                };
                x = !negative ? Math.round(position.x) : Math.round(position.x + position.width + offset);
                subLine.x1 = subLine.x2 = x;
            }

        } else {
            if (categoryIndex !== 0) {
                lLine = {
                    'y1' : Math.round(position.y - barSpacing / 2),
                    'y2' : Math.round(position.y + position.height)
                };
                x = !negative ? Math.round(position.x) : Math.round(position.x + position.width + offset);
                lLine.x1 = lLine.x2 = x;
            }

            dpConfig = configs[lastIndex];
            position = positions[lastIndex];
            negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;

            if (categoryIndex !== this._data.series[0].length - 1) {
                rLine = {
                    'y1' : Math.round(position.y),
                    'y2' : Math.round(position.y + position.height + barSpacing / 2)
                };
                x = !negative ? Math.round(position.x + position.width) : Math.round(position.x + offset);
                rLine.x1 = rLine.x2 = x;
            }
        }
        
        return {
            'lLine' : lLine, 
            'rLine' : rLine,
            'subLine': subLine
        };
    };

    StackedWaterFallPlot.prototype._getVerticalLine = 
    function(configs, positions, wtfType, categoryIndex, childNum) {
        var lLine, rLine, subLine;
        var y;
        var offset = NEGATIVE_OFFSET;
        var lastIndex = configs.length - 1;
        var dpConfig = configs[0];
        var position = positions[0];
        var gap = this._getGap();
        var barSpacing = gap - position.width;        
        var negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;

        if (1 === wtfType || wtfType === 2) {
            dpConfig = configs[lastIndex];
            position = positions[lastIndex];
            negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;

            y = !negative ? Math.round(position.y) : Math.round(position.y + position.height + offset);
            if (categoryIndex !== 0) {
                lLine = {
                    'x1' : Math.round(position.x - barSpacing / 2),
                    'x2' : Math.round(position.x + position.width)
                };
                lLine.y1 = lLine.y2 = y;
            }
            
            if (categoryIndex !== this._data.series[0].length - 1) {
                rLine = {
                    'x1' : Math.round(position.x),
                    'x2' : Math.round(position.x + position.width + barSpacing / 2)
                };
                rLine.y1 = rLine.y2 = y;
            }

            //add subline for subtotal
            if(wtfType === 2){
                dpConfig = configs[0];
                position = positions[0];
                negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;
                subLine = {
                    'x1' : Math.round(position.x - gap * childNum),
                    'x2' : Math.round(position.x + position.width)
                };
                y = !negative ? Math.round(position.y + position.height) : Math.round(position.y + offset);
                subLine.y1 = subLine.y2 = y;
            }
        } else {
            if (categoryIndex !== 0) {
                lLine = {
                    'x1' : Math.round(position.x - barSpacing / 2),
                    'x2' : Math.round(position.x + position.width)
                };
                y = !negative ? Math.round(position.y + position.height) : Math.round(position.y + offset); 
                lLine.y1 = lLine.y2 = y;
            }

            dpConfig = configs[lastIndex];
            position = positions[lastIndex];
            negative = dpConfig.ctx[dpConfig.ctx.measureNames] < 0;

            if (categoryIndex !== this._data.series[0].length - 1) {
                rLine = {
                    'x1' : Math.round(position.x),
                    'x2' : Math.round(position.x + position.width + barSpacing / 2)
                };
                y = !negative ? Math.round(position.y) : Math.round(position.y + position.height + offset);
                rLine.y1 = rLine.y2 = y;
            }
        }
        
        return {
            'lLine' : lLine, 
            'rLine' : rLine,
            'subLine': subLine
        };
    };

    StackedWaterFallPlot.prototype._drawLine = function(lineG, categories) {
        var visible = this._properties.get("linkline.visible");
        if (!visible) {
            return;
        }
        
        var lines = [];
        var retLine;
        var i, category;
        
        for (i = 0; i < categories.length; i++) {
            var currentCategory = categories[i];
            for (var axis in currentCategory) {
                if (currentCategory.hasOwnProperty(axis)) {
                    category = currentCategory[axis];
                    if (!category) {
                        continue;
                    }
                    
                    var configs = category.configs;
                    var allNull = true;
                    for (var j = 0; j < configs.length; j++) {
                        if (null !== configs[j].ctx[configs[j].ctx.measureNames]) {
                            allNull = false;
                            break;
                        }
                    }
                    if (allNull) {
                        continue;
                    }
                    
                    var wtfTypeValue = null;
                    var values = this._data.waterfallType.values;
                    if (values && values.hasOwnProperty(i)) {
                        if (TypeUtils.isArray(values[i])) {
                            wtfTypeValue = values[i][values[i].length - 1];
                        } else {
                            wtfTypeValue = values[i];
                        }
                    }
                    var waterfallType = this._data.waterfallType.scale.scale(wtfTypeValue);
                    var childNum = this._getChildNumScale(wtfTypeValue);

                    if (this.isHorizontal()) {
                        retLine = this._getHorizontalLine(configs, category.positions, waterfallType, i, childNum);
                    } else {
                        retLine = this._getVerticalLine(configs, category.positions, waterfallType, i, childNum);
                    }
                    
                    if (retLine.lLine) {
                        lines.push(retLine.lLine);    
                    }
                    if (retLine.rLine) {
                        lines.push(retLine.rLine);
                    }
                    if (2 === waterfallType) {
                        lines.push(retLine.subLine);
                    }
                }
            }
        }
        WaterfallUtils.drawLines(lines, this._properties, this.isHorizontal(), lineG, true);
    }; 
    
    StackedWaterFallPlot.prototype._getDataLabels = function(name, runtime) {
        this._datalabels = new StackedWaterfallDataLabels(runtime, {
            name: name,
            horizontal: this.isHorizontal()
        });
        return this._datalabels;
    }; 
    
    StackedWaterFallPlot.prototype._buildWrapperConfig = function(data, position, context) {
        var config = StackedWaterFallPlot.superclass._buildWrapperConfig.apply(this, arguments);
        var wtfType = this._data.waterfallType.scale.scale(data.waterfallType);

        if (1 === wtfType && !config.matchSemantic) {
            var totalColor = this._properties.get("dataPoint.color.total");
            var effectMgr = this._effectManager;
            if(totalColor &&  effectMgr.isColorProp(totalColor)){
                config.graphic.fill = effectMgr.parseColorProperty(totalColor, config.graphic.fill);
            }else{
                config.graphic.fill = totalColor;
            }

        }

        return config;
    };

    StackedWaterFallPlot.prototype._getChildNumScale = function(waterfallType) {
        return this._data.waterfallType.scale.childrenNum(waterfallType);
    };
    
    return StackedWaterFallPlot;
});

define('sap/viz/chart/components/plots/WaterFallPlotFactory',[
    'jquery',
    'sap/viz/chart/components/plots/WaterFallPlot',
    'sap/viz/chart/components/plots/StackedWaterFallPlot'
], function($,
    WaterFallPlot,
    StackedWaterFallPlot
) {

    var plotMapping = {
        'waterfall': {
            plotClazz: WaterFallPlot
        },
        'stacked_waterfall': {
            plotClazz: StackedWaterFallPlot
        },
        'horizontal_waterfall': {
            plotClazz: WaterFallPlot
        },
        'horizontal_stacked_waterfall': {
            plotClazz: StackedWaterFallPlot
        },
    };

    return {
        getPlotClazz: function(renderType) {
            var config = plotMapping[renderType];
            return config && config.plotClazz;
        }
    };

});

define('sap/viz/chart/components/axis/renderer/WaterfallCategoryBodyRenderer',[
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/chart/components/axis/renderer/OrdinalCommonBodyRenderer",
    "sap/viz/framework/common/util/oo"
], function(ObjectUtils, OrdinalCommonBodyRenderer, oo) {
    var ret = function() {
        ret.superclass.constructor.apply(this, arguments);
    };
    oo.extend(ret, OrdinalCommonBodyRenderer);

    // Add the CategoryBodyRenerer itself functions.
    ret.prototype._createLabelStyle = function(effectManager, style) {
        ret.superclass._createLabelStyle.apply(this, arguments);
        
        this._propStyleTotal = ObjectUtils.clone(this._propStyle);
        this._propStyleTotal.fontWeight = "bold";
    };
    
    ret.prototype._getLabelStyle = function(data, isParentLayer) {
        if (data && data._waterfallType !== undefined && data._waterfallType !== 0) {
            return ObjectUtils.clone(this._propStyleTotal);
        }
        
        return ret.superclass._getLabelStyle.apply(this, arguments);
    };
    
    return ret;
});

define('sap/viz/chart/components/axis/sub/WaterfallCategoryAxisBody',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/components/axis/sub/CategoryAxisBody",
    "sap/viz/chart/components/axis/renderer/WaterfallCategoryBodyRenderer"
], function(oo, TypeUtils, CategoryAxisBody, WaterfallCategoryBodyRenderer) {

    var WaterfallCategoryAxisBody = function() {
        WaterfallCategoryAxisBody.superclass.constructor.apply(this, arguments);
        this.setBodyRenderer(new WaterfallCategoryBodyRenderer());
    };
    oo.extend(WaterfallCategoryAxisBody, CategoryAxisBody);

    WaterfallCategoryAxisBody.prototype._buildLayers = function(scale) {
        var labelLayers = WaterfallCategoryAxisBody.superclass._buildLayers.apply(this, arguments);
        if (scale._waterfallType && labelLayers && labelLayers.length > 0 && labelLayers[labelLayers.length-1].cells) {
            var values = scale._waterfallType.values;
            if(values){
                var typeLen = values.length;
                var cells = labelLayers[labelLayers.length-1].cells;
                
                for (var i = 0; i < cells.length; i++) {
                    var type = null;
                    if (TypeUtils.isArray(values[i])) {
                        for (var j = 0; j < values[i].length; j++) {
                            if (values[i][j] !== undefined) {
                                type = values[i][j];
                                break;
                            }
                        }
                    } else {
                        type = values[i];
                    }
                    cells[i]._waterfallType = scale._waterfallType.scale.scale(i < typeLen ? type : null);
                }
            }
        }
        return labelLayers;
    }; 
    
    WaterfallCategoryAxisBody.prototype.getLayoutCellsConfig = function(){
        var config = WaterfallCategoryAxisBody.superclass.getLayoutCellsConfig.apply(this, arguments);
        if (config && config.propStyle) {
            config.propStyle.fontWeight = "bold";
            if(config.propParentStyle) {
                config.propParentStyle.fontWeight = "bold";
            }
        }
        return config;
    };
    
    return WaterfallCategoryAxisBody;
});

define('sap/viz/chart/components/axis/WaterfallCategoryAxis',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/CategoryAxis",
    "sap/viz/chart/components/axis/sub/WaterfallCategoryAxisBody"
], function(oo, CategoryAxis, WaterfallCategoryAxisBody) {

    var WaterfallCategoryAxis = function(runtime, options) {
        WaterfallCategoryAxis.superclass.constructor.apply(this, arguments);
    };
    oo.extend(WaterfallCategoryAxis, CategoryAxis);

    WaterfallCategoryAxis.prototype.setData = function(data, hasNegativeValue) {
        if (data && data.hasOwnProperty("categoryAxis")) {
            WaterfallCategoryAxis.superclass.setData.call(this, data.categoryAxis, hasNegativeValue);
            this._hasNegativeValue = hasNegativeValue;
            if (data.categoryAxis.scale) {
                this._scale = data.categoryAxis.scale;
                this._scale._waterfallType = data.waterfallType; 
            }
        }
    };
        
    WaterfallCategoryAxis.prototype._setAxisBody = function(runtime, options) {
        this.setChild("axisBody", new WaterfallCategoryAxisBody(runtime, options), {
            order: 1,
            priority: 2,
            offset: 0
        });
    };
    
    return WaterfallCategoryAxis;

});
define('sap/viz/chart/components/plotareas/WaterfallPlotArea',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/plots/WaterFallPlotFactory',
    'sap/viz/chart/components/plotareas/XYPlotArea',
    'sap/viz/chart/components/axis/WaterfallCategoryAxis',
    'sap/viz/framework/common/util/DataUtils'
], function Setup(oo, PlotFactory, XYPlotArea, WaterfallCategoryAxis, DataUtils) {

    var CHAET_AXIS_WIDTH_RATE = 0.8;
    var WaterfallPlotArea = function(runtime, options) {
        WaterfallPlotArea.superclass.constructor.apply(this, arguments);
    };

    oo.extend(WaterfallPlotArea, XYPlotArea);

    WaterfallPlotArea.prototype._setAxisData = function(data) {
        this._categoryAxis.setData(data, DataUtils.hasNegativeValue(data));
    };

    WaterfallPlotArea.prototype._isAdjustValueScaleForTopLabel = function() {
        return true;
    };
    
    WaterfallPlotArea.prototype._getCategoryAxisClass = function() {
        return WaterfallCategoryAxis;
    };
    
    WaterfallPlotArea.prototype._isHorizontal = function(){
        return this._renderType.indexOf("horizontal")>-1;
    };

    WaterfallPlotArea.prototype._getPlotClazz = function(renderType) {
        return PlotFactory.getPlotClazz(renderType);
    };

    return WaterfallPlotArea;
});
define('sap/viz/chart/components/legend/WaterFallLegend',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/legend/ColorLegend",
    "sap/viz/chart/components/legend/LineLegend",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/scales/ColorScale",
    "sap/viz/framework/scale/ColorShapeScaleMerger",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/framework/common/util/ObjectUtils",
    "sap/viz/framework/common/util/StatusConstants",
    "sap/viz/framework/common/util/TypeUtils"
], function(oo, 
    ColorLegend,
    LineLegend,
    Constants,
    ColorScale,
    ColorShapeScaleMerger,
    LangManager,
    ObjectUtils,
    StatusConstants,
    TypeUtils) {

    var INTERACTION_CLASS = Constants.CSS.CLASS.LEGENDITEM,
        ID_CLASS = "v-legend-element";
    var LEGEND_ORDER = ['positiveValue', 'negativeValue', 'total'];
    var MND = 'measureNames';
        
    var WaterFallLegend = function(runtime, options) {
        WaterFallLegend.superclass.constructor.apply(this, arguments);
        this._labelText = {
            'total': null,
            'positiveValue': null,
            'negativeValue': null
        };
        this._legendColor = {
            'total': null,
            'positiveValue': null,
            'negativeValue': null
        };
        this._isSemanticColoring = null;
        this._colorPalette = null;
        this._validItems = null;
        this._recapVisible = null;
    };
    oo.extend(WaterFallLegend, ColorLegend);

    function createScale(_this, dataModel) {

        var measureName;
        if (dataModel && dataModel.valueAxis && dataModel.valueAxis.metaData && dataModel.valueAxis.metaData[0]) {
            measureName = dataModel.valueAxis.metaData[0].id;
        } else {
            return ;
        }
        var colorScales = [];
        var domain = [];
        var range = [];
        var type, context;
        var keys = _this._validItems;
        var isMeasureNameAdd = false; 

        for (var j = 0; j < keys.length; j++) {
            type = keys[j];
            if (_this._isSemanticColoring || type === 'total') {
                range.push(_this._legendColor[type]);
                domain.push([_this._labelText[type]]);
            } else {

                if (range.indexOf(_this._colorPalette[0]) < 0) {
                    //Use the first color in color palette if isSemanticColoring is false.
                    range.push(_this._colorPalette[0]);
                }
                if (!isMeasureNameAdd) {
                    _this._validItems = _this._validItems.filter(function(item){
                        return item === 'total';
                    });
                    _this._validItems.unshift(measureName);
                    domain.push([measureName]);
                    isMeasureNameAdd = true;
                }
            }
        }
        
        if(!_this._isSemanticColoring && dataModel.color) {
            colorScales.push(dataModel.color);
        }else {
            var colorScale = new ColorScale(domain, range),
                metaData = [{
                    id: MND,
                    type: 'Dimension',
                    values: dataModel.valueAxis.metaData
                }];
            colorScales.push({
                'scale': colorScale,
                'metaData': metaData
            });
        }
        _this.setColorScale(colorScales);
    }
    
    function orderLegendItem(items, order) {
        items.sort(function(a, b) {
            return order.indexOf(a) - order.indexOf(b);
        });
        return items;       
    }
    
    WaterFallLegend.prototype._initColorShapeScale = function() {
        WaterFallLegend.superclass._initColorShapeScale.apply(this, arguments);
        var semanticMgr = this.runtime().semanticManager();
        var type, context;
        if (!(semanticMgr.hasDataPointColorStyle() && semanticMgr.isOverrideMode()) && this._colorShapeScale) {
            var itemLength = this._colorShapeScale.getLength();
            var keys = this._validItems;
            var index = 0;
            for (var i = 0; i < itemLength; i++) {
                if (!this._colorShapeScale.getItem(i).isSemanticItem) {
                    type = keys[index++];
                    context = this._buildLegendContext(type);
                    //Above is a special context building, so need to set context for item.
                    this._colorShapeScale.setContext(i, context);
                }
            }
        }
    };

    WaterFallLegend.prototype._constructTitle = function(header) {
        var text = "",
            semanticMgr = this.runtime().semanticManager(),
            hasSemanticTitle = semanticMgr.isOverrideMode() && semanticMgr.hasDataPointColorStyle();
        /*
        * There are three kinds of waterfall legend: color legend, sematic legend and measure variation.
        * Here we only need to handle measure variation for special.
        */
        if (this._isSemanticColoring && !hasSemanticTitle) {
            var field = header[0];
            if (field.values.length > 1) {
                text = LangManager.get('IDS_DEFAULTMND');
            } else {
                var metaData = field.values[0];
                text = (metaData.name || metaData.id);
            }
        } else {
            text = WaterFallLegend.superclass._constructTitle.apply(this, arguments);
        }
        return text;
    };
    
    WaterFallLegend.prototype.render = function(selection, loadMore) {
        this._getLegendProperties();
        createScale(this, this._data);
        WaterFallLegend.superclass.render.apply(this, arguments);
    };

    //get shown text and legend color from properties
    WaterFallLegend.prototype._getLegendProperties = function() {
        this._labelText.total = this._properties.get("label.text.total") || LangManager.get('IDS_SEMANTICTOTAL');
        var positiveValue = this._properties.get("label.text.positiveValue");
        if(positiveValue === null || positiveValue === ''){
            positiveValue = LangManager.get("IDS_INCREASING");
        }
        this._labelText.positiveValue = positiveValue;
        var negativeValue = this._properties.get("label.text.negativeValue");
        if(negativeValue === null || negativeValue === ''){
            negativeValue = LangManager.get("IDS_DECREASING");
        }
        this._labelText.negativeValue = negativeValue;
        
        this._legendColor.total = this._properties.origin.get("plotArea.dataPoint.color.total");
        this._legendColor.positiveValue = this._properties.origin.get("plotArea.dataPoint.color.positive");
        this._legendColor.negativeValue = this._properties.origin.get("plotArea.dataPoint.color.negative"); 
        
        this._isSemanticColoring = this._properties.origin.get("plotArea.dataPoint.color.isSemanticColoring");
        this._colorPalette = this._properties.origin.get("plotArea.colorPalette");  
        this._recapVisible = this._properties.origin.get("plotArea.dataLabel.showRecap");
        this._recapColor = this._properties.origin.get("plotArea.linkline.color");
    };   
    
    WaterFallLegend.prototype.setData = function(value) {

        this._data = value;
        this._getLegendProperties();
        //get current shown legend item.
        this._validItems = this._getShownLegendItem(value);
        
        createScale(this, value);
        return this;
    };
    

    WaterFallLegend.prototype._buildLegendContext = function(type) {
        var contexts =[];
        var measureNum = 1;

        var metaData = this._data.categoryAxis && this._data.categoryAxis.metaData;
        var i;
        for(i = 0; metaData && i < metaData.length; ++i ){
            if(metaData[i].id === "measureNames" && metaData[i].values.length > 1){
                measureNum = metaData[i].values.length;
            }
        }
        metaData = this._data.valueAxis.metaData;
        
        var wtfMetaData = this._data.waterfallType ? this._data.waterfallType.metaData : undefined;
        var wtfTypeDimensionName = wtfMetaData && wtfMetaData[0] ? wtfMetaData[0].id : undefined;
        var curContext = {};
        if (wtfTypeDimensionName) {
            if (type === 'total') {
                curContext[wtfTypeDimensionName] = 'total';
            } else {
                curContext[wtfTypeDimensionName] = {'notEqual' : 'total'};
            }
        }

        if (this._isSemanticColoring) {
            for(i = 0; i < measureNum; ++i){
                var semContext = ObjectUtils.extend(true, {}, curContext);
                if (type === 'positiveValue') {
                    semContext[metaData[i].id] = {'min': 0};
                } else if (type === 'negativeValue') {
                    semContext[metaData[i].id] = {'openmax': 0};
                }
                contexts.push(semContext);
            }
        }else {
            contexts.push(curContext);
        }

        return contexts;
    };
    
    WaterFallLegend.prototype._getShownLegendItem = function(dataModel) {
        var dataPoints = dataModel._dataPoints;
        var measureName, datapoint, context, type, key, value;
        var validKeys = [];

        var wtfMetaData = this._data.waterfallType ? this._data.waterfallType.metaData : undefined;
        var wtfTypeDimensionName = wtfMetaData && wtfMetaData[0] ? wtfMetaData[0].id : undefined; 

        for (var dp in dataPoints) {
            if (dataPoints.hasOwnProperty(dp)) {
                if (validKeys.length === 3) {
                    break;
                }
                datapoint = dataPoints[dp];
                if (datapoint) {
                    context = datapoint.context();
                    measureName = context.measureNames;
                    type = wtfTypeDimensionName ? context[wtfTypeDimensionName] : undefined;
                    value = context[measureName];
                    if (value >= 0 && type !== 'total') {
                        key = 'positiveValue';
                    } else if (value < 0 && type !== 'total') {
                        key = 'negativeValue';
                    } else if (type === 'total') {
                        key = 'total';
                    }
                    if (validKeys.indexOf(key) === -1) {
                        validKeys.push(key);
                    }
                }
            }
        }
        //BITSDC1-7054
        //Legend should get hide while isSemanticColoring is false and no total in data points.
        if (!this._isSemanticColoring && validKeys.indexOf('total') < 0) {
            return [];
        }
        validKeys = orderLegendItem(validKeys, LEGEND_ORDER);
        return validKeys;
    };

    WaterFallLegend.prototype._buildColorShapeScale = function(colorScales) {
        var colorShapeScale = WaterFallLegend.superclass._buildColorShapeScale.apply(this, arguments);
        var recapTitle = this._properties.origin.get("plotArea.dataLabel.recapTitle") ||
            LangManager.get("IDS_END_OF_PERIOD");
        if(this._recapVisible) {
            colorShapeScale._items.push({
                color:this._recapColor,
                data: [recapTitle],
                shape:"squareWithLine"
            });
        }
        
        return colorShapeScale;
    };

    WaterFallLegend.prototype._isShowWideMarker = function(){
        return this._recapVisible;
    };

    WaterFallLegend.prototype._getMarkerWidth = LineLegend.prototype._getMarkerWidth;

    WaterFallLegend.prototype._calcMetaInfo = LineLegend.prototype._calcMetaInfo;

    WaterFallLegend.prototype._createGroupItems = function(groups, cDomain){
        WaterFallLegend.superclass._createGroupItems.apply(this, arguments);
        if(this._data.timeAxis) {
            groups.selectAll('g.' + INTERACTION_CLASS).classed(INTERACTION_CLASS, false);
        }
    };
    
    WaterFallLegend.prototype.destroy = function() {
        WaterFallLegend.superclass.destroy.apply(this, arguments);
        
        this._labelText = null;
        this._legendColor = null;
        this._validItems = null;
    };
    
    WaterFallLegend.prototype.statusChanged = function(status){
        if(status === StatusConstants.LOCALE_CHANGED){
            this._colorShapeScale = null;
            this._getLegendProperties();
            createScale(this, this._data);
        }
    };
    
    return WaterFallLegend;
});

define('sap/viz/chart/scales/WaterFallTypeScale',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/BaseScale',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/chart/util/WaterfallUtils',
    'sap/viz/framework/common/util/DataUtils',
], function(oo, BaseScale, TypeUtils, WaterfallUtils, DataUtils) {

    var DIMENSION_VALUE = DataUtils.DIMENSION_VALUE;

    /*
     * Used for shape scale
     */
    var WaterFallTypeScale = function(domain, range, options) {
        WaterFallTypeScale.superclass.constructor.apply(this, arguments);
        this.__className = "sap.viz.scale.WaterFallTypeScale";
        this._name = null;
        this._type = "wtfType";
        options = options || {};
        this._key2Type =  WaterfallUtils.Key2Type; 
        this._initScale();
    };

    oo.extend(WaterFallTypeScale, BaseScale);
    
    WaterFallTypeScale.prototype._initScale = function() {
        this._scale = d3.scale.ordinal();
        this._scale.domain(this._domain).range(this._range);
        this._isReset = false;
    };


    WaterFallTypeScale.prototype.getDomain = function() {
        if (this._scale === undefined || this._isReset === true) {
            this._initScale();
        }
        return this._domain;
    };

    WaterFallTypeScale.prototype.getRange = function() {
        if (this._scale === undefined || this._isReset === true) {
            this._initScale();
        }
        return this._range;
    };

    var getDimensionValue = function(dim) {
        var val = dim;
        if (dim && dim.hasOwnProperty(DIMENSION_VALUE)) {
            val = dim[DIMENSION_VALUE];
        }
        return val;
    };

    WaterFallTypeScale.prototype.scale = function(key) {
        return WaterfallUtils.scale(getDimensionValue(key), this._key2Type);
    }; 
    
    WaterFallTypeScale.prototype.childrenNum = function(key) {
        var type = this.scale(key);
        if (type !== 2) {
            return 0;
        }
        var num = parseInt(getDimensionValue(key).split(':')[1].trim());
        return num;
    }; 

    return WaterFallTypeScale;
});
define('sap/viz/chart/scales/WaterScaleProcessor',['sap/viz/chart/scales/WaterFallTypeScale',
        'sap/viz/framework/scale/ScaleDataParseFactory',
        'sap/viz/framework/common/util/ArrayUtils',
        'sap/viz/framework/common/util/TypeUtils',
        'sap/viz/framework/scale/ScaleRepository'],
        function(WaterFallTypeScale,
                ScaleDataParseFactory,
                ArrayUtils,
                TypeUtils,
                ScaleRepository){  
        var waterfall_valueAxis = function(dataModel, chartType, runtime) {
            var valueAxis = dataModel['valueAxis']();
            var waterfallType, types;
            var isTimeWaterFall= /timeseries.*waterfall/.test(chartType);
            if (isTimeWaterFall) {
                types = null;
            } else {
                waterfallType = dataModel['waterfallType']();
                types = waterfallType.values;
            }
            var values = valueAxis.values;
            var categorySum = valueAxis.categorySum;
            var series = dataModel['series']();
            var options = {'isStacked' : ((/stacked_/).test(chartType) ? true : false)};
            var wtfScale = ScaleRepository.waterfallScale(valueAxis, 'waterfallType', null, null, options);
            var startValue = parseFloat(runtime.propertyManager().get("plotArea.startValue")) || 0;
            var data, i, j, min = startValue, max = 0, accumulation = [startValue], totals = [];
            var value, type;
            var categoryValues, subSum = [];

            var calValueAndTotal = function() {
                if (values[i] && data.valueAxis === null) {
                    if (TypeUtils.isArray(values[i])) {
                        data.valueAxis = values[i][j];
                    } else {
                        data.valueAxis = values[i];
                    }
                }                    
                var rValue = (+data.valueAxis) || 0;
                if(rValue === 0){
                    data.valueAxis = 0;
                }
                
                data.total = data.base + (isTimeWaterFall ? rValue : categorySum[i]);
                if (!totals.hasOwnProperty(i)) {
                    totals[i] = data.total;
                }

                if (accumulation.hasOwnProperty(i)) {
                    accumulation[i] += rValue;
                } else {
                    accumulation[i] = data.base + rValue;
                }
            };

            if (!isTimeWaterFall) {
                for (i = 0; i < values.length; i++) {
                    if (TypeUtils.isArray(values[i])) {
                        value = values[i][values[i].length - 1];
                        type = types ? types[i][types[i].length - 1] : null;
                        if (1 === wtfScale.scale(type)) {
                            if (value === null) {
                                categorySum[i] = 0;
                                for (j = i - 1; j >= 0; j--) {
                                    type = types[j][types[j].length - 1];
                                    categorySum[i] += categorySum[j];
                                    if (1 === wtfScale.scale(type)){
                                        break;
                                    }
                                }
                                values[i][values[i].length - 1] = categorySum[i];
                            } else {
                                categorySum[i] = value;
                            }
                        }
                    }
                    else{
                        type = types ? types[i]: null;
                        if (1 === wtfScale.scale(type)) {
                            if (values[i] === null) {
                                categorySum[i] = 0;
                                for (j = i - 1; j >= 0; j--) {
                                    type = types[j];
                                    categorySum[i] += categorySum[j];
                                    if (1 === wtfScale.scale(type)){
                                        break;
                                    }
                                }
                                values[i] = categorySum[i];
                            } else {
                                categorySum[i] = +values[i];
                            }
                        }
                    }
                }

                categoryValues = values;
                for (i = 0; i < categoryValues.length; i++) {
                    for (j = series.length - 1; j >= 0; j--) {
                        data = series[j][i] || {};
                        categorySum[i] = categorySum[i] || 0;
                        type = types ? types[i] : null;
                        if(TypeUtils.isArray(type)){
                            type = type[type.length - 1];
                        }
                        if (i === 0) {
                            data.base = 0;
                        } else {
                            if (1 === wtfScale.scale(type)) {
                                data.base = 0;
                            } else if (2 === wtfScale.scale(type)) {
                                data.base = totals[i - 1] - categorySum[i];
                            } else {
                                data.base = totals[i - 1];
                            }
                        }

                        calValueAndTotal();
                        
                        min = Math.min(min, accumulation[i]);
                        max = Math.max(max, accumulation[i]);
                    }
                }
            } else {
                var timeAxisData = dataModel['timeAxis']();
                var timeValues = timeAxisData.values[0];
                if(timeValues) {
                    timeValues = timeValues.map(function(item) {
                        return item ? item.parsedValue : null;
                    });
                    timeValues = timeValues.filter(function(item) {return item;});
                    timeValues = ArrayUtils.unique(timeValues);
                    timeValues.sort(function(a, b){
                        return a - b;
                    });

                    timeAxisData._sortedTimeStampSet = timeValues;

                    for(i = 0; i < timeValues.length; i++) {
                        for (j = 0; j < series.length; j++) {
                            var seriesData = series[j][ArrayUtils.bisearch(series[j], timeValues[i], function(item) {
                                return item ? item.timeAxis[0].parsedValue : 0;
                            })];
                            if(!seriesData || seriesData.timeAxis[0].parsedValue !== timeValues[i]) {
                                if (!accumulation.hasOwnProperty(i)) {
                                    accumulation[i] = data ? data.base + data.valueAxis : 0;
                                }
                                continue;
                            }
                            data = seriesData;
                            subSum[i] = (subSum[i] || 0) + data.valueAxis;
                            if (i === 0 && j === 0) {
                                data.base = startValue;
                            }else {
                                data.base = (j === 0 ? accumulation[i - 1] : accumulation[i]);
                            }                            

                            calValueAndTotal();
                            
                            min = Math.min(min, accumulation[i]);
                            max = Math.max(max, accumulation[i]);
                        }
                    }
                }
            }
            

            if (subSum.length > 0) {
                valueAxis.categorySum = subSum;
            }

            valueAxis.range = [[min, max]]; 
            return dataModel;
        };
        ScaleRepository["waterfallScale"] =  function(data, name, scaleMgr, propMgr, options) {
            var domain = data && data.values ? data.values.slice(0) : [];
            var range = [0, 1];
            var wtfScale = new WaterFallTypeScale(domain, range, options);

            return wtfScale;
        };
        ScaleDataParseFactory.register("waterfall", "valueAxis",  waterfall_valueAxis);
    });
define('sap/viz/chart/chains/WaterFallChains',[ 
    'sap/viz/chart/chains/BaseChains',
    'sap/viz/chart/chains/ChainUtils',
    'sap/viz/framework/common/util/NumberUtils', 
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/ArrayUtils',
    'sap/viz/chart/util/WaterfallUtils',
    'sap/viz/chart/chains/TYChains',
    'sap/viz/framework/binding/BindingManager'
], function Setup(
    BaseChains, 
    ChainUtils, 
    NumberUtils, 
    TypeUtils,
    ArrayUtils,
    WaterfallUtils,
    TYChains,
    BindingManager
) {
    var waterfallChains = {};

    var defaultChains = [
        'GetDimensionsFromFlattable',
        'GetContext',
        'OnBindingFinished',
        'OnBindingStart'
    ];

    waterfallChains = BaseChains.extend('waterfall', defaultChains);
    
    var getBindingSeries = function(rawData, dimensions, measures, bindingResults, trellisInfo, options) {
        var series = [];

        var categoryMeta = "categoryAxis";
        var categoryBinds = bindingResults[categoryMeta];
        var i, j;
        
        if (categoryBinds) {
            var seriesBinds = [],
                seriesMeta = [],
                measureBinds = [],
                measureMeta = [];

            var contextMeta = 'context';

            dimensions.filter(function(d){
                return d !== categoryMeta;
            }).forEach(function(d){
                if (bindingResults[d]){
                    seriesBinds.push(bindingResults[d]);
                    seriesMeta.push(d);
                }
            });

            measures.forEach(function(m){
                if (bindingResults[m]){
                    measureBinds.push(bindingResults[m]);
                    measureMeta.push(m);
                }
            });

            var initDp = ChainUtils.dpInitializer(trellisInfo);

            var arrayLength = ChainUtils.getArrayLength(seriesBinds);
            var indexArray = ChainUtils.generateIndexArray(arrayLength);
            options = options || {};
            var key2Type = WaterfallUtils.Key2Type;
            var dp, k, temp;
            for (i = 0; i < indexArray.length; i++) {
                series[i] = new Array(categoryBinds.rowArray.length);
                for (var categoryNum = 0, len = categoryBinds.rowArray.length; categoryNum < len; categoryNum++) {
                    dp = initDp();
                    var isExisted = true;
                    for (j = 0; j < indexArray[i].length; j++) {
                        var tmpSeries = seriesBinds[j].rowArray[indexArray[i][j]];
                        if (tmpSeries.mndIndex) {
                            var mndIndex = tmpSeries.mndIndex;
                            var meta = bindingResults[seriesMeta[j]].metaData;
                            var mndMeta = meta[tmpSeries.indexOf(mndIndex)];
                            if (mndMeta && mndMeta.values) {
                                var metaDataValues = mndMeta.values;
                                for (k = 0; k < metaDataValues.length; k++) {
                                    if (metaDataValues[k].id == mndIndex) {
                                        tmpSeries.mndIndex = k;
                                        break;
                                    }
                                }
                            }
                        }
                        dp[seriesMeta[j]] = tmpSeries;
                    }
                    for (k = 0; k < measureBinds.length; k++) {
                        if (TypeUtils.isExist(measureBinds[k].values) && 
                            measureBinds[k].values[categoryNum] !== undefined) {
                            temp = measureBinds[k].values[categoryNum];
                            for (j = 0; j < indexArray[i].length; j++) {
                                if(temp[indexArray[i][j]] !== undefined){
                                    temp = temp[indexArray[i][j]];
                                }
                            }
                            if (TypeUtils.isArray(temp)) {
                                isExisted = false;
                            } else {
                                dp[measureMeta[k]] = temp;
                            }
                        } else {
                            isExisted = false;
                        }
                    }
                    
                    var dpIsValid = false;
                    for (var key in dp) {
                        if ((key === WaterfallUtils.WATERFALLTYPE && 
                            WaterfallUtils.scale(dp[key], key2Type) > 0) || 
                            (key !== WaterfallUtils.WATERFALLTYPE && 
                            measureMeta.indexOf(key) > -1 && dp[key] !== null)) {
                            dpIsValid = true;
                            break;
                        }    
                    }

                    if (!isExisted || !dpIsValid) {
                        continue;
                    }
                    var context = ChainUtils.processSeriesContext(bindingResults.context, categoryNum, indexArray[i]);
                    if(context) {
                        dp.context = context;
                    }
                    
                    var addition = ChainUtils.processSeriesContext(bindingResults.additionInfo,
                            categoryNum, indexArray[i]);
                    if(addition){
                        dp.addition = addition;
                    }
                    
                    var seriesIndex = ChainUtils.generateNum(arrayLength, indexArray[i]);
                    series[seriesIndex] = series[seriesIndex] || [];
                    series[seriesIndex][categoryNum] = dp;
                }
            }
        }

        bindingResults.series = series.filter(function (e){
            return e;
        });
    };
    
    waterfallChains.waterfallGetBindingSeries = ChainUtils.generateSeriesGetter(getBindingSeries);
    
    
    var sumByCategory = function(array) {
        var results = [], item, i, j, len1, len2;
        var total = 0;
        for (i = 0, len1 = array.length; i < len1; i++) {
            var sum = 0;
            item = array[i];
            if (TypeUtils.isArray(item)) {
                for (j = 0, len2 = item.length; j < len2; j++) {
                    if (TypeUtils.isArray(item[j]) || !TypeUtils.isNumber(item[j])) {
                        continue;
                    }
                    if (sum === 0) {
                        sum = +item[j];
                    } else {
                        sum += +item[j];
                    }
                }
            } else {
                sum = +item;
            }
            results[i] = sum;
        }
        return results;
    };

    var sumByTime= function(array) {
        var results = [], item, i, k, len1;
        var total = 0;
        for (i = 0, k = 0, len1 = array.length; i < len1; i++) {
            var sum = 0;
            item = array[i];
            if (TypeUtils.isArray(item)) {
                for (var t = 0; t < item.length; ++t) {
                    if (!TypeUtils.isNumber(item[t])) {
                        continue;
                    }
                    sum += +item[t];
                }
            } else {
                sum = +item;
            }
            results[k++] = sum;
        }
        return results;
    };
    
    waterfallChains.waterfallGetMeasuresFromFlattable = function(rawData, fields, mnd, bindings, duplicated, 
        bindingName, needSum, parserOption) {
        var result = parserOption && parserOption.isTimeWaterFall ? 
            TYChains.tyGetMeasuresFromFlattable.apply(BaseChains, arguments) :
            BaseChains.GetMeasuresFromFlattable.apply(BaseChains, arguments);
        if (parserOption && parserOption.isTimeWaterFall) {
            result.categorySum = sumByTime(result.values);
        } else {
            result.categorySum = sumByCategory(result.values);
        }
        return result;
    };
    Object.keys(waterfallChains).forEach(function(key) {
        BindingManager.registerChain(key, waterfallChains[key]);
    });
    return waterfallChains;
});
define('sap/viz/chart/views/WaterFallChartView',['sap/viz/framework/common/util/oo',
        'sap/viz/chart/views/XYChartView',
        'sap/viz/chart/components/plotareas/WaterfallPlotArea',
        'sap/viz/chart/components/legend/WaterFallLegend',
        "sap/viz/chart/scales/WaterScaleProcessor",
        "sap/viz/chart/chains/WaterFallChains"
    ],
    function Setup(oo, XYChartView, PlotArea, WaterFallLegend) {

        var WaterFallChartView = function(runtime, options) {
            WaterFallChartView.superclass.constructor.apply(this, arguments);
        };

        oo.extend(WaterFallChartView, XYChartView);

        WaterFallChartView.prototype._getDataItems = function() {
            return ["valueAxis", "categoryAxis", "waterfallType", "series"];
        };
        WaterFallChartView.prototype._getLegendInitOptions = function() {
            return [null];
        };
        WaterFallChartView.prototype._createPlotContainer = function() {
            this._plotArea = new PlotArea(this.runtime(), {
                renderType: this._renderType
            });
            this._plotArea.setRoughSize(this._size);
            this.setChild("main", this._plotArea, {
                priority: 3
            });
        };
        
        WaterFallChartView.prototype._getLegendDefinition = function() {
            return [WaterFallLegend];
        };

        WaterFallChartView.prototype._getLegendInitOptions = function() {
            return [{noFeeding: true}];
        };

        return WaterFallChartView;
    });
define('sap/viz/chart/views/TimeWaterFallChartView',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/views/TimeYChartView",
    "sap/viz/chart/views/WaterFallChartView",
    "sap/viz/chart/behavior/config/TimeLassoBehaviorConfig"
], function Setup(oo, TimeYChartView, WaterFallChartView) {

    var TimeWaterFallChartView = function(runtime, option) {
        TimeWaterFallChartView.superclass.constructor.apply(this, arguments);
    };

    oo.extend(TimeWaterFallChartView, TimeYChartView);

    TimeWaterFallChartView.prototype._getLegendDefinition =  WaterFallChartView.prototype._getLegendDefinition;

    TimeWaterFallChartView.prototype._getLegendInitOptions = function() {
        return [null];
    };

    return TimeWaterFallChartView;
});

define('sap/viz/chart/metadata/bindings/TimeYColumnBindings',[], function Setup() {

    var feeds = [{
        "id": "timeAxis",
        "name": "IDS_TIME_AXIS",
        "type": "Dimension",
        "min": 1,
        "max": 1,
        "acceptMND": false,
        "continuous": true,
        "sort": true,
        "role": "layout.time"
    }, {
        "id": "valueAxis",
        "name": "IDS_VALUE_AXIS",
        "type": "Measure",
        "min": 1,
        "max": Number.POSITIVE_INFINITY,
        "role": "layout.value"
    },{
        "id": "color",
        "name": "IDS_COLOR",
        "type": "Dimension",
        "min": 0,
        "max": Number.POSITIVE_INFINITY,
        "acceptMND": true,
        "role": "mark.color"
    }];

    return feeds;
});
define('sap/viz/chart/metadata/bindings/WaterFallBindings',[], function Setup() {
    var feeds = [{
        "id" : "categoryAxis",
        "name" : "IDS_CATEGORY_AXIS",
        "type" : "Dimension",
        "min" : 1,
        "max" : Number.POSITIVE_INFINITY,
        "acceptMND" : true,
        "role" : "layout.category"
    }, {
        "id" : "waterfallType",
        "name" : "IDS_WATERFALLTYPE",
        "type" : "Dimension",
        "min" : 0,
        "max" : 1,
        "acceptMND" : false,
        "role" : "mark.waterfallType",
        "description": "Not recommend to use together with MND enabled on category axis"
    }, {
        "id" : "valueAxis",
        "name" : "IDS_VALUE_AXIS",
        "type" : "Measure",
        "min" : 1,
        "max" : Number.POSITIVE_INFINITY,
        "role" : "layout.value"
    }];

    return feeds;
});

define('sap/viz/chart/layout/RadarLayout',[
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/framework/common/util/TypeUtils',
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/layout/BaseLayout"
], function Setup(NumberUtils, TypeUtils, oo, BaseLayout) {

    var layoutNameMapping = {
        'height': { max: 'maxHeight',
                    fix: 'height'},
        'width': {  max: 'maxWidth',
                    fix: 'width'}
    };
    var position2SizeField = {
        left: "width",
        right: "width",
        top: "height",
        bottom: "height"
    };
    var position2RefSizeField = {
        left: "height",
        right: "height",
        top: "width",
        bottom: "width"
    };

    var TOPPADDINGINDEX = 0;
    var LEFTPADDINGINDEX = 1;
    var BOTTOMPADDINGINDEX = 2;
    var RIGHTPADDINGINDEX = 3;

    var DEFAULT_MAX_WIDTH = 1 / 3;
    var DEFAULT_MAX_HEIGHT = 1 / 3;


    function RadarLayout(){
        RadarLayout.superclass.constructor.apply(this, arguments);
        this.config.add({
            padding: [0, 0, 0, 0],
            rootWidth: 0,
            rootHeight: 0,
            layoutSequence: []
        });
    }

    oo.extend(RadarLayout, BaseLayout);

    /*
     * items:
     * [{
     *      maxHeight: 1,
     *      maxWidth: 1,
     *      module: null,
     *      padding: [],
     *      position: ''
     * }]
     */
    RadarLayout.prototype.layout = function(components){
        var results = {};
        var config = this.config;
        var i = 0;
        var width = config.get('totalWidth');
        var height = config.get('totalHeight');
        var rootWidth = config.get('rootWidth');
        var rootHeight = config.get('rootHeight');
        var rootSize = {
            width: config.get("rootWidth"),
            height: config.get("rootHeight")
        };
        var padding = config.get('padding');
        var layoutSequence = config.get('layoutSequence');

        var totalWidth = width - (padding[LEFTPADDINGINDEX] + padding[RIGHTPADDINGINDEX]);
        var totalHeight = height - (padding[TOPPADDINGINDEX] + padding[BOTTOMPADDINGINDEX]);
        totalWidth = totalWidth > 0 ? totalWidth : 0;
        totalHeight = totalHeight > 0 ? totalHeight : 0;

        var component;
        var item, o, preferredSize;
        var option;
        var pos;
        var componentsByPosition = {};
        for (var key in components) {
            if (components.hasOwnProperty(key)) {
                component = components[key];
                option = component.option;
                pos = option.position;

                componentsByPosition[pos] = {
                    module: component.module,
                    option: {
                        position: pos,
                        padding: {
                            paddingTop: getFloatValueOrZero(option.paddingTop),
                            paddingBottom: getFloatValueOrZero(option.paddingBottom),
                            paddingLeft: getFloatValueOrZero(option.paddingLeft),
                            paddingRight: getFloatValueOrZero(option.paddingRight)
                        },
                        maxWidth: isValidSize(option.maxWidth) ? option.maxWidth : DEFAULT_MAX_WIDTH,
                        maxHeight: isValidSize(option.maxHeight) ? option.maxHeight : DEFAULT_MAX_HEIGHT,
                        width: isValidSize(option.width) ? option.width : null,
                        height: isValidSize(option.height) ? option.height : null
                    }
                };
            }
        }

        var items = [];
        for(i = 0; i < layoutSequence.length; ++i){
            pos = layoutSequence[i];
            if (TypeUtils.isFunction(pos)) {
                items.push(pos);
                continue;
            }
            component = componentsByPosition[pos];
            if(component){
                items.push(component);
            }
        }
        if (!componentsByPosition.center) {
            throw "Cannot solve layout without plot";
        }

        var total = {
            width: rootWidth ? rootWidth : totalWidth,
            height: rootHeight ? rootHeight : totalHeight
        };
        var availableRegion = {
            width: totalWidth,
            height: totalHeight,
            x: padding[LEFTPADDINGINDEX],
            y: padding[TOPPADDINGINDEX]
        };
        var hasOneModule = {
            center: false
        };
        var length = items.length;
        for (i = 0; i < length; i++) {
            item = items[i];
            if (TypeUtils.isFunction(item)) {
                item(results, availableRegion);
                continue;
            }
            o = {};
            results[item.module.alias] = o;
            option = item.option;
            var module = item.module;
            pos = option.position;
            //pos === 'left' means value axis
            if(pos === 'center' || pos === 'left'){
                continue;
            }
            var measureValueName = position2SizeField[pos];
            var refValueName = position2RefSizeField[pos];
            o.padding = option.padding;
            var modulePadding = {
                width: 0,
                height: 0
            };
            modulePadding.height += o.padding.paddingTop + o.padding.paddingBottom;
            modulePadding.width += o.padding.paddingLeft + o.padding.paddingRight;

            var refSize = {},
                rawFixSizeValue = option[layoutNameMapping[measureValueName].fix],
                fixSizeValue = item.module.properties().visible === true && rawFixSizeValue !== null ?
                                NumberUtils.getSizeValue(rawFixSizeValue, total[measureValueName]) : undefined;

            if (fixSizeValue === undefined){
                if (TypeUtils.isFunction(module.getPreferredSize)) {
                    var sizeValue = NumberUtils.getSizeValue(
                                        option[layoutNameMapping[measureValueName].max],
                                        total[measureValueName]
                                    );
                    sizeValue = sizeValue > availableRegion[measureValueName] ?
                            availableRegion[measureValueName] :
                            sizeValue;
                    refSize[refValueName] = availableRegion[refValueName];
                    refSize[measureValueName] = sizeValue;
                    preferredSize = module.getPreferredSize(refSize)[measureValueName] +
                            modulePadding[measureValueName];
                    sizeValue = preferredSize > sizeValue ? sizeValue : preferredSize;

                    availableRegion[measureValueName] = availableRegion[measureValueName] - sizeValue;
                    o[measureValueName] = sizeValue;
                } else {
                    o[measureValueName] = 0;
                }
            }else{
                fixSizeValue = fixSizeValue > availableRegion[measureValueName] ?
                                    availableRegion[measureValueName] :
                                    fixSizeValue;
                if(TypeUtils.isFunction(module.getPreferredSize)){
                    // Still call getPreferredSize to gain its side effect,
                    // such as deciding whether we need a scroll bar in time axis.
                    refSize[refValueName] = availableRegion[refValueName];
                    refSize[measureValueName] = fixSizeValue;
                    module.getPreferredSize(refSize);
                }

                availableRegion[measureValueName] = availableRegion[measureValueName] - fixSizeValue;
                o[measureValueName] = fixSizeValue;
            }
        }

        for (i = 0; i < length; i++) {

            item = items[i];
            if (!item) {
                continue;
            } else if (TypeUtils.isFunction(item)) {
                item(results, availableRegion);
                continue;
            }
            o = results[item.module.alias];
            if (!o.hasOwnProperty('width')) {
                o.width = availableRegion.width;
            } else if (!o.hasOwnProperty('height')) {
                o.height = availableRegion.height;
            }
            switch (item.option.position) {
                case "top":
                    availableRegion.y = availableRegion.y + o.height;
                    break;
            }
        }

        var valueAxis, radarRadius = 0;
        for (i = 0; i < length; i++) {
            item = items[i];
            if (TypeUtils.isFunction(item)) {
                item(results, availableRegion);
                continue;
            }
            else if(item) {
                option = item.option;
                o = results[item.module.alias];
                switch (option.position) {
                    case "top":
                        o.x = availableRegion.x;
                        o.y = availableRegion.y - o.height;
                        break;
                    case "left":
                        var labelHeight = item.module.getLabelHeight({
                            'width': availableRegion.width,
                            'height': availableRegion.height
                        });
                        valueAxis = item.module;
                        availableRegion.height = availableRegion.height - labelHeight / 2;
                        availableRegion.y = availableRegion.y + labelHeight / 2;
                        break;
                    case "bottom":
                        o.x = availableRegion.x;
                        o.y = availableRegion.y + availableRegion.height;
                        break;
                    case "right":
                        o.x = availableRegion.x + availableRegion.width;
                        o.y = availableRegion.y;
                        break;
                    case "center":
                        o = results[item.module.alias] = {};
                        o.x = availableRegion.x;
                        o.y = availableRegion.y;
                        o.width = availableRegion.width;
                        o.height = availableRegion.height;
                        radarRadius = item.module.calculateRadius({
                            "width": availableRegion.width,
                            "height": availableRegion.height
                        });
                        break;
                }

                if (!TypeUtils.isPlainObject(o.padding)) {
                    o.padding = option.padding;
                }
                if (option.position === 'top') {
                    o.y += o.padding.paddingTop;
                }
                o.height -= o.padding.paddingTop + o.padding.paddingBottom;
                o.width -= o.padding.paddingLeft + o.padding.paddingRight;

                availableRegion.height = availableRegion.height > 0 ? availableRegion.height : 0;
                availableRegion.width = availableRegion.width > 0 ? availableRegion.width : 0;
            }
        }

        o = results[valueAxis.alias];
        preferredSize = valueAxis.getPreferredSize({
            'width': radarRadius,
            'height': radarRadius
        });
        o.height = radarRadius;
        o.width = preferredSize["width"];
        o.y = availableRegion.y + availableRegion.height / 2 - radarRadius;
        o.x = availableRegion.x + availableRegion.width / 2 - preferredSize["bodySize"];

        return results;
    };

    // Utility -----------------------------------------------

    function getFloatValueOrZero(v) {
        var ret = parseFloat(v);
        if (isNaN(ret)) {
            ret = 0;
        }
        return ret;
    }

    function isValidSize(v){

        var value = parseFloat(v);

        return TypeUtils.isNumber(value) && value >= 0;
    }

    return RadarLayout;
});

define('sap/viz/chart/components/container/RadarContainer',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/layout/RadarLayout",
    'sap/viz/chart/components/container/XYContainer'
], function(oo, RadarLayout, XYContainer) {

    var RadarContainer = function(runtime, options) {
        RadarContainer.superclass.constructor.apply(this, arguments);
        this.setLayoutAlgorithm(new RadarLayout());
    };
    oo.extend(RadarContainer, XYContainer);

    //TODO: check if scroll is working for radar chart

    RadarContainer.prototype._renderSub = function() {
        var positions = this._layoutSequence || ['left', 'right', 'bottom', 'top'];
        if (positions.indexOf("center") < 0){
            positions.push("center");
        }
        var selections = this._selections;
        var fn = function(child){
            child.render(selections[child.alias]);
        };
        for(var i=0; i< positions.length; i++){
            this.getChildrenByPosition(positions[i]).forEach(fn);
        }
    };

    RadarContainer.prototype._initRenderBase = function(parentNode) {
        this._selections = {};
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                if (this._selections[key] == null) {
                    if (this._children[key].option.position === "center") {
                        this._selections[key] = parentNode.insert("g", ":first-child").attr('class', 'v-m-' + key);
                    } else {
                        this._selections[key] = parentNode.append("g").attr('class', 'v-m-' + key);
                    }
                }
            }
        }
    };

    return RadarContainer;
});

define('sap/viz/chart/components/axis/sub/RadarValueAxisBody',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/ValueAxisBody",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/components/util/BoundUtil",
    "sap/viz/chart/scales/ValueScaleUtil",
    "sap/viz/chart/components/util/ClippathUtil",
    "sap/viz/framework/common/util/DataGraphics"
], function(
    oo,
    ValueAxisBody,
    Constants,
    BoundUtil,
    ValueScaleUtil,
    ClippathUtil,
    DataGraphics
) {

    var TICK_SIZE = 5;
    var LABEL_OFFSET = 6;

    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;

    var RadarValueAxisBody = function() {
        RadarValueAxisBody.superclass.constructor.apply(this, arguments);
    };
    oo.extend(RadarValueAxisBody, ValueAxisBody);

    RadarValueAxisBody.prototype.getLabelHeight = function() {
        var props = this._properties.get();
        var labelStyle = props.label && props.label.style;
        if (props.visible) {
            var size = this._measureTextSize("100", labelStyle);
            return size.height;
        }
        return 0;
    };

    RadarValueAxisBody.prototype.render = function(selection) {
        var props = this._properties.get();

        var width = this._size.width;
        var height = this._size.height;
        BoundUtil.drawBound(selection, width, height, null, true);
        selection.select("g." + AXIS_CLASS_NAMES.LABEL_GROUP).remove();

        if (this._data && props.visible) {
            var position = this._position;

            var scale = this._data;
            var range = scale.getRange();

            var group = null;

            if (this._isSpaceEnough()) {
                var ticks = this._getTicksToRender();
                var labels = this._getAllLabels(ticks, scale);
                var clippathid;

                if (props.label.visible && labels.length) {
                    var padding = this.getPadding(this._data);
                    var clipPathConfig = {
                        x: 0,
                        y: 0,
                        width: this._size.width,
                        height: this._size.height
                    };
                    var actualSize = this._getWidestLabel(labels) + LABEL_OFFSET + TICK_SIZE;
                    var delta = 0;
                    if (this._isVertical()) {
                        clipPathConfig.y -= padding.start;
                        clipPathConfig.height += padding.start + padding.end;
                        delta = actualSize - clipPathConfig.width;
                        if(this._noReLayout && delta > 0){
                            clipPathConfig.width += delta;
                            clipPathConfig.x -= delta;
                        }
                    } else {
                        clipPathConfig.x -= padding.start;
                        clipPathConfig.width += padding.start + padding.end;
                        delta = actualSize - clipPathConfig.height;
                        if(this._noReLayout && delta > 0){
                            clipPathConfig.height += delta;
                            clipPathConfig.y -= delta;
                        }
                    }
                    clippathid = ClippathUtil.drawClippath(selection, clipPathConfig.width + 2,
                        clipPathConfig.height + 2, clipPathConfig.x - 1, clipPathConfig.y - 1,
                        "labels");
                    group = selection.append("g").attr('clip-path', 'url(#' + clippathid + ')');
                    this._labelGroupNode = group.append("g").attr("class", AXIS_CLASS_NAMES.LABEL_GROUP);
                    this.drawLabels(this._labelGroupNode, scale, labels, width, height, position, props, this
                        ._options, this.runtime().effectManager());
                    var domain = scale.getDomain();
                }
            }
        }
    };

    return RadarValueAxisBody;
});

define('sap/viz/chart/layout/RadarAxisLayout',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/NumberUtils",
    "sap/viz/framework/common/util/PositionUtil",
    "sap/viz/chart/layout/AxisLayout"
], function(oo, Constants, NumberUtils, PositionUtil, AxisLayout) {

    var STACK_DIRECTION_HORIZONTAL = Constants.DIRECTION.HORIZONTAL;
    var STACK_DIRECTION_VERTICAL = Constants.DIRECTION.VERTICAL;
    var SPACING_TO_ROUGH = Constants.AXIS.SPACING_TO_ROUGH;
    var SPACING_MAX_IN_PX = Constants.AXIS.SPACING_MAX_IN_PX;


    var RadarAxisLayout = function() {
        RadarAxisLayout.superclass.constructor.apply(this, arguments);
    };

    oo.extend(RadarAxisLayout, AxisLayout);

    RadarAxisLayout.prototype.getPreferredSize = function(components) {
        var config = this.config;

        var totalWidth = config.get('totalWidth');
        var totalHeight = config.get('totalHeight');
        var axisPosition = config.get('position');
        var sizeFn = config.get('sizeFn');
        var offsetFn = config.get('offsetFn');
        var componentsArray = this._dictToArray(components);
        var rootWidth = config.get('rootWidth');
        var rootHeight = config.get('rootHeight');
        var roughWidth = config.get('roughWidth');
        var roughHeight = config.get('roughHeight');

        var spacings = [];
        var i = 0;
        var size = 0, axisBodySize = 0;
        var componentsPriority = getComponentsPriority(componentsArray, config);
        var length = componentsPriority.length;
        var direction = getDirection(axisPosition);
        var isStackHorizontal = direction === STACK_DIRECTION_HORIZONTAL;
        var majorSizeName = isStackHorizontal ? 'height' : 'width';
        var minorSizeName = isStackHorizontal ? 'width' : 'height';
        var refSize = getRefSize(axisPosition, totalWidth, totalHeight);
        var sizeLimit = PositionUtil.isVertical(axisPosition) ? totalWidth : totalHeight;
        var component, moduleSize, spacing, offset, maxSizeField, minRefSizeField, rootField, roughField;

        roughField = Math.min(roughWidth, roughHeight);
        if (isStackHorizontal) {
            maxSizeField = "maxWidth";
            minRefSizeField = "minHeight";
            rootField = rootWidth;
        } else {
            maxSizeField = "maxHeight";
            minRefSizeField = "minWidth";
            rootField = rootHeight;
        }
        var hideRest = false;
        for (; i < length && !hideRest; ++i) {
            component = componentsPriority[i];
            var rootOffsetInPX = offsetFn(component, rootField);
            var roughOffsetInPX = SPACING_TO_ROUGH * roughField;
            offset = Math.min(rootOffsetInPX, roughOffsetInPX);
            offset = Math.min(offset, SPACING_MAX_IN_PX);
            var componentRefSize = {};
            componentRefSize[minorSizeName] = sizeLimit - size - offset;
            componentRefSize[majorSizeName] = refSize;
            moduleSize = sizeFn(component, componentRefSize);
            if (Math.ceil(moduleSize[minRefSizeField]) <= Math.ceil(refSize) && moduleSize[maxSizeField] &&
                NumberUtils.preciseSimple(size + offset + moduleSize[maxSizeField]) <=
                NumberUtils.preciseSimple(sizeLimit)) {
                size += offset + moduleSize[maxSizeField];
                if (component.option && component.option.axisBody) {
                    axisBodySize = moduleSize[maxSizeField];
                }
            } else if (moduleSize[maxSizeField] !== 0) {
                hideRest = true;
            }

        }
        var width = 0,
            height = 0;
        if (isStackHorizontal) {
            width = size;
            height = refSize;
        } else {
            width = refSize;
            height = size;
        }
        return {
            width: width,
            height: height,
            bodySize: axisBodySize
        };
    };

    function getDirection(position) {
        if (position === Constants.POSITION.TOP || position === Constants.POSITION.BOTTOM) {
            return STACK_DIRECTION_VERTICAL;
        } else {
            return STACK_DIRECTION_HORIZONTAL;
        }
    }

    function getRefSize(position, width, height){
        return PositionUtil.isVertical(position) ? height : width;
    }

    function getComponentsPriority(components, config){
        return components.slice().sort(config.get('sortPriorityFn'));
    }

    return RadarAxisLayout;
});

define('sap/viz/chart/components/axis/RadarValueAxis',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/RadarValueAxisBody",
    "sap/viz/chart/scales/ValueScale",
    "sap/viz/chart/layout/RadarAxisLayout",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/PositionUtil",
    "sap/viz/chart/components/axis/sub/AxisTitle",
    "sap/viz/chart/components/container/UIContainer",
    'sap/viz/chart/components/util/BoundUtil',
    "sap/viz/framework/common/util/NumberUtils",
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/PropertyZoneUtil'
], function(oo, RadarValueAxisBody, ValueScale, RadarAxisLayout, Constants, PositionUtil, AxisTitle, UIContainer,
    BoundUtil, NumberUtils, TypeUtils, PropertyZoneUtil) {

    var DEFAULT_TITLE_TEXT = "Axis Title";

    var RadarValueAxis = function(runtime, options) {
        RadarValueAxis.superclass.constructor.apply(this, arguments);

        var properties = this._properties;
        this._showTitle = properties.get('title.visible');
        this._roughSize = {
            width: 0,
            height: 0
        };
        this._bodyLayersNumber = -1;
        var that = this;

        ['height', 'width'].forEach(function(e){
            var prop = {
                    set: function(value, obj){
                        if(value === null || parseFloat(value)>=0){
                            return value;
                        }else{
                            return obj.value; /**no change*/
                        }
                    }
                },
            fullPathprop = {
                    layout:{}
                };
            fullPathprop.layout[e] = prop;
            properties.add(fullPathprop);
        });

        var axisPropertyZone = {};
        axisPropertyZone[this._name] = {
            value: [],
            readonly: true,
            serializable: false,
            get: function() {
                var result = [], zonenamePrefix, boundRect, boundRect1, bound, bound1, temp, root;
                if (that._properties.get('title.visible') &&
                    that._selections && that._selections["axisTitle"] &&
                    that._selections["axisTitle"].length > 0) {
                    boundRect = that._selections["axisTitle"].node().getBoundingClientRect();
                    if (boundRect.width > 1.5 && boundRect.height > 1.5) {
                        bound = [
                            []
                        ];
                        bound[0].push([boundRect.left, boundRect.top]);
                        bound[0].push([boundRect.right, boundRect.top]);
                        bound[0].push([boundRect.right, boundRect.bottom]);
                        bound[0].push([boundRect.left, boundRect.bottom]);
                        result.push({
                            "name": that._name + ' title',
                            "bound": bound
                        });
                    }
                }
                if (that._parent && that._parent.select(".v-m-axisBody").node()) {
                    //if .v-m-axisBody has covered by clippath, we have to use BoundingClientRect of clippath.
                    var axisBodyVisibleElement = that._parent.select(".v-m-axisBody").node();

                    var axisBodyClipPath = axisBodyVisibleElement.getAttribute('clip-path');
                    if(axisBodyClipPath && axisBodyClipPath.length > 0) {
                        //remove all spaces
                        axisBodyClipPath = axisBodyClipPath.replace(/\s/g, "");

                        //remove prefix
                        var prefixStr = /^url\(/;
                        axisBodyClipPath = axisBodyClipPath.replace(prefixStr, "");

                        //remove suffix
                        axisBodyClipPath = axisBodyClipPath.replace(/\)$/, "");

                        //fix BITSDC1-5040, filter "" because IE will automatically add "" in URL()
                        axisBodyClipPath = axisBodyClipPath.replace(/^\"/, "");
                        axisBodyClipPath = axisBodyClipPath.replace(/\"$/, "");

                        //select clippath
                        axisBodyVisibleElement = that._parent.select(axisBodyClipPath).node();
                    }

                    temp = axisBodyVisibleElement.getBoundingClientRect();

                    // Fix BITSDC4-4467:
                    // Lumira's CEF engine return empty size of clippath, we need to get its rect's dimension.
                    if (axisBodyClipPath && axisBodyClipPath.length > 0) {
                        if (temp.width === 0 && temp.height === 0) {
                            var clipRectNode = axisBodyVisibleElement.querySelector('rect');
                            if (clipRectNode) {
                                temp = clipRectNode.getBoundingClientRect();
                            }
                        }
                    }

                    if (temp.width > 1.5 || temp.height > 1.5) {
                        boundRect1 = {
                            left: temp.left,
                            right: temp.right,
                            top: temp.top,
                            bottom: temp.bottom
                        };

                        bound1 = [[]];
                        bound1[0].push([boundRect1.left, boundRect1.top]);
                        bound1[0].push([boundRect1.right, boundRect1.top]);
                        bound1[0].push([boundRect1.right, boundRect1.bottom]);
                        bound1[0].push([boundRect1.left, boundRect1.bottom]);

                        result.push({
                            "name": that._name,
                            "bound": bound1
                        });
                    }
                    root = that._parent.node().ownerSVGElement;
                }
                PropertyZoneUtil.calcOffsetFromChart(root, result);
                return result;
            }
        };

        runtime.zoneManager().add({
            tempPropertyZone: axisPropertyZone
        });

        this.setLayoutAlgorithm(new RadarAxisLayout());
        this._scale = null;
        this._bindingFields = [];
        if (this._showTitle) {
            this.setChild("axisTitle", new AxisTitle(runtime, options), {
                order: 1,
                priority: 2,
                offset: Constants.AXIS.SPACING_TO_ROOT
            });
        }

        this._position = null;
        this._parent = null;

        this.runtime().graphicModel().registerExposedModule(options.name);

        this.setChild("axisBody", new RadarValueAxisBody(runtime, options), {
            order: 2,
            priority: 1,
            offset: 0,
            axisBody: true
        });
        var autoMin, autoMax, min, max, scaleName, fixedRange;

        scaleName = 'primaryScale';
        autoMin = 'plotArea.' + scaleName + '.autoMinValue';
        autoMax = 'plotArea.' + scaleName + '.autoMaxValue';
        min = 'plotArea.' + scaleName + '.minValue';
        max = 'plotArea.' + scaleName + '.maxValue';
        fixedRange = 'plotArea.' + scaleName + '.fixedRange';

        this._properties.origin.add(autoMin, {
            defaultValue : [],
            readonly : true,
            serializable: false,
            get : function() {
                return (that._scale ? (that._scale.getAutoDomain() ? that._scale.getAutoDomain()[0] :
                    that._scale.getDomain()[0]) : undefined);
            }
        });
        this._properties.origin.add(autoMax, {
            defaultValue : [],
            readonly : true,
            serializable: false,
            get : function() {
                return (that._scale ? (that._scale.getAutoDomain() ? that._scale.getAutoDomain()[1] :
                    that._scale.getDomain()[1]) : undefined);
            }
        });

        this._properties.origin.add(min, {
            defaultValue : [],
            readonly : true,
            serializable: false,
            get : function() {
                if (that._scale && that._scale.getDomainFixed()[0]) {
                    return that._scale.getDomain()[0];
                }
                return null;
            }
        });
        this._properties.origin.add(max, {
            defaultValue : [],
            readonly : true,
            serializable: false,
            get : function() {
                if (that._scale && that._scale.getDomainFixed()[1]) {
                    return that._scale.getDomain()[1];
                }
                return null;
            }
        });
        this._properties.origin.add(fixedRange, {
            defaultValue : [],
            readonly : true,
            serializable: false,
            get : function() {
                if (that._scale && that._scale.getDomainFixed()) {
                    var domainFixed = that._scale.getDomainFixed();
                    var fixedMin = domainFixed[0];
                    var fixedMax = domainFixed[1];
                    if (!fixedMin && !fixedMax) {
                        return false;
                    }
                    return true;
                }
                return false;
            }
        });
    };

    oo.extend(RadarValueAxis, UIContainer);

    RadarValueAxis.prototype.getLabelHeight = function(info) {
        return this.getChild('axisBody').module.getLabelHeight();
    };

    RadarValueAxis.prototype.getMaxZoomRatio = function(){
        var ratio = this._scale.getTickHint();
        if (ratio >= 1){
            return ratio;
        } else {
            return Number.MAX_VALUE;
        }
    };

    RadarValueAxis.prototype.setScale = function(data) {
        if (data.scale) {
            this._scale = new ValueScale(data.scale.getDomain(), [0, 1], data.scale.getDomainFixed());
            this._scale.setAutoDomain(data.scale.getAutoDomain());
            this._scale.setTickHint(data.tickHint);
        }
    };

    RadarValueAxis.prototype.setData = function(data, noReLayout) {
        if (data.metaData) {
            var metaData = data.metaData;
            this._bindingFields = [];
            for (var i = 0, len = metaData.length; i < len; ++i) {

                var bindingField = {
                    id: metaData[i].id,
                    name: metaData[i].name
                };

                // measureNames
                if (metaData[i].values) {
                    var mapping = {};
                    metaData[i].values.forEach(function(item) {
                        mapping[item.id] = item.name;
                    });
                    bindingField.values = mapping;
                }

                this._bindingFields.push(bindingField);
            }
        }
        this._noReLayout = noReLayout;
        this.setScale(data);
    };

    RadarValueAxis.prototype.getPadding = function(scale){
        var axisBody = this.getChild("axisBody");
        if(!axisBody || !scale){
            return {
                start: 0,
                end:0
            };
        }
        return axisBody.module.getPadding(scale);
    };

    RadarValueAxis.prototype._updateData = function(info) {
        if (this._showTitle) {
            this.getChild("axisTitle").module.setData(this._getTitle());
        }
        this._scale.setRange([info.height, 0]);
        // Tell axisBody not to re-layout itself using updated scale
        this.getChild("axisBody").module.setData(this._scale, this._noReLayout);
    };

    RadarValueAxis.prototype._constructTitle = function(header, titleItems) {
        var titleText = header.map(function(o) {
            return o.name || o.id;
        }).join(" & ");

        var itemObj = {};
        itemObj.isHidden = false;
        itemObj.text = titleText;

        titleItems.push(itemObj);
        return titleText;
    };

    RadarValueAxis.prototype.zoom = function (scale){
        if (scale){
            this._realSize.width = this._size.width * scale.x;
            this._realSize.height = this._size.height * scale.y;
            this._updateData(this._getSizeInfo());
        }
        this._updateSubModules();
    };

    RadarValueAxis.prototype.update = function(){
        this._updateData(this._getSizeInfo());
        this._updateSubModules();
    };

    RadarValueAxis.prototype._updateSubModules = function (){
        if (this.getChild("axisBody")){
            this.getChild("axisBody").module.update();
        }
    };

    RadarValueAxis.prototype.setPosition = function(pos) {
        var prop, option;

        this._position = pos;
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var module = this.getChild(key).module;
                module.setPosition(this._position);

                if (key === 'axisTitle'){
                    prop = this.properties();
                    option = this.getChild(key).option;
                    if (prop.visible && PositionUtil.isHorizontal(option.position) ?
                            parseFloat(prop.layout.height) >=0 : parseFloat(prop.layout.width) >= 0){
                        //set type of axis title layout
                        option.offsetType = Constants.AXIS.FIX_LAYOUT_TYPE;
                    }
                }
            }
        }
        return this;
    };

    RadarValueAxis.prototype._getTitle = function() {
        //we cannot just return title text. Axis Title should be an object.
        var titleObj = {};
        titleObj.text = "";
        titleObj.isCustomized = false;
        titleObj.items = [];
        //an item is an obj as {text: "abc", isHidden: false}

        var text = "";

        var titleText = this._properties.get('title.text');

        if (TypeUtils.isString(titleText)) {
            text = titleText;
            titleObj.isCustomized = true;
        } else if (this._bindingFields) {
            //we should build the items of axis title. _constructTitle will change
            //titleObj.items
            text = this._constructTitle(this._bindingFields, titleObj.items);
        } else {
            text = DEFAULT_TITLE_TEXT;
            titleObj.isCustomized = true;
        }

        titleObj.text = text;
        return titleObj;
    };

    RadarValueAxis.prototype.getParent = function() {
        if (this._parent) {
            return this._parent.select("g." + Constants.CSS.CLASS.AXIS.CONTAINER);
        } else {
            return null;
        }
    };

    RadarValueAxis.prototype.render = function(rootElement) {
        this._parent = rootElement;
        RadarValueAxis.superclass.render.apply(this, arguments);
        BoundUtil.drawBound(rootElement, this._size.width, this._size.height, undefined, true);
        var parent = rootElement.select("g." + Constants.CSS.CLASS.AXIS.CONTAINER);
        if (this._size.width > 0 || this._size.height > 0) {
            if (!parent.node()) {
                delete this._selections;
                this._selections = null;
                parent = rootElement.append("g").attr("class", Constants.CSS.CLASS.AXIS.CONTAINER);
            }
            this._initRenderBase(parent);
            this.layout();
            if (this.getChild("axisBody")) {
                var bodyLayersNumber = this.getChild("axisBody").module.getAvailableLayersNumber();
                this._bodyLayersNumber = bodyLayersNumber;
                if (this._showTitle) {
                    this.getChild("axisTitle").module.setTitleHiddenItems(bodyLayersNumber);
                }
            }
            this._renderSub();
        }
        this.appendSynonymClass(rootElement);
        //This is for datapoint hover and selection because it may be covered by valueAxis
        rootElement.node().style.pointerEvents = "none";
    };

    RadarValueAxis.prototype.isVisible = function() {
        return this._bodyLayersNumber > 0;
    };

    RadarValueAxis.prototype.setChild = function(key, module, option) {
        RadarValueAxis.superclass.setChild.apply(this, arguments);
        if (module.setPosition && option.position) {
            module.setPosition(option.position);
        }
    };

    RadarValueAxis.prototype._configLayout = function() {
        this._setupLayout(this._getSizeInfo());
    };

    RadarValueAxis.prototype._setupLayout = function(info) {
        this._updateData(info);
        // this._updateProperties();
        var getPositiveInt = NumberUtils.getPositiveInt;
        var originProp = this._properties.origin;
        var paddingInfo = this.calculatePaddingInPX(originProp, this._roughSize.width, this._roughSize.height);

        var padding = getPositiveInt(paddingInfo.propertyPaddingInPX, paddingInfo.constantPaddingInPX);
        var paddingTop = getPositiveInt(paddingInfo.propertyPaddingTopInPX, padding);
        var paddingRight = getPositiveInt(paddingInfo.propertyPaddingRightInPX, padding);
        var paddingBottom = getPositiveInt(paddingInfo.propertyPaddingBottomInPX, padding);
        var paddingLeft = getPositiveInt(paddingInfo.propertyPaddingLeftInPX, padding);

        var layoutConfig = this._layoutAlgorithm.config;
        layoutConfig.set({
            position: this._position,
            rootWidth: this._roughSize.width - (paddingRight + paddingLeft),
            rootHeight: this._roughSize.height - (paddingTop + paddingBottom),
            roughWidth: this._roughSize.width,
            roughHeight: this._roughSize.height
        });
        if (info.hasOwnProperty('width')) {
            layoutConfig.set('totalWidth', info.width);
        }
        if (info.hasOwnProperty('height')) {
            layoutConfig.set('totalHeight', info.height);
        }
    };

    RadarValueAxis.prototype._configLayout = function() {
        this._setupLayout(this._getSizeInfo());
    };

    RadarValueAxis.prototype._getSizeInfo = function(info) {
        var sizeInfo = {
            width: this._size.width,
            height: this._size.height
        };

        if (info) {
            if (info.width) {
                sizeInfo.width = info.width;
            }
            if (info.height) {
                sizeInfo.height = info.height;
            }
        } else if (this._realSize.width > this._size.width ||
            this._realSize.height > this._size.height) {
            if (this._isHorizontal()) {
                sizeInfo.width = this._realSize.width;
            } else {
                sizeInfo.height = this._realSize.height;
            }
        }
        return sizeInfo;
    };

    RadarValueAxis.prototype._postLayout = function() {
        var results = this._layoutResult;

        var selections = this._selections;
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                var module = this._children[key].module;
                var selection = selections ? selections[key] : null;
                var anchor = results[key];
                module.setSize({
                    width: anchor.width,
                    height: this._size.height
                });
                module.setRealSize({
                    width: anchor.width,
                    height: anchor.height
                });
                if (module.layout) { //force category axis body to layout with new size
                    module.layout();
                }
                if (selection) {
                    selection.attr("transform", "translate(" + anchor.x + "," + anchor.y + ")");
                }
            }
        }
    };

    RadarValueAxis.prototype.getPreferredSize = function(info) {
        this._setupLayout(this._getSizeInfo(info));
        var layoutSize = this._layoutAlgorithm.getPreferredSize(this._children);
        return NumberUtils.preciseObject(layoutSize);
    };

    RadarValueAxis.prototype._renderSub = function() {
        for (var key in this._children) {
            if (this._children.hasOwnProperty(key)) {
                this.getChild(key).module.render(this._selections[key]);
            }
        }
    };

    RadarValueAxis.prototype.appendSynonymClass = function(element, synonym) {
        var synonymClass = 'v-m-yAxis';
        element.classed(synonymClass, true);
    };

    RadarValueAxis.prototype.setRoughSize = function(value) {
        if (value.width != null) {
            this._roughSize.width = value.width;
        }
        if (value.height != null) {
            this._roughSize.height = value.height;
        }
    };

    RadarValueAxis.prototype.destroy = function() {
        RadarValueAxis.superclass.destroy.call(this);
        this._scale = null;
        this._bindingFields = null;
        this._showTitle = null;
        this._parent = null;
        this._position = null;
    };

    RadarValueAxis.prototype.supportFixedLayout = true;

    return RadarValueAxis;
});

define('sap/viz/chart/components/renderers/RadarRenderer',[
    "sap/viz/framework/common/util/SVG"
],function(
    SVG
    ) {
    var RadarRender = function(config) {

        var graphic = config.graphic;

        var path = SVG.create("path");
        var d = buildPath(config.points);
        var colorCfg = getEffectColor(config);
        var opacity = graphic.visible ? graphic.opacity : 0;

        path.setAttribute("d", d);
        path.setAttribute("fill-opacity", opacity);
        path.setAttribute("fill", colorCfg.fill);
        path.style.pointerEvents = "none";
        if(graphic.strokeVisible) {
            path.setAttribute("stroke-width", graphic.strokeWidth);
            path.setAttribute("stroke", colorCfg.color);
            path.setAttribute("stroke-linejoin", "round");
        }
        if(config.filterId) {
            path.setAttribute("filter", 'url(#' + config.filterId  + ')');
        }
        return path;
    };

    RadarRender.update = function(node, config) {};

    function buildPath(data) {
        var d;
        var close;
        for(var i = 0; i < data.length; i ++) {
            if(data[i] && data[i].position) {
                d = d ? d + "L" : "M";
                if(d === "M") {
                    close = "L" + data[i].position.x + "," + data[i].position.y;
                }
                d += data[i].position.x + "," + data[i].position.y;
            }
        }
        d += close;
        return d;
    }

    var getEffectColor = function(config) {
        var colorCfg = {};
        colorCfg.fill = config.effectManager.register({
            drawingEffect: config.graphic.drawingEffect,
            fillColor: config.graphic.fill,
        });
        colorCfg.color = config.effectManager.register({
            drawingEffect: config.graphic.drawingEffect,
            fillColor: config.graphic.color,
        });
        return colorCfg;
    };

    return RadarRender;
});
define('sap/viz/chart/components/util/RadarSeriesUtil',[
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/NameColorUtils',
    'sap/viz/chart/components/renderers/RadarRenderer',
    'sap/viz/framework/common/util/Constants'
], function(
    DataGraphics,
    NameColorUtils,
    RadarRenderer,
    Constants
) {
    var utils = {     
        drawNet: function(seriesG, data, index, effectMgr, context, lineAreaConfig, areaProps, lineProps) {
            //TODO: adapt the customer renderer
            lineAreaConfig.line.color = NameColorUtils.convertColor(lineAreaConfig.line.color);
            lineAreaConfig.area.color = NameColorUtils.convertColor(lineAreaConfig.area.color);
            var visible = lineAreaConfig.area.hasOwnProperty("visible") ?
                            lineAreaConfig.area.visible : areaProps.visible;
            var opacity = lineAreaConfig.area.opacity || areaProps.opacity;
            var config = {
                graphic: {
                    visible : visible,
                    color: lineAreaConfig.line.color,
                    fill: lineAreaConfig.area.color,
                    opacity: opacity,
                    strokeVisible : lineProps.visible,
                    strokeWidth : lineProps.width
                },
                points: data,
                effectManager: effectMgr,
                ctx: context
            };

            var netG = RadarRenderer(config);
            netG.setAttribute("class", Constants.CSS.CLASS.RADAR_NET);
            DataGraphics.setData(netG, {
                "seriesIndex": index,
                "color" : config.graphic.color,
                // there may be null/undefined elements in data, not count them
                "pointSum": data.filter(function (e) { return Boolean(e); }).length,
                "fill" : config.graphic.fill,
                "visibility": visible ? "visible" : "hidden",
                "opacity": opacity
            });
            DataGraphics.setContext(netG, context);
            seriesG.insertBefore(netG, seriesG.firstChild);
        }
    };
    return utils;
});

define('sap/viz/chart/components/datalabels/RadarDataLabels',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/datalabels/DataLabels',
    'sap/viz/chart/components/util/DataPointUtils',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ObjectUtils'
], function(oo, DataLabels, DataPointUtils, DataGraphics, Constants, ObjectUtils) {

    //1, 2, 3, 4 means the first, second, third, fourth quadrant
    var labelPosition = [
        [1, 4, 3, 2],
        [2, 3, 4, 1],
        [3, 2, 1, 4],
        [4, 1, 2, 3]
    ];
    var tryTimes = 4;

    var RadarDataLabels = function(runtime, options) {
        RadarDataLabels.superclass.constructor.apply(this, arguments);
        this._labelsPool = [];
    };

    oo.extend(RadarDataLabels, DataLabels);

    RadarDataLabels.prototype.render = function(selection) {
        if (this._isTrellis) {
            this._bound = {
                left: this._trellisPadding.left,
                right: this._realSize.width - this._trellisPadding.right,
                top: this._trellisPadding.top,
                bottom: this._realSize.height - this._trellisPadding.bottom,
            };
        } else {
            this._bound = {
                left: 0,
                right: this._realSize.width,
                top: 0,
                bottom: this._realSize.height
            };
        }
        RadarDataLabels.superclass.render.apply(this, arguments);
    };

    RadarDataLabels.prototype._render = function(selection, dataPoints) {
        //init the labels pool before render
        this._labelsPool = ObjectUtils.extend(true, [],
            this._runtime.statusManager().get("polarAxisLabelRenderInfo"));
        RadarDataLabels.superclass._render.apply(this, arguments);
    };

    RadarDataLabels.prototype.setCenter = function(center) {
        if (center === undefined) {
            return;
        }
        this._center = center;
    };

    RadarDataLabels.prototype._computeDataLabelPosition = function(nodeX, nodeY, labelPosition, shapeBBox, labelBBox) {
        var x, y;
        switch(labelPosition) {
            case 1 :
                x = nodeX - labelBBox.width + shapeBBox.x;
                y = nodeY + shapeBBox.y;
                break;
            case 2 :
                x = nodeX - shapeBBox.x;
                y = nodeY + shapeBBox.y;
                break;
            case 3 :
                x = nodeX - shapeBBox.x;
                y = nodeY + labelBBox.height;
                break;
            case 4 :
                x = nodeX - labelBBox.width + shapeBBox.x;
                y = nodeY + labelBBox.height;
                break;
        }
        var pos = {
            x : x,
            y : y,
            width : labelBBox.width,
            height : labelBBox.height
        };
        if(this._overlap(pos) || this._outPlot(pos)) {
            pos.overlap = true;
        }
        return pos;
    };

    RadarDataLabels.prototype._overlap = function(pos) {
        //TODO : enhance the performance
        function comparePosition(p1, p2) {
            //http://jsfiddle.net/98sAG/
            //judge whether two rectangles overlap
            var x1 = p1.x < p2.x ? p1 : p2;
            var x2 = p1.x < p2.x ? p2 : p1;
            var y1 = p1.y - p1.height < p2.y - p2.height ? p1 : p2;
            var y2 = p1.y - p1.height < p2.y - p2.height ? p2 : p1;
            return (x1.x + x1.width > x2.x || x1.x === x2.x) &&
                (y1.y > y2.y - y2.height || y1.y - y1.height === y2.y - y2.height);
        }
        function decreaseDetectionArea(p) {
            //as UX design
            var result = {
                x : p.x,
                y : p.y - 1,
                height : p.height - 2,
                width : p.width
            };
            return result;
        }
        var result;
        for (var i = 0; i < this._labelsPool.length; i ++) {
            result = comparePosition(decreaseDetectionArea(pos), decreaseDetectionArea(this._labelsPool[i]));
            if (result) {
                return true;
            }
        }
        return false;
    };

    RadarDataLabels.prototype._outPlot = function(pos) {
        if(pos.x > this._bound.left && pos.x + pos.width < this._bound.right &&
            pos.y - pos.height >this._bound.top && pos.y < this._bound.bottom) {
            return false;
        }
        return true;
    };

    RadarDataLabels.prototype._computeDataLabelTranslate = function(node, ctm,
        labelPosition, labelBBox, config) {
        var hideWhenOverlap = this._properties.get("hideWhenOverlap");
        var shapeBBox = this._fixBBoxWhenInvisible(node, config && config.dpBBox);
        var nodeX = ctm.e;
        var nodeY = ctm.f;
        var position = this._judgeQuadrant(nodeX, nodeY);
        var labelTranslate;
        for (var i = 0; i < tryTimes; i ++) {
            labelPosition = this._getLabelPosition(position, i);
            labelTranslate = this._computeDataLabelPosition(nodeX, nodeY, labelPosition, shapeBBox, labelBBox);
            if (!labelTranslate.overlap || (i === tryTimes - 1 && !hideWhenOverlap)) {
                //if hideWhenOverlap is false, always show data label
                this._labelsPool.push(labelTranslate);
                var locationArray = [labelTranslate.x, labelTranslate.y];
                this._forceInner(locationArray, labelBBox);
                return locationArray;
            }
        }
        return;
    };

    RadarDataLabels.prototype._getLabelPosition = function(position, index) {
        return labelPosition[position][index];
    };

    RadarDataLabels.prototype._judgeQuadrant = function(nodeX, nodeY) {
        //the quadrant number - 1 to get the priority queue from labelPosition
        //solve the accuracy doesn't match problem
        var x = Math.floor(this._center.x);
        var y = Math.floor(this._center.y);
        nodeX = Math.floor(nodeX);
        nodeY = Math.floor(nodeY);
        if (nodeX < x && nodeY <= y) {
            return 0;
        } else if (nodeX >= x && nodeY <= y) {
            return 1;
        } else if (nodeX >= x && nodeY > y) {
            return 2;
        } else if (nodeX < x && nodeY > y) {
            return 3;
        }
    };

    RadarDataLabels.prototype.destroy = function() {
        DataLabels.superclass.destroy.call(this);
        this._center = null;
        this._labelsPool = null;
        this._size = null;
        this._bound = null;
    };

    return RadarDataLabels;
});

define('sap/viz/chart/components/axis/sub/PolarAxisTitle',[
    "sap/viz/framework/common/util/Constants",
    "sap/viz/framework/common/util/oo",
    "sap/viz/chart/components/axis/sub/AxisTitle",
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/framework/common/lang/LangManager",
    "sap/viz/chart/components/util/TextUtils",
    "sap/viz/framework/common/util/NameColorUtils",
    "sap/viz/chart/components/util/StyleUtils",
    'sap/viz/framework/common/util/PropertyZoneUtil',
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/common/util/NumberUtils"
], function(Constants, oo, AxisTitle, TypeUtils, LangManager, TextUtils, NameColorUtils,
    StyleUtils, PropertyZoneUtil, DataGraphics, NumberUtils) {

    var DEFAULT_TITLE_TEXT = "Axis Title";
    var MEASURE_NAMES = "measureNames";
    var AXIS_CLASS_NAMES = Constants.CSS.CLASS.AXIS;

    var PolarAxisTitle = function(runtime, options) {
        PolarAxisTitle.superclass.constructor.apply(this, arguments);
        var that = this;
        if (!options.inTrellis) {
            var axisPropertyZone = {};
            axisPropertyZone[this._name] = {
                value: [],
                readonly: true,
                serializable: false,
                get: function() {
                    var result = [],
                        zonenamePrefix, boundRect, boundRect1, bound, bound1, temp, root;
                    if (that._properties.get('polarAxis.title.visible') && that._selection) {
                        boundRect = that._selection.node().getBoundingClientRect();
                        if (boundRect.width > 1.5 && boundRect.height > 1.5) {
                            bound = [
                                []
                            ];
                            bound[0].push([boundRect.left, boundRect.top]);
                            bound[0].push([boundRect.right, boundRect.top]);
                            bound[0].push([boundRect.right, boundRect.bottom]);
                            bound[0].push([boundRect.left, boundRect.bottom]);
                            result.push({
                                "name": that._name + ' title',
                                "bound": bound
                            });
                        }
                    }
                    PropertyZoneUtil.calcOffsetFromChart(root, result);
                    return result;
                }
            };

            runtime.zoneManager().add({
                tempPropertyZone: axisPropertyZone
            });
        }
    };
    oo.extend(PolarAxisTitle, AxisTitle);

    PolarAxisTitle.prototype.setData = function(data) {
        if (data.metaData) {
            var metaData = data.metaData;
            this._bindingFields = [];
            for (var i = 0, len = metaData.length; i < len; ++i) {

                var bindingField = {
                    id: metaData[i].id,
                    name: metaData[i].name
                };

                // measureNames
                if (metaData[i].values) {
                    var mapping = {};
                    metaData[i].values.forEach(function(item) {
                        mapping[item.id] = item.name;
                    });
                    bindingField.values = mapping;
                }

                this._bindingFields.push(bindingField);
            }
        }
        PolarAxisTitle.superclass.setData.apply(this, [this._getTitle()]);
    };

    PolarAxisTitle.prototype.setTitleHiddenItems = function() {
        this.visibleItemsNumber = this._bindingFields.length;
    };

    PolarAxisTitle.prototype._getTitle = function() {
        //we cannot just return title text. Axis Title should be an object.
        var titleObj = {};
        titleObj.text = "";
        titleObj.isCustomized = false;
        titleObj.items = [];
        //an item is an obj as {text: "abc", isHidden: false}

        var text = "";

        var titleText = this._properties.get('title.text');

        if (TypeUtils.isString(titleText)) {
            text = titleText;
            titleObj.isCustomized = true;
        } else if (this._bindingFields) {
            //we should build the items of axis title. _constructTitle will change
            //titleObj.items
            text = this._constructTitle(this._bindingFields, titleObj.items);
        } else {
            text = DEFAULT_TITLE_TEXT;
            titleObj.isCustomized = true;
        }

        titleObj.text = text;
        return titleObj;
    };

    PolarAxisTitle.prototype._constructTitle = function(header, titleItems) {
        var toDraw = header.map(function(o) {
            var title =  o.name || o.id;
            if(title === MEASURE_NAMES){
                title = LangManager.get("IDS_DEFAULTMND");
            }

            return title;
        });

        titleItems.splice(0, titleItems.length);
        var allText = "";
        var itemText = "";

        for (var i = 0; i < toDraw.length; i++) {
            if (i === 0) {
                itemText = toDraw[i];
            } else {
                itemText = " / " + toDraw[i];
            }

            allText += itemText;

            var itemObj = {};
            itemObj.isHidden = false;
            itemObj.text = itemText;
            //an item is an obj as {text: "abc", isHidden: false}
            titleItems.push(itemObj);
        }
        return allText;
    };

    PolarAxisTitle.prototype.render = function(selection) {
        this._selection = selection;
        PolarAxisTitle.superclass.render.apply(this, arguments);
    };

    PolarAxisTitle.prototype.destroy = function() {
        this._runtime.zoneManager().remove("tempPropertyZone." + this._name);
        PolarAxisTitle.superclass.destroy.call(this);
    };

    return PolarAxisTitle;

});

define('sap/viz/chart/components/plots/RadarPlot',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/common/util/ObjectUtils',
    'sap/viz/chart/components/util/DrawUtil',
    'sap/viz/framework/common/util/SVG',
    'sap/viz/chart/components/plots/BaseColumnPlot',
    'sap/viz/chart/components/plots/ItemScaleHandler',
    'sap/viz/chart/components/plots/ScaleHandler',
    'sap/viz/chart/components/renderers/SeriesRenderer',
    'sap/viz/chart/components/renderers/PathRenderer',
    'sap/viz/framework/chartmodel/ContextBuilder',
    'sap/viz/chart/components/util/RadarSeriesUtil',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/DataGraphics',
    'sap/viz/chart/components/renderers/GridlineRenderer',
    'sap/viz/framework/common/util/DataUtils',
    'sap/viz/chart/components/util/TextUtils',
    'sap/viz/chart/components/util/StyleUtils',
    'sap/viz/chart/components/util/BuildLayerUtil',
    'sap/viz/chart/components/datalabels/RadarDataLabels',
    'sap/viz/chart/components/axis/sub/PolarAxisTitle',
    'sap/viz/chart/components/util/AxisBodyUtil',
    'sap/viz/chart/components/plots/BaseLinePlot',
    "sap/viz/chart/components/accessibility/ChartComponentNavigatorFactory",
    "sap/viz/chart/components/accessibility/LineDataPointNavigator",
    "sap/viz/chart/components/util/ChartConstants",
], function Setup(oo,
        ObjectUtils,
        DrawUtil,
        SVG,
        BaseColumnPlot,
        ItemScaleHandler,
        ScaleHandler,
        SeriesRenderer,
        PathRenderer,
        ContextBuilder,
        SeriesUtil,
        Constants,
        DataGraphics,
        GridlineRenderer,
        DataUtils,
        TextUtils,
        StyleUtils,
        BuildLayerUtil,
        RadarDataLabels,
        PolarAxisTitle,
        AxisBodyUtil,
        BaseLinePlot,
        ChartNavigator,
        DataPointNavigator,
        ChartConstants) {

    var gap = 5;
    //if the radius is smaller than minRadius, the polar axis label won't be shown
    var minRadius = 50;
    var threshold = gap + minRadius;
    var topOffset = 7;
    var thresholdForTitle = 2 * (gap + minRadius) + topOffset;

    var RadarPlot = function(runtime, options) {
        RadarPlot.superclass.constructor.apply(this, arguments);
        this._dataPointRenderer = PathRenderer;
        this._markerPropName = "marker";
        this._markerD = null;
        this._branchAngles = [];
        this._center = null;
        this._radius = null;
        this._branchTitileSize = null;
        this._resetLabelCache();
        if (this._properties.get("polarAxis.title.visible")) {
            this._axisTitle = new PolarAxisTitle(runtime, {
                "name": "plotArea.polarAxis",
                "inTrellis": options.inTrellis
            });
        }
        this.runtime().markManager().setMode("dual");
        this.runtime().markManager().lock();
        this._attachMarkRestrict();

        var semanticMgr = this.runtime().semanticManager();
        semanticMgr.setUseSemanticPattern(true);
        semanticMgr.bindSeriesStyleProperty(this._name + ".seriesStyle");
    };

    oo.extend(RadarPlot, BaseColumnPlot);

    RadarPlot.prototype._attachMarkRestrict = function() {
        var shape = this._getMarkerShape();
        var markMgr = this.runtime().markManager();
        markMgr.setShape([shape], shape);
    };
    RadarPlot.prototype._renderNode =  BaseLinePlot.prototype._renderNode;

    RadarPlot.prototype.destroy = function() {
        RadarPlot.superclass.destroy.call(this);
        this._dataPointRenderer = null;
        this._markerD = null;
        this._branchAngles = null;
        this._center = null;
        this._radius = null;
        this._branchLabels = null;
        this._branchLabelHeight = null;
        this._branchLabelWidth = null;
        this._truncatedBranchLabels = null;
        this._hideBranchLabels = null;
        this._labelContext = null;
        this._branchTitileSize = null;
        this._polarAxisLabelRenderInfo = null;
        if (this._axisTitle) {
            this._axisTitle.destroy();
            this._axisTitle = null;
        }
    };

    RadarPlot.prototype._getDataLabels = function(name, runtime) {
        return new RadarDataLabels(runtime, {
            name: name
        });
    };

    RadarPlot.prototype._resetLabelCache = function() {
        //TODO: reuse these cache if they can in calculateBranchLabels
        this._branchLabels = [];
        this._branchLabelHeight = [];
        this._branchLabelWidth = [];
        this._truncatedBranchLabels = [];
        this._hideBranchLabels = [];
        this._labelContext = [];
    };

    RadarPlot.prototype._getValueScaleHandlers = function(isHorizontal) {
        return [ScaleHandler.getPerfectValueScaleHandler("valueAxis", {
            isHorizontal: isHorizontal
        })];
    };

    RadarPlot.prototype._getCategoryScaleHandlers = function(isHorizontal) {
        this._categoryScaleHandler = ScaleHandler.getPolarScaleHandler("categoryAxis", {
            isHorizontal: isHorizontal,
            itemScaleHandler: ItemScaleHandler.get(false)
        });
        return [this._categoryScaleHandler];
    };

    RadarPlot.prototype._buildData = function(dpConfig) {
        return {
            color: dpConfig.graphic.fill,
            trellisInfo: dpConfig.trellisInfo
        };
    };

    RadarPlot.prototype._buildWrapperConfig = function(data, position, context) {
        var config = RadarPlot.superclass._buildWrapperConfig.apply(this, arguments);
        //add trellis infomation to data point for selection highlight
        var info;
        if(data.trellisColumn) {
            info = info || "";
            data.trellisColumn.forEach(function (e) {
                info += DataUtils.getDimensionValue(e) + ".";
            });
        }
        if(data.trellisRow) {
            info = info || "";
            data.trellisRow.forEach(function (e) {
                info += DataUtils.getDimensionValue(e) + ".";
            });
        }
        config.trellisInfo = info;
        return config;
    };

    RadarPlot.prototype.calculateRadius = function(size) {
        var seriesCount = this._data.trellisSeriesLength ? this._data.trellisSeriesLength : this._data.series.length;
        this._initXHandler(this._xHandlers, this._data, 0, seriesCount);
        var sum = this._xHandlers[0].categorySum();
        for(var i = 0; i < sum; i ++) {
            var xResult = this._getXPosition(0, i, 0);
            //save angles for branches
            this._branchAngles[i] = xResult[0];
        }
        this._center = {
            x : size.width / 2,
            y : size.height / 2
        };
        this._radius = size.width > size.height ? size.height / 2 : size.width / 2;
        var polarAxisLabelProps = this._properties.get("polarAxis.label");
        this._branchLabelStyle = polarAxisLabelProps.style;
        if(polarAxisLabelProps.visible && this._radius > threshold) {
            this._calculateBranchLabels(size);
        }
        return this._radius;
    };

    RadarPlot.prototype._applyChanges = function() {
        this._resetLabelCache();
        if (this._axisTitle) {
            var preferredSize = this._axisTitle.getPreferredSize(this._realSize);
            this._branchTitileSize = {
                "width": preferredSize.maxWidth > this._realSize.width ?
                    this._realSize.width : preferredSize.maxWidth + 1, // add 1px for IE to aviod useless truncation
                "height": preferredSize.maxHeight > this._realSize.height ?
                    this._realSize.height : preferredSize.maxHeight
            };
        }
        var size = {
            "width": this._realSize.width,
            "height": this._realSize.height
        };
        if (this._branchTitileSize) {
            var height = this._realSize.height - this._branchTitileSize.height;
            if (height < thresholdForTitle) {
                height = this._realSize.height;
                this._branchTitileSize.height = 0;
                this._branchTitileSize.width = 0;
            }
            size.height = height;
        }

        this.calculateRadius(size);
        var seriesCount = this._data.trellisSeriesLength ? this._data.trellisSeriesLength : this._data.series.length;
        this._initYHandler(this._yHandlers, this._data, this._radius, seriesCount);
    };

    RadarPlot.prototype._calculateBranchLabels = function(size) {
        //get PolarAxis labels
        var bindingFieldIds = [];
        this._data.categoryAxis.metaData.forEach(function(e) {
            bindingFieldIds.push(e.id);
        });
        this._bindingFields = AxisBodyUtil.getBindingFields(this._data.categoryAxis.metaData) || this._bindingFields;
        var rawLayers = BuildLayerUtil.mergeLabels(this, this._data.categoryAxis.scale.getDomain(), bindingFieldIds);
        //the first layer includes all the label texts
        //the label elements can be controlled by different layer
        this.buildLabelsText(rawLayers[0].cells, "");
        //as UX design
        this._center = {
            x : size.width / 2,
            y : size.height / 2 + topOffset / 2
        };
        var labelHeight, maxRadius;
        var maxWidth = size.width / 2, maxHeight = size.height / 2 - topOffset / 2;
        var radius = maxWidth >maxHeight? maxHeight : maxWidth;
        for(var i = 0; i < this._branchAngles.length; i ++) {
            var labelSize = TextUtils.fastMeasure(this._branchLabels[i], this._branchLabelStyle.fontSize,
                this._branchLabelStyle.fontWeight, this._branchLabelStyle.fontFamily);
            //get width and height for layout internal component of plot
            labelHeight = labelHeight >= labelSize.height ? labelHeight : labelSize.height;
            this._branchLabelHeight.push(labelSize.height);
            this._branchLabelWidth.push(labelSize.width);
            var sin = Math.abs(Math.sin(this._branchAngles[i]));
            var cos = Math.abs(Math.cos(this._branchAngles[i]));
            if (sin) {
                maxRadius = (maxWidth - labelSize.width) / sin;
                radius = radius < maxRadius ? radius : maxRadius;
            }
            if (cos) {
                maxRadius = (maxHeight - labelSize.height) / cos;
                radius = radius < maxRadius ? radius : maxRadius;
            }
            if (radius < threshold) {
                //this label will be truncated
                radius = threshold;
                var minWidth = maxWidth - threshold * sin;
                if(minWidth < this._branchLabelWidth[i]) {
                    this._branchLabelWidth[i] = minWidth;
                    this._truncatedBranchLabels[i] = true;
                } else {
                    this._hideBranchLabels[i] = true;
                }
            }
        }
        this._radius = radius - gap;
    };

    RadarPlot.prototype._getPosition = function(seriesIndex, itemIndex, data) {
        var xResult = this._getXPosition(seriesIndex, itemIndex, data);
        var yResult = this._getYPosition(seriesIndex, itemIndex, data);
        if(isNaN(xResult[0]) || isNaN(xResult[1]) || isNaN(yResult[0]) || isNaN(yResult[1])){
            return null;
        }
        return {
            angle : xResult[0],
            distance : this._radius - yResult[0]
        };
    };


    RadarPlot.prototype._convertPosition = function (position) {
        var offsetX = position.distance * Math.sin(position.angle);
        var offsetY = position.distance * Math.cos(position.angle);
        position.x = this._center.x - offsetX;
        position.y = this._center.y - offsetY;
        return position;
    };

    RadarPlot.prototype._buildConfig = function(data, position, context, effectManager) {
        var color = this._getColor(data);
        this._convertPosition(position);
        var opacity = this._isMarkerVisible ? 1 : 0;
        return {
            graphic: {
                width: 0,
                height: position.distance,
                drawingEffect: this._properties.get('drawingEffect'),
                fill: color,
                opacity: opacity,
                d : this._markerD
            },
            data: {
                color: color,
                width: 0,
                height: position.distance,
                translate: [position.x, position.y]
            },
            ctx: context,
            effectManager: effectManager || this._effectManager
        };
    };

    RadarPlot.prototype._preRender = function() {
        RadarPlot.superclass._preRender.apply(this, arguments);
        this._isMarkerVisible = this._properties.get("marker.visible");
        this._generateMarkerPath();
    };

    RadarPlot.prototype._getSeriesRenderer = function() {
        return new SeriesRenderer(this._drawNet.bind(this), this._updateNet.bind(this));
    };

    RadarPlot.prototype._updateNet = function() {};

    RadarPlot.prototype._drawNet = function(seriesG, data, seriesIndex) {
        var areaProps = this._properties.get("area"),
            lineProps = this._properties.get("line"),
            effectMgr = this.runtime().effectManager(),
            context = ContextBuilder.buildSeriesContext(this._data, seriesIndex,
                ["color", "color2", "trellisColumn", "trellisRow"]);
        SeriesUtil.drawNet(seriesG, data, seriesIndex, effectMgr,
            context, this._getlineAreaConfig(this._data, seriesIndex, context), areaProps, lineProps);
    };

    RadarPlot.prototype._getlineAreaConfig = function(data, seriesIndex, context) {
        var semanticMgr = this._semanticMgr;
        var config =  {line: {}, area: {}};
        var semanticProps = semanticMgr.analyzeSeriesStyle(context, "line");
        if (semanticProps && semanticProps.line && semanticProps.line.color) {
            config.line.color = semanticProps.line.color;
        } else if (
            (semanticMgr.hasDataPointColorStyle() || semanticMgr.hasDataPointLineStyle()) &&
            semanticMgr.isOverrideMode() && semanticMgr.shouldChangeColor()) {
            config.line.color = semanticMgr.getOthersStyle("color").properties.color;
        } else {
            var seriesInfo = ContextBuilder.getSeriesScaleInfo(data, seriesIndex, ["color"]);
            if (seriesInfo){
                config.line.color = data[seriesInfo.field].scale.scale(seriesInfo.domain);
            } else {
                config.line.color = data.color.scale.getRange()[0];
            }
        }
        config.area.color = config.line.color;
        semanticProps = semanticMgr.analyzeSeriesStyle(context, "area");
        if (semanticProps && semanticProps.area) {
            var areaProp = semanticProps.area;
            if (areaProp.hasOwnProperty("color")) {
                config.area.color = areaProp.color;
            }
            if (areaProp.hasOwnProperty("opacity")) {
                config.area.opacity = areaProp.opacity;
            }
            if (areaProp.hasOwnProperty("visible")) {
                config.area.visible = areaProp.visible;
            }
        }
        return config;
    };

    RadarPlot.prototype._drawBranchLabels = function() {
        //TODO: adapt branch label renderer to customer render
        this._polarAxisLabelRenderInfo = [];
        var labelGroup = SVG.create("g");
        labelGroup.setAttribute("class", Constants.CSS.CLASS.AXIS.CONTAINER);
        var distance = this._radius + gap;
        var minHeight = Number(this._branchLabelStyle.fontSize.match(/\d+/));
        for (var i = 0; i < this._branchAngles.length; i ++) {
            if(this._hideBranchLabels[i] || !this._branchLabelWidth[i]) {
                continue;
            }
            var angle = this._branchAngles[i];
            var offset = this._convertPosition({
                angle : angle,
                distance : distance
            });
            if (angle === 0) {
                offset.x -= this._branchLabelWidth[i] / 2;
                offset.y -= this._branchLabelHeight[i] / 2 + topOffset;
            } else if (angle === Math.PI) {
                offset.x -= this._branchLabelWidth[i] / 2;
            } else if (angle > 0 && angle < Math.PI) {
                offset.x -= this._branchLabelWidth[i];
            }
            offset.y += this._branchLabelHeight[i] / 2;
            var axisItem = SVG.create("g");
            axisItem.setAttribute("class", Constants.CSS.CLASS.AXIS.LABEL_SELECTION);
            if(this._trellisContext !== undefined) {
            //save trellis context info for polar axis item
                ObjectUtils.extend(true, this._labelContext[i], this._trellisContext);
            }
            DataGraphics.setContext(axisItem, this._labelContext[i]);
            var text = SVG.create("text");
            var rect = SVG.create("rect");
            text.setAttribute("class", Constants.CSS.CLASS.RADAR_BRANCH_LABEL);
            text.setAttribute("x", offset.x);
            text.setAttribute("y", offset.y);
            text.setAttribute("font-size", this._branchLabelStyle.fontSize);
            text.setAttribute("font-weight", this._branchLabelStyle.fontWeight);
            text.setAttribute("font-family", this._branchLabelStyle.fontFamily);
            text.setAttribute("font-style", this._branchLabelStyle.fontStyle);
            text.setAttribute("fill", this._branchLabelStyle.color);

            var textAnchor = null;
            var envManager = this.runtime().envManager();
            if (envManager) {
                textAnchor = envManager.textAnchor();
            }

            var ellipsisOptions = {};
            ellipsisOptions.reverseDots = (envManager && envManager.reverseDots());

            text.setAttribute("text-anchor", textAnchor);

            var labelFont = StyleUtils.convertToCss(this._branchLabelStyle);
            if(this._truncatedBranchLabels[i]) {
                TextUtils.ellipsis(this._branchLabels[i], text, this._branchLabelWidth[i], labelFont, ellipsisOptions);
            } else {
                text.textContent = this._branchLabels[i];
            }
            rect.setAttribute("fill", "transparent");
            rect.setAttribute("x", offset.x);
            rect.setAttribute("y", offset.y - this._branchLabelHeight[i] + 1);
            rect.setAttribute("height", this._branchLabelHeight[i]);
            rect.setAttribute("width", this._branchLabelWidth[i]);
            rect.setAttribute("class", Constants.CSS.CLASS.AXIS.BACKGROUND_RECT);
            this._polarAxisLabelRenderInfo.push({
                x : offset.x,
                y : offset.y,
                height : this._branchLabelHeight[i],
                width : this._branchLabelWidth[i]
            });
            axisItem.appendChild(rect);
            axisItem.appendChild(text);
            labelGroup.appendChild(axisItem);
        }
        this._dataLabels.setSize(this._realSize);
        return labelGroup;
    };

    RadarPlot.prototype.renderBranches = function(parent) {
        var props = this._properties.get("polarAxis");
        if (props.visible === false) {
            return;
        }
        var sum = this._xHandlers[0].categorySum();
        var branchGroup = SVG.create("g");
        branchGroup.setAttribute("class", Constants.CSS.CLASS.RADAR_BRANCH_GROUP);
        var lineGroup = SVG.create("g");
        lineGroup.setAttribute("class", Constants.CSS.CLASS.RADAR_BRANCH_AXIS_GROUP);
        if (props.axisLine.visible) {
            for(var i = 0; i < sum; i ++) {
                var line = SVG.create("line");
                line.setAttribute("class", Constants.CSS.CLASS.RADAR_BRANCH_AXIS);
                line.setAttribute("stroke", props.color);
                line.setAttribute("stroke-width", props.axisLine.size);
                var end = this._convertPosition({
                    angle : this._branchAngles[i],
                    distance : this._radius
                });
                line.setAttribute("x1", this._center.x);
                line.setAttribute("y1", this._center.y);
                line.setAttribute("x2", end.x);
                line.setAttribute("y2", end.y);
                lineGroup.appendChild(line);
            }
            branchGroup.appendChild(lineGroup);
        }
        if(props.label.visible && this._radius >= minRadius) {
            var labelGroup = this._drawBranchLabels();
            branchGroup.appendChild(labelGroup);
        }
        if (parent.node().childNodes[0]) {
            parent.node().insertBefore(branchGroup, parent.node().childNodes[0]);
        } else {
            parent.node().appendChild(branchGroup);
        }
        var polarAxisLabelRenderInfo = this._polarAxisLabelRenderInfo;
        this._runtime.statusManager().add({
            'polarAxisLabelRenderInfo' : {
                get : function() {
                    return polarAxisLabelRenderInfo;
                }
            }
        });
    };

    RadarPlot.prototype._updateNegativeDatapoint = function(dpConfig, dataPoint) {};

    RadarPlot.prototype._drawGridlines = function(parent) {
        var props = this._properties.get('gridline');
        var range = [0, this._radius];
        var scale = this._gridlineScale = this._getGridLineScale(range);
        GridlineRenderer.drawRadarGridLine(parent, this._center, this._branchAngles, scale, props);
        this.renderBranches(parent);
        this._dataLabels.setCenter(this._center);
    };

    RadarPlot.prototype.buildLabelsText = function(layer, text) {
        for (var i = 0; i < layer.length; i ++) {
            if (layer[i].children && layer[i].children.length) {
                this.buildLabelsText(layer[i].children, text + layer[i].text + "/");
            } else {
                var label = text + layer[i].text;
                this._branchLabels.push(text + layer[i].text);
                this._labelContext.push(layer[i]);
            }
        }
    };

    RadarPlot.prototype.setTrellisContext = function(data) {
        this._trellisContext = data;
    };

    RadarDataLabels.prototype.hideConditional = function() {
        //the hide operation has been done in render
        return;
    };

    RadarPlot.prototype.render = function(selection) {
        RadarPlot.superclass.render.apply(this, arguments);
        if (this._axisTitle) {
            var offset = {
                "x": 0,
                "y": this._realSize.height - this._branchTitileSize.height
            };
            var sizeInfo = {
                height: this._branchTitileSize.height,
                width: this._realSize.width
            };
            this._axisTitle.setSize(sizeInfo);
            var polarAxisContainer = selection.append("g").attr('class', 'v-m-polarAxis');
            polarAxisContainer.attr("transform", 'translate(' + offset.x + ', ' + offset.y + ')');
            //do not hide title items for polarAxis
            this._axisTitle.setTitleHiddenItems();
            this._axisTitle.render(polarAxisContainer);
        }
    };

    RadarPlot.prototype.setData = function(data) {
        RadarPlot.superclass.setData.apply(this, arguments);
        if (this._axisTitle) {
            this._axisTitle.setData(data.categoryAxis, DataUtils.hasNegativeValue(data));
        }
    };

    ChartNavigator.register(ChartConstants.DATAPOINT_NAVIGATOR,ChartConstants.RADAR, DataPointNavigator);

    return RadarPlot;
});

define('sap/viz/chart/components/plotareas/RadarPlotArea',[
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/components/container/RadarContainer',
    'sap/viz/chart/components/axis/RadarValueAxis',
    'sap/viz/chart/components/plots/PlotHelper',
    'sap/viz/chart/components/plots/RadarPlot',
    'sap/viz/chart/components/util/ValueAxisUtils',
    'sap/viz/chart/components/scrollbar/Scrollbar',
    'sap/viz/framework/common/util/DataUtils'
], function Setup(oo, RadarContainer, RadarValueAxis, PlotHelper, RadarPlot, ValueAxisUtils, Scrollbar,
    DataUtils) {
    var RadarPlotArea = function(runtime, options) {
        RadarPlotArea.superclass.constructor.apply(this, arguments);
        this._init();
    };

    oo.extend(RadarPlotArea, RadarContainer);

    RadarPlotArea.prototype._getPlotOptions = function() {
        return this._options;
    };

    RadarPlotArea.prototype._reRenderComplete = function(){
        if (this._eventDispatch) {
            this._eventDispatch.reRenderComplete();
        }
    };

    RadarPlotArea.prototype._registerZoneManager = function(runtime, options) {
        if(!options || !options.inTrellis) {
            RadarPlotArea.superclass._registerZoneManager.call(this, runtime);
        }
    };

    RadarPlotArea.prototype._init = function() {
        this._plot = PlotHelper.create(this._renderType, RadarPlot, this.runtime(), this._getPlotOptions());
        this.setChild("plot", this._plot, {
            position: "center"
        });
        this._plot.getDispatch().on("reRenderComplete.plotarea", this._reRenderComplete.bind(this));

        this.setLayoutSequence(['bottom', 'top', 'left', 'right', 'center']);

        this._valueAxis = new RadarValueAxis(this.runtime(), {
            name: "plotArea.valueAxis"
        });
        this.setChild("valueAxis", this._valueAxis, {
            position: "left"
        });
    };

    RadarPlotArea.prototype.destroy = function() {
        RadarPlotArea.superclass.destroy.call(this);
        this._plot = null;
        this._hScrollbar = null;
        this._valueAxis = null;
    };

    RadarPlotArea.prototype._calcValueAxisScale = function(key, range, domain) {
        var scale = this._data[key].scale;
        return ValueAxisUtils.calcScale(scale, range, {
            domain: domain
        });
    };

    RadarPlotArea.prototype.setData = function(data) {
        RadarPlotArea.superclass.setData.apply(this, arguments);
        var updatedData = this.updateValueScale();
        if(updatedData){
            this._plot.setData(updatedData);
        }
    };

    RadarPlotArea.prototype.setTrellisContext = function(data) {
        this._plot.setTrellisContext(data);
    };

    RadarPlotArea.prototype.updateValueScale = function() {
        var data = this._data;
        var width = this._roughSize.width;
        var height = this._roughSize.height;
        if (!data || width <= 0 || height <= 0) {
            return data;
        }
        var range = [0, 1];
        range[1] = height;
        range[1] *= 0.8;
        var valueAxisData;

        if (this._options.inTrellis) {
            if (this._data.valueAxis._scaleCalculated) {
                this._valueAxis.setData(data.valueAxis);
                return data;
            } else {
                this._data.valueAxis._scaleCalculated = true;
            }
        }

        valueAxisData = this._calcValueAxisScale("valueAxis", range);
        data.valueAxis.scale = valueAxisData.scale;
        data.valueAxis.tickHint = valueAxisData.tickHint;
        data.valueAxis.scale.setRange([0, 1]);
        this._valueAxis.setData(data.valueAxis);

        return data;
    };

    RadarPlotArea.prototype.setSize = function(size) {
        var result = RadarPlotArea.superclass.setSize.apply(this, arguments);
        if (this._options.inTrellis) {
            this.setRoughSize(size);
            var updatedData = this.updateValueScale();
            if(updatedData){
                this._plot.setData(updatedData);
            }
        }
        return result;
    };

    RadarPlotArea.prototype._hasScrollbar = function(){
        return !!this._properties.get('plotArea.isFixedDataPointSize') ||
            !!this._properties.get("plotArea.window.start") ||
            !!this._properties.get("plotArea.window.end");
    };

    RadarPlotArea.prototype._preRender = function() {
        var offset = {x:0, y:0};
        if (this._hasScrollbar()) {
            offset = this._plot.getOffset();
        }
        RadarPlotArea.superclass._preRender.apply(this, arguments);
        if(offset.x || offset.y){
            this.scroll(offset);
        }
    };

    RadarPlotArea.prototype._configLayout = function() {
        var zoomer = this.getZoomer();
        var isVScrollbarExist = false, isHScrollbarExist = false;
        if (zoomer){
            isVScrollbarExist = true;
            isHScrollbarExist = true;
        }

        if (this._hasScrollbar()) {
            isVScrollbarExist = true;
            isHScrollbarExist = true;
            // save the real size here for CategoryAxis to correctly calculate its size
            this.runtime().statusManager().add('plotRealSize', {
                value: this._plot.getPreferredSize()
            });
        }
        if (this._vScrollbar) {
            this._vScrollbar.isExist(isVScrollbarExist);
        }
        if (this._hScrollbar) {
            this._hScrollbar.isExist(isHScrollbarExist);
        }

        return RadarPlotArea.superclass._configLayout.apply(this, arguments);
    };

    RadarPlotArea.prototype._cloneData = function(replaced) {
        var newData = {};
        var data = this._data;
        for(var i in data) {
            if (data.hasOwnProperty(i)) {
                newData[i] = data[i];
            }
        }

        for (var prop in replaced) {
            if (replaced.hasOwnProperty(prop)) {
                newData[prop] = replaced[prop];
            }
        }
        return newData;
    };

    RadarPlotArea.prototype.drawTrellisDataLabels = function(cellPadding, cellSize) {
        //the cell of trellis radar is RadarPlotArea but not RadarPlot
        //because the cell should include value axis as well as plot
        this._plot.drawTrellisDataLabels(cellPadding, cellSize);
    };

    return RadarPlotArea;
});

define('sap/viz/chart/behavior/config/AxisBehaviorConfigForRadar',[
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/interaction/Constants',
    'sap/viz/chart/components/util/ChartTypeUtils',
    'sap/viz/framework/common/util/UADetector',
    "sap/viz/framework/interaction/BehaviorManager"
], function (Constants, 
        SDKConstants,
        ChartTypeUtils,
        UADetector,
        BehaviorManager) {
    var axisItemPattern = "v-axis-item",
        CSS_CLASS = Constants.CSS.CLASS,
        radarType = ["info/radar"],
        axisName = "plotArea.polarAxis";
    radarType = ChartTypeUtils.addTrellisType(radarType);

    function isTriggerable(service) {
        var selectability = service.getProperties().get("interaction.selectability");
        if (!selectability) {
            return false;
        }
        var selectionMode = selectability.mode ? selectability.mode.toUpperCase() : selectability.mode;
        var axisNode = service.getNodes(service.NodeType.AXIS_ITEM);
        if (!selectability.axisLabelSelection || selectionMode === SDKConstants.SELECTION_MODE.NONE ||
            selectionMode === SDKConstants.SELECTION_MODE.SINGLE || !axisNode.node()) {
            return false;
        } else {
            return true;
        }
    }

    var axisRadar = [{
        "id": "hover_on_axis_label_radar",
        "triggerEvent": {
            "name": "hover",
            "targets": axisItemPattern,
            "supportedChartTypes": radarType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            service.fireEvent("cleanAxisHoverEffect");
            var color = service.getProperties().get(axisName + ".hoverShadow.color");
            if (color) {
                d3.select(event.data.currentTarget).select("rect")
                    .attr("fill", event.data.byKeyboard ? "transparent" : color)
                    .classed(CSS_CLASS.HOVER_SHADOW, true);
            }
        }
    }, {
        "id": "down_on_axis_label_radar",
        "triggerEvent": {
            "name": "down",
            "targets": axisItemPattern,
            "supportedChartTypes": radarType
        },
        "handler": function (event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            service.fireEvent("cleanAxisHoverEffect");
            var color = service.getProperties().get(axisName + ".mouseDownShadow.color");
            if (color) {
                d3.select(event.data.currentTarget).select("rect")
                    .attr("fill", color)
                    .classed(CSS_CLASS.HOVER_SHADOW, false)
                    .classed(CSS_CLASS.FOCUS_SHADOW, true);
            }
        }
    }, {
        "id": "up_on_axis_label_radar",
        "triggerEvent": {
            "name": "up",
            "targets": axisItemPattern,
            "supportedChartTypes": radarType
        },
        "handler": function(event, service) {
            if (!isTriggerable(service)) {
                return;
            }
            var axisBackground = service.getNodes(service.NodeType.AXIS_ITEM_BACKGROUND);
            axisBackground.attr("fill", "transparent").classed(CSS_CLASS.FOCUS_SHADOW, false);

            if (UADetector.isMobile()) {
                axisBackground.classed(CSS_CLASS.HOVER_SHADOW, false);
            } else {
                var color = service.getProperties().get(axisName + ".hoverShadow.color");
                if (color) {
                    d3.select(event.data.currentTarget).select("rect")
                        .attr("fill", color)
                        .classed(CSS_CLASS.HOVER_SHADOW, true);
                }
            }
        }
    }];
    BehaviorManager.registerAll(axisRadar);
    return axisRadar;
});
define('sap/viz/chart/behavior/config/DataPointBehaviorConfigForRadar',[
    'sap/viz/framework/common/util/Constants',
    "sap/viz/framework/common/util/TypeUtils",
    "sap/viz/chart/behavior/config/HighlightHelper",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/chart/components/util/ChartTypeUtils",
    "sap/viz/framework/common/util/DataGraphics",
    "sap/viz/framework/interaction/InteractionUtils",
    "sap/viz/framework/interaction/BehaviorManager",
    "sap/viz/framework/interaction/BehaviorFactory",
    "sap/viz/framework/interaction/Constants"
], function(
    Constants,
    TypeUtils,
    HighlightHelper,
    DataPointUtils,
    ChartTypeUtils,
    DataGraphics,
    InteractionUtils,
    BehaviorManager,
    BehaviorFactory,
    ConstantsBehavior
) {

    var radarType = [
        "info/radar"
    ];

    radarType = ChartTypeUtils.addTrellisType(radarType);

    var dataPointPattern = "v-datapoint";
    var dataLabelPattern = "v-datalabel";

    var CSS_CLASS = Constants.CSS.CLASS;
    var NET_CLASS = CSS_CLASS.RADAR_NET;

    function highlightNet(dataPoints, service, arranged, isSelected) {
        if (!dataPoints.length) {
            return;
        }
        if(!arranged && DataGraphics.getData(dataPoints[0]).trellisInfo) {
            //for trellis plot
            var trellisDataPoints = arrangeDataPointsByTrellis(dataPoints);
            for(var key in trellisDataPoints) {
                if(trellisDataPoints.hasOwnProperty(key)) {
                    highlightNet(trellisDataPoints[key], service, true, isSelected);
                }
            }
            return;
        }
        var parent = getParentNode(service, service.NodeType.DATA_POINT_GROUP, dataPoints[0]);
        var netNodes = parent.querySelectorAll("." + NET_CLASS);
        var arrangedDataPoints = arrangeSelectedDataPoints(dataPoints);
        for(var seriesIndex in arrangedDataPoints) {
            if (arrangedDataPoints.hasOwnProperty(seriesIndex) && arrangedDataPoints[seriesIndex]) {
                highlightSelectedNet(service, parseInt(seriesIndex),
                    arrangedDataPoints[seriesIndex], isSelected, netNodes);
            }
        }
    }

    function arrangeDataPointsByTrellis(dataPoints) {
        var arrangedDataPoints = {};
        for(var i = 0; i < dataPoints.length; i ++) {
            var trellisInfo = DataGraphics.getData(dataPoints[i]).trellisInfo;
            arrangedDataPoints[trellisInfo] = arrangedDataPoints[trellisInfo] || [];
            arrangedDataPoints[trellisInfo].push(dataPoints[i]);
        }
        return arrangedDataPoints;
    }

    function arrangeSelectedDataPoints(dataPoints) {
        var arrangedDataPoints = [];
        for(var i = 0; i < dataPoints.length ; i ++) {
            var extraData = DataGraphics.getData(dataPoints[i]);
            arrangedDataPoints[extraData.seriesIndex] = arrangedDataPoints[extraData.seriesIndex] || [];
            arrangedDataPoints[extraData.seriesIndex].push(dataPoints[i]);
        }
        return arrangedDataPoints;
    }

    function highlightSelectedNet(service, seriesIndex, elements, isSelected, netNodes) {
        var props;
        var lineProp = service.getProperties().get('plotArea.line');
        if (netNodes && netNodes.length > 0) {
            [].slice.apply(netNodes).every(function(item) {
                var extraData = DataGraphics.getData(item);
                if (extraData.seriesIndex !== seriesIndex) {
                    return true;
                }
                if (isSelected) {
                    if (elements && extraData.pointSum === elements.length) {
                        props = service.getProperties().get('interaction.selected');
                        if (d3.select(item).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                            return false;
                        } else {
                            d3.select(item).classed(CSS_CLASS.DATAPOINTSELECTED, true);
                        }

                        var areaConfig = {
                            fill: extraData.fill,
                            visible: extraData.visibility === "visible"
                        };
                        fillNet(service, item, props.area, areaConfig);
                        if (lineProp.visible === true) {
                            item.setAttribute("stroke-opacity", 1);
                        } else {
                            item.setAttribute("stroke-opacity", 0);
                        }
                    } else {
                        if (lineProp.visible !== true) {
                            item.setAttribute("stroke-opacity", 0);
                        } else {
                            item.removeAttribute("stroke-opacity");
                        }
                    }
                } else {
                    props = service.getProperties().get('interaction.deselected');
                    if (d3.select(item).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                        d3.select(item).classed(CSS_CLASS.DATAPOINTSELECTED, false);
                    } else {
                        return false;
                    }
                    fillNet(service, item, props.area);
                }
                return true;
            });
        }
    }

    function fillNet(service, node, props, areaConfig) {
        var colors = HighlightHelper.getColors(service, node, props.color);
        var visible = areaConfig ?
            areaConfig.visible : service.getProperties().get('plotArea.area.visible');
        var netFill = colors.customizedColor || (areaConfig && areaConfig.fill) || colors.defaultColor;
        colors = colors.customizedColor || colors.defaultColor;
        node.setAttribute("fill", netFill);
        node.setAttribute("stroke", colors);
        if (visible) {
            if (props.opacity) {
                node.setAttribute("fill-opacity", props.opacity);
            }
        } else {
            node.setAttribute("fill-opacity", 0);
        }
    }

    function getParentNode(service, nodeType, element) {
        if (element) {
            var nodes = service.getNodes(nodeType, false);
            var parentNode;
            nodes.forEach(function(item) {
                if (item.contains && item.contains(element)) {
                    parentNode = item;
                } else if (item.compareDocumentPosition && !! (item.compareDocumentPosition(element) & 16)) {
                    parentNode = item;
                }
            });
            return parentNode;
        }
        return null;
    }

    var radarBehavior =  [{
        "id": "selectDataPoint_radar",
        "triggerEvent": {
            "name": "selectDataPoint",
            "supportedChartTypes": radarType
        },
        "handler": function(event, service) {
            var elements = HighlightHelper.turnToArray(event.data.targets);
            service.fireEvent(event, true);

            var prop = service.getProperties().get('interaction.selected');
            elements.forEach(function(e) {
                var d3Node = d3.select(e);
                d3Node.classed(CSS_CLASS.DATAPOINTDEFAULT, false);
                d3Node.classed(CSS_CLASS.DATAPOINTSELECTED, true);
                DataPointUtils.highlight(e);
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'path', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')), true);
            });
            highlightNet(elements, service, false, true);
        }
    }, {
        "id": "deselectDataPoint_radar",
        "triggerEvent": {
            "name": "deselectDataPoint",
            "supportedChartTypes": radarType
        },
        "handler": function(event, service) {
            if (!event.data.targets || event.data.targets.length <= 0) {
                return;
            }
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            if(event.data.isAnyOtherSelected) {
                prop = service.getProperties().get('interaction.deselected');
            }else{
                prop = service.getProperties().get('plotArea.dataPoint');
                if (!service.getProperties().get("plotArea.marker.visible")) {
                    prop.opacity = 0;
                }
            }
            elements.forEach(function(e) {
                var d3Node = d3.select(e);
                if (!d3Node) {
                    return;
                }
                d3Node.classed(CSS_CLASS.DATAPOINTSELECTED, false);
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'path', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')), true);
            });
            if (event.data.isAnyOtherSelected) {
                highlightNet(elements, service, false, false);
            }
        }
    }, {
        "id": "hoverOnDataPoint_radar",
        "triggerEvent": {
            "name": "hoverOnDataPoint",
            "supportedChartTypes": radarType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop = service.getProperties().get('interaction.hover');
            elements.forEach(function(e) {
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 2);
                HighlightHelper.drawFill(service, e, 'path', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')), true);
            });
        }
    }, {
        "id": "unhoverOnDataPoint_radar",
        "triggerEvent": {
            "name": "unhoverOnDataPoint",
            "supportedChartTypes": radarType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);
            var elements = HighlightHelper.turnToArray(event.data.targets);
            var prop;
            elements.forEach(function(e) {
                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    prop = service.getProperties().get('interaction.selected');
                } else {
                    var selectedDataPoints = service.getStatus("selectedDataPoints");
                    if(selectedDataPoints.length) {
                        prop = service.getProperties().get('interaction.deselected');
                    } else {
                        prop = service.getProperties().get('plotArea.dataPoint');
                    }
                    if (!service.getProperties().get("plotArea.marker.visible")) {
                        prop.opacity = 0;
                    }
                }
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'path', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')), true);
            });

        }
    }, {
        "id": "clearPlot_radar",
        "triggerEvent": {
            "name": "clearPlot",
            "supportedChartTypes": radarType
        },
        "handler": function(event, service) {
            service.fireEvent(event, true);

            var mainNode = service.getNodes(service.NodeType.DATA_POINT, false);
            if(!mainNode || !mainNode.length){
                return;
            }
            var prop, gray = event.data.isGray;
            if(gray){
                prop = service.getProperties().get('interaction.deselected');
            }else{
                prop = service.getProperties().get('plotArea.dataPoint');
            }
            if (!service.getProperties().get("plotArea.marker.visible")) {
                prop.opacity = 0;
            }
            mainNode.forEach(function(e) {
                HighlightHelper.drawStroke(service, e, 'path', prop.stroke, 1);
                HighlightHelper.drawFill(service, e, 'path', prop,
                    TypeUtils.isExist(service.getProperties().get('plotArea.markerRenderer')), true);
            });
            var visible = service.getProperties().get('plotArea.area.visible');
            if (gray) {
                prop = service.getProperties().get('interaction.deselected.area');
            } else {
                prop = service.getProperties().get('plotArea.area');
            }
            var areaNodes = service.getNodes(service.NodeType.RADAR_NET, false);
            var lineProp = service.getProperties().get('plotArea.line');

            areaNodes.forEach(function(e){
                if (d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED)) {
                    d3.select(e).classed(CSS_CLASS.DATAPOINTSELECTED, false);
                }
                var extraData = DataGraphics.getData(e);
                var fill;
                var opacity = visible ? prop.opacity : 0;
                if (extraData.visibility === "visible") {
                    if (!gray) {
                        opacity = extraData.opacity;
                    } else {
                        opacity = prop.opacity;
                    }
                    fill = extraData.fill;
                } else if (extraData.visibility === "hidden") {
                    opacity = 0;
                }
                var colors = HighlightHelper.getColors(service, e, prop.color);

                if(gray && colors.customizedColor) {
                    e.setAttribute('fill', colors.customizedColor);
                    e.setAttribute('stroke', colors.customizedColor);
                }else{
                    e.setAttribute('fill', fill || colors.defaultColor);
                    e.setAttribute('stroke', colors.defaultColor);
                }
                if(lineProp.visible !== true) {
                    e.setAttribute('stroke-opacity', 0);
                } else {
                    e.removeAttribute("stroke-opacity");
                }
                e.setAttribute('fill-opacity', opacity);
            });
        }
    },
    InteractionUtils.getDeselectEvent("click_on_non_selection_radar", radarType,
        HighlightHelper.getDeselAllExTargets())];
    BehaviorManager.registerAll(radarBehavior);
    return radarBehavior;
});

define('sap/viz/chart/views/RadarChartView',['sap/viz/framework/common/util/oo',
        'sap/viz/chart/views/ChartView',
        'sap/viz/chart/components/plotareas/RadarPlotArea',
        "sap/viz/chart/behavior/config/AxisBehaviorConfigForRadar",
        "sap/viz/chart/behavior/config/DataPointBehaviorConfigForRadar"
    ],
    function Setup(oo, ChartView, RadarPlotArea) {

        var RadarChartView = function(runtime, option) {
            RadarChartView.superclass.constructor.apply(this, arguments);
            this._supportLazyRender = true;
        };

        oo.extend(RadarChartView, ChartView);

        RadarChartView.prototype.setSize = function() {
            if (this._plotArea && this._plotArea.setRoughSize) {
                this._plotArea.setRoughSize.apply(this._plotArea, arguments);
            }
            RadarChartView.superclass.setSize.apply(this, arguments);
        };
        

        RadarChartView.prototype._getLegendInitOptions = function() {
            return [{noFillSupport:true}];
        };

        RadarChartView.prototype._getDataItems = function() {
            //TODO: maybe categoryAxis will be replaced by polarAxis
            return ["valueAxis", "categoryAxis", "color", "dataFrame", "series", "trellisRow", "trellisColumn"];
        };

        RadarChartView.prototype._createPlotContainer = function(isTrellis) {
            this._plotArea = new RadarPlotArea(this.runtime(), {
                renderType: this._renderType
            });

            this._plotArea.setRoughSize(this._size);

            this.setChild("main", this._plotArea, {
                priority: 3
            });
        };

        return RadarChartView;
    });

define('sap/viz/chart/metadata/properties/chartTypes',[], function(){
    return [
        "DEFAULT",
        "100_dual_stacked_bar",
        "100_dual_stacked_column",
        "mekko",
        "100_mekko",
        "horizontal_mekko",
        "100_horizontal_mekko",
        "100_stacked_bar",
        "100_stacked_column",
        "100_area",
        "100_horizontal_area",
        "bar",
        "bullet",
        "vertical_bullet",
        "timeseries_bullet",
        "column",
        "combination",
        "dual_bar",
        "dual_column",
        "dual_horizontal_line",
        "dual_line",
        "dual_stacked_bar",
        "dual_stacked_column",
        "horizontal_combination",
        "horizontal_line",
        "line",
        "area",
        "horizontal_area",
        "timeseries_line",
        "timeseries_column",
        "timeseries_combination",
        "dual_timeseries_combination",
        "timeseries_stacked_combination",
        "timeseries_stacked_column",
        "timeseries_100_stacked_column",
        "stacked_bar",
        "stacked_column",
        "pie",
        "donut",
        "scatter",
        "bubble",
        "time_bubble",
        "timeseries_scatter",
        "timeseries_bubble",
        "treemap",
        "heatmap",
        "tagcloud",
        "number",
        "radar",
        "trellis_100_dual_stacked_bar",
        "trellis_100_dual_stacked_column",
        "trellis_100_stacked_bar",
        "trellis_100_stacked_column",
        "trellis_100_area",
        "trellis_100_horizontal_area",
        "trellis_bar",
        "trellis_column",
        "trellis_combination",
        "trellis_combinationEx",
        "trellis_dual_bar",
        "trellis_dual_column",
        "trellis_dual_horizontal_line",
        "trellis_dual_line",
        "trellis_dual_stacked_bar",
        "trellis_dual_stacked_column",
        "trellis_horizontal_combination",
        "trellis_horizontal_line",
        "trellis_horizontal_area",
        "trellis_line",
        "trellis_area",
        "trellis_stacked_bar",
        "trellis_stacked_column",
        "trellis_pie",
        "trellis_scatter",
        "trellis_bubble",
        "trellis_donut",
        "stacked_combination",
        "horizontal_stacked_combination",
        "dual_stacked_combination",
        "dual_horizontal_stacked_combination",
        "dual_combination",
        "dual_horizontal_combination",
        "waterfall",
        "stacked_waterfall",
        "timeseries_waterfall",
        "horizontal_waterfall",
        "horizontal_stacked_waterfall",
        "trellis_radar",
        "combinationEx"
    ];
});

define('sap/viz/chart/metadata/properties/metadata',[
    'sap/viz/chart/metadata/properties/chartTypes',
    'sap/viz/chart/metadata/properties/PropertyLoader'
], function(chartTypes, PropertyLoader){

    function loadProperties(chartType, properties) {
        var chartProps;
        var props = PropertyLoader.getProperties(chartType);
        if (props) {
            chartProps = {};
            for (var name in props) {
                if (props.hasOwnProperty(name)) {
                    var prop = props[name];
                    if (!isPropObj(prop)) {
                        prop = {
                            defaultValue: prop
                        };
                    }
                    setObject(name, prop, chartProps);
                }
            }
        }
        return chartProps;
    }

    function getFullChartType(chartType){
        return 'info/' + chartType;
    }

    function setObject(name, value, root){
        var parts = name.split('.');
        var p = root;
        for(var i = 0; i < parts.length; ++i){
            var part = parts[i];
            if(i < parts.length - 1){
                p[part] = p[part] || {
                    children: {}
                };
                p = p[part].children;
            }else{
                p[part] = value;
            }
        }
    }

    function isPropObj(it){
        return Object.prototype.toString.call(it) === '[object Object]' &&
            (it.hasOwnProperty('defaultValue') || it.hasOwnProperty('readonly') ||
             it.hasOwnProperty('serializable'));
    }
    var propsByChartType = {};
    var fullChartTypes = chartTypes.map(function(name){return getFullChartType(name);});
    return {
        // load property will spend lots of time, use delay load will save time
        get: function(chartType){
            if(arguments.length){
                var ret = propsByChartType[chartType];
                // if cache is not hit, look into PropertyLoader again for dynamically registered properties
                if(!ret) {
                    ret = loadProperties(chartType);
                    if(fullChartTypes.indexOf(chartType) > -1){
                        propsByChartType[chartType] = ret;
                    }
                }
                return ret;
            }else {
                for(var i = 0; i < fullChartTypes.length; ++i){
                    var cType = fullChartTypes[i];
                    propsByChartType[cType] = propsByChartType[cType] || loadProperties(cType);
                }
                return propsByChartType;
            }
        }
    };
});

define('scaleDefs',[], function Setup() {
    var colorPalette = ["#748CB2", "#9CC677", "#EACF5E", "#F9AD79", "#D16A7C", "#8873A2", "#3A95B3", "#B6D949",
                        "#FDD36C", "#F47958", "#A65084", "#0063B1", "#0DA841", "#FCB71D",
                        "#F05620", "#B22D6E", "#3C368E",
                        "#8FB2CF", "#95D4AB", "#EAE98F", "#F9BE92", "#EC9A99", "#BC98BD",
                        "#1EB7B2", "#73C03C", "#F48323",
                        "#EB271B", "#D9B5CA", "#AED1DA", "#DFECB2", "#FCDAB0", "#F5BCB4"];

    var dualColorPalette = [
        ["#8FBADD", "#B8D4E9", "#7AAED6", "#A3C7E3", "#3D88C4", "#66A1D0", "#297CBE", "#5295CA",
            "#005BA3", "#146FB7", "#005395", "#0063B1"
        ],
        ["#F6A09B", "#F9C3C0", "#F58E88", "#F8B1AD", "#F05B52", "#F37D76", "#EE4A40", "#F16C64",
            "#D92419", "#ED382D", "#C52117", "#EB271B"
        ]
    ];


    var bulletActualColor = [  "#748CB2", "#9CC677","#EACF5E","#F9AD79", "#D16A7C",
                               "#8873A2", "#3A95B3","#B6D949","#FDD36C","#F47958",
                               "#A65084", "#0063B1","#0DA841","#FCB71D","#F05620",
                               "#B22D6E", "#3C368E"];
    var bulletAdditionalColor = [ "#A7BFE5",  "#CFF9AA", "#FFFF91", "#FFE0AC", "#FF9DAF"  ,
                                "#BBA6D5" , "#6DC8E6", "#E9FF7C", "#FFFF9F", "#FFAC8B"  ,
                                "#D983B7" , "#3396E4", "#40DB74", "#FFEA50", "#FF8953"  ,
                                "#E560A1" , "#6F69C1"];
    var bulletForecastColor =  [ "#D5DADC"];

    var color_Properties_single = {
        "palette": {
            "defaultValue": colorPalette,
        }
    };

    var color_Properties_dual = {
        "palette": {
            "defaultValue": dualColorPalette,
        }
    };

    var color_Properties_combinationEx = {
        "palette": {
            "defaultValue": [[colorPalette, dualColorPalette[0]], dualColorPalette[1]],
        }
    };

    var color_Palette = {
        "palette": {
            "defaultValue": colorPalette,
        }
    };

    var donut_color_Properties_single = {
        "palette": {
            "defaultValue": colorPalette,
        }
    };

    var color_Properties_bullet = {
        "ActualColor": {
            "defaultValue": bulletActualColor,
        },
        "AdditionalColor": {
            "defaultValue": bulletAdditionalColor,
        },
        "ForecastColor": {
            "defaultValue": bulletForecastColor,
        },
    };

    var color_Properties_time_bullet = {
        "ActualColor": {
            "defaultValue": bulletActualColor,
        },
        "AdditionalColor": {
            "defaultValue": bulletAdditionalColor,
        }
    };

    var shape_Properties = {
        "palette": {
            "defaultValue": ["circle", "square", "diamond", "triangleUp", "triangleDown", "triangleLeft",
                "triangleRight", "cross", "intersection"],
        }
    };

    var valueAxis2_Properties = {
        "min": {
            "defaultValue": "auto",
        },
        "max": {
            "defaultValue": "auto",
        },
        "type": {
            "defaultValue": "linear",
        }
    };
    var valueAxis_Properties = {
        "min": {
            "defaultValue": "auto",
        },
        "max": {
            "defaultValue": "auto",
        },
        "type": {
            "defaultValue": "linear",
        },
    };

    var timeAxis_Properties = {
        "start": {
            "defaultValue": "auto",
        },
        "end": {
            "defaultValue": "auto",
        }
    };

    var primary_Properties = {
        "type": {
            "defaultValue": "linear",
        },
        "min": {
            "defaultValue": "auto",
        },
        "max": {
            "defaultValue": "auto",
        }
    };

    var secondary_Properties = {
        "type": {
            "defaultValue": "linear",
        },
        "min": {
            "defaultValue": "auto",
        },
        "max": {
            "defaultValue": "auto",
        },
    };

    var dataFrame_Properties = {
        "domain" : {
            "defaultValue":[],
        }
    };

    var MBC_Properties = {
        "palette" : {
            "defaultValue": [],
        },
        "startColor" : {
            "defaultValue": "#C2E3A9",
        },
        "endColor" : {
            "defaultValue": "#73C03C",
        },
        "legendValues" : {
            "defaultValue": [],
        },
        "numOfSegments": {
            "defaultValue": 5,
        },
        "maxNumOfSegments": {
            "defaultValue": 9,
            "access": "internal"
        },
        "nullColor" : {
            "defaultValue": "#E0E0E0",
        }
    };

    var waterfallType_Properties = {
    };
    var singleColorScale =  {
        "feed": "color",
        "properties": color_Properties_single
    };
    var vAxisScale =  {
        "feed": "valueAxis",
        "properties": valueAxis_Properties
    };
    var dfScale = {
        "feed": "dataFrame",
        "properties": dataFrame_Properties
    };

    var vAxis2Scale = {
        "feed": "valueAxis2",
        "properties": valueAxis2_Properties
    };
    var dualColorScale =  {
        "feed": "color",
        "properties": color_Properties_dual
    };
    var comboExColorScale =  {
        "feed": "color",
        "properties": color_Properties_combinationEx
    };
    var priScale = {
        "feed": "valueAxis",
        "properties": primary_Properties
    };
    var secScale = {
        "feed": "valueAxis2",
        "properties": secondary_Properties
    };
    var shapeScale = {
        "feed": "shape",
        "properties": shape_Properties
    };
    var timeScale = {
        "feed": "timeAxis",
        "properties": timeAxis_Properties
    };
    var mbcScale = {
        "feed": "color",
        "properties" : MBC_Properties
    };

    var bulletScales = [{
        "feed": "actualValues",
        "properties": primary_Properties
    }, {
        "feed": "color",
        "properties" : color_Properties_bullet
    }];

    var timeBulletScales = [timeScale, {
        "feed": "actualValues",
        "properties": primary_Properties
    }, {
        "feed": "color",
        "properties" : color_Properties_time_bullet
    }];

    var barScales = [vAxisScale,singleColorScale , dfScale];
    var mekkoScales = [vAxisScale, singleColorScale];

    var stackedScales = [singleColorScale , dfScale];
    var dualScales =  [vAxisScale, vAxis2Scale, dualColorScale,dfScale];
    var comboExScales =  [vAxisScale, vAxis2Scale, comboExColorScale];
    var trllisBubbleScales = [priScale, secScale, singleColorScale, shapeScale];
    var bubbleScales = trllisBubbleScales.concat(dfScale);
    var trePieScales =  [{
        "feed": "color",
        "properties": donut_color_Properties_single
    }];
    var pieScales =  trePieScales.concat(dfScale);
    var trellisBarScales = [vAxisScale, singleColorScale];
    var treDualScales = [vAxisScale, vAxis2Scale, dualColorScale];
    var dualColorScales =  [dualColorScale,dfScale];

    var timeLineScales = [priScale,singleColorScale, timeScale];

    var duaTimeScales = timeLineScales.concat(vAxis2Scale);

    var waterFallScales = [vAxisScale, {
        "feed": "waterfallType",
        "properties": waterfallType_Properties
    }];

    var timeseriesWaterFallScale = [vAxisScale, singleColorScale, timeScale];

    var stackedWaterScales = waterFallScales.concat(singleColorScale);

    var timeseriesBubbleScales = [priScale,singleColorScale,timeScale,shapeScale];

    var tCombScales = [vAxisScale, singleColorScale, timeScale];
    var dualTCombScales = tCombScales.concat(vAxis2Scale);

    var allChartTypeScales = {
        "column":barScales,
        "donut": pieScales,
        "pie": pieScales,
        "bar": barScales,
        "line":barScales,
        "area":barScales,
        "stacked_column": barScales,
        "stacked_bar":barScales,
        "100_stacked_bar": stackedScales,
        "100_stacked_column": stackedScales,
        "100_area": stackedScales,
        "100_horizontal_area": stackedScales,
        "mekko":mekkoScales,
        "horizontal_mekko":mekkoScales,
        "100_mekko":mekkoScales,
        "100_horizontal_mekko":mekkoScales,
        "combination":barScales,
        "stacked_combination":barScales,
        "horizontal_stacked_combination": barScales,
        "dual_bar": dualScales,
        "dual_column": dualScales,
        "dual_line":dualScales,
        "scatter":bubbleScales,
        "bubble":bubbleScales,
        "trellis_column": trellisBarScales,
        "trellis_donut": trePieScales,
        "trellis_pie":trePieScales,
        "trellis_bar": trellisBarScales,
        "trellis_line": trellisBarScales,
        "trellis_area": trellisBarScales,
        "trellis_100_area":[singleColorScale],
        "trellis_100_horizontal_area": [singleColorScale],
        "trellis_stacked_column":trellisBarScales,
        "trellis_stacked_bar":trellisBarScales,
        "trellis_100_stacked_bar": [singleColorScale],
        "trellis_100_stacked_column": [singleColorScale],
        "trellis_combination": trellisBarScales,
        "trellis_dual_bar": treDualScales,
        "trellis_dual_column": treDualScales,
        "trellis_dual_line": treDualScales,
        "trellis_scatter": trllisBubbleScales,
        "trellis_bubble": trllisBubbleScales,
        "horizontal_line": barScales,
        "horizontal_area": barScales,
        "trellis_horizontal_line":trellisBarScales,
        "trellis_horizontal_area":trellisBarScales,
        "horizontal_combination": barScales,
        "trellis_horizontal_combination": [vAxisScale, {
            "feed": "color",
            "properties": color_Palette
        }],
        "dual_horizontal_line":dualScales,
        "trellis_dual_horizontal_line":treDualScales,
        "100_dual_stacked_column":dualColorScales,
        "trellis_100_dual_stacked_column": dualColorScales,
        "100_dual_stacked_bar": dualColorScales,
        "trellis_100_dual_stacked_bar": [dualColorScale],
        "dual_stacked_column":dualScales,
        "trellis_dual_stacked_column":treDualScales,
        "dual_stacked_bar": dualScales,
        "trellis_dual_stacked_bar": treDualScales,
        "treemap": [mbcScale],
        "heatmap": [mbcScale],
        "number": [],
        "tagcloud": [mbcScale, dfScale],
        "time_bubble": [priScale, secScale, singleColorScale,shapeScale, dfScale],
        "bullet":bulletScales ,
        "vertical_bullet": bulletScales,
        "timeseries_bullet": timeBulletScales,
        "dual_combination":  dualScales,
        "dual_stacked_combination":dualScales,
        "dual_horizontal_combination": dualScales,
        "dual_horizontal_stacked_combination":dualScales,
        "timeseries_line" : timeLineScales,
        "timeseries_column" : [priScale, singleColorScale, timeScale],
        "timeseries_combination" : tCombScales,
        "timeseries_stacked_combination" : tCombScales,
        "dual_timeseries_combination" : dualTCombScales,
        "timeseries_scatter" : timeseriesBubbleScales,
        "timeseries_bubble" : timeseriesBubbleScales,
        "waterfall": waterFallScales,
        "timeseries_waterfall" : timeseriesWaterFallScale,
        "horizontal_waterfall":waterFallScales,
        "stacked_waterfall": stackedWaterScales,
        "horizontal_stacked_waterfall": stackedWaterScales,
        "radar": [vAxisScale, singleColorScale,dfScale],
        "trellis_radar": [vAxisScale, singleColorScale],
        "combinationEx": comboExScales,
        "trellis_combinationEx": comboExScales,
        "timeseries_stacked_column":[priScale, singleColorScale, timeScale],
        "timeseries_100_stacked_column":[singleColorScale, timeScale],
    };

    return allChartTypeScales;
});

define('sap/viz/chart/metadata/properties/ScaleLoader',[
    "scaleDefs",
    'sap/viz/framework/common/util/ObjectUtils',
], function(
    allChartScales,
    ObjectUtils
){
    var scaleByType = ObjectUtils.clone(allChartScales);

    //flatten scales, remove node properties.
    var flattenScale = function(chartScales) {
        var returnScales = [];
        var i = 0;
        if (chartScales) {
            for (i = 0; i < chartScales.length; ++i) {
                var scales = chartScales[i];
                returnScales[i] = {};
                for (var items in scales) {
                    if (scales.hasOwnProperty(items)) {
                        returnScales[i][items] = scales[items];
                    }
                }
                if (returnScales[i].hasOwnProperty("properties")) {
                    delete returnScales[i].properties;
                    for (var propItem in scales.properties) {
                        if (scales.properties.hasOwnProperty(propItem)) {
                            returnScales[i][propItem] = scales.properties[propItem];
                        }
                    }
                }
            }
        }
        return returnScales;
    };

    return {
        addScales: function(scales){
            scaleByType = ObjectUtils.extend(true, {}, scaleByType, scales);
        },
        getScale: function(type){
            return flattenScale(scaleByType[type]);
        }
    };
});

define('sap/viz/chart/metadata/metadata',[
    "sap/viz/chart/metadata/properties/metadata",
    'sap/viz/framework/common/lang/LangManager',
    "sap/viz/framework/core/ChartViewRegistry",
    "sap/viz/framework/common/util/ObjectUtils",
    'sap/viz/chart/metadata/properties/ScaleLoader'
], function Setup(
                    propertyMetadata,
                    LangManager, 
                    ChartViewRegistry, 
                    ObjectUtils,
                    ScaleLoader) {
    var cutOffCharType = function(type) {
        if (type.search("info/") != -1) {
            var cutOffType = type.slice(5);
            return cutOffType;
        } else {
            return type;
        }
    };

    var deleteName = function(binding) {
        if(!binding){
            return;
        }
        var data = ObjectUtils.clone(binding);
        for (var i = 0; i < data.length; i++) {
            delete data[i].name;
        }
        return data;
    };

    var adjustMeta = function(metadata){
        var cutType = cutOffCharType(metadata.type);
        if(metadata.isBuiltIn) {
            metadata.bindings = deleteName(metadata.bindings);
        }
        metadata.properties = propertyMetadata.get(metadata.type);
        metadata.scales = ScaleLoader.getScale(cutType); 
        metadata.name = LangManager.get(metadata.name)|| metadata.name;

        return metadata;
    };

    var BaseMetadata = {
        get: function(chartType) {
            var metadata = ChartViewRegistry.getMetadata(chartType);
            if(metadata){
                return adjustMeta(metadata);
            }
            return metadata;
            
        },

        getAll: function() {
            var metadata = ChartViewRegistry.getAllMetadata();

            for (var i in metadata) {
                if (metadata.hasOwnProperty(i)) {
                    adjustMeta(metadata[i]);
                }
            }
            return metadata;
        }
    };

    return BaseMetadata;
});
define('sap/viz/api/metadata/Viz',['sap/viz/chart/metadata/metadata', 'exports'], function Setup(metadataObj, scaleUtil) {

    var metadata =
        /**
         * sap.viz.api.metadata.Viz
         * @namespace sap.viz.api.metadata.Viz
         */
        {


            /**
             * @function get
             * @memberof sap.viz.api.metadata.Viz
             * @static
             * @param {String} [id]
             *                        Returns viz metadata that is associated with the id. If the id is not defined,
              returns all the vizs' metadata.
             * @return {[sap.viz.api.metadata.VizMetadata]} viz metadata, this is a read only object
             *
             * @example <caption>Sample Code:</caption>
             * var viz = sap.viz.api.metadata.Viz.get('info/column'); //Get specified viz by id; returns an array which
              contains one viz object
             * viz manifest returned:
             * {
             *     "type": String, chart type, for info/column is info/column.
             *     "family": String, chart family, for info/column is xy.
             *     "renderType": String,  rendering type, for info/column is column.
             *     "vender": String,  Ddependencies between modules.
             *     "bindings": Array,  get all binding defintion for the chart.
             *     "scales": Array,  get all scale defintion with default scale properties for the chart.
             *     "properties": Object, get all properties of the viz including default and customer setting.
             * }
             *
             */
            get: function(chartType) {
                if (arguments.length) {
                    var getBaseMetadata = metadataObj.get(chartType);
                    return getBaseMetadata;

                } else {
                    var allMetadata = metadataObj.getAll();
                    return allMetadata;

                }

            }
        };


    return metadata;
});
define('sap/viz/chart/components/legend/ExtensionColorLegend',[
    'sap/viz/chart/components/legend/ColorLegend',
    'sap/viz/framework/common/util/oo',
    'sap/viz/chart/scales/ColorScale'
], function (ColorLegend, oo, ColorScale) {
    var ExtensionColorLegend = function () {

        ExtensionColorLegend.superclass.constructor.apply(this, arguments);
        var that = this;
        this._runtime.eventDispatcher().on('addEventListener.colorLegend', function () {
            that.addEventListener.apply(that, arguments[0]);
        });
        this._runtime.eventDispatcher().on('removeEventListener.colorLegend', function () {
            that.removeEventListener.apply(that, arguments[0]);
        });
        this._eventMap = {};
        this.initEvent();
    };
    oo.extend(ExtensionColorLegend, ColorLegend);
    var supportedEvents = ['selectionChanged'];

    ExtensionColorLegend.prototype.initEvent = function () {

        var eventMap = {};
        for (var i in supportedEvents) {
            if (supportedEvents.hasOwnProperty((i))) {
                eventMap[supportedEvents[i]] = {};
            }
        }
        this._eventMap = eventMap;
    };



    ExtensionColorLegend.prototype.registerEvent = function () {

        var cb = function (e) {
            for (var j in this._eventMap['selectionChanged']) {
                if (this._eventMap['selectionChanged'].hasOwnProperty(j)) {
                    this._eventMap['selectionChanged'][j].call(this, e);
                }
            }
        }.bind(this);

        this._runtime.eventDispatcher().on('legendSelection', cb);
    };
    ExtensionColorLegend.prototype.render = function () {
        ExtensionColorLegend.superclass.render.apply(this, arguments);
        this.registerEvent();
    };

    ExtensionColorLegend.prototype._buildData = function(obj){
        var color = obj.color||this._properties.origin.get('plotArea.colorPalette');
        var data = obj.data;
        var meta = obj.metadata;
        var domain = [];
        
        var rowArray = [];

        data.forEach(function(d) {
            domain.push([d]);
            var row = [d];
            row.mndIndex = -1;
            rowArray.push(row);
        });

        var scale = new ColorScale(domain, color);

        return {
            color: {
                scale: scale,
                metaData: meta,
                rowArray : rowArray
            }
        };
    };

    ExtensionColorLegend.prototype.setData = function (data, setFromExtension) {
        if (setFromExtension) {
            var newData = this._buildData(data);
            ExtensionColorLegend.superclass.setData.call(this, newData);
        }else{
            ExtensionColorLegend.superclass.setData.call(this, data);
        }
    };

    ExtensionColorLegend.prototype.addEventListener = function (type, listener, scope, priority) {
        var handler = function () {
            listener.apply(scope, arguments);
        };
        if (this._eventMap[type]) {
            this._eventMap[type][listener] = handler;
        }
    };
    ExtensionColorLegend.prototype.removeEventListener = function (type, listener, scope) {
        if (!!this._eventMap[type][listener]) {
            delete this._eventMap[type][listener];
        }
    };

    return ExtensionColorLegend;


});
define('sap/viz/chart/components/extension/componentWrapper/BaseWrapper',['sap/viz/framework/common/util/TypeUtils'],function(TypeUtils){

    var baseWrapper = function(module, evtDispatch){
        this._evtDispatch = evtDispatch;
        this._supportedEvent = [];
        this._properties = module._properties;
    };

    baseWrapper.prototype.properties = function(properties){
        
        if (arguments.length === 0 || (arguments.length === 1 && TypeUtils.isString(properties))) {
            return this._properties.get.apply(this._properties, arguments);
        }
        this._properties.set.apply(this._properties, arguments);
    };

    baseWrapper.prototype.addEventListener = function(type, listener, scope, priority){
        if(this._supportedEvent.indexOf(type)>-1){
            this._evtDispatch.addEventListener(type, listener, scope, priority);
        }
    };

    baseWrapper.prototype.removeEventListener = function(type, listener, scope) {
        this._evtDispatch.removeEventListener(type, listener, scope);
    };

    baseWrapper.prototype.supportedEvent = function(){
        return this._supportedEvent;
    };




    return baseWrapper;

});
define('sap/viz/chart/components/extension/componentWrapper/TitleWrapper',[
    'sap/viz/framework/common/util/oo', 
    'sap/viz/chart/components/extension/componentWrapper/BaseWrapper'
], function(oo, base){

    var titleWrapper = function(){
        titleWrapper.superclass.constructor.apply(this, arguments);
    };
    
    oo.extend(titleWrapper, base);

    return titleWrapper;

});
define('sap/viz/chart/components/extension/componentWrapper/LegendWrapper',[
    'sap/viz/framework/common/util/oo', 
    'sap/viz/chart/components/extension/componentWrapper/BaseWrapper'
], function(oo, base){

    var legendWrapper = function(module, evtDispatch){
        legendWrapper.superclass.constructor.apply(this, arguments);
        this._properties = module._properties.origin.proxy('legend');
        this._supportedEvent = ['selectionChanged'];
    };

    oo.extend(legendWrapper, base);

    return legendWrapper;

});
define('sap/viz/chart/components/extension/BuiltInComponentWrapper',[
    'sap/viz/chart/components/extension/componentWrapper/TitleWrapper',
    'sap/viz/chart/components/extension/componentWrapper/LegendWrapper',    
    'sap/viz/framework/extension/Constants'
], function (TitleWrapper, LegendWrapper, Constants) {


    var moduleMapping = {
        'title': TitleWrapper,
        'legendGroup': LegendWrapper
    };


    var createModuleWrapper = function (module, scope) {


        if (!moduleMapping[module._name]) {
            return null;
        }


        var wrapperModule = new moduleMapping[module._name](module, scope);
        wrapperModule.name = Constants.ModuleName[module._name];

        return wrapperModule;

    };



    return {
        createWrapper: createModuleWrapper
    };

});
define('sap/viz/chart/components/plots/ExtensionPlot',[
    'sap/viz/chart/components/UIComponent',
    'sap/viz/framework/common/util/oo',
    'sap/viz/framework/extension/DataModelToCSVUtil',
    'sap/viz/chart/components/extension/BuiltInComponentWrapper',
    'sap/viz/framework/common/util/TypeUtils',
    'sap/viz/framework/common/util/PropertyZoneUtil',
    'sap/viz/framework/common/util/FeedingZoneUtil',
    'sap/viz/framework/common/util/Constants',
    'sap/viz/framework/common/util/ObjectUtils'
], function (
    UIComponent,
    oo,
    DataModelToCSVUtil,
    BuiltInComponentWrapper,
    TypeUtils,
    PropertyZoneUtil,
    FeedingZoneUtil,
    Constants,
    ObjectUtils
) {
    var basePlot = function (runtime, options) {
        if (!TypeUtils.isFunction(this.getDefintion)) {
            return;
        }
        var vizClass = this.getDefintion();
        basePlot.superclass.constructor.apply(this, arguments);
        //support propertyZone.
        runtime.zoneManager().add(PropertyZoneUtil.plot(this));
        //support feedingZone.
        runtime.zoneManager().add(FeedingZoneUtil.plot(this));

        //support semanticManager.
        var semanticMgr = this.runtime().semanticManager();
        //default at: plotArea.dataPointStyle
        semanticMgr.bindDataPointProperty(this._name + ".dataPointStyle");

        this._semanticMgr = semanticMgr;
        this.Viz = new vizClass();
        this._rawdata = {};
        this._supportTooltip = true;
        this._originalSize = {};

        var scope = this;

        this._properties.origin.add(vizClass.metadata.properties, true);

        if (vizClass.metadata.events && TypeUtils.isArray(vizClass.metadata.events)) {

            vizClass.metadata.events.forEach(function (e) {
                scope._exposeMoreEvents(e);
            });
        }

        //Add default support events.
        this._exposeMoreEvents('initialized');
        this._exposeMoreEvents('renderComplete');


        this.Viz.dispatchEvent = function (eventName, args) {
            fireEvent.call(scope, eventName, args);
        };

        var extensionModule = this.Viz;

        window.setTimeout(function () {
            if(this._runtime){
                this._runtime.statusManager().add(
                    "interaction.selectedDataPoints", {
                        serializable: false,
                        set: function (config) {
                            config.success = extensionModule.setSelection(config.items);
                        },
                        get: function () {
                            return extensionModule.getSelection();
                        }
                    }
                );                
            }

        }.bind(this), 0);


        this._buildTooltip();

        _setProperties.call(this, this._properties.origin);
        
        this._changes = {};

    };

    oo.extend(basePlot, UIComponent);


    basePlot.prototype.renderTo = function () {
        return 'DIV';
    };


    basePlot.prototype._buildModuleWrapper = function (children) {
        var result = {};
        for (var i in children) {
            if (children.hasOwnProperty(i)) {
                var module = children[i].module;
                var wrappedModule = BuiltInComponentWrapper.createWrapper(module, this);
                if (wrappedModule && wrappedModule.name) {
                    result[wrappedModule.name] = wrappedModule;
                    (function (module) {
                        wrappedModule.setData = function (data) {
                            module.setData(data, true);
                        };
                    }(module));
                }

            }
        }

        return result;

    };

    basePlot.prototype._buildTooltip = function(){

        var extensionModule = this.Viz;
        var vizClass = this.getDefintion();
        var scope = this;
        
        extensionModule.showTooltip = function(data){
            scope._runtime.eventDispatcher().fire('showTooltip', data);
        };
        extensionModule.hideTooltip = function(data){
            scope._runtime.eventDispatcher().fire('hideTooltip', data);
        };

    };

    basePlot.prototype.addEventListener = function () {
        this._runtime.eventDispatcher().fire('addEventListener', arguments);
    };

    basePlot.prototype.removeEventListener = function () {
        this._runtime.eventDispatcher().fire('removeEventListener', arguments);
    };

    basePlot.prototype.setBuiltInComponent = function (children) {
        this._builtInComponents = children;

        this._builtInComponents = this._buildModuleWrapper(children);

    };

    basePlot.prototype.changes = function (obj) {
        if(arguments.length>0){
            this._changes = obj;
        }else{
            return this._changes;
        }
    };

    basePlot.prototype.updateBuiltInComponents = function () {
        if(this.Viz && this.Viz.updateBuiltInComponents){
            this.Viz.updateBuiltInComponents(this._builtInComponents, this._changes);
        }
    };

    basePlot.prototype.render = function (parent) {
        basePlot.superclass.render.apply(this, arguments);
        this._selection = parent;
        if (this.Viz) {
            _pretInit.call(this, parent);

            var colorPalette = this._properties.origin.get('plotArea.colorPalette') ||
                Constants.COLOR.SAPColorSingleAxis;

            this.Viz.colorPalette = function(){
                return colorPalette;            
            };

            this._originalProperties = this._properties.origin.get();            

            

            var size = this._size;
            this._originalSize = ObjectUtils.clone(size);
            this.Viz.size = function(){
                return size;
            };

            if (this.Viz.init && !this._initialized) {
                this.Viz.init();
                this._initialized = true;
            }
            if (this.Viz.render) {
                this.Viz.render(this._builtInComponents, this._changes);
            }
        }


    };

    basePlot.prototype.destroy = function () {
        basePlot.superclass.destroy.apply(this, arguments);
        if (this.Viz.destroy) {
            this.Viz.destroy();
        }
        this.Viz = undefined;
    };

    basePlot.prototype.setRawData = function (data) {

        this._rawdata = data;
        _setBindings.call(this, data.bindings);
        _setScales.call(this, data.scales);
        _setData.call(this, data.data);

    };

    var fireEvent = function (eventName, args) {
        window.setTimeout((function () {
            if (this._eventDispatch && this._eventDispatch[eventName]) {
                this._eventDispatch[eventName](args);
            }

        }).bind(this), 0);

    };

    basePlot.prototype.propertyZone = function () {
        return this.Viz.propertyZone(this._properties._prefix);
    };

    basePlot.prototype.feedingZone = function () {
        return this.Viz.feedingZone();
    };

    basePlot.prototype.exportContent = function (options) {
        return this.Viz.exportToSVGString && this.Viz.exportToSVGString(options);
    };

    basePlot.prototype.supportExportToContentType = function () {
        return !!this.Viz.exportToSVGString;
    };

    //Private functions    

    var _pretInit = function (container) {
        // create build-in components
        this.Viz.container = function () {
            return container;
        };
    };
    var _setData = function (value) {

        var data = value;
        if (this.getDefintion().metadata.dataType === 'csv') {
            data = DataModelToCSVUtil(value, this._rawdata.bindings);
        }

        if (this.Viz.data) {
            this.Viz.data(data);
        } else {
            this.Viz.data = function () {
                return data;
            };
        }


    };

    //TODO: Add post rendering support.
    // var _postRender = function () { // render build-in components       
    // };

    // var _postDestory = function () {
    //     // destory this._properties, this._scales, this._eventDispatcher, this._buildInComponents...
    // };

    var _setBindings = function (data) {
        if (this.Viz.bindings) {
            this.Viz.bindings(data);
        } else {
            this.Viz.bindings = function () {
                return data;
            };
        }
    };

    var _setScales = function (data) {
        if (this.Viz.scales) {
            this.Viz.scales(data);
        } else {
            this.Viz.scales = function () {
                return data;
            };
        }
        var _ = this._semanticMgr;

        this.Viz.getSemanticColor = function(dataCtx){
            return _.analyzeDataPoint("color", dataCtx);

        };

    };

    var _setProperties = function (props) {

        this.Viz.properties = function (properties) {
            if (arguments.length === 0 || (arguments.length === 1 && TypeUtils.isString(properties))) {
                return props.get.apply(props, arguments);
            }
            props.set.apply(props, arguments);
        };
    };

    return basePlot;

});
define('sap/viz/chart/behavior/ExtensionBehavior',[
    "sap/viz/framework/common/util/oo",
    "sap/viz/framework/common/util/Constants",
    "sap/viz/chart/components/util/DataPointUtils",
    "sap/viz/framework/interaction/BehaviorManager",
    "sap/viz/chart/behavior/DefaultBehavior",
    "sap/viz/chart/behavior/config/handler/RuntimeSelectionHelperHandler",
    "sap/viz/chart/behavior/config/handler/LegendBehaviorHandler",
    "sap/viz/chart/behavior/config/SelectionUtil"
], function (oo,
    Constants,
    DataPoints,
    BehaviorManager,
    DefaultBehavior,
    RuntimeSelectionHelperHandler,
    LegendBehaviorHandler,
    SelectionUtil
) {


    var ExtensionBehavior = BehaviorManager.get("default").clone();

    var ExtensionBehaviorHanlder = function () {};

    oo.extend(ExtensionBehaviorHanlder, RuntimeSelectionHelperHandler);



    var legendHandler = function () {};

    oo.extend(legendHandler, LegendBehaviorHandler);

    legendHandler.prototype.click = function (event, service, behavior) {
        if (!SelectionUtil.isLegendTriggerable(service, service.NodeType.LEGEND_ITEM)) {
            return;
        }
        var ctx = DataPoints.getContext(event.data.currentTarget).ctx;

        service.fireExternalEvent("legendSelection", ctx);
    };

    var legendDefinitionAction = ExtensionBehavior.getActionById("legendBehaviorDefinition");

    legendDefinitionAction.setHandler(legendHandler);

    BehaviorManager.register("ExtensionBehavior", ExtensionBehavior);
    BehaviorManager.addBehaviorType("ExtensionBehavior");
});
define('sap/viz/chart/views/ExtensionChartView',['sap/viz/framework/common/util/oo', 'sap/viz/chart/views/ChartView', 'sap/viz/framework/extension/Constants',
    'sap/viz/chart/components/legend/ExtensionColorLegend', 'sap/viz/chart/behavior/config/tooltip/Tooltip',
    'sap/viz/chart/components/plots/ExtensionPlot', "sap/viz/chart/behavior/ExtensionBehavior", 
    'sap/viz/framework/common/util/ObjectUtils', 'require'

], function (oo, ChartView, Constants, ExtensionColorLegend, Tooltip, ExtensionPlot, ExtensionBehavior, 
    ObjectUtils, require) {
    function moduleFactory(module) {
        switch (module.name) {
        case Constants.ModuleName.title:
            return {
                id: 'title',
                place: (module.properties && module.properties.position) || 'top',
                properties: module.properties || {}
            };
        case Constants.ModuleName.legend:
            return {
                id: 'legend',
                place: (module.properties && module.properties.position) || 'right',
                properties: module.properties || {}
            };
        }

    }

    var newChartView = function () {

        this._supportTooltip = true;
        this._needDispatchTooltipEvent = false;
        this._changes = false;
        this._dataItem = [];
        this.viz = this.getDefintion().metadata;
        this.plot = createBasePlot(this.getDefintion());
        // this.plot = newChartView.plot;
        this.childrens = [];

        this.childrens.push(this.plot);

        if (this.viz.builtInComponents) {
            for (var i in this.viz.builtInComponents) {
                if (this.viz.builtInComponents.hasOwnProperty(i)) {
                    this.childrens.push(moduleFactory(this.viz.builtInComponents[i]));
                }

            }
        }

        if (this.viz.bindingDefinition) {
            this._dataItem = parseId(this.viz.bindingDefinition);
        }
        newChartView.superclass.constructor.apply(this, arguments);
        this.id = this.viz.id;

    };



    function createBasePlot(plotDef) {

        var newPlot = function () {
            newPlot.superclass.constructor.apply(this, arguments);
        };

        oo.extend(newPlot, ExtensionPlot);

        newPlot.prototype.getDefintion = function () {
            return plotDef;
        };


        return newPlot;
    }


    oo.extend(newChartView, ChartView);
    var parseId = function (feeds) {
        return feeds.map(function (item) {
            return item.id;
        });
    };
    newChartView.prototype.renderTo = function () {
        return 'DIV';
    };


    newChartView.prototype._dataChanged = function () {
        this._resetPlotContainer();
    };

    newChartView.prototype._createChildren = function () {
        var that = this;
        var index = 2;
        this.childrens.forEach(function (child) {
            if (child.id === 'title') {
                that._createTitle(child.place);
                that._properties.proxy('title').setDefault(child.properties);
            } else if (child.id === 'legend') {
                that._createLegendGroup(child.place);
                that._properties.proxy('legend').setDefault(child.properties);
                //Add property for the legend.position if user defined.
                if (child.properties.position) {
                    that._properties.add('legend.position', child.properties.position);
                }
            } else {
                var moduleInstance = new child(that.runtime(), {
                    name: 'plotArea',
                    supportTooltip: that._supportTooltip
                });
                that.setChild('plot', moduleInstance, {
                    priority: ++index
                });
            }
        });

        this._createBackground();

        this._createTooltip();


        if (this.getChild('plot')) {
            var module = this.getChild('plot').module;
            if (module.setBuiltInComponent) {
                module.setBuiltInComponent(this._children);
            }
        }
        //if legend is reused, set behavior for extension and disable lasso.
        if (this.getChild(this._getLegendGroupModuleKey())) {
            this._properties.origin.add({
                'interaction.selectability.plotLassoSelection': {
                    'defaultValue': false,
                    'serializable': false,
                    'readonly': true
                },
                'interaction.selectability.legendSelection': {
                    'defaultValue': true,
                    'serializable': false,
                    'readonly': true
                }
            });
        } else {
            this._needDispatchTooltipEvent = true;
            this._exposeMoreEvents('showTooltip');
            this._exposeMoreEvents('hideTooltip');
        }

    };

    newChartView.prototype.render = function () {
        if (!this._size.width || !this._size.height) {
            return;
        }
        if (this.getChild('plot') && this.getChild('plot').module &&
            this.getChild('plot').module.changes) {
            var plotModule = this.getChild('plot').module;
            plotModule.changes(this._changes);
            if (plotModule.updateBuiltInComponents) {
                plotModule.updateBuiltInComponents();
            }
        }

        if (this._properties.get("interaction.behaviorType") !== 'DesignTimeBehavior' &&
            this.getChild(this._getLegendGroupModuleKey())) {
            this._properties.origin.setDefault({
                'interaction.behaviorType': 'ExtensionBehavior'
            });
        }
        //Keep update legend's position by the position property.
        var legendPosition = this._properties.get('legend.position');
        if (legendPosition) {
            this.getChild('legendGroup').module.setDefaultPosition(legendPosition);
        }

        newChartView.superclass.render.apply(this, arguments);
        if(this._selections && this._selections.plot && this._selections.plot.node){
            var plot = this._selections.plot.node();
            plot.parentNode.appendChild(plot);            
        }

    };

    newChartView.prototype._getLegendDefinition = function () {
        return [ExtensionColorLegend];
    };
    newChartView.prototype._createTooltip = function () {
        if (!this._tooltipModule) {
            this._tooltipModule = new Tooltip(this._properties.origin);          
            this._runtime.eventDispatcher().on('showTooltip.extension', function (data) {
                if(this._properties.get('interaction.behaviorType') !== 'DesignTimeBehavior'){
                    this._tooltipModule.showTooltip({
                        container : data.container,
                        mode : data.mode,
                        position : data.position,
                        //clone the data as this will be changed in tooltip module
                        data : ObjectUtils.extend(true, [], data.data) 
                    });
                    if (this._needDispatchTooltipEvent) {
                        this._eventDispatch['showTooltip'](data);
                    }
                }
            }.bind(this));

            this._runtime.eventDispatcher().on('hideTooltip.extension', function (data) {
                if(this._properties.get('interaction.behaviorType') !== 'DesignTimeBehavior'){
                    this._tooltipModule.hideTooltip(data);
                    if (this._needDispatchTooltipEvent) {
                        this._eventDispatch['hideTooltip'](data);
                    }
                }
            }.bind(this));
        }

    };

    newChartView.prototype.changes = function (obj) {
        if (arguments.length > 0) {
            this._changes = obj;
        } else {
            return this._changes;
        }
    };

    newChartView.prototype.setChild = function (key, module, option) {
        module.alias = key;
        if (!this._children[key]) {
            this._children[key] = {};
        }
        this._children[key].module = module;
        this._children[key].option = option ? option : {};
        return this;
    };

    newChartView.prototype.enableInteraction = function () {
        if (!this.getChild(this._getLegendGroupModuleKey())) {
            return false;
        }
        return true;
    };

    newChartView.prototype._updateData = function () {
        newChartView.superclass._updateData.apply(this, arguments);
        if (this._data) {
            for (var key in this._children) {
                if (this._children.hasOwnProperty(key)) {
                    if (this.getChild(key).module.setRawData && this._rawData.dataModel._rawData) {
                        this.getChild(key).module.setRawData({
                            data: this._rawData.dataModel._rawData,
                            bindings: this._rawData.bindings,
                            scales: this._rawData.scales
                        });
                    }
                }
            }
        }
    };
    newChartView.prototype.exportContent = function (options) {
        return this._children['plot'].module.exportContent(options);
    };
    newChartView.prototype.supportExportToContentType = function () {
        return this._children['plot'].module.supportExportToContentType();
    };
    newChartView.prototype._getDataItems = function () {
        return this._dataItem;
    };

    newChartView.prototype._dispatchInitialized = function () {
        if (this._eventDispatch) {
            this._eventDispatch.ready(); //an inner event used only by modules inside like interaction.

            var plot = this.getChild('plot');
            if (plot.module && plot.module._eventDispatch) {
                var callback = function () {
                    if (!this._initialized) {
                        this._initialized = true;
                        // notify the external handler if any
                        window.setTimeout(function () {
                            if (window._sap_viz_notify_load_complete) {
                                window._sap_viz_notify_load_complete();
                            }
                        }, 0);
                    }

                }.bind(this);
                plot.module._eventDispatch.on('renderComplete.renderExtensionComplete', callback);
                plot.module._eventDispatch.on('initialized.renderExtensionComplete', callback);
            }
        }

    };



    return newChartView;
});
(function(){
    var list = define && define.__autoLoad;
    if(list && list.length){
        define.__autoLoad = [];
        require(list);
    }
})();
(function(components){
    var chartBundle = sap.bi.framework.declareBundle( {
        id: "sap.viz.chart",
        components: components
    });

    (chartBundle.components || []).forEach(function(component) {
        component.instance = component.instance || {};
        window._cvom_kernel.register(component);
    });
})((function() {var p0="sap.viz.impls";var c0={"resources":[{"key":"sap.viz.api.env.Template.loadPaths","path":"./resources/chart/templates"},{"key":"sap.viz.api.env.Language.loadPaths","path":"./resources/chart/langs"},{"key":"sap.viz.api.env.Language.loadPaths","path":"./resources/framework/langs"}]};var ns0="sap/viz/chart/views/";var ns1="sap/viz/chart/metadata/bindings/";return [{"id":"info/bar","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"bar",plot:"sap/viz/chart/components/plots/ColumnPlot",family:"xy",name:"IDS_BARCHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/stacked_bar","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"stacked_bar",plot:"sap/viz/chart/components/plots/StackedColumnPlot",family:"xy",name:"IDS_STACKEDBARCHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/100_stacked_bar","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"100_stacked_bar",plot:"sap/viz/chart/components/plots/PercentagePlot",family:"xy",name:"IDS_PERCENTAGESTACKEDBARCHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/column","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"column",family:"xy",name:"IDS_VERTICALBARCHART",plot:"sap/viz/chart/components/plots/ColumnPlot",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/stacked_column","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"stacked_column",plot:"sap/viz/chart/components/plots/StackedColumnPlot",family:"xy",name:"IDS_STACKEDVERTICALBARCHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/100_stacked_column","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"100_stacked_column",plot:"sap/viz/chart/components/plots/PercentagePlot",family:"xy",name:"IDS_PERCENTAGESTACKEDVERTICALBARCHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/line","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"line",plot:"sap/viz/chart/components/plots/LinePlot",family:"xy",name:"IDS_LINECHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/area","provide":p0,"instance":{view:ns0 + "XYChartView",plot:"sap/viz/chart/components/plots/AreaPlot",renderType:"area",family:"xy",name:"IDS_AREACHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/horizontal_area","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"horizontal_area",plot:"sap/viz/chart/components/plots/AreaPlot",family:"xy",name:"IDS_HORIZONTALAREACHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/100_area","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"100_area",family:"xy",name:"IDS_PERCENTAGEAREACHART",plot:"sap/viz/chart/components/plots/PercentageAreaPlot",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/100_horizontal_area","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"100_horizontal_area",plot:"sap/viz/chart/components/plots/PercentageAreaPlot",family:"xy",name:"IDS_PERCENTAGEHORIZONTALAREACHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0},{"id":"info/combination","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"combination",family:"xy",name:"IDS_COMBINATIONCHART",plot:"sap/viz/chart/components/plots/CombinationPlot",vender:"sap.viz",bindings:ns1 + "CombinationBindings"},"customProperties":c0},{"id":"info/bubble","provide":p0,"instance":{view:ns0 + "YYChartView",renderType:"bubble",family:"yy",name:"IDS_BUBBLECHART",vender:"sap.viz",bindings:ns1 + "YYBindings"},"customProperties":c0},{"id":"info/time_bubble","provide":p0,"instance":{view:ns0 + "YYChartView",renderType:"time_bubble",family:"yy",name:"IDS_TIMEBUBBLECHART",vender:"sap.viz",bindings:ns1 + "YYBindings"},"customProperties":c0},{"id":"info/scatter","provide":p0,"instance":{view:ns0 + "YYChartView",renderType:"scatter",family:"yy",name:"IDS_SCATTERCHART",vender:"sap.viz",bindings:ns1 + "YYBindings"},"customProperties":c0},{"id":"info/dual_column","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"column",plot:"sap/viz/chart/components/plots/ColumnPlot",family:"xyy",name:"IDS_DUALVERTICALBARCHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/dual_stacked_column","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"stacked_column",plot:"sap/viz/chart/components/plots/StackedColumnPlot",family:"xyy",name:"IDS_DUALSTACKEDVERTICALBARCHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/100_dual_stacked_column","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"100_stacked_column",plot:"sap/viz/chart/components/plots/PercentagePlot",family:"xyy",name:"IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/dual_bar","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"bar",plot:"sap/viz/chart/components/plots/ColumnPlot",family:"xyy",name:"IDS_DUALBARCHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/dual_stacked_bar","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"stacked_bar",plot:"sap/viz/chart/components/plots/StackedColumnPlot",family:"xyy",name:"IDS_DUALSTACKEDBARCHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/100_dual_stacked_bar","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"100_stacked_bar",plot:"sap/viz/chart/components/plots/PercentagePlot",family:"xyy",name:"IDS_DUALPERCENTAGESTACKEDBARCHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/dual_line","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"line",plot:"sap/viz/chart/components/plots/LinePlot",family:"xyy",name:"IDS_DUALLINECHART",vender:"sap.viz",bindings:ns1 + "XYYBindings"},"customProperties":c0},{"id":"info/bullet","provide":p0,"instance":{view:ns0 + "BulletChartView",renderType:"bullet",family:"bullet",name:"IDS_BULLETCHART",vender:"sap.viz",bindings:ns1 + "BulletBindings"},"customProperties":c0},{"id":"info/vertical_bullet","provide":p0,"instance":{view:ns0 + "BulletChartView",renderType:"vertical_bullet",family:"bullet",name:"IDS_VERTICALBULLETCHART",vender:"sap.viz",bindings:ns1 + "BulletBindings"},"customProperties":c0},{"id":"info/pie","provide":p0,"instance":{view:ns0 + "PieChartView",renderType:"pie",family:"pie",name:"IDS_PIECHART",vender:"sap.viz",bindings:ns1 + "PieBindings"},"customProperties":c0},{"id":"info/donut","provide":p0,"instance":{view:ns0 + "PieChartView",renderType:"donut",family:"pie",name:"IDS_DONUTCHART",vender:"sap.viz",bindings:ns1 + "PieBindings"},"customProperties":c0},{"id":"info/treemap","provide":p0,"instance":{view:ns0 + "TreeChartView",renderType:"treemap",family:"treemap",name:"IDS_TREEMAPCHART",vender:"sap.viz",bindings:ns1 + "TreeBindings"},"customProperties":c0},{"id":"info/heatmap","provide":p0,"instance":{view:ns0 + "XXChartView",renderType:"heatmap",family:"xx",name:"IDS_HEATMAPCHART",vender:"sap.viz",bindings:ns1 + "XXBindings"},"customProperties":c0},{"id":"info/stacked_combination","provide":p0,"instance":{view:ns0 + "XYChartView",renderType:"stacked_combination",plot:"sap/viz/chart/components/plots/StackedCombinationPlot",family:"xy",name:"IDS_STACKEDCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "CombinationBindings"},"customProperties":c0},{"id":"info/horizontal_stacked_combination","provide":p0,"instance":{view:ns0 + "XYChartView",plot:"sap/viz/chart/components/plots/StackedCombinationPlot",renderType:"horizontal_stacked_combination",family:"xy",name:"IDS_HORIZONTALSTACKEDCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "CombinationBindings"},"customProperties":c0},{"id":"info/dual_stacked_combination","provide":p0,"instance":{view:ns0 + "XYYChartView",plot:"sap/viz/chart/components/plots/StackedCombinationPlot",renderType:"stacked_combination",family:"xyy",name:"IDS_DUALSTACKEDCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "XYYCombinationBindings"},"customProperties":c0},{"id":"info/dual_horizontal_stacked_combination","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"horizontal_stacked_combination",plot:"sap/viz/chart/components/plots/StackedCombinationPlot",family:"xyy",name:"IDS_DUALHORIZONTALSTACKEDCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "XYYCombinationBindings"},"customProperties":c0},{"id":"info/dual_combination","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"combination",plot:"sap/viz/chart/components/plots/CombinationPlot",family:"xyy",name:"IDS_DUALCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "XYYCombinationBindings"},"customProperties":c0},{"id":"info/dual_horizontal_combination","provide":p0,"instance":{view:ns0 + "XYYChartView",renderType:"horizontal_combination",plot:"sap/viz/chart/components/plots/CombinationPlot",family:"xyy",name:"IDS_DUALHORIZONTALCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "XYYCombinationBindings"},"customProperties":c0},{"id":"info/timeseries_line","provide":p0,"instance":{view:ns0 + "TimeYChartView",renderType:"timeseries_line",family:"ty",name:"IDS_TIMELINECHART",vender:"sap.viz",bindings:ns1 + "TimeYBindings"},"customProperties":c0},{"id":"info/timeseries_column","provide":p0,"instance":{view:ns0 + "TimeYChartView",renderType:"timeseries_column",family:"ty",name:"IDS_TIMESERIESCOLUMNCHART",vender:"sap.viz",bindings:ns1 + "TimeYBindings"},"customProperties":c0},{"id":"info/timeseries_bullet","provide":p0,"instance":{view:ns0 + "TimeBulletChartView",renderType:"timeseries_bullet",family:"tBullet",name:"IDS_TIMESERIESBULLETCHART",vender:"sap.viz",bindings:ns1 + "TimeBulletBindings"},"customProperties":c0},{"id":"info/timeseries_combination","provide":p0,"instance":{view:ns0 + "TimeYChartView",renderType:"timeseries_combination",family:"ty",name:"IDS_TIMESERIESCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "TimeYCombinationBindings"},"customProperties":c0},{"id":"info/dual_timeseries_combination","provide":p0,"instance":{view:ns0 + "TimeYYChartView",renderType:"timeseries_combination",family:"tyy",name:"IDS_DUALTIMESERIESCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "TimeYYBindings"},"customProperties":c0},{"id":"info/timeseries_stacked_combination","provide":p0,"instance":{view:ns0 + "TimeYChartView",renderType:"timeseries_stacked_combination",plot:"sap/viz/chart/components/plots/TimeStackedCombinationPlot",family:"ty",name:"IDS_TIMESERIESSTACKEDCOMBINATIONCHART",vender:"sap.viz",bindings:ns1 + "TimeYStackedCombinationBindings"},"customProperties":c0},{"id":"info/timeseries_stacked_column","provide":p0,"instance":{view:ns0 + "TimeYChartView",renderType:"timeseries_stacked_column",family:"ty",name:"IDS_TIMESERIESSTACKEDCOLUMNCHART",vender:"sap.viz",bindings:ns1 + "TimeYBindings"},"customProperties":c0},{"id":"info/timeseries_100_stacked_column","provide":p0,"instance":{view:ns0 + "TimeYChartView",renderType:"timeseries_100_stacked_column",family:"ty",name:"IDS_TIMESERIESPERCENTSTACKEDCOLUMNCHART",vender:"sap.viz",bindings:ns1 + "TimeYBindings"},"customProperties":c0},{"id":"info/timeseries_scatter","provide":p0,"instance":{view:ns0 + "YYChartView",renderType:"timeseries_scatter",family:"ty",name:"IDS_TIMESERIESSCATTERCHART",vender:"sap.viz",bindings:ns1 + "YYTimeBindings"},"customProperties":c0},{"id":"info/timeseries_bubble","provide":p0,"instance":{view:ns0 + "YYChartView",renderType:"timeseries_bubble",family:"ty",name:"IDS_TIMESERIESBUBBLECHART",vender:"sap.viz",bindings:ns1 + "YYTimeBindings"},"customProperties":c0},{"id":"info/timeseries_waterfall","provide":p0,"instance":{view:ns0 + "TimeWaterFallChartView",renderType:"timeseries_waterfall",family:"ty",name:"IDS_TIMESERIESWATERFALLCHART",vender:"sap.viz",bindings:ns1 + "TimeYColumnBindings"},"customProperties":c0},{"id":"info/waterfall","provide":p0,"instance":{view:ns0 + "WaterFallChartView",renderType:"waterfall",family:"waterfall",name:"IDS_WATERFALLCHART",vender:"sap.viz",bindings:ns1 + "WaterFallBindings"},"customProperties":c0},{"id":"info/horizontal_waterfall","provide":p0,"instance":{view:ns0 + "WaterFallChartView",renderType:"horizontal_waterfall",family:"waterfall",name:"IDS_HORIZONTALWATERFALLCHART",vender:"sap.viz",bindings:ns1 + "WaterFallBindings"},"customProperties":c0},{"id":"info/radar","provide":p0,"instance":{view:ns0 + "RadarChartView",renderType:"radar",family:"radar",name:"IDS_RADARCHART",vender:"sap.viz",bindings:ns1 + "XYBindings"},"customProperties":c0}];})());
(function(){
	try {
	    var ChartViewRegistry = require("sap/viz/framework/core/ChartViewRegistry");
	    
	    if (ChartViewRegistry && ChartViewRegistry.registerAll) {
	        ChartViewRegistry.registerAll();
	    }
	} catch(e) {

	}
})();


(function (global) {
    // restore global require & define
    global.define = sap.viz.moduleloader.originalDefine;
    global.require = sap.viz.moduleloader.originalRequire;
    global.requirejs = sap.viz.moduleloader.originalRequirejs;
})(this);

(function(global){
    var sap = global.sap;
    var root = sap && sap.viz;
    if(root){
        global.__sap_v3 = {};
        for(var i in root){
            if(i==='api'||i==='extapi'){
                if(jQuery && jQuery.extend){
                    global.__sap_v3[i] = jQuery.extend(true,{},root[i]);
                }else{
                    global.__sap_v3[i] = root[i];
                }
                
            }else{
                global.__sap_v3[i] = root[i];
            }
        }
        if(global.__sap_metadata){
            sap.viz.api.metadata = global.__sap_metadata;
        }
    }
})(this);

(function(global){
    var root = sap.viz;
    var v2 = global.__sap_v2;
    var v3 = global.__sap_v3;

    function mergedCallback(cb, err){
        // handle callback for both versions
        var args;
        var errArgs;
        var flag = 1;
        var versions = {
            v2: 2, // v2 and v3 must be relatively prime numbers
            v3: 3
        };
        return function(version, isErr){
            // This is the real callback handler
            return function(){
                flag *= versions[version];
                // save arguments to use the correct one in callback
                errArgs = isErr ? arguments : errArgs;
                args = isErr ? args : arguments;
                if(flag % (versions.v2 * versions.v3) === 0){
                    // both versions have returned, so call callback.
                    // call err as long as one version fails.
                    var callback = errArgs && err ? err : cb;
                    if(callback){
                        callback.apply(this, callback === err ? errArgs : args);
                    }
                    // once successful, reset this flag.
                    flag = 1;
                }
            };
        };
    }

    if(v2 && v3){

        root.api = jQuery.extend(true, {}, v2.api, v3.api);
        root.extapi = jQuery.extend(true, {}, v2.extapi, v3.extapi);

        root.v2 = v2;
        root.v3 = v3;
        root.extapi.Flow = v3.extapi.Flow;
        root.api.data.CrosstableDataset = v2.api.data.CrosstableDataset;
        root.api.data.FlatTableDataset = v2.api.data.FlatTableDataset;
        if(v2.extapi.env.Resource && v2.extapi.env.Resource.path){
            var resourcePath = v2.extapi.env.Resource.path();
            for(var i in resourcePath){
                v3.extapi.env.Resource.path(i, resourcePath[i]);
            }
        }

        var LocaleListenerCache = {};
        var TemplateListenerCache = {};
        var LanguageListenerCache = {};
        if(v2.api.env.Format && v2.api.env.Format.numericFormatter){
            var formatter = v2.api.env.Format.numericFormatter();
                v3.api.env.Format.numericFormatter(formatter);
        }

        if(v2.api.env.Format && v2.api.env.Format.useDefaultFormatter){
            var useDefaultFormatter = v2.api.env.Format.useDefaultFormatter();
                v3.api.env.Format.useDefaultFormatter(useDefaultFormatter);
        }

        root.api.core.createViz = function (param) {
            var version = sap.viz.api.metadata.Viz.get(param.type)? 'v3' : 'v2';
            return root[version].api.core.createViz(param);
        };

        root.api.core.loadViz = function (vizJSON, container) {
            var chartJSON = JSON.parse(JSON.stringify(vizJSON));
            var version = sap.viz.api.metadata.Viz.get(param.type)? 'v3' : 'v2';
            return root[version].api.core.loadViz(vizJSON, container);
        };

        root.api.env.Language.set = function(lang, callback, errCallback){
            var cb = mergedCallback(callback, errCallback);
            root.v2.api.env.Language.set(lang, cb('v2'), cb('v2', true));
            root.v3.api.env.Language.set(lang, cb('v3'), cb('v3', true));
        };

        root.api.env.Locale.set = function(value, callback, options){
            var cb = mergedCallback(callback);
            root.v2.api.env.Locale.set(value, cb('v2'));
            root.v3.api.env.Locale.set(value, cb('v3'), options);
        };

        root.api.env.Format.numericFormatter = function(value){
            root.v2.api.env.Format.numericFormatter(value);
            root.v3.api.env.Format.numericFormatter(value);
        };

        root.api.env.Format.useDefaultFormatter = function(value){
            root.v2.api.env.Format.useDefaultFormatter(value);
            root.v3.api.env.Format.useDefaultFormatter(value);
        };

        root.api.env.Resource.path = function(id, path){
            root.v2.api.env.Resource.path.apply(root.v2.api.env.Resource, arguments);
            return root.v3.api.env.Resource.path.apply(root.v3.api.env.Resource, arguments);
        };

        root.api.env.Template.set = function(value, callback, errCallback){
            var cb = mergedCallback(callback, errCallback);
            root.v2.api.env.Template.set(value, cb('v2'), cb('v2', true));
            root.v3.api.env.Template.set(value, cb('v3'), cb('v3', true));
        };

        root.api.env.Template.load = function(value, callback, errCallback){
            var versionCount = 2;
            function cb(){
                if(--versionCount === 0 && callback){
                    callback.apply(this, arguments);
                }
            }
            root.v2.api.env.Template.load(value, cb);
            root.v3.api.env.Template.load(value, cb, errCallback);
        };

        root.extapi.env.Template.isRegistered = function(id){
            return root.v3.extapi.env.Template.isRegistered(id);
        };

        root.extapi.env.Language.register = function(v){
            root.v2.extapi.env.Language.register(v);
            root.v3.extapi.env.Language.register(v);
        };
        root.extapi.env.Language.get = function(){
            root.v2.extapi.env.Language.get();
            return root.v3.extapi.env.Language.get();
        };
        root.extapi.env.Language.addListener = function(v) {
            var cb = mergedCallback(v);
            var v2cb = cb('v2');
            var v3cb = cb('v3');
            LanguageListenerCache[v] = {
                v2:v2cb,
                v3:v3cb
            };
            root.v2.extapi.env.Language.addListener(v2cb);
            return root.v3.extapi.env.Language.addListener(v3cb);
        };
        root.extapi.env.Language.removeListener = function(v) {
            if(LanguageListenerCache[v]){
                root.v2.extapi.env.Language.removeListener(LanguageListenerCache[v].v2);
                return root.v3.extapi.env.Language.removeListener(LanguageListenerCache[v].v3);
            }
        };
        root.extapi.env.Language.getErrorMessage = function(v) {
            root.v2.extapi.env.Language.getErrorMessage(v);
            return root.v3.extapi.env.Language.getErrorMessage(v);
        };
        root.extapi.env.Language.getResourceString = function(v) {
            root.v2.extapi.env.Language.getResourceString(v);
            return root.v3.extapi.env.Language.getResourceString(v);
        };
        root.extapi.env.Locale.get = function() {
            root.v2.extapi.env.Locale.get();
            return root.v3.extapi.env.Locale.get();
        };
        root.extapi.env.Locale.addListener = function(v) {
            var cb = mergedCallback(v);
            var v2cb = cb('v2');
            var v3cb = cb('v3');
            LocaleListenerCache[v] = {
                v2:v2cb,
                v3:v3cb
            };
            root.v2.extapi.env.Locale.addListener(v2cb);
            return root.v3.extapi.env.Locale.addListener(v3cb);
        };
        root.extapi.env.Locale.removeListener = function(v) {
            if(LocaleListenerCache[v]){
                root.v2.extapi.env.Locale.removeListener(LocaleListenerCache[v].v2);
                return root.v3.extapi.env.Locale.removeListener(LocaleListenerCache[v].v3);
            }
        };
        root.extapi.env.Template.get = function() {
            root.v2.extapi.env.Template.get();
            return root.v3.extapi.env.Template.get();
        };
        root.extapi.env.Template.current = function() {
            root.v2.extapi.env.Template.current();
            return root.v3.extapi.env.Template.current();
        };
        root.extapi.env.Template.getPackage = function(id) {
            root.v2.extapi.env.Template.getPackage(id);
            return root.v3.extapi.env.Template.getPackage(id);
        };

        root.extapi.env.Template.addListener = function(v) {
            var cb = mergedCallback(v);
            var v2cb = cb('v2');
            var v3cb = cb('v3');
            TemplateListenerCache[v] = TemplateListenerCache[v] || [];
            TemplateListenerCache[v].push({
                v2:v2cb,
                v3:v3cb,
                v:v
            });
            root.v2.extapi.env.Template.addListener(v2cb);
            return root.v3.extapi.env.Template.addListener(v3cb);
        };
        root.extapi.env.Template.register = function(v){
            root.v2.extapi.env.Template.register(v);
            root.v3.extapi.env.Template.register(v);
        };
        root.api.env.Template.addListener = function (v) {
            var cb = mergedCallback(v);
            var v2cb = cb('v2');
            var v3cb = cb('v3');
            TemplateListenerCache[v] = TemplateListenerCache[v] || [];
            TemplateListenerCache[v].push({
                v2:v2cb,
                v3:v3cb,
                v:v
            });
            root.v2.api.env.Template.addListener(v2cb);
            return root.v3.api.env.Template.addListener(v3cb);
        };
        root.api.env.Template.removeListener = function (v) {
            var cache = TemplateListenerCache[v],
                ret;
            if(cache){
                for (var i = 0; i < cache.length; i++) {
                    if (cache[i].v === v) {
                        root.v2.api.env.Template.removeListener(cache[i].v2);
                        ret = root.v3.api.env.Template.removeListener(cache[i].v3);
                        cache.splice(i, 1);
                        break;
                    }
                }
            }
            return ret;
        };
        root.extapi.env.Template.removeListener = function(v) {
            var cache = TemplateListenerCache[v],
                ret;
            if(cache){
                for (var i = 0; i < cache.length; i++) {
                    if (cache[i].v === v) {
                        root.v2.extapi.env.Template.removeListener(cache[i].v2);
                        ret = root.v3.extapi.env.Template.removeListener(cache[i].v3);
                        cache.splice(i, 1);
                        break;
                    }
                }
            }
            return ret;
        };
        root.extapi.core.registerBundle = function(v){
            root.v2.extapi.core.registerBundle(v);
            return root.v3.extapi.core.registerBundle(v);
        };
    }

    if (sap && sap.viz && sap.viz.framework && sap.viz.framework.core && sap.viz.framework.core.ChartViewRegistry) {
        delete sap.viz.framework.core.ChartViewRegistry;

        function isEmptyObj(obj) {
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    return false;
                }
            }
            return true;
        }
        if (isEmptyObj(sap.viz.framework.core)) {
            delete sap.viz.framework.core;
        }
        if (isEmptyObj(sap.viz.framework)) {
            delete sap.viz.framework;
        }
    }
})(this);

//# sourceMappingURL=sap-viz-info-charts.js.map
